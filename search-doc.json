{"searchDocs":[{"title":"Interchain Security Docs","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0","content":"Interchain Security Docs Welcome to the official Interchain Security module documentation for Cosmos-SDK based chains. Here you can find information about Interchain Security, consumer chain development and instructions for validator onboarding. Basic Concepts Get started with the basic concepts and ideas. FAQ Frequently asked questions about the protocol and its implications Start Building Click here to start building with Interchain Security Onboarding Checklist Checklist to help you integrate Interchain Security, get support and onboard validators Become an ICS Validator Start validating on consumer chains Assign Consumer Keys Learn how to assign separate key on the consumer chains","keywords":"","version":"v4.5.0"},{"title":"ADR 004: Denom DOS fixes","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes#changelog","content":" 5/9/2023: ADR created  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes#status","content":" Accepted  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes#context","content":" The provider and consumer modules are vulnerable to similar issues involving an attacker sending millions of denoms to certain addresses and causing the chain to halt. This ADR outlines both fixes since they are similar. Both fixes involve processing only denoms that are on a whitelist to avoid iterating over millions of junk denoms but have different requirements and are implemented in different ways.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes#decision","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Provider​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes#provider","content":" Put the distribution module's FeePoolAddress back on the blocklist so that it cannot receive funds from users.Create a new address called ConsumerRewardPool and unblock it, allowing funds to be sent to it.Create a set of strings in the store for allowed ConsumerRewardDenoms.Create an endpoint called RegisterConsumerRewardDenom which deducts a fee from the sender's account, sends it to the community pool and adds a string to the ConsumerRewardDenoms set.Create a parameter called ConsumerRewardDenomRegistrationFee which determines the fee which is charged to register a consumer reward denom in the step above.Create a function called TransferRewardsToFeeCollector which gets the entire ConsumerRewardDenoms set from the store, iterates over it, and for each entry: Gets the balance of this denom for the ConsumerRewardPool accountSends the entire balance out to the FeePoolAddress using SendCoinsFromModuleToModule which is not affected by the blocklist. Run TransferRewardsToFeeCollector in the endblock  Now, nobody can send millions of junk denoms to the FeePoolAddress because it is on the block list. If they send millions of junk denoms to the ConsumerRewardPool, this does not matter because all balances are not iterated over, only those which are in the ConsumerRewardDenoms set.  We also add a new tx: register-consumer-reward-denom, and a new query: registered-consumer-reward-denoms  ","version":"v4.5.0","tagName":"h3"},{"title":"Consumer​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes#consumer","content":" Create a new param RewardDenoms with a list of stringsCreate a new param ProviderRewardDenoms with a list of stringsCreate a function AllowedRewardDenoms which iterates over ProviderRewardDenoms and converts each denom to its ibc-prefixed denom using the provider chain's ibc channel information, then concatenates the RewardDenoms list and returns the combined list of allowed denoms.In SendRewardsToProvider, instead of iterating over the balances of all denoms in the ToSendToProvider address, iterate over AllowedRewardDenoms  Now, if somebody sends millions of junk denoms to ToSendToProvider, they will not be iterated over. Only the RewardDenoms and ProviderRewardDenoms will be iterated over. Since we do not require this feature to be permissionless on the consumer, the registration fee process is not needed.  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes#positive","content":" Denom DOS is no longer possible on either provider or consumer.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v4.5.0/adrs/adr-004-denom-dos-fixes#negative","content":" Consumer chain teams must pay a fee to register a denom for distribution on the provider, and add some extra parameters in their genesis file. ","version":"v4.5.0","tagName":"h3"},{"title":"ADR 003: Equivocation governance proposal","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal#changelog","content":" 2023-02-06: Initial draft2023-11-30: Change status to deprecated  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal#status","content":" Deprecated  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal#context","content":" Note: ADR deprecated as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  We want to limit the possibilities of a consumer chain to execute actions on the provider chain to maintain and ensure optimum security of the provider chain.  For instance, a malicious consumer consumer chain can send slash packet to the provider chain, which will slash a validator without the need of providing an evidence.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal#decision","content":" To protect against a malicious consumer chain, slash packets unrelated to downtime are ignored by the provider chain. Thus, an other mechanism is required to punish validators that have committed a double-sign on a consumer chain.  A new kind of governance proposal is added to the provider module, allowing to slash and tombstone a validator for double-signing in case of any harmful action on the consumer chain.  If such proposal passes, the proposal handler delegates to the evidence module to process the equivocation. This module ensures the evidence isn’t too old, or else ignores it (see code). Too old is determined by 2 consensus params :  evidence.max_age_duration number of nanoseconds before an evidence is considered too oldevidence.max_age_numblocks number of blocks before an evidence is considered too old.  On the hub, those parameters are equals to  // From https://cosmos-rpc.polkachu.com/consensus_params?height=13909682 (...) &quot;evidence&quot;: { &quot;max_age_num_blocks&quot;: &quot;1000000&quot;, &quot;max_age_duration&quot;: &quot;172800000000000&quot;, (...) }, (...)   A governance proposal takes 14 days, so those parameters must be big enough so the evidence provided in the proposal is not ignored by the evidence module when the proposal passes and is handled by the hub.  For max_age_num_blocks=1M, the parameter is big enough if we consider the hub produces 12k blocks per day (blocks_per_year/365 = 436,0000/365). The evidence can be up to 83 days old (1,000,000/12,000) and not be ignored.  For max_age_duration=172,800,000,000,000, the parameter is too low, because the value is in nanoseconds so it’s 2 days. Fortunately the condition that checks those 2 parameters uses a AND, so if max_age_num_blocks condition passes, the evidence won’t be ignored.  ","version":"v4.5.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal#positive","content":" Remove the possibility from a malicious consumer chain to “attack” the provider chain by slashing/jailing validators.Provide a more acceptable implementation for the validator community.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal#negative","content":" Punishment action of double-signing isn’t “automated”, a governance proposal is required which takes more time.You need to pay 250ATOM to submit an equivocation evidence.  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal#neutral","content":" ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v4.5.0/adrs/adr-003-equivocation-gov-proposal#references","content":" PR that ignores non downtime slash packet : https://github.com/cosmos/interchain-security/pull/692PR that adds the governance slash proposal: https://github.com/cosmos/interchain-security/pull/703 ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 001: Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#changelog","content":" 2022-12-01: Initial Draft2024-03-01: Updated to take into account they key-assigment-replacement deprecation.  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#status","content":" Accepted  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#context","content":" KeyAssignment is the name of the feature that allows validator operators to use different consensus keys for each consumer chain validator node that they operate.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#decision","content":" It is possible to change the keys at any time by submitting a transaction (i.e., MsgAssignConsumerKey).  ","version":"v4.5.0","tagName":"h2"},{"title":"State required​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#state-required","content":" ValidatorConsumerPubKey - Stores the validator assigned keys for every consumer chain.  ConsumerValidatorsBytePrefix | len(chainID) | chainID | providerConsAddress -&gt; consumerKey   ValidatorByConsumerAddr - Stores the mapping from validator addresses on consumer chains to validator addresses on the provider chain. Needed for the consumer initiated slashing sub-protocol.  ValidatorsByConsumerAddrBytePrefix | len(chainID) | chainID | consumerConsAddress -&gt; providerConsAddress   ConsumerAddrsToPrune - Stores the mapping from VSC ids to consumer validators addresses. Needed for pruning ValidatorByConsumerAddr.  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; []consumerConsAddresses   ","version":"v4.5.0","tagName":"h3"},{"title":"Protocol overview​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#protocol-overview","content":" On receiving a MsgAssignConsumerKey(chainID, providerAddr, consumerKey) message:  // get validator from staking module validator, found := stakingKeeper.GetValidator(providerAddr) if !found { return ErrNoValidatorFound } providerConsAddr := validator.GetConsAddr() // make sure consumer key is not in use consumerAddr := utils.TMCryptoPublicKeyToConsAddr(consumerKey) if _, found := GetValidatorByConsumerAddr(ChainID, consumerAddr); found { return ErrInvalidConsumerConsensusPubKey } // check whether the consumer chain is already registered // i.e., a client to the consumer was already created if _, consumerRegistered := GetConsumerClientId(chainID); consumerRegistered { // get the previous key assigned for this validator on this consumer chain oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr) if found { // mark this old consumer key as prunable once the VSCMaturedPacket // for the current VSC ID is received oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) vscID := GetValidatorSetUpdateId() AppendConsumerAddrsToPrune(chainID, vscID, oldConsumerAddr) } } else { // if the consumer chain is not registered, then remove the previous reverse mapping if oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr); found { oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) DeleteValidatorByConsumerAddr(chainID, oldConsumerAddr) } } // set the mapping from this validator's provider address to the new consumer key SetValidatorConsumerPubKey(chainID, providerConsAddr, consumerKey) // set the reverse mapping: from this validator's new consensus address // on the consumer to its consensus address on the provider SetValidatorByConsumerAddr(chainID, consumerAddr, providerConsAddr)   When a new consumer chain is registered, i.e., a client to the consumer chain is created, the provider constructs the consumer CCV module part of the genesis state (see MakeConsumerGenesis).  func (k Keeper) MakeConsumerGenesis(chainID string) (gen consumertypes.GenesisState, nextValidatorsHash []byte, err error) { // ... // get initial valset from the staking module var updates []abci.ValidatorUpdate{} stakingKeeper.IterateLastValidatorPowers(func(providerAddr sdk.ValAddress, power int64) (stop bool) { validator := stakingKeeper.GetValidator(providerAddr) providerKey := validator.TmConsPublicKey() updates = append(updates, abci.ValidatorUpdate{PubKey: providerKey, Power: power}) return false }) // applies the key assignment to the initial validator for i, update := range updates { providerAddr := utils.TMCryptoPublicKeyToConsAddr(update.PubKey) if consumerKey, found := GetValidatorConsumerPubKey(chainID, providerAddr); found { updates[i].PubKey = consumerKey } } gen.InitialValSet = updates // get a hash of the consumer validator set from the update updatesAsValSet := tendermint.PB2TM.ValidatorUpdates(updates) hash := tendermint.NewValidatorSet(updatesAsValSet).Hash() return gen, hash, nil }   Note that key assignment works hand-in-hand with epochs. For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. Specifically, for each validator in the set we store among others, the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacketwith all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   where DiffValidators internally checks if the consumer public key for a validator has changed since the last epoch and if so generates a validator update. This way, a validator can change its consumer public key for a consumer chain an arbitrary amount of times and only the last set consumer public key would be taken into account.  On receiving a SlashPacket from a consumer chain with id chainID for a infraction of a validator data.Validator:  func HandleSlashPacket(chainID string, data ccv.SlashPacketData) (success bool, err error) { // ... // the slash packet validator address may be known only on the consumer chain; // in this case, it must be mapped back to the consensus address on the provider chain consumerAddr := sdk.ConsAddress(data.Validator.Address) providerAddr, found := GetValidatorByConsumerAddr(chainID, consumerAddr) if !found { // the validator has the same key on the consumer as on the provider providerAddr = consumerAddr } // ... }   On receiving a VSCMatured:  func OnRecvVSCMaturedPacket(packet channeltypes.Packet, data ccv.VSCMaturedPacketData) exported.Acknowledgement { // ... // prune previous consumer validator address that are no longer needed consumerAddrs := GetConsumerAddrsToPrune(chainID, data.ValsetUpdateId) for _, addr := range consumerAddrs { DeleteValidatorByConsumerAddr(chainID, addr) } DeleteConsumerAddrsToPrune(chainID, data.ValsetUpdateId) // ... }   On stopping a consumer chain:  func (k Keeper) StopConsumerChain(ctx sdk.Context, chainID string, closeChan bool) (err error) { // ... // deletes all the state needed for key assignments on this consumer chain // ... }   ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#positive","content":" Validators can use different consensus keys on the consumer chains.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#negative","content":" None  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#neutral","content":" The consensus state necessary to create a client to the consumer chain must use the hash returned by the MakeConsumerGenesis method as the nextValsHash.The consumer chain can no longer check the initial validator set against the consensus state on InitGenesis.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v4.5.0/adrs/adr-001-key-assignment#references","content":" Key assignment issue ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 007: Pause validator unbonding during equivocation proposal","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#changelog","content":" 2023-05-16: Initial Draft2023-11-30: Change the status to rejected  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#status","content":" Rejected  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#context","content":" Note: ADR rejected as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  Currently, if an equivocation slashing proposal is created after more than one week has passed since the equivocation, it is possible that the validator in question could unbond and get away without being slashed, since the unbonding period is 3 weeks, and the voting period is 2 weeks. For this reason, it might be good to pause unbondings for validators named in an equivocation slashing proposal until the proposal's voting period is over.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#decision","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"How​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#how","content":" Pausing the unbonding period is already possible thanks to the changes in thestaking module of the cosmos-sdk:  stakingKeeper.PutUnbondingOnHold pauses an unbonding periodstakingKeeper.UnbondingCanComplete unpauses an unbonding period  These methods use a reference counter under the hood, that gets incremented every time PutUnbondingOnHold is called, and decreased whenUnbondingCanComplete is called instead. A specific unbonding is considered fully unpaused when its underlying reference counter reaches 0. Therefore, as long as we safeguard consistency - i.e. we make sure we eventually decrement the reference counter for each time we have incremented it - we can safely use this existing mechanism without conflicts with the Completion of Unbonding Operations system.  ","version":"v4.5.0","tagName":"h3"},{"title":"When pause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-pause","content":" The unbonding period (if there is any unbonding) should be paused once an equivocation proposal enters the voting period. For that, the gov module's hook AfterProposalDeposit can be used.  If the hook is triggered with a an equivocation proposal in voting period, then for each equivocation of the proposal, the unbonding operations of the related validator that were initiated after the equivocation block time must be paused  i.e. the underlying reference counter has to be increased.  Note that even after the voting period has started, a proposal can receive additional deposits. The hook is triggered however at arrival of a deposit, so a check to verify that the proposal is not already in voting period is required.  ","version":"v4.5.0","tagName":"h3"},{"title":"When unpause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-unpause","content":" We can use a gov module's hook also here and it isAfterProposalVotingPeriodEnded.  If the hook is triggered with an equivocation proposal, then for each associated equivocation, the unbonding operations of the related validator that were initiated between the equivocation block time and the start of the proposal voting period must be unpaused - i.e. decrease the underlying reference counter - regardless of the proposal outcome.  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#positive","content":" Validators subject to an equivocation proposal cannot finish unbonding their tokens before the end of the voting period.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#negative","content":" A malicious consumer chain could forge slash packets enabling submission of an equivocation proposal on the provider chain, resulting in the freezing of validator's unbondings for an undeterminated amount of time.Misbehavior on a consumer chain can potentially go unpunished, if no one submits an equivocation proposal in time, or if the proposal doesn't pass.  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#neutral","content":" This feature can't be used for social slashing, because an equivocation proposal is only accepted if there's a slash log for the related validator(s), meaning the consumer chain has reported the equivocation to the provider chain.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v4.5.0/adrs/adr-007-pause-unbonding-on-eqv-prop#references","content":" https://github.com/cosmos/interchain-security/issues/747https://github.com/cosmos/interchain-security/pull/791 ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 005: Cryptographic verification of equivocation evidence","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#changelog","content":" 5/1/2023: First draft7/23/2023: Add light client attacks handling9/6/2023: Add double signing attacks handling11/3/2023: Update limitations to clarify amnesia attacks are ignored  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#status","content":" Accepted  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#context","content":" Currently, we use a governance proposal to slash validators for equivocation (double signing and light client attacks). Every proposal needs to go through a (two weeks) voting period before it can be approved. Given a three-week unbonding period, this means that an equivocation proposal needs to be submitted within one week since the infraction occurred.  This ADR proposes a system to slash validators automatically for equivocation, immediately upon the provider chain's receipt of the evidence. Another thing to note is that we intend to introduce this system in stages, since even the partial ability to slash and/or tombstone is a strict improvement in security. The feature is implemented in two parts, each with its dedicated endpoint. One endpoint handles light client attacks, while the other handles double signing attacks.  ","version":"v4.5.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack","content":" In a nutshell, the light client is a process that solely verifies a specific state machine's consensus without executing the transactions. The light clients get new headers by querying multiple nodes, called primary and witness nodes.  Light clients download new headers committed on chain from a primary. Headers can be verified in two ways: sequentially, where the block height of headers is serial, or using skipping. This second verification method allows light clients to download headers with nonconsecutive block height, where some intermediate headers are skipped (see Tendermint Light Client, Figure 1 and Figure 3). Additionally, light clients are cross-checking new headers obtained from a primary with witnesses to ensure all nodes share the same state.  A light client attack occurs when a Byzantine validator sends invalid headers to a light client. As the light client doesn't execute transactions, it can be deceived into trusting corrupted application state transitions. For instance, if a light client receives header A from the primary and header B from a witness for the same block height H, and both headers are successfully verified, it indicates a light client attack. Note that in this case, either the primary or the witness or both are malicious.  The types of light client attacks are defined by analyzing the differences between the conflicting headers. There are three types of light client attacks: lunatic attack, equivocation attack, and amnesia attack. For details, see the CometBFT specification.  When a light client agent detects two conflicting headers, it will initially verify their traces (see cometBFT detector) using its primary and witness nodes. If these headers pass successful verification, the Byzantine validators will be identified based on the header's commit signatures and the type of light client attack. The agent will then transmit this information to its nodes using a LightClientAttackEvidence evidence to be eventually voted on and added to a block. Note that from a light client agent perspective, it is not possible to establish whether a primary or a witness node, or both, are malicious. Therefore, it will create and send two evidences: one against the primary (sent to the witness), and one against the witness (sent to the primary). Both nodes will then verify it before broadcasting it and adding it to the evidence pool. If an evidence is finally committed to a block, the chain's evidence module will execute it, resulting in the jailing and the slashing of the validators responsible for the light client attack.  Light clients are a core component of IBC. In the event of a light client attack, IBC relayers notify the affected chains by submitting an IBC misbehavior message. A misbehavior message includes the conflicting headers that constitute a light client attack evidence. Upon receiving such a message, a chain will first verify whether these headers would have convinced its light client. This verification is achieved by checking the header states against the light client consensus states (see IBC misbehaviour handler). If the misbehaviour is successfully verified, the chain will then &quot;freeze&quot; the light client, halting any further trust in or updating of its states.  ","version":"v4.5.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack","content":" A double signing attack, also known as equivocation, occurs when a validator votes for two different blocks in the same round of the CometBFT consensus. This consensus mechanism operates with multiple voting rounds at each block height, and it strictly prohibits sending two votes of the same type during a round (see CometBFT State Machine Overview).  When a node observes two votes from the same peer, it will use these two votes to create a DuplicateVoteEvidenceevidence and gossip it to the other nodes in the network (see CometBFT equivocation detection). Each node will then verify the evidence according to the CometBFT rules that define a valid double signing infraction, and based on this verification, they will decide whether to add the evidence to a block. During the evidence verification process, the signatures of the conflicting votes must be verified successfully. Note that this is achieved using the public key of the misbehaving validator, along with the chain ID of the chain where the infraction occurred (see CometBFT equivocation verification).  Once a double signing evidence is committed to a block, the consensus layer will report the equivocation to the evidence module of the Cosmos SDK application layer. The application will, in turn, punish the malicious validator through jailing, tombstoning and slashing (see handleEquivocationEvidence).  ","version":"v4.5.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#decision","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack-1","content":" In the first part of the feature, we introduce a new endpoint: HandleConsumerMisbehaviour(ctx sdk.Context, misbehaviour ibctmtypes.Misbehaviour). The main idea is to leverage the current IBC misbehaviour handling and update it to solely jail and slash the validators that performed a light client attack. Note that in this context, we assume that chains connected via a light client share a subset of the validator set of the provider.  This endpoint reuses the IBC client libraries to verify that the misbehaviour headers would have fooled the light client. Additionally, it’s crucial that the endpoint logic results in the slashing and jailing of validators under the same conditions as a light client agent detector. Therefore, the endpoint ensures that the two conditions are met: the headers in the misbehaviour message have the same block height, and the light client isn’t expired.  After having successfully verified a misbehaviour, the endpoint executes the jailing and slashing of the malicious validators similarly as in the evidence module.  ","version":"v4.5.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack-1","content":" In the second part of the feature, we introduce a new endpoint HandleConsumerDoubleVoting( ctx sdk.Context, evidence *tmtypes.DuplicateVoteEvidence, chainID string, pubkey cryptotypes.PubKey). Simply put, the handling logic verifies a double signing evidence against a provided public key and chain ID and, if successful, executes the jailing of the malicious validator who double voted.  We define a newMsgSubmitConsumerDoubleVoting message to report a double voting evidence observed on a consumer chain to the endpoint of the provider chain. This message contains two fields: a double signing evidenceduplicate_vote_evidence and a light client header for the infraction block height, referred to as infraction_block_header. The latter provides the malicious validator's public key and the chain ID required to verify the signature of the votes contained in the evidence.  Note that double signing evidence is not verified using the same conditions as in the implementation CometBFT (seeverify(evidence types.Evidence) method). Specifically, we do not check that the evidence hasn't expired. More details can be found in the &quot;Current limitations&quot; section below.  Upon a successful equivocation verification, the misbehaving validator is jailed for the maximum time (see DoubleSignJailEndTimein the SDK evidence module).  ","version":"v4.5.0","tagName":"h3"},{"title":"Current limitations:​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#current-limitations","content":" We cannot derive an infraction height from the evidence, so it is only possible to jail validators, not actually slash them. To explain the technical reasons behind this limitation, let's recap the initial consumer initiated slashing logic. In a nutshell, consumer heights are mapped to provider heights through VSCPackets, namely through the so called vscIDs. When an infraction occurs on the consumer, a SlashPacket containing the vscID obtained from mapping the consumer infraction height is sent to the provider. Upon receiving the packet, the provider maps the consumer infraction height to a local infraction height, which is used to slash the misbehaving validator. In the context of untrusted consumer chains, all their states, including vscIDs, could be corrupted and therefore cannot be used for slashing purposes. For the same reasons explained above, the age of a consumer double signing evidence can't be verified, either using its infraction height or its unsigned timestamp. Note that changes the jailing behaviour, potentially leading to a validator's jailing based on some &quot;old&quot; evidence from a consumer, which wouldn't occur if the consumer were a standalone chain. In the first stage of this feature, validators are jailed indefinitely without being tombstoned. The underlying reason is that a malicious validator could take advantage of getting tombstoned to avoid being slashed on the provider (see comment). Currently, the endpoint can only handle equivocation light client attacks. This is because the lunatic attacks require the endpoint to possess the ability to dissociate which header is conflicted or trusted upon receiving a misbehavior message. Without this information, it's not possible to extract the Byzantine validators from the conflicting headers (see comment). In addition, &quot;amnesia&quot; attacks are ignored, similar to CometBFT (see ADR-056).  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#positive","content":" It is now possible for the provider chain to jail validators who committed light client or double signing attacks on a consumer chain.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#negative","content":" N/A  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v4.5.0/adrs/adr-005-cryptographic-equivocation-verification#references","content":" ICS misbehaviour handling PRConsumer double voting handler PRArchitectural diagramsADR on equivocation slashing ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 002: Jail Throttling","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#changelog","content":" 2023-01-26: Initial Draft2023-02-07: Property refined, ADR ready to review/merge2023-11-22: Refactor for better understanding  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#status","content":" Accepted  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#context","content":" The CCV spec is based around the assumption that the provider binary and all consumers binaries are non-malicious, and follow the defined protocols. In practice, this assumption may not hold. A malicious consumer binary could potentially include code which is able to send many slash/jail packets at once to the provider.  Before the throttling feature was implemented, the following attack was possible. Attacker(s) would create provider validators just below the provider's active set. Using a malicious consumer binary, slash packets would be relayed to the provider, that would slash/jail a significant portion (or all) of honest validator at once. Control of the provider would then pass over to the attackers' validators. This enables the attacker(s) to halt the provider. Or even worse, commit arbitrary state on the provider, potentially stealing all tokens bridged to the provider over IBC.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#decision","content":" The throttling feature was designed to slow down the mentioned attack from above, allowing validators and the community to appropriately respond to the attack, i.e., this feature limits (enforced by on-chain params) the rate that the provider validator set can be jailed over time.  ","version":"v4.5.0","tagName":"h2"},{"title":"Required State​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#required-state","content":" Slash meter: There exists one slash meter on the provider which stores an amount of voting power (integer), corresponding to an allowance of validators that can be jailed over time. This meter is initialized to a certain value on genesis, decremented by the amount of voting power jailed whenever a slash packet is handled, and periodically replenished as decided by on-chain params.  Global entry queue: There exists a single queue which stores &quot;global slash entries&quot;. These entries allow the provider to appropriately handle slash packets sent from any consumer in FIFO ordering. This queue is responsible for coordinating the order that slash packets (from multiple chains) are handled over time.  Per-chain data queue: For each established consumer, there exists a queue which stores &quot;throttled packet data&quot;, i.e.,pending slash packet data is queued together with pending VSC matured packet data in FIFO ordering. Order is enforced by IBC sequence number. These &quot;per-chain&quot; queues are responsible for coordinating the order that slash packets are handled in relation to VSC matured packets from the same chain.  Note: The reason for a multiple-queue design is the VSC Maturity and Slashing Order property (see spec). There are other ways to ensure such a property (like a queue of linked lists, etc.), but the proposed approach seemed to be the most understandable and easiest to implement with a KV store.  ","version":"v4.5.0","tagName":"h3"},{"title":"Params​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#params","content":" SlashMeterReplenishPeriod -- the period after which the slash meter is replenished.  SlashMeterReplenishFraction -- the portion (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs. This param also serves as a maximum fraction of total voting power that the slash meter can hold.  MaxThrottledPackets -- the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value. This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness.  ","version":"v4.5.0","tagName":"h3"},{"title":"Protocol Overview​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#protocol-overview","content":" OnRecvSlashPacket​  Upon the provider receiving a slash packet from any of the established consumers during block execution, two things occur:  A global slash entry is queued.The data of such a packet is added to the per-chain queue.  OnRecvVSCMaturedPacket​  Upon the provider receiving a VSCMatured packet from any of the established consumers during block execution, the VSCMatured packet data is added to the per-chain queue.  Endblocker​  In the EndBlock of the provider CCV module, there are three actions performed:  replenish the slash meter;handle the leading VSCMaturedPackets;and handle the throttle queues.  Slash Meter Replenishment​  Once the slash meter becomes not full, it'll be replenished after SlashMeterReplenishPeriod by incrementing the meter with its allowance for the replenishment block, where allowance = SlashMeterReplenishFraction * currentTotalVotingPower. The slash meter will never exceed its current allowance (function of the total voting power for the block) in value.  Note a few things:  The slash meter can go negative in value, and will do so when handling a single slash packet that jails a validator with significant voting power. In such a scenario, the slash meter may take multiple replenishment periods to once again reach a positive value (or 0), meaning no other slash packets may be handled for multiple replenishment periods.Total voting power of a chain changes over time, especially as validators are jailed. As validators are jailed, total voting power decreases, and so does the jailing allowance. See below for more detailed throttling property discussion.The voting power allowance added to the slash meter during replenishment will always be greater than or equal to 1. If the SlashMeterReplenishFraction is set too low, integer rounding will put this minimum value into effect. That is, if SlashMeterReplenishFraction * currentTotalVotingPower &lt; 1, then the effective allowance would be 1. This min value of allowance ensures that there's some packets handled over time, even if that is a very long time. It's a crude solution to an edge case caused by too small of a replenishment fraction.  The behavior described above is achieved by executing CheckForSlashMeterReplenishment() every EndBlock, BEFORE HandleThrottleQueues() is executed.  Handle Leading VSCMaturedPackets​  In every block, it is possible that VSCMaturedPacket data was queued before any slash packet data. Since this &quot;leading&quot; VSCMatured packet data does not have to be throttled (see VSC Maturity and Slashing Order), we can handle all VSCMatured packet data at the head of the queue, before the any throttling or packet data handling logic executes.  Handle Throttle Queues​  In every EndBlock, the following logic is executed to handle data from the throttle queues.  meter := getSlashMeter() // Keep iterating as long as the meter has a positive (or 0) value, and global slash entries exist while meter.IsPositiveOrZero() &amp;&amp; entriesExist() { // Get next entry in queue entry := getNextGlobalSlashEntry() // Decrement slash meter by the voting power that will be removed from the valset from handling this slash packet valPower := entry.getValPower() meter = meter - valPower // Using the per-chain queue, handle the single slash packet using its queued data, // then handle all trailing VSCMatured packets for this consumer handleSlashPacketAndTrailingVSCMaturedPackets(entry) // Delete entry in global queue, delete handled data entry.Delete() deleteThrottledSlashPacketData() deleteTrailingVSCMaturedPacketData() }   ","version":"v4.5.0","tagName":"h3"},{"title":"System Properties​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#system-properties","content":" All CCV system properties should be maintained by implementing this feature, see CCV spec - Consumer Initiated Slashing.  One implementation-specific property introduced is that if any of the chain-specific packet data queues become larger than MaxThrottledPackets, then the provider binary will panic, and the provider chain will halt. Therefore this param should be set carefully. See SetThrottledPacketDataSize. This behavior ensures that if the provider binaries are queuing up more packet data than machines can handle, the provider chain halts deterministically between validators.  ","version":"v4.5.0","tagName":"h3"},{"title":"Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#main-throttling-property","content":" Using on-chain params and the sub protocol defined, slash packet throttling is implemented such that the following property holds under some conditions.  First, we introduce the following definitions:  A consumer initiated slash attack &quot;starts&quot; when the first slash packet from such an attack is received by the provider.The &quot;initial validator set&quot; for the attack is the validator set that existed on the provider when the attack started.There is a list of honest validators such that if they are jailed, X% of the initial validator set will be jailed.  For the Throttling Property to hold, the following assumptions must be true:  We assume the total voting power of the chain (as a function of delegations) does not increase over the course of the attack.No validator has more than SlashMeterReplenishFraction of total voting power on the provider.SlashMeterReplenishFraction is large enough that SlashMeterReplenishFraction * currentTotalVotingPower &gt; 1, i.e., the replenish fraction is set high enough that we can ignore the effects of rounding.SlashMeterReplenishPeriod is sufficiently longer than the time it takes to produce a block.  Note if these assumptions do not hold, throttling will still slow down the described attack in most cases, just not in a way that can be succinctly described. It's possible that more complex properties can be defined.  Throttling Property: The time it takes to jail/tombstone X% of the initial validator set will be greater than or equal toSlashMeterReplenishPeriod⋅XSlashMeterReplenishFraction−2⋅SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod} \\cdot \\frac{X}{\\mathit{SlashMeterReplenishFraction}} - 2 \\cdot \\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriod⋅SlashMeterReplenishFractionX​−2⋅SlashMeterReplenishPeriod.  Intuition Let's use the following notation: CCC: Number of replenishment cyclesPPP: SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriodFFF: SlashMeterReplenishFraction\\mathit{SlashMeterReplenishFraction}SlashMeterReplenishFractionVmaxV_{\\mathit{max}}Vmax​: Max power of a validator as a fraction of total voting power In CCC number of replenishment cycles, the fraction of total voting power that can be removed, aaa, is a≤F⋅C+Vmaxa \\leq F \\cdot C + V_{\\mathit{max}}a≤F⋅C+Vmax​ (where VmaxV_{\\mathit{max}}Vmax​ is there to account for the power fraction of the last validator removed, one which pushes the meter to the negative value). So, we need at least C≥a−VmaxFC \\geq \\frac{a - V_{\\mathit{max}}}{F}C≥Fa−Vmax​​ cycles to remove aaa fraction of the total voting power. Since we defined the start of the attack to be the moment when the first slash request arrives, then FFF fraction of the initial validator set can be jailed immediately. For the remaining X−FX - FX−F fraction of the initial validator set to be jailed, it takes at least C≥(X−F)−VmaxFC \\geq \\frac{(X - F) - V_{\\mathit{max}}}{F}C≥F(X−F)−Vmax​​ cycles. Using the assumption that Vmax≤FV_{\\mathit{max}} \\leq FVmax​≤F (assumption 2), we get C≥X−2FFC \\geq \\frac{X - 2F}{F}C≥FX−2F​ cycles. In order to execute CCC cycles, we need C⋅PC \\cdot PC⋅P time. Thus, jailing the remaining X−FX - FX−F fraction of the initial validator set corresponds to P⋅(X−2F)F\\frac{P \\cdot (X - 2F)}{F}FP⋅(X−2F)​ time. In other words, the attack must take at least P⋅XF−2P\\frac{P \\cdot X}{F} - 2PFP⋅X​−2P time (in the units of replenish period PPP).  This property is useful because it allows us to reason about the time it takes to jail a certain percentage of the initial provider validator set from consumer initiated slash requests. For example, if SlashMeterReplenishFraction is set to 0.06, then it takes no less than 4 replenishment periods to jail 33% of the initial provider validator set on the Cosmos Hub. Note that as of writing this on 11/29/22, the Cosmos Hub does not have a validator with more than 6% of total voting power.  Note also that 4 replenishment period is a worst case scenario that depends on well crafted attack timings.  ","version":"v4.5.0","tagName":"h3"},{"title":"How Unjailing Affects the Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#how-unjailing-affects-the-main-throttling-property","content":" Note that the jailing allowance is directly proportional to the current total voting power of the provider chain. Therefore, if honest validators don't unjail themselves during the attack, the total voting power of the provider chain will decrease over the course of the attack, and the attack will be slowed down, main throttling property is maintained.  If honest validators do unjail themselves, the total voting power of the provider chain will still not become higher than when the attack started (unless new token delegations happen), therefore the main property is still maintained. Moreover, honest validators unjailing themselves helps prevent the attacking validators from gaining control of the provider.  In summary, the throttling mechanism as designed has desirable properties whether or not honest validators unjail themselves over the course of the attack.  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#positive","content":" The described attack is slowed down in seemingly all cases.If certain assumptions hold, the described attack is slowed down in a way that can be precisely time-bounded.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#negative","content":" Throttling introduces a vector for a malicious consumer chain to halt the provider, see issue below. However, this is sacrificing liveness in a edge case scenario for the sake of security. As an improvement, using retries would fully prevent this attack vector.  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#neutral","content":" Additional state is introduced to the provider chain.VSCMatured and slash packet data is not always handled in the same block that it is received.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v4.5.0/adrs/adr-002-throttle#references","content":" Original issue inspiring throttling featureIssue on DOS vectorConsideration of another attack vector ","version":"v4.5.0","tagName":"h2"},{"title":"Soft Opt-Out","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out","content":"","keywords":"","version":"v4.5.0"},{"title":"ADR 009: Soft Opt-Out​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#adr-009-soft-opt-out","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#changelog","content":" 6/13/23: Initial draft of ADR. Feature already implemented and in production.6/19/24: Change status to deprecated  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#status","content":" Deprecated Deprecated by Partial Set Security  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#context","content":" Some small validators may not have the resources needed to validate all consumer chains. Therefore a need exists to allow the bottom x% of validators to opt-out of validating a consumer chain. Meaning downtime infractions for these validators are dropped without ever reaching the provider.  This document specifies a modification to the ccv protocol which allows the bottom x% of the validator set by power to opt out of validating consumer chains without being jailed or otherwise punished for it. The feature is implemented with entirely consumer-side code.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#decision","content":" A consumer param exists, known as SoftOptOutThreshold, which is a string decimal in the range of [0, 0.2], that determines the portion of validators which are allowed to opt out of validating that specific consumer.  In every consumer beginblocker, a function is ran which determines the so called smallest non opt-out voting power. Validators with voting power greater than or equal to this value must validate the consumer chain, while validators below this value may opt out of validating the consumer chain.  The smallest non opt-out voting power is recomputed every beginblocker in UpdateSmallestNonOptOutPower(). In a nutshell, the method obtains the total voting power of the consumer, iterates through the full valset (ordered power ascending) keeping track of a power sum, and when powerSum / totalPower &gt; SoftOptOutThreshold, the SmallestNonOptOutPower is found and persisted.  Then, whenever the Slash() interface is executed on the consumer, if the voting power of the relevant validator being slashed is less than SmallestNonOptOutPower for that block, the slash request is dropped and never sent to the provider.  ","version":"v4.5.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#positive","content":" Small validators can opt out of validating specific consumers without being punished for it.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#negative","content":" The bottom x% is still part of the total voting power of the consumer chain. This means that if the soft opt-out threshold is set to 10% for example, and every validator in the bottom 10% opts out from validating the consumer, then a 24% downtime of the remaining voting power would halt the chain. This may be especially problematic during consumer upgrades.In nominal scenarios, consumers with soft opt out enabled will be constructing slash packets for small vals, which may be dropped. This is wasted computation, but necessary to keep implementation simple. Note that the sdk's full downtime logic is always executed on the consumer, which can be computationally expensive and slow down certain blocks.In a consumer chain, when a validator that has opted out becomes the proposer, there will naturally be no proposal made and validators would need to move to the next consensus round for the same height to reach a decision. As a result, we would need more time to finalize blocks on a consumer chain.  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#neutral","content":" Validators in the bottom of the valset who don't have to validate, may receive large delegation(s) which suddenly boost the validator to the subset that has to validate. This may catch the validator off guard.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v4.5.0/adrs/adr-009-soft-opt-out#references","content":" Original issue with some napkin math #784 ","version":"v4.5.0","tagName":"h2"},{"title":"Throttle with retries","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries","content":"","keywords":"","version":"v4.5.0"},{"title":"ADR 008: Throttle with retries​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#adr-008-throttle-with-retries","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#changelog","content":" 6/9/23: Initial draft6/22/23: added note on consumer pending packets storage optimization7/14/23: Added note on upgrade order  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#status","content":" Accepted  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#context","content":" For context on why the throttling mechanism exists, see ADR 002.  Note the terms slash throttling and jail throttling are synonymous, since in Interchain Security a SlashPacket simply jails a validator for downtime infractions.  Currently the throttling mechanism is designed so that provider logic (slash meter, etc.) dictates how many SlashPackets can be handled over time. Throttled SlashPackets are persisted on the provider, leading to multiple possible issues. Namely:  If SlashPackets or VSCMaturedPackets are actually throttled/queued on the provider, state can grow and potentially lead to a DoS attack. We have short term solutions around this, but overall they come with their own weaknesses. See #594.If a jailing attack described in ADR 002 were actually to be carried out with the current throttling design, we'd likely have to halt the provider, and perform an emergency upgrade and/or migration to clear the queues of SlashPackets that were deemed to be malicious. Alternatively, validators would just have to tough it out and wait for the queues to clear, during which all/most validators would be jailed. Right after being jailed, validators would have to unjail themselves promptly to ensure safety. The coordination required to maintain safety in such a scenario is not ideal.  As a solution, we can improve the throttling mechanism to instead queue/persist relevant data on each consumer, and have consumers retry slash requests as needed.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#decision","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Consumer changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#consumer-changes","content":" Note the consumer already queues up both SlashPackets and VSCMaturedPackets via AppendPendingPacket. Those packets are dequeued in every EndBlock in SendPackets and sent to the provider.  Instead, we will now introduce the following logic on EndBlock:  Slash packets will always be sent to the provider once they're at the head of the queue. However, once sent, the consumer will not send any subsequent VSCMaturedPackets from the queue until the provider responds with an acknowledgement that the sent SlashPacket has been handled, i.e., validator was jailed. That is, SlashPackets block the sending of subsequent VSCMaturedPackets in the consumer queue.If two SlashPackets are at the head of the queue, the consumer will send the first SlashPacket, and then wait for a success acknowledgement from the provider before sending the second SlashPacket. This seems like it'd simplify implementation.VSCMaturedPackets at the head of the queue (i.e., NOT following a SlashPacket) can be sent immediately, and do not block any other packets in the queue, since the provider always handles them immediately.  To prevent the provider from having to keep track of what SlashPackets have been rejected, the consumer will have to retry the sending of SlashPackets over some period of time. This can be achieved with an on-chain consumer param, i.e., RetryDelayPeriod. To reduce the amount of redundant re-sends, we recommend setting RetryDelayPeriod ~ SlashMeterReplenishmentPeriod, i.e., waiting for the provider slash meter to be replenished before resending the rejected SlashPacket.  Note to prevent weird edge case behavior, a retry would not be attempted until either a success or failure acknowledgement has been received from the provider.  With the behavior described, we maintain very similar behavior to the previous throttling mechanism regarding the timing that SlashPackets and VSCMaturedPackets are handled on the provider. Obviously the queueing and blocking logic is moved, and the two chains would have to send more messages between one another (only in the case the throttling mechanism is triggered).  In the normal case, when no or a few SlashPackets are being sent, the VSCMaturedPackets will not be delayed, and hence unbonding will not be delayed.  For the implementation of this design, see throttle_retry.go.  Consumer pending packets storage optimization​  In addition to the mentioned consumer changes, an optimization will need to be made to the consumer's pending packets storage to properly implement the feature from this ADR.  The consumer ccv module previously queued &quot;pending packets&quot; to be sent in each EndBlock in SendPackets. These packets are queued in state with a protobuf list of ConsumerPacketData. For a single append operation, the entire list is deserialized, then a packet is appended to that list, and the list is serialized again. See older version of AppendPendingPacket. That is, a single append operation has O(N) complexity, where N is the size of the list.  This poor append performance isn't a problem when the pending packets list is small. But with this ADR being implemented, the pending packets list could potentially grow to the order of thousands of entries when SlashPackets need to be resent.  We can improve the append time for this queue by converting it from a protobuf-esq list, to a queue implemented with sdk-esq code. The idea is to persist a uint64 index that will be incremented each time you queue up a packet. You can think of this as storing the tail of the queue. Then, packet data will be keyed by that index, making the data naturally ordered byte-wise for sdk's iterator. The index will also be stored in the packet data value bytes, so that the index can later be used to delete certain packets from the queue.  Two things are achieved with this approach:  More efficient packet append/enqueue timesThe ability to delete select packets from the queue (previously all packets were deleted at once)  ","version":"v4.5.0","tagName":"h3"},{"title":"Provider changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#provider-changes","content":" The main change needed for the provider is the removal of queuing logic for SlashPackets and VSCMaturedPackets upon being received.  Instead, the provider will consult the slash meter to determine if a SlashPacket can be handled immediately. If not, the provider will return an acknowledgement message to the consumer communicating that the SlashPacket could not be handled, and needs to be sent again in the future (retried).  VSCMaturedPackets will always be handled immediately upon being received by the provider.  Note spec. Specifically the section on VSC Maturity and Slashing Order. Previously the onus was on the provider to maintain this property via queuing packets and handling them FIFO.  Now this property will be maintained by the consumer sending packets in the correct order, and blocking the sending of VSCMaturedPackets as needed. Then, the ordered IBC channel will ensure that SlashPackets and VSCMaturedPackets are received in the correct order on the provider.  The provider's main responsibility regarding throttling will now be to determine if a received SlashPacket can be handled via slash meter etc., and appropriately acknowledge to the sending consumer.  Handling VSCMaturedPackets immediately​  Why the provider can handle VSCMatured packets immediately​  A VSCMaturedPacket communicates to the provider that sufficient time passed on the consumer since the corresponding VSCPacket has been applied (on the consumer) such that infractions committed on the consumer could have been submitted.  If the consumer is following the queuing/blocking protocol described, then no bad behavior occurs and the VSC Maturity and Slashing Order property is maintained.  If a consumer sends VSCMaturedPackets too leniently -- the consumer is malicious and sends duplicate VSCMaturedPackets, or sends the packets sooner than the CCV protocol specifies -- then the provider needs to handle VSCMaturedPackets immediately to prevent DOS, state bloat, or other issues. The only possible negative outcome is that the malicious consumer may not be able to jail a validator who should have been jailed. The malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  If a consumer blocks the sending of VSCMaturedPackets, then unbonding operations on the provider will be delayed, but only until the VSC timeout period has elapsed. At that time, the consumer is removed. Again the malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  ","version":"v4.5.0","tagName":"h3"},{"title":"Splitting of PRs and Upgrade Order​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#splitting-of-prs-and-upgrade-order","content":" This feature will implement consumer changes in #1024.  ❗These changes should be deployed to production for all consumers before the provider changes are deployed to production.  In other words, the consumer changes in #1024 are compatible with the current (&quot;v1&quot;) provider implementation of throttling that's running on the Cosmos Hub as of July 2023.  Once all consumers have deployed the changes in #1024, the provider changes from #1321 can be deployed to production, fully enabling v2 throttling.  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#consequences","content":" Consumers will now have to manage their own queues, and retry logic.Consumers still aren't trustless, but the provider is now less susceptible to mismanaged or malicious consumers.Recovering from the &quot;jailing attack&quot; is more elegant.Some issues like #1001 will now be handled implicitly by the improved throttling mechanism.SlashPackets and VSCMaturedPackets can be handled immediately once received by the provider if the slash meter allows.In general, we reduce the amount of computation that happens in the provider EndBlock.  ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#positive","content":" We no longer have to reason about a &quot;global queue&quot; and a &quot;chain specific queue&quot;, and keeping those all in-sync. Now SlashPackets and VSCMaturedPackets queuing is handled on each consumer individually.Due to the above, the throttling protocol becomes less complex overall.We no longer have to worry about throttle related DoS attack on the provider, since no queuing exists on the provider.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#negative","content":" Increased number of IBC packets being relayed anytime throttling logic is triggered.Consumer complexity increases, since consumers now have manage queuing themselves, and implement packet retry logic.  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#neutral","content":" Core throttling logic on the provider remains unchanged, i.e., slash meter, replenishment cycles, etc.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v4.5.0/adrs/adr-008-throttle-retries#references","content":" EPIC tracking the changes proposed by this ADRADR 002: Jail Throttling#594 ","version":"v4.5.0","tagName":"h2"},{"title":"Standalone to Consumer Changeover","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover","content":"","keywords":"","version":"v4.5.0"},{"title":"ADR 010: Standalone to Consumer Changeover​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#adr-010-standalone-to-consumer-changeover","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#changelog","content":" 6/30/23: Feature completed, first draft of ADR.  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#status","content":" Implemented  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#context","content":" Stride will be the first consumer to &quot;changeover&quot; from a standalone cosmos blockchain, to a consumer chain secured by the Cosmos Hub. This document outlines the changes made to support this changeover process.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#decision","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Process​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#process","content":" Prior to the changeover, the consumer chain will have an existing staking keeper and validator set, these may be referred to as the &quot;standalone staking keeper&quot; and &quot;standalone validator set&quot; respectively.  The first step in the changeover process is to submit a ConsumerAdditionProposal. If the proposal passes, the provider will create a new IBC client for the consumer at spawn time, with the provider's validator set. A consumer genesis will also be constructed by the provider for validators to query. Within this consumer genesis contains the initial validator set for the consumer to apply after the changeover.  Next, the standalone consumer chain runs an upgrade which adds the CCV module, and is properly setup to execute changeover logic.  The consumer upgrade height must be reached after the provider has created the new IBC client. Any Interchain Security validators who will run the consumer, but are not a part of the sovereign validator set, must sync up a full node before the consumer upgrade height is reached. The disk state of said full node will be used to run the consumer chain after the changeover has completed.  The meat of the changeover logic is that the consumer chain validator set is updated to that which was specified by the provider via the queried consumer genesis. Validators which were a part of the old set, but not the new set, are given zero voting power. Once these validator updates are given to Comet, the set is committed, and in effect 2 blocks later (see FirstConsumerHeight).  A relayer then establishes the new IBC connection between the provider and consumer. The CCV channel handshake is started on top of this connection. Once the CCV channel is established and VSC packets are being relayed, the consumer chain is secured by the provider.  ","version":"v4.5.0","tagName":"h3"},{"title":"Changes to CCV Protocol​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#changes-to-ccv-protocol","content":" Consumer Genesis state is updated to include a PreCCV boolean. When this boolean is set true in the consumer genesis JSON, special logic is executed on InitGenesis to trigger the changeover process on the consumer's first endblocker after the upgrade which adds the CCV module. Note that InitGenesis is not automatically called during chain upgrades, so the consumer must manually call the consumer's InitGenesis method in an upgrade handler.The ConsumerAdditionProposal type is updated to include a DistributionTransmissionChannel field. This field allows the consumer to use an existing IBC transfer channel to send rewards as a part of the CCV protocol. Consumers that're not changing over from a standalone chain will leave this field blank, indicating that a new transfer channel should be created on top of the same connection as the CCV channel.The CCV consumer keeper is updated to contain an optional reference to the standalone staking keeper. The standalone staking keeper is used to slash for infractions that happened before the changeover was completed. Ie. any infraction from a block height before the changeover, that is submitted after the changeover, will call the standalone staking keeper's slash method. Note that a changeover consumer's standalone staking keeper becomes a democracy module keeper, so it is possible for a governance token to be slashed.  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#positive","content":" Existing cosmos chains are now able to onboard over to a consumer chain secured by a provider.The previous staking keepers for such chains can be transitioned to democracy staking module keepers.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#negative","content":" The delineation between different types of consumers in this repo becomes less clear. Ie. there is code in the democracy consumer's app.go that only applies to a previously standalone chain, but that file also serves as the base for a normal democracy consumer launched with RS from genesis.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v4.5.0/adrs/adr-010-standalone-changeover#references","content":" EPIC: Standalone to Consumer Changeover #756Changeover diagram from Stride ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 012: Separate Releasing","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#changelog","content":" 0.0202020202020202: Initial draft of idea in #8010.01652892561983471: Put idea in this ADR0.05: Reject this ADR  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#status","content":" Rejected  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#context","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Spike results​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#spike-results","content":" I explored the idea of #801 with this spike branch. Here's my conclusions:  Splitting this repo to have multiple go.mods is possible. However there are various intricacies involved in decoupling the package hierarchy to have x/ccv/types as the lowest level dep, with x/ccv/consumer and x/ccv/provider being one dep layer above, with high-level tests depending on all three of the mentioned packages. I'd estimate this decoupling would take 2-5 workdays to finish, and require significant review effort.  ","version":"v4.5.0","tagName":"h3"},{"title":"Why go.mod split is not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#why-gomod-split-is-not-the-way-to-go","content":" Let's take a step back and remember the issue we're trying to solve - We need a clean way to decouple semver/releasing for the consumer and provider modules. After more consideration, splitting up go.mods gives us little benefit in achieving this. Reasons:  The go.mod dependency system is tied to git tags for the entire repo (ex: require github.com/cometbft/cometbft v0.37.2 refers to a historical tag for the entire cometbft repo).It'd be an odd dev experience to allow modules to reference past releases of other modules in the same repo. When would we ever want the consumer module to reference a past release of the types module for example?If we allow for go.mod replace statements to build from local source code, why split up the package deps at all?Splitting go.mods adds a bunch of complexity with go.work files and all that shiz. VSCode does not play well with multiple module repos either.  ","version":"v4.5.0","tagName":"h3"},{"title":"Why separate repos is cool but also not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#why-separate-repos-is-cool-but-also-not-the-way-to-go","content":" All this considered, the cleanest solution to decoupling semver/releasing for the consumer and provider modules would be to have multiple repos, each with their own go.mod (3-4 repos total including high level tests). With this scheme we could separately tag each repo as changes are merged, they could share some code from types being an external dep, etc.  I don't think any of us want to split up the monorepo, that's a lot of work and seems like bikeshedding. There's another solution that's very simple..  ","version":"v4.5.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#decision","content":" Slightly adapting the current semver ruleset:  A library API breaking change to EITHER the provider or consumer module will result in an increase of the MAJOR version number for BOTH modules (X.y.z-provider AND X.y.z-consumer).A state breaking change (change requiring coordinated upgrade and/or state migration) will result in an increase of the MINOR version number for the AFFECTED module(s) (x.Y.z-provider AND/OR x.Y.z-consumer).Any other changes (including node API breaking changes) will result in an increase of the PATCH version number for the AFFECTED module(s) (x.y.Z-provider AND/OR x.y.Z-consumer).  ","version":"v4.5.0","tagName":"h2"},{"title":"Example release flow​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#example-release-flow","content":" We upgrade main to use a new version of SDK. This is a major version bump, triggering a new release for both the provider and consumer modules, v5.0.0-provider and v5.0.0-consumer.  A state breaking change is merged to main for the provider module. We release only a v5.1.0-provider off main.Another state breaking change is merged to main for the provider module. We release only a v5.2.0-provider off main.At this point, the latest consumer version is still v5.0.0-consumer. We now merge a state breaking change for the consumer module to main, and consequently release v5.1.0-consumer. Note that v5.1.0-consumer is tagged off a LATER commit from main than v5.2.0-provider. This is fine, as the consumer module should not be affected by the provider module's state breaking changes.Once either module sees a library API breaking change, we bump the major version for both modules. For example, we merge a library API breaking change to main for the provider module. We release v6.0.0-provider and v6.0.0-consumer off main. Note that most often, a library API breaking change will affect both modules simultaneously (example being bumping sdk version).  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#positive","content":" Consumer repos have clear communication of what tagged versions are relevant to them. Consumer devs should know to never reference an ICS version that starts with provider, even if it'd technically build.Consumer and provider modules do not deviate as long as we continually release off a shared main branch. Backporting remains relatively unchanged besides being explicit about what module(s) your changes should affect.No code changes, just changes in process. Very simple.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#negative","content":" ~~Slightly more complexity.~~Considerably more complex to manage the ICS library. This is because ICS needs to support multiple versions of SDK (e.g., 0.45, 0.47, 0.50). In addition, ICS needs to support a special fork of SDK (with LSM included) for the Cosmos Hub. This means that instead of focusing on main the development team needs to manage multiple release branches with different dependency trees.This solution does not allow having provider and consumer on separate versions of e.g. the Cosmos SDK.  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#neutral","content":" ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v4.5.0/adrs/adr-012-separate-releasing#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  #801#801 comment ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 014: Epochs","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs#changelog","content":" 2024-01-05: Proposed, first draft of ADR.2024-02-29: Updated so that it describes the implementation where we store the whole consumer validator set.  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs#status","content":" Accepted  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs#context","content":" In every block that the provider valset changes, a VSCPacket must be sent to every consumer and a corresponding VSCMaturedPacket sent back. Given that the validator powers may change very often on the provider chain (e.g., the Cosmos Hub), this approach results in a large workload for the relayers. Although the validator powers may change very often, these changes are usually small and have an insignificant impact on the chain's security. In other words, the valset on the consumers can be slightly outdated without affecting security. As a matter of fact, this already happens due to relaying delays.  As a solution, this ADR introduces the concept of epochs. An epoch consists of multiple blocks. The provider sends VSCPackets once per epoch. A VSCPacket contains all the validator updates that are needed by a consumer chain.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs#decision","content":" The implementation of epochs requires the following changes:  For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. For each validator in the set we store i) its voting power, and ii) the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. The initial consumer validator set for a chain is set during the creation of the consumer genesis.We introduce the BlocksPerEpoch param that sets the number of blocks in an epoch. By default, BlocksPerEpoch is set to be 600 which corresponds to 1 hour, assuming 6 seconds per block. This param can be changed through a governance proposal. In the provider EndBlock we check BlockHeight() % BlocksPerEpoch() == 0to decide when an epoch has ended.At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacket with all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   Note that a validator can change its consumer public key for a specific consumer chain an arbitrary amount of times during a block and during an epoch. Then, when we generate the validator updates in DiffValidators, we have to check whether the current consumer public key (retrieved by calling GetValidatorConsumerPubKey) is different from the consumer public key the validator was using in the current epoch.  ","version":"v4.5.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs#positive","content":" Reduce the cost of relaying.Reduce the amount of IBC packets needed for ICS.Simplifies key-assignment code because we only need to check if the consumer_public_key has been modified since the last epoch to generate an update.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs#negative","content":" Increase the delay in the propagation of validator set changes (but for reasonable epoch lengths on the order of ~hours or less, this is unlikely to be significant).  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs#neutral","content":" N/A  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v4.5.0/adrs/adr-014-epochs#references","content":" EPIC ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 013: Slashing on the provider for consumer equivocation","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#changelog","content":" 1st Sept. 2023: Initial draft  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#status","content":" Accepted  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#context","content":" This ADR presents some approaches on how to slash on the provider chain validators that performed equivocations on consumer chains. Currently, the provider chain can receive and verify evidence of equivocation, but it cannot slash the misbehaving validator.  In the remainder of this section, we explain how slashing is performed on a single chain and show why slashing on the provider for equivocation on the consumer is challenging.  Note that future versions of the Cosmos SDK, CometBFT, and ibc-go could modify the way we slash, etc. Therefore, a future reader of this ADR, should note that when we refer to Cosmos SDK, CometBFT, and ibc-go we specifically refer to their v0.47, v0.37 and v7.3.0 versions respectively.  ","version":"v4.5.0","tagName":"h2"},{"title":"Single-chain slashing​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#single-chain-slashing","content":" Slashing is implemented across the slashingand staking modules. The slashing module's keeper calls the staking module's Slash() method, passing among others, the infractionHeight (i.e., the height when the equivocation occurred), the validator's power at the infraction height, and the slashFactor (currently set to 5% in case of equivocation on the Cosmos Hub).  Slashing undelegations and redelegations​  To slash undelegations, Slash goes through all undelegations and checks whether they started before or after the infraction occurred. If an undelegation started before the infractionHeight, then it is not slashed, otherwise it is slashed by slashFactor.  The slashing of redelegations happens in a similar way, meaning that Slash goes through all redelegations and checks whether the redelegations started before or after the infractionHeight.  Slashing delegations​  Besides undelegations and redelegations, the validator's delegations need to also be slashed. This is performed by deducting the appropriate amount of tokens from the validator. Note that this deduction is computed based on the voting power the misbehaving validator had at the height of the equivocation. As a result of the tokens deduction, the tokens per sharereduce and hence later on, when delegators undelegate or redelegate, the delegators retrieve back less tokens, effectively having their tokens slashed. The rationale behind this slashing mechanism, as mentioned in the Cosmos SDK documentation  [...] is to simplify the accounting around slashing. Rather than iteratively slashing the tokens of every delegation entry, instead the Validators total bonded tokens can be slashed, effectively reducing the value of each issued delegator share.  This approach of slashing delegations does not utilize theinfractionHeight in any way and hence the following scenario could occur:  a validator V performs an equivocation at a height Hia new delegator D delegates to V after height Hievidence of the equivocation by validator V is receivedthe tokens of delegator D are slashed  In the above scenario, delegator D is slashed, even though D's voting power did not contribute to the infraction.  Old evidence​  In the single-chain case, old evidence (e.g., from 3 years ago) is ignored. This is achieved throughCometBFT that ignores old evidence based on the parameters MaxAgeNumBlocks and MaxAgeDuration (see here). Additionally, note that when the evidence is sent by CometBFT to the application, the evidence is rechecked in the evidence module of Cosmos SDK and if it is old, the evidence is ignored. In Cosmos Hub, the MaxAgeNumBlocks is set to 1000000 (i.e., ~70 days if we assume we need ~6 sec per block) and MaxAgeDuration is set to 172800000000000 ns (i.e., 2 days). Because of this check, we can easily exclude old evidence.  ","version":"v4.5.0","tagName":"h3"},{"title":"Slashing for equivocation on the consumer​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#slashing-for-equivocation-on-the-consumer","content":" In the single-chain case, slashing requires both the infractionHeight and the voting power. In order to slash on the provider for an equivocation on a consumer, we need to have both the provider's infractionHeight and voting power. Note that the infractionHeight on the consumer chain must be mapped to a height on the provider chain. Unless we have a way to find the corresponding infractionHeight and power on the provider chain, we cannot slash for equivocation on the consumer in the same way as we would slash in the single-chain case.  The challenge of figuring out the corresponding infractionHeight and power values on the provider chain is due to the following trust assumption:  We trust the consensus layer and validator set of the consumer chains, but we do not trust the application layer.  As a result, we cannot trust anything that stems from the application state of a consumer chain.  Note that when a relayer or a user sends evidence through a MsgSubmitConsumerDoubleVoting message, the provider gets access to DuplicateVoteEvidence:  type DuplicateVoteEvidence struct { VoteA *Vote `json:&quot;vote_a&quot;` VoteB *Vote `json:&quot;vote_b&quot;` // abci specific information TotalVotingPower int64 ValidatorPower int64 Timestamp time.Time }   The &quot;abci specific information&quot; fields cannot be trusted because they are not signed. Therefore, we can use neither ValidatorPower for slashing on the provider chain, nor the Timestamp to check the evidence age. We can get the infractionHeight from the votes, but this infractionHeight corresponds to the infraction height on the consumer and not on the provider chain. Similarly, when a relayer or a user sends evidence through a MsgSubmitConsumerMisbehaviour message, the provider gets access to Misbehaviour that we cannot use to extract the infraction height, power, or the time on the provider chain.  ","version":"v4.5.0","tagName":"h3"},{"title":"Proposed solution​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#proposed-solution","content":" As a first iteration, we propose the following approach. At the moment the provider receives evidence of equivocation on a consumer:  slash all the undelegations and redelegations using slashFactor;slash all delegations using as voting power the sum of the voting power of the misbehaving validator and the power of all the ongoing undelegations and redelegations.  Evidence expiration: Additionally, because we cannot infer the actual time of the evidence (i.e., the timestamp of the evidence cannot be trusted), we do not consider evidence expiration and hence old evidence is never ignored (e.g., the provider would act on 3 year-old evidence of equivocation on a consumer). Additionally, we do not need to store equivocation evidence to avoid slashing a validator more than once, because we do not slash tombstoned validators and we tombstone a validator when slashed.  We do not act on evidence that was signed by a validator consensus key that is pruned when we receive the evidence. We prune a validator's consensus key if the validator has assigned a new consumer key (using MsgAssignConsumerKey) and an unbonding period on the consumer chain has elapsed (see key assignment ADR). Note that the provider chain is informed that the unbonding period has elapsed on the consumer when the provider receives a VSCMaturedPacket and because of this, if the consumer delays the sending of a VSCMaturedPacket, we would delay the pruning of the key as well.  ","version":"v4.5.0","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#implementation","content":" The following logic needs to be added to the HandleConsumerDoubleVoting and HandleConsumerMisbehaviour methods:  undelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetUnbondingDelegationsFromValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // undelegation no longer eligible for slashing, skip it continue } undelegationsInTokens = undelegationsInTokens.Add(entry.InitialBalance) } } redelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetRedelegationsFromSrcValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // redelegation no longer eligible for slashing, skip it continue } redelegationsInTokens = redelegationsInTokens.Add(entry.InitialBalance) } } infractionHeight := 0 undelegationsAndRedelegationsInPower = sdk.TokensToConsensusPower(undelegationsInTokens.Add(redelegationsInTokens)) totalPower := validator's voting power + undelegationsAndRedelegationsInPower slashFraction := k.slashingKeeper.SlashFractionDoubleSign(ctx) k.stakingKeeper.Slash(ctx, validatorConsAddress, infractionHeight, totalPower, slashFraction, DoubleSign)   Infraction height: We provide a zero infractionHeight to the Slash method in order to slash all ongoing undelegations and redelegations (see checks in Slash, SlashUnbondingDelegation, and SlashRedelegation).  Power: We pass the sum of the voting power of the misbehaving validator when the evidence was received (i.e., at evidence height) and the power of all the ongoing undelegations and redelegations. If we assume that the slashFactor is 5%, then the voting power we pass is power + totalPower(undelegations) + totalPower(redelegations). Hence, when the Slash method slashes all the undelegations and redelegations it would end up with 0.05 * power + 0.05 * totalPower(undelegations) + 0.05 * totalPower(redelegations) - 0.05 * totalPower(undelegations) - 0.05 * totalPower(redelegations) = 0.05 * power and hence it would slash 5% of the validator's power when the evidence is received.  ","version":"v4.5.0","tagName":"h3"},{"title":"Positive​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#positive","content":" With the proposed approach we can quickly implement slashing functionality on the provider chain for consumer chain equivocations. This approach does not need to change the staking module and therefore does not change in any way how slashing is performed today for a single chain.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#negative","content":" We definitely slash more when it comes to undelegations and redelegations because we slash for all of them without considering an infractionHeight.We potentially slash more than what we would have slashed if we knew the voting power at the corresponding infractionHeight in the provider chain.We slash on old evidence of equivocation on a consumer.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v4.5.0/adrs/adr-013-equivocation-slashing#references","content":" ADR 005: Cryptographic verification of equivocation evidenceEPIC tracking cryptographic equivocation featureCosmos Hub Forum discussion on cryptographic equivocation slashing ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 011: Improving testing and increasing confidence","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#changelog","content":" 2023-08-11: Proposed, first draft of ADR.  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#status","content":" Proposed  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#context","content":" Testing, QA, and maintenance of interchain-security libraries is an ever-evolving area of software engineering we have to keep incrementally improving. The purpose of the QA process is to catch bugs as early as possible. In an ideal development workflow a bug should never reach production. A bug found in the specification stage is a lot cheaper to resolve than a bug discovered in production (or even in testnet). Ideally, all bugs should be found during the CI execution, and we hope that no bugs will ever even reach the testnet (although nothing can replace actual system stress test under load interacting with users).  During development and testnet operation the following types of bugs were the most commonly found:  improper iterator usageunbounded array access/iterationimproper input handling and validationimproper cached context usagenon-determinism check (improper use of maps in go, relying on random values)KV store management and/or how keys are defineddeserialization issues arising from consumer/provider versioning mismatch  Such bugs can be discovered earlier with better tooling. Some of these bugs can induce increases in block times, chain halts, state corruption, or introduce an attack surface which is difficult to remove if other systems have started depending on that behavior.  Current state of testing​  Our testing suites consist of multiple parts, each with their own trade-offs and benefits with regards to code coverage, complexity and confidence they provide.  ","version":"v4.5.0","tagName":"h2"},{"title":"Unit testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#unit-testing","content":" Unit testing is employed mostly for testing single-module functionality. It is the first step in testing and often the most practical. While highly important, unit tests often test a single piece of code and don't test relationships between different moving parts, this makes them less valuable when dealing with multi-module interactions.  Unit tests often employ mocks to abstract parts of the system that are not under test. Mocks are not equivalent to actual models and should not be treated as such.  Out of all the approaches used, unit testing has the most tools available and the coverage can simply be displayed as % of code lines tested. Although this is a very nice and very easy to understand metric, it does not speak about the quality of the test coverage.  Since distributed systems testing is a lot more involved, unit tests are oftentimes not sufficient to cover complex interactions. Unit tests are still necessary and helpful, but in cases where unit tests are not helpful e2e or integration tests should be favored.  ","version":"v4.5.0","tagName":"h3"},{"title":"Integration testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#integration-testing","content":" With integration testing we test the multi-module interactions while isolating them from the remainder of the system. Integration tests can uncover bugs that are often missed by unit tests.  It is very difficult to gauge the actual test coverage imparted by integration tests and the available tooling is limited. In interchain-security we employ the ibc-go/testing framework to test interactions in-memory.  At present, integration testing does not involve the consensus layer - it is only concerned with application level state and logic.  ","version":"v4.5.0","tagName":"h3"},{"title":"End-to-end testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#end-to-end-testing","content":" In our context end-to-end testing comprises of tests that use the actual application binaries in an isolated environment (e.g. docker container). During test execution the inputs are meant to simulate actual user interaction, either by submitting transactions/queries using the command line or using gRPC/REST APIs and checking for state changes after an action has been performed. With this testing strategy we also include the consensus layer in all of our runs. This is the closest we can get to testing user interactions without starting a full testnet.  End-to-end testing strategies vary between different teams and projects and we strive to unify our approach to the best of our ability (at least for ICS and gaia).  The available tooling does not give us significant (or relevant) line of code coverage information since most of the tools are geared towards analyzing unit tests and simple code branch evaluation.  We aim to adapt our best practices by learning from other similar systems and projects such as cosmos-sdk, ibc-go and CometBFT.  ","version":"v4.5.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#decision","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"1. Connect specifications to code and tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#1-connect-specifications-to-code-and-tooling","content":" Oftentimes, specifications are disconnected from the development and QA processes. This gives rise to problems where the specification does not reflect the actual state of the system and vice-versa. Usually specifications are just text files that are rarely used and go unmaintained after a while, resulting in consistency issues and misleading instructions/expectations about system behavior.  Decision context and hypothesis​  Specifications written in a dedicated and executable specification language are easier to maintain than the ones written entirely in text. Additionally, we can create models based on the specification OR make the model equivalent to a specification.  Models do not care about the intricacies of implementation and neither do specifications. Since both models and specifications care about concisely and accurately describing a system (such as a finite state machine), we see a benefit of adding model based tools (such as quint) to our testing and development workflows.  Main benefit​  MBT tooling can be used to generate test traces that can be executed by multiple different testing setups.  ","version":"v4.5.0","tagName":"h3"},{"title":"2. Improve e2e tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#2-improve-e2e-tooling","content":" Matrix tests​  Instead of only running tests against current main branch we should adopt an approach where we also:  run regression tests against different released software versions (ICS v1 vs v2 vs v3)run non-determinism tests to uncover issues quickly  Matrix tests can be implemented using CometMock and refactoring our current e2e CI setup.  Introducing e2e regression testing​  This e2e test suite would execute using a cronjob in our CI (nightly, multiple times a day etc.)  Briefly, the same set of traces is run against different maintained versions of the software and the main branch. This would allow us to discover potential issues during development instead of in a testnet scenarios.  The most valuable issues that can be discovered in this way are state breaking changes, regressions and version incompatibilities.  The setup is illustrated by the image below.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  USES: ICS v1 PROVIDER\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv1 consumer (sdk45,ibc4.3)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v2 consumer (sdk45, ibc4.4)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v3 consumer (sdk47, ibc7)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main consumer\t❌\t❌\t❌\t❌\t❌\t❌\t❌\t❌ neutron\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌ stride\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌  Introducing e2e CometMock tests​  CometMock is a mock implementation of the CometBFT consensus engine. It supports most operations performed by CometBFT while also being lightweight and relatively easy to use.  CometMock tests allow more nuanced control of test scenarios because CometMock can &quot;fool&quot; the blockchain app into thinking that a certain number of blocks had passed.This allows us to test very nuanced scenarios, difficult edge cases and long-running operations (such as unbonding operations).  Examples of tests made easier with CometMock are listed below:  regression testsnon-determinism testsupgrade testsstate-breaking changes  With CometMock, the matrix test approach can also be used. The image below illustrates a CometMock setup that can be used to discover non-deterministic behavior and state-breaking changes.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  SCENARIO\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv3 provi + v3 consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main provi + main consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ commit provi + commit consu\t✅\t❌\t✅\t❌\t✅\t✅\t❌\t❌  Briefly; multiple versions of the application are run against the same CometMock instance and any deviations in app behavior would result in app hash errors (the apps would be in different states after performing the same set of actions).  ","version":"v4.5.0","tagName":"h3"},{"title":"3. Introduce innovative testing approaches​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#3-introduce-innovative-testing-approaches","content":" When discussing e2e testing, some very important patterns emerge - especially if test traces are used instead of ad-hoc tests written by hand.  We see a unique opportunity to clearly identify concerns and modularize the testing architecture.  The e2e testing frameworks can be split into a pipeline consisting of 3 parts: model, driver and harness.  Model​  Model is the part of the system that can emulate the behavior of the system under test. Ideally, it is very close to the specification and is written in a specification language such as quint, TLA+ or similar. One of the purposes of the model is that it can be used to generate test traces.  Driver​  The purpose of the driver is to accept test traces (generated by the model or written by hand), process them and provide inputs to the next part of the pipeline.  Basically, the driver sits between the model and the actual infrastructure on which the test traces are being executed on.  Harness​  Harness is the infrastructure layer of the pipeline that accepts inputs from the driver.  There can be multiple harnesses as long as they can perform four things:  bootstrap a test execution environment (local, docker, k8s…)accept inputs from driversperform the action specified by the driverreport results after performing actions  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#consequences","content":" The procedure outlined in this ADR is not an all-or-nothing approach. Concepts introduced here do not rely on each other, so this ADR may only be applied partially without negative impact on test coverage and code confidence.  ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#positive","content":" introduction of maintainable MBT solutions  improvement over the current &quot;difftest&quot; setup that relies on an opinionated typescript model and go driver  increased code coverage and confidence  using CometMock allows us to run more tests in less timeadding matrix e2e tests allows us to quickly pinpoint differences between code versions  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#negative","content":" It might be easier to forgo the MBT tooling and instead focus on pure property based testing  PBT proof of conceptproperty based testing in go  The solutions are potentially expensive if we increase usage of the CI pipeline - this is fixed by running &quot;expensive&quot; tests using a cronjob, instead of running them on every commit.  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#neutral","content":" The process of changing development and testing process is not something that can be thought of and delivered quickly. Luckily, the changes can be rolled out incrementally without impacting existing workflows.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v4.5.0/adrs/adr-011-improving-test-confidence#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  https://github.com/cosmos/gaia/issues/2427https://github.com/cosmos/gaia/issues/2420ibc-go e2e tests ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 015: Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#changelog","content":" 2024-01-22: Proposed, first draft of ADR.  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#status","content":" Accepted  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#context","content":" Currently, in Replicated Security, the entire validator set of the provider chain is used to secure consumer chains. There are at least three concerns with this approach. First, a large number of validators might be forced to validate consumer chains they are not interested in securing. Second, it is costly for small validators to secure additional chains. This concern is only partially addressed through soft opt-out that allows small validators to opt out from validating consumer chains. Third and for the above reasons, it is challenging for a new consumer chain to join Replicated Security.  As a solution, we present Partial Set Security (PSS). As the name suggests, PSS allows for every consumer chain to be secured by only a subset of the provider validator set. In what follows we propose the exact steps we need to take to implement PSS. This is a first iteration of PSS, and therefore we present the most minimal solution that make PSS possible.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#decision","content":" In Replicated Security, all the provider validators have to secure every consumer chain (with the exception of those validators allowed to opt out through the soft opt-out feature).  In PSS, we allow validators to opt in and out of validating any given consumer chain. This has one exception: we introduce a parameter N for each consumer chain and require that the validators in top N% of the provider's voting power have to secure the consumer chain. Validators outside of the top N% can dynamically opt in if they want to validate on the consumer chain.  For example, if a consumer chain has N = 95%, then it ultimately receives the same security it receives today with Replicated Security (with a default SoftOptOutThreshold of 5%). On the other hand, if a consumer chain has N = 0%, then no validator is forced to validate the chain, but validators can opt in to do so instead.  For the remainder of this ADR, we call a consumer chain Top N if it has joined as a Top N chain with N &gt; 0 and Opt In chain otherwise. An Opt In consumer chain is secured only by the validators that have opted in to secure that chain.  We intend to implement PSS using a feature branch off v4.0.0 interchain security.  ","version":"v4.5.0","tagName":"h2"},{"title":"How do consumer chains join?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#how-do-consumer-chains-join","content":" As a simplification and to avoid chain id squatting, a consumer chain can only join PSS through a governance proposal and not in a permissionless way.  However, this proposal type will be modified so that it requires a lower quorum percentage than normal proposal, and every validator who voted &quot;YES&quot; on the proposal will form the consumer chain's initial validator set.  Consumer chains join PSS the same way chains now join Replicated Security, namely through a ConsumerAdditionProposal proposal. We extend ConsumerAdditionProposal with one optional field:  uint32 top_N: Corresponds to the percentage of validators that join under the Top N case. For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators have to validate the proposed consumer chain.top_N can be 0 or include any value in [50, 100]. A chain can join with top_N == 0 as an Opt In, or with top_N ∈ [50, 100] as a Top N chain.  In case of a Top N chain, we restrict the possible values of top_N from (0, 100] to [50, 100]. By having top_N &gt;= 50 we can guarantee that we cannot have a successful attack, assuming that at most 1/3 of provider validators can be malicious. This is because, a Top N chain with N &gt;= 50% would have at least 1/3 honest validators, which is sufficient to stop attacks. Additionally, by having N &gt;= 50% (and hence N &gt; (VetoThreshold = 33.4%)) we enable the top N validators to Veto any ConsumerAdditionProposal for consumer chains they do not want to validate.  If a proposal has the top_N argument wrongly set, it should get rejected in [ValidateBasic] (https://github.com/cosmos/interchain-security/blob/v4.0.0/x/ccv/provider/types/proposal.go#L86).  In the code, we distinguish whether a chain is Top N or Opt In by checking whether top_N is zero or not.  In a future version of PSS, we intend to introduce a ConsumerModificationProposal so that we can modify the parameters of a consumer chain, e.g, a chain that is Opt In to become Top N, etc.  State &amp; Query​  We augment the provider module’s state to keep track of the top_N value for each consumer chain. The key to store this information would be:  topNBytePrefix | len(chainID) | chainID   To create the above key, we can use ChainIdWithLenKey.  Then in the keeper we introduce methods as follows:  func (k Keeper) SetTopN(ctx sdk.Context, chainID string, topN uint32) func (k Keeper) IsTopN(ctx sdk.Context, chainID string) bool func (k Keeper) IsOptIn(ctx sdk.Context, chainID string) bool // returns the N if Top N chain, otherwise an error func (k Keeper) GetTopN(ctx sdk.Context, chainID string) (uint32, error)   We also extend the interchain-security-pd query provider list-consumer-chains query to return information on whether a consumer chain is an Opt In or a Top N chain and with what N. This way, block explorers can present informative messages such as &quot;This chain is secured by N% of the provider chain&quot; for consumer chains.  ","version":"v4.5.0","tagName":"h3"},{"title":"How do validators opt in?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#how-do-validators-opt-in","content":" A validator can opt in by sending a new type of message that we introduce in tx.proto.  message MsgOptIn { // the chain id of the consumer chain to opt in to string chainID = 1; // the provider address of the validator string providerAddr = 2; // (optional) the consensus public key to use on the consumer optional string consumerKey = 3; }   Note that in a Top N consumer chain, the top N% provider validators have to validate the consumer chain. Nevertheless, validators in the bottom (100 - N)% can opt in to validate as well. Provider validators that belong or enter the top N% validators are automatically opted in to validate a Top N consumer chain. This means that if a validator V belongs to the top N% validators but later falls (e.g., due to undelegations) to the bottom (100 - N)%, V is still considered opted in and has to validate unless V sends a MsgOptOut message (see below). By automatically opting in validators when they enter the top N% validators and by forcing top N% validators to explicitly opt out in case they fall to the (100 - N)% bottom validators we simplify the design of PSS.  Note that a validator can send a MsgOptIn message even if the consumer chain is not yet running. To do this we reuse the IsConsumerProposedOrRegistered. If the chainID does not exist, the MsgOptIn should fail, as well as if the provider address does not exist.  Optionally, a validator that opts in can provide a consumerKey so that it assigns a different consumer key (from the provider) to the consumer chain. Naturally, a validator can always change the consumer key on a consumer chain by sending a MsgAssignConsumerKey message at a later point in time, as is done in Replicated Security.  State &amp; Query​  For each validator, we store a pair (blockHeight, isOptedIn) that contains the block height the validator opted in and whether the validator is currently opted in or not, under the key:  optedInBytePrefix | len(chainID) | chainID | addr   By using a prefix iterator on optedInBytePrefix | len(chainID) | chainID we retrieve all the opted in validators.  We introduce the following Keeper methods.  // returns all the validators that have opted in on chain `chainID` func (k Keeper) GetOptedInValidators(ctx sdk.Context, chainID string) []Validators func (k Keeper) IsValidatorOptedIn(ctx sdk.Context, chainID string, val Validator) bool   We introduce the following two queries:  interchain-security-pd query provider optedInValidators $chainID interchain-security-pd query provider hasToValidate $providerAddr   One query to retrieve the validators that are opted in and hence the validators that need to validate the consumer chain and one query that given a validator's address returns all the chains this validator has to validate.  When do validators opt in?​  As described earlier, validators can manually opt in by sending a MsgOptIn message. Additionally, in a Top N chain, a validator is automatically opted in when it moves from the bottom (100 - N)% to the top N% validators.  Lastly, validators can also opt in if they vote Yes during the ConsumerAdditionProposal that introduces a consumer chain. This simplifies validators operations because they do not have to send an additional message to opt in.  Because the Tally method deletes the votes after reading them, we cannot check the votes of the validators after the votes have been tallied. To circumvent this, we introduce a hook for AfterProposalVote and keep track of all the votes cast by a validator. If a validator casts more than one vote, we only consider the latest vote. Finally, we only consider a validator has opted in if it casts a 100% Yes vote in case of a weighted vote.  ","version":"v4.5.0","tagName":"h3"},{"title":"How do validators opt out?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#how-do-validators-opt-out","content":" Validators that have opted in on a chain can opt out by sending the following message:  message MsgOptOut { // the chain id of the consumer chain to opt out from string chainID = 1; // the provider address of the validator string providerAddr = 2; }   Validators can only opt out after a consumer chain has started and hence the above message returns an error if the chain with chainID is not running. Additionally, a validator that belongs to the top N% validators cannot opt out from a Top N chain and hence a MsgOptOut would error in such a case.  State &amp; Query​  We also update the state of the opted-in validators when a validator has opted out by removing the opted-out validator.  Note that only opted-in validators can be punished for downtime on a consumer chain. For this, we use historical info of all the validators that have opted in; We can examine the blockHeight stored under the key optedInBytePrefix | len(chainID) | chainID | addr to see if a validator was opted in. This way we can jail validators for downtime knowing that indeed the validators have opted in at some point in the past. Otherwise, we can think of a scenario where a validator V is down for a period of time, but before V gets punished for downtime, validator V opts out, and then we do not know whether V should be punished or not.  ","version":"v4.5.0","tagName":"h3"},{"title":"When does a consumer chain start?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#when-does-a-consumer-chain-start","content":" A Top N consumer chain always starts at the specified date (spawn_time) if the ConsumerAdditionProposal has passed. An Opt In consumer chain only starts if at least one validator has opted in. We check this in BeginBlockInit:  func (k Keeper) BeginBlockInit(ctx sdk.Context) { propsToExecute := k.GetConsumerAdditionPropsToExecute(ctx) for _, prop := range propsToExecute { chainID := prop.ChainId if !k.IsTopN(ctx, chainID) &amp;&amp; len(k.GetOptedInValidators(ctx, chainID)) == 0 { // drop the proposal ctx.Logger().Info(&quot;could not start chain because no validator has opted in&quot;) continue } ...   ","version":"v4.5.0","tagName":"h3"},{"title":"How do we send the partial validator sets to the consumer chains?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#how-do-we-send-the-partial-validator-sets-to-the-consumer-chains","content":" A consumer chain should only be validated by opted in validators. We introduce logic to do this when we queue the VSCPackets. The logic behind this, is not as straightforward as it seems because CometBFT does not receive the validator set that has to validate a chain, but rather a delta of validator updates. For example, to remove an opted-out validator from a consumer chain, we have to send a validator update with a power of 0, similarly to what is done in the assignment of consumer keys. We intend to update this ADR at a later stage on how exactly we intend to implement this logic.  ","version":"v4.5.0","tagName":"h3"},{"title":"How do we distribute rewards?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#how-do-we-distribute-rewards","content":" Currently, rewards are distributed as follows: The consumer periodically sends rewards on the provider ConsumerRewardsPool address. The provider then transfers those rewards to the fee collector address and those transferred rewards are distributed to validators and delegators.  In PSS, we distribute rewards only to validators that actually validate the consumer chain. To do this, we have a pool associated with each consumer chain and consumers IBC transfer the rewards to this pool. We then extract the rewards from each consumer pool and distribute them to the opted in validators.  Note that we only distribute rewards to validators that have been opted in for some time (e.g., 10000 blocks) to avoid cases where validators opt in just to receive rewards and then opt out immediately afterward.  ","version":"v4.5.0","tagName":"h3"},{"title":"Misbehaviour​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#misbehaviour","content":" Fraud votes​  In an Opt In chain, a set of validators might attempt to perform an attack. To deter such potential attacks, PSS allows for the use of fraud votes. A fraud vote is a governance proposal that enables the slashing of validators that performed an attack. Due to their inherent complexity, we intend to introduce fraud votes in a different ADR and at a future iteration of PSS.  Double signing​  We do not change the way slashing for double signing and light client attacks functions. If a validator misbehaves on a consumer, then we slash that validator on the provider.  Downtime​  We do not change the way downtime jailing functions. If a validator is down on a consumer chain for an adequate amount of time, we jail this validator on the provider but only if the validator was opted in on this consumer chain in the recent past.  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#positive","content":" Easier for new consumer chains to consume the provider's chain economic security because proposals are more likely to pass if not everyone is forced to validate. Smaller validators are not forced to validate chains anymore if they do not want to. We can deprecate the soft opt-out implementation.  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#negative","content":" A consumer chain does not receive the same economic security as with Replicated Security (assuming the value of SoftOptOutThreshold is 5%), unless it is a Top N chain with N &gt;= 95%.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v4.5.0/adrs/adr-015-partial-set-security#references","content":" PSS: Permissionless vs premissioned-lite opt-in consumer chainsCHIPs discussion phase: Partial Set Security (updated)PSS: Exclusive vs Inclusive Top-NInitial PSS ADR and notes #1518Replicated vs. Mesh Security ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 016: Security aggregation","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#changelog","content":" 2024-04-24: Initial draft of ADR  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#status","content":" Proposed  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#context","content":" Security Aggregation enables staking of tokens from external sources such as Ethereum or Bitcoin to Cosmos blockchains. By integrating Security Aggregation, a Cosmos blockchain can be secured by both native tokens and external tokens (e.g. ETH, BTC).  Security Aggregation consists of the following parts:  A mechanism for delegating external tokens to Cosmos validators, such as Babylon or EigenLayer AVS contract.An oracle that tracks how much external stake has been delegated to each Cosmos validator and provides price feeds for external tokens.Power mixing: a mechanism to combine external and native stake to derive the power of each validator.A reward distribution protocol that enables sending back rewards to the external source.  External staking information is received from an oracle together with price information of related stakes. The CosmosLayer derives validator powers based on external and native staking information and initiates rewarding of external depositors.  This ADR describes the Cosmos modules of the solution.  ","version":"v4.5.0","tagName":"h2"},{"title":"Alternative Approaches​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#alternative-approaches","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Rewards​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#rewards","content":" As an alternative to sending rewards back to the external chains, stakers could be rewarded on the Cosmos chain. This would require a mapping of external addresses to addresses on Cosmos chain for each staker on external source. In addition detailed external staking information such as staking addresses, amount of stakes per staker and validator, etc. have to be provided by the oracle.  ","version":"v4.5.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#decision","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#rewards-will-be-sent-back-to-external-chains-instead-of-paying-rewards-for-external-stakers-on-cosmos-chain","content":" Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain  due to amount of additional staking information to be sent and tracked by the oracledue to the additional complexity of managing external and Cosmos addresses  ","version":"v4.5.0","tagName":"h3"},{"title":"Detailed Design​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#detailed-design","content":" The Power Mixing feature and Reward Distribution protocol are an integral part of the Security Aggregation solution. The Power Mixing module provides the capability of deriving validator power based on stake originated from external sources such as Ethereum/Bitcoin and the native staking module. The Reward Distribution manages the process of sending rewards to external stakers.  ","version":"v4.5.0","tagName":"h2"},{"title":"Power Mixing​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#power-mixing","content":" Power Mixing provides the final validator powers based on staking information of the native chain and the external stakes. The information about external staking and related price feeds are received from an oracle. Once the final validator powers are determined the result is submitted to the underlying CometBFT consensus layer by updating the validator set.  Requirements:  validator updates are performed on each EndBlocka validator's power is determined based on its native on-chain stakes and external stakesprice information of staked tokens is used to determine a validator’s power, e.g. price ratio (price of native on-chain token / price of external stake)price information of native/external tokens are received from an oraclestaking information from external sources received from the oraclenative staking information are received from the Cosmos SDK Staking Moduleset of validator stakes from oracle always have the current price, full set of validators, and current stakes  The Power Mixing implementation  queries current validators and their powers from x/stakingand from oracle (see below).calculates power updates by mixing power values of external and internal sources Following pseudocode snippet shows a possible implementation of how power mixing feature works.  // PowerSource is an abstract entity providing validator powers which // are used by the mixer. This can be an oracle, staking module or an // IBC connected bridge. type PowerSource interface { GetValidatorUpdates() []abci.ValidatorUpdate } // MixPowers calculates power updates by mixing validator powers from different sources func (k *Keeper) MixPowers(source ...PowerSource) []abci.ValidatorUpdate { var valUpdate []abci.ValidatorUpdate for _, ps := range source { // mix powers from two sets of validator updates an return set of validator updates // with aggregated powers valUpdate = mixPower(valUpdate, ps.GetValidatorUpdates()) } return valUpdate } func (k *keeper) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { // GetPowerSources (including local staking module) registeredPowerSource := GetPowerSources() return k.MixPowers(registeredPowerSource...) }   Integration with ICS provider​  The provider module updates the validator set on CometBFT instead of the SDK staking module (x/staking). The provider implementation will intervene in this behavior and ensure that the validator updates are taken from the Power Mixing feature.  External power sources are managed by the provider module. Only registered power sources can provide input to the Power Mixing feature. Power sources will be assigned a unique identifier which will be used by the oracle, provider module and the power mixing and rewarding feature.  Updates with the next validator set are sent to consumer chains on each epoch (see EndBlockVSU()). When collecting the validator updates for each consumer chain (see QueueVSCPackets()), the validator powers of the bonded validators will be updated with the validator powers from the external sources using the Power Mixing module. These updates are sent as part of the VSC packets to all registered consumer chains.  Integration with ICS consumer​  Consumer chains receive validator updates as part of VSC packets from the provider. These packets contain validator powers which were already mixed with external staked powers.  ","version":"v4.5.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#queries","content":" // GetValidatorUpdates returns the power mixed validator results from the provided sources service Query { rpc GetValidatorUpdates(PowerMixedValUpdateRequest) PowerMixedValUpdateResponse {}; } // PowerMixedValUpdateRequest contains the list of power sources on which the // power mixing should be based on message PowerMixedValUpdateRequest { repeated PowerSource sources; } // PowerMixedValUpdateResponse returns the validator set with the updated powers // from the power mixing feature message PowerMixedValUpdateResponse { repeated abci.ValidatorUpdate val_set }   The following queries will be provided by the oracle  service Query { rpc GetExtValidators(GetExtValidatorRequest) returns (ExtValidatorsResponse) { option (google.api.http).get = &quot;oracle/v1/get_validators&quot;; }; } message GetExtValidatorRequest {} // ExtValidatorsResponse is the response from GetExtValidators queries message ExtValidatorsResponse { repeated ExtValPower powers; } // ExtValPower represents a validator with its staking and token information, // where: // `power_source_identifier` is the identifier of the registered power source // `validator_address` is the address of the validator // `stakes` is the total amount of stakes for a validator // `denom` is the source token of the stake e.g. ETH,BTC // `price_ratio` is the ratio of price of the external token to the price of the 'local' token message ExtValPower { string power_source_identifier; string validator_address; uint64 stakes; string denom; float price_ratio; } // GetPrice returns a price feed for a given token service Query { rpc GetPrice(GetPriceRequest) returns (GetPriceResponse) { option (google.api.http).get = &quot;/oracle/v1/get_price&quot;; }; }   For security reasons the amount of external stakes needs to be limited. Limitation of external staking could be driven by governance and is not subject of this version of the ADR.  ","version":"v4.5.0","tagName":"h3"},{"title":"Reward Handler​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#reward-handler","content":" For native staked tokens the Distribution Module of the Cosmos SDK is taking care of sending the rewards to stakers. For stakes originated from external chains (Ethereum/Bitcoin) the Reward Handler module sends rewards to EigenLayer/Babylon. The transfer of rewards is done using a bridge between the Cosmos chain and the external provider chain.  Note: currently there's no support paying rewards on EigenLayer (see here)  ","version":"v4.5.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#positive","content":" Allow external depositors to stake their tokens to secure a Cosmos chain  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#negative","content":" Dependency to external sources e.g (price feeds) for validator power calculationSecurity impact  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#neutral","content":" Additional complexity for staking  ","version":"v4.5.0","tagName":"h3"},{"title":"Questions:​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#questions","content":" Slashing: subject of this ADR? (Defined but not activated currently on EigenLayer).  ","version":"v4.5.0","tagName":"h2"},{"title":"References​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v4.5.0/adrs/adr-016-securityaggregation#references","content":" EigenLayerBabylon ","version":"v4.5.0","tagName":"h2"},{"title":"ADR 017: ICS with Inactive Provider Validators","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators","content":"","keywords":"","version":"v4.5.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#changelog","content":" 15th May 2024: Initial draft  ","version":"v4.5.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#status","content":" Proposed  ","version":"v4.5.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#context","content":" Currently, only validators in the active set on the provider can validate on consumer chains, which limits the number of validators that can participate in Interchain Security (ICS). Validators outside of the active set might be willing to validate on consumer chains, but we might not want to make the provider validator set larger, e.g. to not put more strain on the consensus engine. This runs the risk of leaving consumer chains with too few validators.  The purpose of this ADR is to allow validators that are not part of the consensus process on the provider chain (because they are inactive) to validate on consumer chains.  In the context of this ADR, &quot;consensus validator set&quot; is the set of validators participating in the consensus protocol, and &quot;staking validator set&quot; is the set of validators viewed as active by the staking module.  Currently, the staking module, provider module, and CometBFT interact in this way:    The staking module keeps a list of validators. The MaxValidators validators with the largest amount of stake are &quot;active&quot; validators. MaxValidators is a parameter of the staking module. The staking module sends these validators to CometBFT to inform which validators make up the next consensus validators, that is, the set of validators participating in the consensus process. Separately, the provider module reads the list of bonded validators and sends this to the consumer chain, after shaping it according to which validators are opted in and the parameters set by the consumer chain for allowlist, denylist, etc.  ","version":"v4.5.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#decision","content":" The proposed solution to allow validators that are not participating in the consensus process on the provider (inactive validators) is to change 3 main things:  a) increase the MaxValidators parameter of the staking module  b) do not take the updates for CometBFT directly from the bonded validators in the staking module, by wrapping the staking modules EndBlocker with a dummy EndBlocker that doesn't return any validator updates. Instead, we adjust the provider module to return validator updates on its EndBlocker. These validator updates are obtained by filtering the bonded validators to send only the first MaxProviderConsensusValidators (sorted by largest amount of stake first) many validators to CometBFT  c) use the enlarged list of bonded validators from the staking module as basis for the validator set that the provider module sends to consumer chains (again after applying power shaping and filtering out validatiors that are not opted in).  In consequence, the provider chain can keep a reasonably-sized consensus validator set, while giving consumer chains a much larger pool of potential validators.    Some additional considerations:  Migration: In the migration, the last consensus validator set will be set to the last active validator set from the view of the staking module. Existing consumer chains are migrated to have a validator set size cap (otherwise, they could end up with a huge validator set including all the staking-but-not-consensus-active validators from the provider chain)Slashing: Validators that are not part of the active set on the provider chain can still be jailed for downtime on a consumer chain (via an Interchain Security SlashPacket sent to the provider, who will then jail the validator), but they are not slashed for downtime on the provider chain. This is achieved without any additional changes to the slashing module, because the slashing module checks for downtime by looking at the consensus participants reported by CometBFT, and thus with the proposed solution, validators that are not part of the consensus validators on the provider chain are not considered for downtime slashing (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/slashing/abci.go#L22).Rewards: Validators that are not part of the active set on the provider chain can still receive rewards on the consumer chain, but they do not receive rewards from the provider chain. This change is achieved without further changes to staking or reward distributions, because similar to downtime, rewards are based on the consensus validator set (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/distribution/abci.go#L28)  ","version":"v4.5.0","tagName":"h2"},{"title":"Changes to the state​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#changes-to-the-state","content":" The following changes to the state are required:  Introduce the MaxProviderConsensusValidators parameter to the provider module, which is the number of validators that the provider module will send to consumer chains.Store the provider consensus validator set in the provider module state under the LastProviderConsensusValsPrefix key. This is the last set of validators that the provider sent to the consensus engine. This is needed to compute the ValUpdates to send to the consensus engine (by diffing the current set with this last sent set).Increase the MaxValidators parameter of the staking module to the desired size of the potential validator set of consumer chains.  ","version":"v4.5.0","tagName":"h3"},{"title":"Risk Mitigations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#risk-mitigations","content":" To mitigate risks from validators with little stake, we introduce a minimum stake requirement for validators to be able to validate on consumer chains, which can be set by each consumer chain independently, with a default value set by the provider chain.  Additionally, we independently allow individual consumer chains to disable this feature, which will disallow validators from outside the provider active set from validating on the consumer chain and revert them to the previous behaviour of only considering validators of the provider that are part of the active consensus validator set.  Additional risk mitigations are to increase the active set size slowly, and to monitor the effects on the network closely. For the first iteration, we propose to increase the active set size to 200 validators (while keeping the consensus validators to 180), thus letting the 20 validators with the most stake outside of the active set validate on consumer chains.  ","version":"v4.5.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#consequences","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#positive","content":" Validators outside of the active set can validate on consumer chains without having an impact on the consensus engine of the provider chainConsumer chains can have a much larger validator set than the provider chain if they prefer this e.g. for decentralization reasonsConsumer chain teams can, with much less cost than today, start up their own consumer chain node to keep the chain running (in a centralized manner) even if no hub validators have opted in to validate on the chain. This is useful to stop the chain from ending up with an empty validator set and becoming recoverable only with a hardfork  ","version":"v4.5.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#negative","content":" Allowing validators from the inactive set brings with it some additional risks. In general, consumer chains will now face some of the problems also faced by standalone chains. It’s reasonable to assume that the validator set on the hub has a minimum amount of operational quality due to being battle tested and decentralized, and consumer chains with validators from outside the hub active set cannot rely on this as much anymore.  Sybil attacks​  With the restricted size of the active set today, it’s clear that the set is at least minimally competitive and it is not trivial to spin up multiple nodes as a validator.  When we make the “potential validator set” much larger, we should assume that it becomes much less competitive to be part of that set, and thus trivial for single entities to control many of those validators.  Reputational damage is not a deterrent​  For validators in the active set, we typically assume that if they would misbehave, they pay a large reputational cost. This represents delegators deciding to switch validators (potentially even on chains other than the one the misbehaviour happened on), and loss of credibility in the ecosystem. With the much larger active set, it seems prudent to assume that reputational damage is not a deterrent for many validators. They might only have minimal amounts of delegated stake and control most of it themselves, so they might not be deterred from performing actions that would usually bring reputational damage.  Additional negative consequences​  The provider keeper will need to implement the staking keeper interface, and modules need to be wired up to either the staking or provider keeper, depending on whether they need the consensus or staking validator setThis will impact how future modules are integrated, since we will need to consider whether those modules should consider the consensus validators or the bonded validators (which other modules might assume to be the same)  ","version":"v4.5.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#neutral","content":" There might be validators that are bonded, but not validating on any chain at all. This is not a problem, but it might be a bit confusing.  ","version":"v4.5.0","tagName":"h3"},{"title":"Alternative considerations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#alternative-considerations","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Modifying the staking module​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#modifying-the-staking-module","content":" We could instead adapt the staking module with a similar change. This might be better if it turns out that the staking module active set is used in many other places.  ","version":"v4.5.0","tagName":"h3"},{"title":"Allowing unbonding validators to validate​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#allowing-unbonding-validators-to-validate","content":" Instead of increasing the active set size, we could allow validators that are unbonded (but still exist on the provider) to validate consumer chains. For this, we would need to:  Modify the VSC updates to consider the set of all validators, even unbonded ones, instead of just active onesAdjust our downtime jailing/equivocation slashing logic to work correctly with unbonded validators. This is very hard, because redelegations are not usually tracked for unbonded validators.  ","version":"v4.5.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v4.5.0/adrs/adr-017-allowing-inactive-validators#references","content":" Security Aggregation has similar concerns where the staking validator set will differ from the consensus validator set ","version":"v4.5.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/adrs/intro","content":"","keywords":"","version":"v4.5.0"},{"title":"Table of Contents​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/adrs/intro#table-of-contents","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Accepted​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/adrs/intro#accepted","content":" ADR 001: Key AssignmentADR 002: Jail ThrottlingADR 004: Denom DOS fixesADR 005: Cryptographic verification of equivocation evidenceADR 008: Throttle with retriesADR 010: Standalone to Consumer ChangeoverADR 013: Slashing on the provider for consumer equivocationADR 014: EpochsADR 015: Partial Set Security  ","version":"v4.5.0","tagName":"h3"},{"title":"Proposed​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/adrs/intro#proposed","content":" ADR 011: Improving testing and increasing confidenceADR 016: Security aggregationADR 017: ICS with Inactive Provider Validators  ","version":"v4.5.0","tagName":"h3"},{"title":"Rejected​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/adrs/intro#rejected","content":" ADR 007: Pause validator unbonding during equivocation proposalADR 012: Separate Releasing  ","version":"v4.5.0","tagName":"h3"},{"title":"Deprecated​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/adrs/intro#deprecated","content":" ADR 003: Equivocation governance proposalADR 009: Soft Opt-Out ","version":"v4.5.0","tagName":"h3"},{"title":"Developing an ICS consumer chain","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/consumer-development/app-integration","content":"","keywords":"","version":"v4.5.0"},{"title":"Basic consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v4.5.0/consumer-development/app-integration#basic-consumer-chain","content":" The source code for the example app can be found here.  Please note that consumer chains do not implement the staking module - part of the validator set of the provider is replicated over to the consumer, meaning that the consumer uses a subset of provider validator set and the stake of the validators on the provider determines their stake on the consumer. Note that after the introduction of Partial Set Security, not all the provider validators have to validate a consumer chain (e.g., if top_N != 100).  Your chain should import the consumer module from x/consumer and register it in the correct places in your app.go. The x/consumer module will allow your chain to communicate with the provider using the ICS protocol. The module handles all IBC communication with the provider, and it is a simple drop-in. You should not need to manage or override any code from the x/consumer module.  ","version":"v4.5.0","tagName":"h2"},{"title":"Democracy consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v4.5.0/consumer-development/app-integration#democracy-consumer-chain","content":" The source code for the example app can be found here.  This type of consumer chain wraps the basic CosmosSDK x/distribution, x/staking and x/governance modules allowing the consumer chain to perform democratic actions such as participating and voting within the chain's governance system.  This allows the consumer chain to leverage those modules while also using the x/consumer module.  With these modules enabled, the consumer chain can mint its own governance tokens, which can then be delegated to prominent community members which are referred to as &quot;representatives&quot; (as opposed to &quot;validators&quot; in standalone chains). The token may have different use cases besides just voting on governance proposals.  ","version":"v4.5.0","tagName":"h2"},{"title":"Standalone chain to consumer chain changeover​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v4.5.0/consumer-development/app-integration#standalone-chain-to-consumer-chain-changeover","content":" See the standalone chain to consumer chain changeover guide for more information on how to transition your standalone chain to a consumer chain. ","version":"v4.5.0","tagName":"h2"},{"title":"Consumer Chain Governance","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/consumer-development/consumer-chain-governance","content":"","keywords":"","version":"v4.5.0"},{"title":"Democracy module​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v4.5.0/consumer-development/consumer-chain-governance#democracy-module","content":" The democracy module provides a governance experience identical to what exists on a standalone Cosmos chain, with one small but important difference. On a standalone Cosmos chain validators can act as representatives for their delegators by voting with their stake, but only if the delegator themselves does not vote. This is a lightweight form of liquid democracy.  Using the democracy module on a consumer chain is the exact same experience, except for the fact that it is not the actual validator set of the chain (since it is a consumer chain, these are the Cosmos Hub validators) acting as representatives. Instead, there is a separate representative role who token holders can delegate to and who can perform the functions that validators do in Cosmos governance, without participating in proof of stake consensus.  For an example, see the Democracy Consumer  ","version":"v4.5.0","tagName":"h2"},{"title":"CosmWasm​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v4.5.0/consumer-development/consumer-chain-governance#cosmwasm","content":" There are several great DAO and governance frameworks written as CosmWasm contracts. These can be used as the main governance system for a consumer chain. Actions triggered by the CosmWasm governance contracts are able to affect parameters and trigger actions on the consumer chain.  For an example, see Neutron.  ","version":"v4.5.0","tagName":"h2"},{"title":"The Whitelist​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v4.5.0/consumer-development/consumer-chain-governance#the-whitelist","content":" Not everything on a consumer chain can be changed by the consumer's governance. Some settings having to do with consensus etc. can only be changed by the provider chain. Consumer chains include a whitelist of parameters that are allowed to be changed by the consumer chain governance. For an example, see Neutron's whitelist. ","version":"v4.5.0","tagName":"h2"},{"title":"Consumer Offboarding","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/consumer-development/offboarding","content":"Consumer Offboarding To offboard a consumer chain simply submit a ConsumerRemovalProposal governance proposal listing a stop_time. After stop time passes, the provider chain will remove the chain from the ICS protocol (it will stop sending validator set updates). // ConsumerRemovalProposal is a governance proposal on the provider chain to remove (and stop) a consumer chain. // If it passes, all the consumer chain's state is removed from the provider chain. The outstanding unbonding // operation funds are released. { // the title of the proposal &quot;title&quot;: &quot;This was a great chain&quot;, &quot;description&quot;: &quot;Here is a .md formatted string specifying removal details&quot;, // the chain-id of the consumer chain to be stopped &quot;chain_id&quot;: &quot;consumerchain-1&quot;, // the time on the provider chain at which all validators are responsible to stop their consumer chain validator node &quot;stop_time&quot;: &quot;2023-03-07T12:40:00.000000Z&quot;, } More information will be listed in a future version of this document.","keywords":"","version":"v4.5.0"},{"title":"Consumer Genesis Transformation","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/consumer-development/consumer-genesis-transformation","content":"","keywords":"","version":"v4.5.0"},{"title":"1. Prerequisite​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v4.5.0/consumer-development/consumer-genesis-transformation#1-prerequisite","content":" used provider and consumer versions require transformation step as indicated in in the compatibility notesinterchain-security-cd application supports the versions used by the consumer and provider  ","version":"v4.5.0","tagName":"h2"},{"title":"2. Export the CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v4.5.0/consumer-development/consumer-genesis-transformation#2-export-the-ccv-data","content":" Export the CCV data from the provider chain as described in the Onboarding and Changeover your following. As a result the CCV data will be stored in a file in JSON format.  ","version":"v4.5.0","tagName":"h2"},{"title":"Consumer Onboarding Checklist","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/consumer-development/onboarding","content":"","keywords":"","version":"v4.5.0"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v4.5.0/consumer-development/onboarding#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.4.1) reach out to the ICS team if you are facing issues  ","version":"v4.5.0","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v4.5.0/consumer-development/onboarding#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json without CCV data (before the proposal passes) genesis.json with CCV data (after spawn time passes). Check if CCV data needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) copy of your governance proposal (as JSON) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"v4.5.0","tagName":"h2"},{"title":"3. Submit a Governance Proposal​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v4.5.0/consumer-development/onboarding#3-submit-a-governance-proposal","content":" Before you submit a ConsumerChainAddition proposal, please consider allowing at least a day between your proposal passing and the chain spawn time. This will allow the validators, other node operators and the community to prepare for the chain launch. If possible, please set your spawn time so people from different parts of the globe can be available in case of emergencies. Ideally, you should set your spawn time to be between 12:00 UTC and 20:00 UTC so most validator operators are available and ready to respond to any issues.  Additionally, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters to be put in the proposal take note to include a link to your onboarding repository describe the purpose and benefits of running your chain determine whether your chain should be an Opt-In chain or a Top N chain (see Partial Set Security) if desired, decide on power-shaping parameters (see Power Shaping)  Example of a consumer chain addition proposal.  // ConsumerAdditionProposal is a governance proposal on the provider chain to spawn a new consumer chain. // If it passes, if the top_N parameter is not equal to 0, the top N% of validators by voting power on the provider chain are expected to validate the consumer chain at spawn time. // Otherwise, only validators that opted in during the proposal period are expected to validate the consumer chain at spawn time. // It is recommended that spawn time occurs after the proposal end time. { // Title of the proposal &quot;title&quot;: &quot;Add consumer chain&quot;, // Description of the proposal // format the text as a .md file and include the file in your onboarding repository &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, // Proposed chain-id of the new consumer chain. // Must be unique from all other consumer chain ids of the executing provider chain. &quot;chain_id&quot;: &quot;newchain-1&quot;, // Initial height of new consumer chain. // For a completely new chain, this will be {0,1}. &quot;initial_height&quot; : { &quot;revision_height&quot;: 0, &quot;revision_number&quot;: 1, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // It is used for off-chain confirmation of genesis.json validity by validators and other parties. &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on chain initialization. // It is used for off-chain confirmation of binary validity by validators and other parties. &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should be smaller than that of the provider. &quot;unbonding_period&quot;: 86400000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 259200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot;, // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. &quot;top_N&quot;: 95, // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis. &quot;validators_power_cap&quot;: 0, // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. &quot;validator_set_cap&quot;: 0, // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate // the consumer chain. &quot;allowlist&quot;: [], // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. &quot;denylist&quot;: [] }   ","version":"v4.5.0","tagName":"h2"},{"title":"4. Launch​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v4.5.0/consumer-development/onboarding#4-launch","content":" The consumer chain starts after at least 66.67% of its voting power comes online. Note that this means 66.67% of the voting power in the consumer validator set, which will be comprised of all validators that either opted in to the chain or are part of the top N% of the provider chain (and are thus automatically opted in). The consumer chain is considered interchain secured once the appropriate CCV channels are established and the first validator set update is propagated from the provider to the consumer   provide a repo with onboarding instructions for validators (it should already be listed in the proposal) genesis.json with ccv data populated (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) have a block explorer in place to track chain activity &amp; health ","version":"v4.5.0","tagName":"h2"},{"title":"3. Transform CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v4.5.0/consumer-development/consumer-genesis-transformation#3-transform-ccv-data","content":" To transform the CCV data  to the format supported by the current version of the consumer run the following command: interchain-security-cd genesis transform [genesis-file] where 'genesis-file' is the path to the file containing the CCV data exported in step 2. As a result the CCV data in the new format will be written to standard output.a specific target version of a consumer run the following command: interchain-security-cd genesis transform --to &lt;target_version&gt; [genesis-file] where &lt;target_version is the ICS version the consumer chain is running. Use interchain-security-cd genesis transform --help to get more details about supported target versions and more.  Use the new CCV data as described in the procedure you're following. ","version":"v4.5.0","tagName":"h2"},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/faq","content":"","keywords":"","version":"v4.5.0"},{"title":"What is a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#what-is-a-consumer-chain","content":" Consumer chain is a blockchain operated by (a subset of) the validators of the provider chain. The ICS protocol ensures that the consumer chain gets information about which validators should run it (informs consumer chain about the current state of the validator set and the opted in validators for this consumer chain on the provider).  Consumer chains are run on infrastructure (virtual or physical machines) distinct from the provider, have their own configurations and operating requirements.  ","version":"v4.5.0","tagName":"h2"},{"title":"What happens to consumer if provider is down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#what-happens-to-consumer-if-provider-is-down","content":" In case the provider chain halts or experiences difficulties the consumer chain will keep operating - the provider chain and consumer chains represent different networks, which only share the validator set.  The consumer chain will not halt if the provider halts because they represent distinct networks and distinct infrastructures. Provider chain liveness does not impact consumer chain liveness.  However, if the trusting_period (currently 5 days for protocol safety reasons) elapses without receiving any updates from the provider, the consumer chain will essentially transition to a Proof of Authority chain. This means that the validator set on the consumer will be the last validator set of the provider that the consumer knows about.  Steps to recover from this scenario and steps to &quot;release&quot; the validators from their duties will be specified at a later point. At the very least, the consumer chain could replace the validator set, remove the ICS module and perform a genesis restart. The impact of this on the IBC clients and connections is currently under careful consideration.  ","version":"v4.5.0","tagName":"h2"},{"title":"What happens to provider if consumer is down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#what-happens-to-provider-if-consumer-is-down","content":" Consumer chains do not impact the provider chain. The ICS protocol is concerned only with validator set management, and the only communication that the provider requires from the consumer is information about validator activity (essentially keeping the provider informed about slash events).  ","version":"v4.5.0","tagName":"h2"},{"title":"Can I run the provider and consumer chains on the same machine?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-i-run-the-provider-and-consumer-chains-on-the-same-machine","content":" Yes, but you should favor running them in separate environments so failure of one machine does not impact your whole operation.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can the consumer chain have its own token?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-the-consumer-chain-have-its-own-token","content":" As any other cosmos-sdk chain the consumer chain can issue its own token, manage inflation parameters and use them to pay gas fees.  ","version":"v4.5.0","tagName":"h2"},{"title":"How are Tx fees paid on consumer?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#how-are-tx-fees-paid-on-consumer","content":" The consumer chain operates as any other cosmos-sdk chain. The ICS protocol does not impact the normal chain operations.  ","version":"v4.5.0","tagName":"h2"},{"title":"Are there any restrictions the consumer chains need to abide by?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#are-there-any-restrictions-the-consumer-chains-need-to-abide-by","content":" No. Consumer chains are free to choose how they wish to operate, which modules to include, use CosmWASM in a permissioned or a permissionless way. The only thing that separates consumer chains from standalone chains is that they share their validator set with the provider chain.  ","version":"v4.5.0","tagName":"h2"},{"title":"What's in it for the validators and stakers?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#whats-in-it-for-the-validators-and-stakers","content":" The consumer chains sends a portion of its fees and inflation as reward to the provider chain as defined by ConsumerRedistributionFraction. The rewards are distributed (sent to the provider) every BlocksPerDistributionTransmission.  note ConsumerRedistributionFraction and BlocksPerDistributionTransmission are parameters defined in the ConsumerAdditionProposal used to create the consumer chain. These parameters can be changed via consumer chain governance.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can the consumer chain have its own governance?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-the-consumer-chain-have-its-own-governance","content":" Yes.  In that case the validators are not necessarily part of the governance structure. Instead, their place in governance is replaced by &quot;representatives&quot; (governors). The representatives do not need to run validators, they simply represent the interests of a particular interest group on the consumer chain.  Validators can also be representatives but representatives are not required to run validator nodes.  This feature discerns between validator operators (infrastructure) and governance representatives which further democratizes the ecosystem. This also reduces the pressure on validators to be involved in on-chain governance.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can validators opt out of validating a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-validators-opt-out-of-validating-a-consumer-chain","content":" A validator can always opt out from an Opt-In consumer chain. A validator can only opt out from a Top N chain if the validator does not belong to the top N% validators.  ","version":"v4.5.0","tagName":"h2"},{"title":"How does Slashing work?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#how-does-slashing-work","content":" Validators that perform an equivocation or a light-client attack on a consumer chain are slashed on the provider chain. We achieve this by submitting the proof of the equivocation or the light-client attack to the provider chain (see slashing).  ","version":"v4.5.0","tagName":"h2"},{"title":"Can Consumer Chains perform Software Upgrades?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-consumer-chains-perform-software-upgrades","content":" Consumer chains are standalone chains, in the sense that they can run arbitrary logic and use any modules they want (ie CosmWASM).  Consumer chain upgrades are unlikely to impact the provider chain, as long as there are no changes to the ICS module.  ","version":"v4.5.0","tagName":"h2"},{"title":"How can I connect to the testnets?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#how-can-i-connect-to-the-testnets","content":" Check out the Joining Interchain Security testnet section.  ","version":"v4.5.0","tagName":"h2"},{"title":"How do I start using ICS?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#how-do-i-start-using-ics","content":" To become a consumer chain use this checklist and check the App integration section  ","version":"v4.5.0","tagName":"h2"},{"title":"Which relayers are supported?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#which-relayers-are-supported","content":" Currently supported versions:  Hermes 1.8.0  ","version":"v4.5.0","tagName":"h2"},{"title":"How does key delegation work in ICS?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#how-does-key-delegation-work-in-ics","content":" You can check the Key Assignment Guide for specific instructions.  ","version":"v4.5.0","tagName":"h2"},{"title":"How does Partial Set Security work?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#how-does-partial-set-security-work","content":" Partial Set Security allows a provider chain to share only a subset of its validator set with a consumer chain. This subset can be determined by the top N% validators by voting power, or by validators opting in to validate the consumer chain. Partial Set Security allows for flexible tradeoffs between security, decentralization, and the budget a consumer chain spends on rewards to validators.  See the Partial Set Security section for more information.  ","version":"v4.5.0","tagName":"h2"},{"title":"How does a validator know which consumers chains it has to validate?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#how-does-a-validator-know-which-consumers-chains-it-has-to-validate","content":" In order for a validator to keep track of all the chains it has to validate, the validator can use thehas-to-validate query.  ","version":"v4.5.0","tagName":"h2"},{"title":"How many chains can a validator opt in to?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#how-many-chains-can-a-validator-opt-in-to","content":" There is no limit in the number of consumers chains a validator can choose to opt in to.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can validators assign a consensus keys while a consumer-addition proposal is in voting period?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-validators-assign-a-consensus-keys-while-a-consumer-addition-proposal-is-in-voting-period","content":" Yes, see the Key Assignment Guide for more information.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can validators assign a consensus key during the voting period for a consumer-addition proposal if they are not in the top N?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-validators-assign-a-consensus-key-during-the-voting-period-for-a-consumer-addition-proposal-if-they-are-not-in-the-top-n","content":" Yes.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can validators opt in to an Opt-in or Top N chain after its consumer-addition proposal voting period is over but before the spawn time?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-validators-opt-in-to-an-opt-in-or-top-n-chain-after-its-consumer-addition-proposal-voting-period-is-over-but-before-the-spawn-time","content":" Yes.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can validators opt in to an Opt-in chain after the spawn time if nobody else opted in?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-validators-opt-in-to-an-opt-in-chain-after-the-spawn-time-if-nobody-else-opted-in","content":" No, the consumer chain will not be added if nobody opted in by the spawn time. At least one validator, regardless of its voting power, must opt in before the spawn time arrives in order for the chain can start.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can all validators opt out of an Opt-in chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-all-validators-opt-out-of-an-opt-in-chain","content":" Yes, the consumer chain will halt with an ERR CONSENSUS FAILURE error after the opt-out message for the last validator is received.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can validators set a commission rate for chains they have not opted in to?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-validators-set-a-commission-rate-for-chains-they-have-not-opted-in-to","content":" Yes, and this is useful for validators that are not in the top N% of the provider chain, but might move into the top N% in the future. By setting the commission rate ahead of time, they can make sure that they immediately have a commission rate of their choosing as soon as they are in the top N%.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can a consumer chain modify its power shaping parameters?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-a-consumer-chain-modify-its-power-shaping-parameters","content":" Yes, by issuing a ConsumerModificationProposal.  ","version":"v4.5.0","tagName":"h2"},{"title":"Can a Top N consumer chain become Opt-In or vice versa?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v4.5.0/faq#can-a-top-n-consumer-chain-become-opt-in-or-vice-versa","content":" Yes, by issuing a ConsumerModificationProposal. ","version":"v4.5.0","tagName":"h2"},{"title":"Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure","content":"","keywords":"","version":"v4.5.0"},{"title":"Overview​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#overview","content":" Standalone to consumer changeover procedure can roughly be separated into 4 parts:  ","version":"v4.5.0","tagName":"h2"},{"title":"1. ConsumerAddition proposal submitted to the provider chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#1-consumeraddition-proposal-submitted-to-the-provider-chain","content":" The proposal is equivalent to the &quot;normal&quot; ConsumerAddition proposal submitted by new consumer chains.  However, here are the most important notes and differences between a new consumer chain and a standalone chain performing a changeover:  chain_id must be equal to the standalone chain idinitial_height field has additional rules to abide by:  caution { ... &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. stride-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_height&quot;: 1, }, ... } RevisionNumber: 0, RevisionHeight: 111  genesis_hash can be safely ignored because the chain is already running. A hash of the standalone chain's initial genesis may be used binary_hash may not be available ahead of time. All chains performing the changeover go through rigorous testing - if bugs are caught and fixed the hash listed in the proposal may not be the most recent one. spawn_time listed in the proposal MUST be before the upgrade_height listed in the upgrade proposal on the standalone chain.  caution spawn_time must occur before the upgrade_height on the standalone chain is reached because the provider chain must generate the ConsumerGenesis that contains the validator set that will be used after the changeover.  unbonding_period must correspond to the value used on the standalone chain. Otherwise, the clients used for the ccv protocol may be incorrectly initialized. distribution_transmission_channel should be set.  note Populating distribution_transmission_channel will enable the standalone chain to reuse one of the existing channels to the provider for consumer chain rewards distribution. This will preserve the ibc denom that may already be in use. If the parameter is not set, a new channel will be created.  ccv_timeout_period has no important notes transfer_timeout_period has no important notes consumer_redistribution_fraction has no important notes blocks_per_distribution_transmission has no important notes historical_entries has no important notes  ","version":"v4.5.0","tagName":"h3"},{"title":"2. upgrade proposal on standalone chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#2-upgrade-proposal-on-standalone-chain","content":" The standalone chain creates an upgrade proposal to include the interchain-security/x/ccv/consumer module.  caution The upgrade height in the proposal should correspond to a height that is after the spawn_time in the consumer addition proposal submitted to the provider chain.  Otherwise, the upgrade is indistinguishable from a regular on-chain upgrade proposal.  ","version":"v4.5.0","tagName":"h3"},{"title":"3. spawn time is reached​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#3-spawn-time-is-reached","content":" When the spawn_time is reached on the provider it will generate a ConsumerGenesis that contains the validator set that will supersede the standalone validator set.  This ConsumerGenesis must be available on the standalone chain during the on-chain upgrade.  ","version":"v4.5.0","tagName":"h3"},{"title":"4. standalone chain upgrade​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#4-standalone-chain-upgrade","content":" Performing the on-chain upgrade on the standalone chain will add the ccv/consumer module and allow the chain to become a consumer of Interchain Security.  caution The ConsumerGenesis must be exported to a file and placed in the correct folder on the standalone chain before the upgrade. The file must be placed at the exact specified location, otherwise the upgrade will not be executed correctly. Usually the file is placed in $NODE_HOME/config, but the file name and the exact directory is dictated by the upgrade code on the standalone chain. please check exact instructions provided by the standalone chain team  After the genesis.json file has been made available, the process is equivalent to a normal on-chain upgrade. The standalone validator set will sign the next couple of blocks before transferring control to provider validator set.  The standalone validator set can still be slashed for any infractions if evidence is submitted within the unboding_period.  Notes​  The changeover procedure may be updated in the future to create a seamless way of providing the validator set information to the standalone chain.  ","version":"v4.5.0","tagName":"h3"},{"title":"Onboarding Checklist​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#onboarding-checklist","content":" This onboarding checklist is slightly different from the one under Onboarding  Additionally, you can check the testnet repo for a comprehensive guide on preparing and launching consumer chains.  ","version":"v4.5.0","tagName":"h2"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.4.1) test the changeover procedure reach out to the ICS team if you are facing issues  ","version":"v4.5.0","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json with CCV data (after spawn time passes). Check if CCV data needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) copy of your governance proposal (as JSON) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"v4.5.0","tagName":"h2"},{"title":"3. Submit a ConsumerChainAddition Governance Proposal to the provider​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#3-submit-a-consumerchainaddition-governance-proposal-to-the-provider","content":" Before you submit a ConsumerChainAddition proposal, please provide a spawn_time that is before the upgrade_height of the upgrade that will introduce the ccv module to your chain.  danger If the spawn_time happens after your upgrade_height the provider will not be able to communicate the new validator set to be used after the changeover.  Additionally, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters to be put in the proposal take note to include a link to your onboarding repository  Example of a consumer chain addition proposal (compare with the ConsumerAdditionProposal in the ICS Provider Proposals section for chains that launch as consumers):  // ConsumerAdditionProposal is a governance proposal on the provider chain to spawn a new consumer chain or add a standalone chain. // If it passes, then a subset (i.e., depends on `top_N` and on the power shaping parameters) of validators on the provider chain are expected // to validate the consumer chain at spawn time. It is recommended that spawn time occurs after the proposal end time and that it is // scheduled to happen before the standalone chain upgrade that sill introduce the ccv module. { // Title of the proposal &quot;title&quot;: &quot;Changeover Standalone chain&quot;, // Description of the proposal // format the text as a .md file and include the file in your onboarding repository &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, // Proposed chain-id of the new consumer chain. // Must be unique from all other consumer chain ids of the executing provider chain. &quot;chain_id&quot;: &quot;standalone-1&quot;, // Initial height of new consumer chain. &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. standalone-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_number&quot;: 1, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // =&gt; not relevant for changeover procedure &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on standalone chain upgrade // =&gt; not relevant for changeover procedure as it may become stale &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and all validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should should be smaller than that of the provider. &quot;unbonding_period&quot;: 86400000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 259200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot; // NOTE: use existing transfer channel if available // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. &quot;top_N&quot;: 95, // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis. &quot;validators_power_cap&quot;: 0, // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. &quot;validator_set_cap&quot;: 0, // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate // the consumer chain. &quot;allowlist&quot;: [], // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. &quot;denylist&quot;: [] }   info As seen in the ConsumerAdditionProposal example above, the changeover procedure can be used together with Partial Set Security. This means, that a standalone chain can choose to only be validated by some of the validators of the provider chain by setting top_N appropriately, or by additionally setting a validators-power cap, validator-set cap, etc. by using the power-shaping parameters.  ","version":"v4.5.0","tagName":"h2"},{"title":"3. Submit an Upgrade Proposal & Prepare for Changeover​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#3-submit-an-upgrade-proposal--prepare-for-changeover","content":" This proposal should add the ccv consumer module to your chain.   proposal upgrade_height must happen after spawn_time in the ConsumerAdditionProposal advise validators about the exact procedure for your chain and point them to your onboarding repository  ","version":"v4.5.0","tagName":"h2"},{"title":"4. Upgrade time 🚀​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v4.5.0/consumer-development/changeover-procedure#4-upgrade-time-","content":"  after spawn_time, request ConsumerGenesis from the provider and place it in &lt;CURRENT_USER_HOME_DIR&gt;/.sovereign/config/genesis.json upgrade the binary to the one listed in your UpgradeProposal  The chain starts after at least 66.67% of standalone voting power comes online. The consumer chain is considered interchain secured once the &quot;old&quot; validator set signs a couple of blocks and transfers control to the provider validator set.   provide a repo with onboarding instructions for validators (it should already be listed in the proposal) genesis.json after spawn_time obtained from provider (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) ","version":"v4.5.0","tagName":"h2"},{"title":"Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/features/key-assignment","content":"","keywords":"","version":"v4.5.0"},{"title":"Rules​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v4.5.0/features/key-assignment#rules","content":" a key can be assigned as soon as the consumer addition proposal is submitted to the providervalidator A cannot assign consumer key K to consumer chain X if there is already a validator B (B!=A) using K on the providervalidator A cannot assign consumer key K to consumer chain X if there is already a validator B using K on Xa new validator on the provider cannot use a consensus key K if K is already used by any validator on any consumer chain  tip Validators can use a different key for each consumer chain.  ","version":"v4.5.0","tagName":"h2"},{"title":"Adding a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v4.5.0/features/key-assignment#adding-a-key","content":" First, create a new node on the consumer chain using the equivalent:  consumerd init &lt;moniker&gt;   Then query your node for the consensus key.  consumerd tendermint show-validator # {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, make an assign-consensus-key transaction on the provider chain in order to inform the provider chain about the consensus key you will be using for a specific consumer chain.  gaiad tx provider assign-consensus-key &lt;consumer-chain-id&gt; '&lt;pubkey&gt;' --from &lt;tx-signer&gt; --home &lt;home_dir&gt; --gas 900000 -b sync -y -o json   consumer-chain-id is the string identifier of the consumer chain, as assigned on the provider chainconsumer-pub-key has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}  Check that the key was assigned correctly by querying the provider:  gaiad query provider validator-consumer-key &lt;consumer-chain-id&gt; cosmosvalcons1e....3xsj3ayzf4uv6   You must use a valcons address. You can obtain it by querying your node on the provider gaiad tendermint show-address  OR  gaiad query provider validator-provider-key &lt;consumer-chain-id&gt; consumervalcons1e....123asdnoaisdao   You must use a valcons address. You can obtain it by querying your node on the consumer consumerd tendermint show-address  OR  gaiad query provider all-pairs-valconsensus-address &lt;consumer-chain-id&gt;   You just need to use the chainId of consumer to query all pairs valconsensus address with consumer-pub-key for each of pair  ","version":"v4.5.0","tagName":"h2"},{"title":"Changing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v4.5.0/features/key-assignment#changing-a-key","content":" To change your key, simply repeat all of the steps listed above. Take note that your old key will be remembered for at least the unbonding period of the consumer chain so any slashes can be correctly applied  ","version":"v4.5.0","tagName":"h2"},{"title":"Removing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v4.5.0/features/key-assignment#removing-a-key","content":" To remove a key, simply switch it back to the consensus key you have assigned on the provider chain by following steps in the Adding a key section and using your provider consensus key.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  ","version":"v4.5.0","tagName":"h2"},{"title":"Querying proposed consumer chains​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v4.5.0/features/key-assignment#querying-proposed-consumer-chains","content":" To query the consumer addition proposals that are in the voting period, you can use the following command on the provider:  gaiad query provider list-proposed-consumer-chains   This query is valuable for staying informed about when keys can be assigned to newly proposed consumer chains. ","version":"v4.5.0","tagName":"h2"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/features/partial-set-security","content":"Partial Set Security Partial Set Security (PSS) allows consumer chains to leverage only a subset of validators from the provider chain, which offers more flexibility than the traditional Replicated Security model. By introducing the top_N parameter, each consumer chain can choose the extent of security needed: Top N: Requires the top N% validators from the provider chain to secure the consumer chain. This guarantees that the validators with the most power on the provider will validate the consumer chain, while others can voluntarily opt in. Opt-In: If the top_N parameter is set to zero, no validator is mandated to secure the consumer chain. Instead, any validator from the provider chain can opt in using a dedicated transaction. An advantage of a Top N chain is that the consumer chain is guaranteed to receive at least a certain fraction of the market cap of the provider chain in security. In turn, this chain needs to be approved by governance, since validators will be forced to run the chain. Thus, Top N chains should typically expect to need to provide a strong case for why they should be added to the provider chain, and they should make sure they offer enough rewards to incentivize validators and delegators to vote for their proposal. Opt-In chains, on the other hand, are more flexible. While for technical reasons, they are also currently added via governance proposals, since validators are never forced to validate these chains and simply opt in if they want to, they should typically expect to get their proposals approved much more easily compared to Top N chains, since validators that do not want to validate the chain can simply choose not to opt in. However, opt in chains do not get a fixed amount of security as a relation of the market cap of the provider as top N chains do, so opt in chains might want to keep an eye on how many validators have opted in to validate their chain and adjust their reward emissions accordingly to incentivize validators. tip Partial Set Security is handled only by the provider chain - the consumer chains are simply sent validator sets, and they are not aware that this represents only a subset of the provider chain's validator set. caution Both Opt In and Top N chains currently require a governance proposal to be added to the provider chain. For Top N chains, this is also the long term vision for how they are launched. For Opt In chains, this is a temporary measure to prevent issues around chain ID squatting, i.e. someone could spuriously register many desirable chain IDs of upcoming consumer chain and simply deny legitimate consumer chains from using them. Eventually, the plan is to allow launching Opt In chains permissionlessly without going through governance, with quality control being handled by the market of validators deciding which chains they would like to validate on. tip A running Top N consumer chain might want to become an Opt-In chain or vice versa. This can be achieved by issuing a ConsumerModificationProposal.","keywords":"","version":"v4.5.0"},{"title":"Power Shaping","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/features/power-shaping","content":"","keywords":"","version":"v4.5.0"},{"title":"Guidelines for setting power shaping parameters​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v4.5.0/features/power-shaping#guidelines-for-setting-power-shaping-parameters","content":" When setting power shaping parameters, please consider the following guidelines:  Do not cap the validator set size too low: Notice that this number is the *maximum number of validators that will ever validate the consumer chain. If this number is too low, the chain will be very limited in the amount of stake that secures it. The validator set size cap should only be used if there are strong reasons to prefer fewer validators. Consider that setting the cap will mean that even if the whole validator set of the provider wants to validate on the chain, some validators will simply not be able to.Capping the fraction of power any single validator can have is a decent security measure, but it's good to be aware of the interactions with the size of the validator set. For example, if there are only 3 validators, and the cap is 20%, this will not be possible (since even splitting the power fairly would mean that each validator has 33% of the power, so is above the cap). However, the cap can be a good measure to prevent a single large validator from essentially taking over the chain. In general, values under 33% make sense (since a validator that has 33% of the chains power would halt the chain if they go offline). Notice that the smaller this value is, the more the original voting power gets distorted, which could discourage large validators from deciding to opt in to the chain.If the allowlist is empty, all validators can validate the chain. If it is non empty, then only validators on the allowlist can validate the chain. Thus, an allowlist containing too few validators is a security risk. In particular, consider that if the validators on the allowlist lose a lot of stake or stop being validators, an allowlist that is too short can very quickly become outdated and leave too few validators, or validators with too little stake, to secure the chain in a decentralized way.If the denylist is too full, this can likewise be problematic. If too many large validators are denylisted, the chain might not be secured by a large enough fraction of the provider's power, in particular when the power distribution on the provider shifts and the denylisted validators gain more power.  In general, when setting these parameters, consider that the voting power distribution in the future might be very different from the one right now, and that the chain should be secure even if the power distribution changes significantly.  tip The power shaping parameters of a running consumer chain can be changed through a ConsumerModificationProposal. ","version":"v4.5.0","tagName":"h2"},{"title":"Reward Distribution","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/features/reward-distribution","content":"","keywords":"","version":"v4.5.0"},{"title":"Whitelisting Reward Denoms​","type":1,"pageTitle":"Reward Distribution","url":"/interchain-security/v4.5.0/features/reward-distribution#whitelisting-reward-denoms","content":" The ICS distribution system works by allowing consumer chains to send rewards to a module address on the provider called the ConsumerRewardsPool. To avoid spam, the provider must whitelist denoms before accepting them as ICS rewards. Only whitelisted denoms are transferred from the ConsumerRewardsPool to the FeePoolAddress, to be distributed to delegators and validators. The whitelisted denoms can be adjusted through governance by sending a ChangeRewardDenomProposal.  To query the list of whitelisted reward denoms on the Cosmos Hub, use the following command:  &gt; gaiad q provider registered-consumer-reward-denoms denoms: - ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 - ibc/6B8A3F5C2AD51CD6171FA41A7E8C35AD594AB69226438DB94450436EA57B3A89 - uatom   tip Use the following command to get a human readable denom from the ibc/* denom trace format: &gt; gaiad query ibc-transfer denom-trace ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 denom_trace: base_denom: untrn path: transfer/channel-569  ","version":"v4.5.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/introduction/overview","content":"","keywords":"","version":"v4.5.0"},{"title":"Why Interchain Security?​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/introduction/overview#why-interchain-security","content":" The right amount of security for each application. Consumer chains can choose to inherit the whole validator set from the provider, or they can launch as an opt in chain where only a subset of the provider validators validate the consumer chain. This allows for a wide range of security tradeoffs.Independent block-space. Transactions on consumer chains do not compete with any other applications. This means that there will be no unexpected congestion, and performance will generally be much better than on a shared smart contract platform such as Ethereum.Projects keep majority of gas fees. Depending on configuration, these fees either go to the project’s community DAO, or can be used in the protocol in other ways.No validator search. Consumer chains do not have their own validator sets, and so do not need to find validators one by one. Validators from the provider chain validate on the consumer chain with their stake on the provider chain, earning additional rewards. For the consumer chain, this comes with the benefit of exposing their chain to the wider audience of the provider chain.Instant sovereignty. Consumers can run arbitrary app logic similar to standalone chains. At any time in the future, a consumer chain can elect to become a completely standalone chain, with its own validator set.  ","version":"v4.5.0","tagName":"h2"},{"title":"Core protocol​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/introduction/overview#core-protocol","content":" info Protocol specification is available as ICS-028 in the IBC repository.  Once an IBC connection and proper channel is established between a provider and consumer chain, the provider will continually send validator set updates to the consumer over IBC. The consumer uses these validator set updates to update its own validator set in Comet. Thus, the provider validator set is effectively replicated on the consumer.  To ensure the security of the consumer chain, provider delegators cannot unbond their tokens until the unbonding periods of each consumer chain has passed. In practice this will not be noticeable to the provider delegators, since consumer chains will be configured to have a slightly shorter unbonding period than the provider.  ","version":"v4.5.0","tagName":"h2"},{"title":"Downtime Slashing​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/introduction/overview#downtime-slashing","content":" If downtime is initiated by a validator on a consumer chain, a downtime packet will be relayed to the provider to jail that validator for a set amount of time. The validator who committed downtime will then miss out on staking rewards for the configured jailing period.  ","version":"v4.5.0","tagName":"h3"},{"title":"Tokenomics and Rewards​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/introduction/overview#tokenomics-and-rewards","content":" Consumer chains are free to create their own native token which can be used for fees, and can be created on the consumer chain in the form of inflationary rewards. These rewards can be used to incentivize user behavior, for example, LPing or staking. A portion of these fees and rewards will be sent to provider chain stakers, but that proportion is completely customizable by the developers, and subject to governance. ","version":"v4.5.0","tagName":"h3"},{"title":"Democracy modules","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/features/democracy-modules","content":"","keywords":"","version":"v4.5.0"},{"title":"Staking​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v4.5.0/features/democracy-modules#staking","content":" The democracy staking module allows the cosmos-sdk x/staking module to be used alongside the interchain security consumer module.  The module uses overrides that allow the full x/staking functionality with one notable difference - the staking module will no longer be used to provide the consensus validator set.  ","version":"v4.5.0","tagName":"h2"},{"title":"Implications for consumer chains​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v4.5.0/features/democracy-modules#implications-for-consumer-chains","content":" The x/ccv/democracy/staking allows consumer chains to separate governance from block production.  info The validator set coming from the provider chain does not need to participate in governance - they only provide infrastructure (create blocks and maintain consensus).  Governators (aka. Governors)​  Validators registered with the x/staking module become &quot;Governators&quot;.  Unlike Validators, Governators are not required to run any chain infastructure since they are not signing any blocks.  However, Governators retain a subset of the validator properties:  new Governators can be created (via MsgCreateValidator)Governators can accept delegationsGovernators can vote on governance proposals (with their self stake and delegations)Governators earn token rewards  With these changes, Governators can become community advocates that can specialize in chain governance and they get rewarded for their participation the same way the validators do.  Additionally, Governators can choose to provide additional infrastructure such as RPC/API access points, archive nodes, indexers and similar software.  Tokenomics​  The consumer chain's token will remain a governance and reward token. The token's parameters (inflation, max supply, burn rate) are not affected.  info Staking rewards are distributed to all Governators and their delegators after distributing the rewards to the provider chain's validator set.  ","version":"v4.5.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v4.5.0/features/democracy-modules#integration","content":" The x/ccv/democracy/staking module provides these x/staking overrides:   // InitGenesis delegates the InitGenesis call to the underlying x/staking module, // however, it returns no validator updates as validators are tracked via the // consumer chain's x/cvv/consumer module and so this module is not responsible for returning the initial validator set. func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run staking InitGenesis return []abci.ValidatorUpdate{} // do not return validator updates } // EndBlock delegates the EndBlock call to the underlying x/staking module. // However, no validator updates are returned as validators are tracked via the // consumer chain's x/cvv/consumer module. func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates return []abci.ValidatorUpdate{} // do not return validator updates }   To integrate the democracy/staking follow this guide:  1. confirm that no modules are returning validator updates​  tip Only the x/ccv/consumer module should be returning validator updates.  If some of your modules are returning validator updates please disable them while maintaining your business logic:  func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) -\treturn am.keeper.InitGenesis(ctx, &amp;genesisState) + _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run InitGenesis but drop the result +\treturn []abci.ValidatorUpdate{} // return empty validator updates } func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { -\treturn am.keeper.BlockValidatorUpdates(ctx) + _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates +\treturn []abci.ValidatorUpdate{} // return empty validator updates }   2. wire the module in app.go​  You do not need to remove the cosmos-sdk StakingKeeper from your wiring.  import ( ... + ccvstaking &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/staking&quot; ) var ( // replace the staking.AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, - sdkstaking.AppModuleBasic{}, + ccvstaking.AppModuleBasic{}, // replace sdkstaking ... ) ) func NewApp(...) { ... // use sdk StakingKeepeer app.StakingKeeper = stakingkeeper.NewKeeper( appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.MintKeeper = mintkeeper.NewKeeper( appCodec, keys[minttypes.StoreKey], app.StakingKeeper, app.AccountKeeper, app.BankKeeper, authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // no changes required for the distribution keeper app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // keep StakingKeeper! authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) + // pre-initialize ConsumerKeeper to satsfy ibckeeper.NewKeeper +\tapp.ConsumerKeeper = consumerkeeper.NewNonZeroKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), +\t) + +\tapp.IBCKeeper = ibckeeper.NewKeeper( + appCodec, + keys[ibchost.StoreKey], + app.GetSubspace(ibchost.ModuleName), + &amp;app.ConsumerKeeper, + app.UpgradeKeeper, + scopedIBCKeeper, +\t) + +\t// Create CCV consumer and modules +\tapp.ConsumerKeeper = consumerkeeper.NewKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), + scopedIBCConsumerKeeper, + app.IBCKeeper.ChannelKeeper, + &amp;app.IBCKeeper.PortKeeper, + app.IBCKeeper.ConnectionKeeper, + app.IBCKeeper.ClientKeeper, + app.SlashingKeeper, + app.BankKeeper, + app.AccountKeeper, + &amp;app.TransferKeeper, + app.IBCKeeper, + authtypes.FeeCollectorName, +\t) + +\t// Setting the standalone staking keeper is only needed for standalone to consumer changeover chains + // New chains using the democracy/staking do not need to set this +\tapp.ConsumerKeeper.SetStandaloneStakingKeeper(app.StakingKeeper) // change the slashing keeper dependency app.SlashingKeeper = slashingkeeper.NewKeeper( appCodec, legacyAmino, keys[slashingtypes.StoreKey], - app.StakingKeeper, + &amp;app.ConsumerKeeper, // ConsumerKeeper implements StakingKeeper interface authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register slashing module StakingHooks to the consumer keeper +\tapp.ConsumerKeeper = *app.ConsumerKeeper.SetHooks(app.SlashingKeeper.Hooks()) +\tconsumerModule := consumer.NewAppModule(app.ConsumerKeeper, app.GetSubspace(consumertypes.ModuleName)) // register the module with module manager // replace the x/staking module app.MM = module.NewManager( ... - sdkstaking.NewAppModule(appCodec, &amp;app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), + ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }   ","version":"v4.5.0","tagName":"h3"},{"title":"Governance​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v4.5.0/features/democracy-modules#governance","content":" The x/ccv/democracy/governance module extends the x/governance module with the functionality to filter proposals.  tip Consumer chains can limit in the types of governance proposals that can be executed on chain to avoid inadvertent changes to interchain security protocol that could affect security properties.  The module uses AnteHandler to limit the types of proposals that can be executed.  ","version":"v4.5.0","tagName":"h2"},{"title":"Integration​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v4.5.0/features/democracy-modules#integration-1","content":" Add new AnteHandler to your app.   // app/ante/forbidden_proposals.go package ante import ( &quot;fmt&quot; sdk &quot;github.com/cosmos/cosmos-sdk/types&quot; govv1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1&quot; govv1beta1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; ibctransfertypes &quot;github.com/cosmos/ibc-go/v7/modules/apps/transfer/types&quot; &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; &quot;github.com/cosmos/cosmos-sdk/x/params/types/proposal&quot; ) type ForbiddenProposalsDecorator struct { isLegacyProposalWhitelisted func(govv1beta1.Content) bool isModuleWhiteList func(string) bool } func NewForbiddenProposalsDecorator( whiteListFn func(govv1beta1.Content) bool, isModuleWhiteList func(string) bool, ) ForbiddenProposalsDecorator { return ForbiddenProposalsDecorator{ isLegacyProposalWhitelisted: whiteListFn, isModuleWhiteList: isModuleWhiteList, } } func (decorator ForbiddenProposalsDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (newCtx sdk.Context, err error) { currHeight := ctx.BlockHeight() for _, msg := range tx.GetMsgs() { // if the message is MsgSubmitProposal, check if proposal is whitelisted submitProposalMgs, ok := msg.(*govv1.MsgSubmitProposal) if !ok { continue } messages := submitProposalMgs.GetMessages() for _, message := range messages { if sdkMsg, isLegacyProposal := message.GetCachedValue().(*govv1.MsgExecLegacyContent); isLegacyProposal { // legacy gov proposal content content, err := govv1.LegacyContentFromMessage(sdkMsg) if err != nil { return ctx, fmt.Errorf(&quot;tx contains invalid LegacyContent&quot;) } if !decorator.isLegacyProposalWhitelisted(content) { return ctx, fmt.Errorf(&quot;tx contains unsupported proposal message types at height %d&quot;, currHeight) } continue } // not legacy gov proposal content and not whitelisted if !decorator.isModuleWhiteList(message.TypeUrl) { return ctx, fmt.Errorf(&quot;tx contains unsupported proposal message types at height %d&quot;, currHeight) } } } return next(ctx, tx, simulate) } func IsProposalWhitelisted(content v1beta1.Content) bool { switch c := content.(type) { case *proposal.ParameterChangeProposal: return isLegacyParamChangeWhitelisted(c.Changes) default: return false } } func isLegacyParamChangeWhitelisted(paramChanges []proposal.ParamChange) bool { for _, paramChange := range paramChanges { _, found := LegacyWhitelistedParams[legacyParamChangeKey{Subspace: paramChange.Subspace, Key: paramChange.Key}] if !found { return false } } return true } type legacyParamChangeKey struct { Subspace, Key string } // Legacy params can be whitelisted var LegacyWhitelistedParams = map[legacyParamChangeKey]struct{}{ {Subspace: ibctransfertypes.ModuleName, Key: &quot;SendEnabled&quot;}: {}, {Subspace: ibctransfertypes.ModuleName, Key: &quot;ReceiveEnabled&quot;}: {}, } // New proposal types can be whitelisted var WhiteListModule = map[string]struct{}{ &quot;/cosmos.gov.v1.MsgUpdateParams&quot;: {}, &quot;/cosmos.bank.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.staking.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.distribution.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.mint.v1beta1.MsgUpdateParams&quot;: {}, } func IsModuleWhiteList(typeUrl string) bool { _, found := WhiteListModule[typeUrl] return found }   Add the AnteHandler to the list of supported antehandlers:  // app/ante_handler.go package app import ( ... +\tdemocracyante &quot;github.com/cosmos/interchain-security/v4/app/consumer-democracy/ante&quot; +\tconsumerante &quot;github.com/cosmos/interchain-security/v4/app/consumer/ante&quot; +\ticsconsumerkeeper &quot;github.com/cosmos/interchain-security/v4/x/ccv/consumer/keeper&quot; ) type HandlerOptions struct { ante.HandlerOptions IBCKeeper *ibckeeper.Keeper +\tConsumerKeeper ibcconsumerkeeper.Keeper } func NewAnteHandler(options HandlerOptions) (sdk.AnteHandler, error) { .... anteDecorators := []sdk.AnteDecorator{ ... + consumerante.NewMsgFilterDecorator(options.ConsumerKeeper), + consumerante.NewDisabledModulesDecorator(&quot;/cosmos.evidence&quot;, &quot;/cosmos.slashing&quot;), + democracyante.NewForbiddenProposalsDecorator(IsProposalWhitelisted, IsModuleWhiteList), ... } return sdk.ChainAnteDecorators(anteDecorators...), nil }   Wire the module in app.go.  // app/app.go package app import ( ... sdkgov &quot;github.com/cosmos/cosmos-sdk/x/gov&quot; govkeeper &quot;github.com/cosmos/cosmos-sdk/x/gov/keeper&quot; govtypes &quot;github.com/cosmos/cosmos-sdk/x/gov/types&quot; govv1beta1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; +\tccvgov &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/governance&quot; ) var ( // use sdk governance module ModuleBasics = module.NewBasicManager( ... sdkgov.NewAppModuleBasic( []govclient.ProposalHandler{ paramsclient.ProposalHandler, upgradeclient.LegacyProposalHandler, upgradeclient.LegacyCancelProposalHandler, }, ), ) ) func NewApp(...) { // retain sdk gov router and keeper registrations sdkgovRouter := govv1beta1.NewRouter() sdkgovRouter. AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler). AddRoute(paramproposal.RouterKey, params.NewParamChangeProposalHandler(app.ParamsKeeper)). AddRoute(upgradetypes.RouterKey, upgrade.NewSoftwareUpgradeProposalHandler(&amp;app.UpgradeKeeper)) govConfig := govtypes.DefaultConfig() app.GovKeeper = *govkeeper.NewKeeper( appCodec, keys[govtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, app.MsgServiceRouter(), govConfig, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.GovKeeper.SetLegacyRouter(sdkgovRouter) // register the module with module manager // replace the x/gov module app.MM = module.NewManager( - sdkgov.NewAppModule(appCodec, app.GovKeeper, app.AccountKeeper, app.BankKeeper, IsProposalWhitelisted, app.GetSubspace(govtypes.ModuleName), IsModuleWhiteList), + ccvgov.NewAppModule(appCodec, app.GovKeeper, app.AccountKeeper, app.BankKeeper, IsProposalWhitelisted, app.GetSubspace(govtypes.ModuleName), IsModuleWhiteList), ... ) }   ","version":"v4.5.0","tagName":"h3"},{"title":"Distribution​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v4.5.0/features/democracy-modules#distribution","content":" tip The democracy/distribution module allows the consumer chain to send rewards to the provider chain while retaining the x/distribution module for internal reward distribution to Governators and stakers.  ","version":"v4.5.0","tagName":"h2"},{"title":"How it works​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v4.5.0/features/democracy-modules#how-it-works","content":" First, a % of rewards to be distributed to the provider chain's validator set is calculated and sent to the provider chain. Only opted-in validators from the provider chain will receive the consumer rewards.  Second, the remaining rewards get distributed to the consumer chain's Governators and their delegators.  info The % that is sent to the provider chain corresponds to 1 - ConsumerRedistributionFraction. e.g. ConsumerRedistributionFraction = &quot;0.75&quot; means that the consumer chain retains 75% of the rewards, while 25% gets sent to the provider chain to be distributed as rewards to provider chain validators.  ","version":"v4.5.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v4.5.0/features/democracy-modules#integration-2","content":" Change the wiring in app.go  import ( ... distrkeeper &quot;github.com/cosmos/cosmos-sdk/x/distribution/keeper&quot; distrtypes &quot;github.com/cosmos/cosmos-sdk/x/distribution/types&quot; sdkdistr &quot;github.com/cosmos/cosmos-sdk/x/distribution&quot; + ccvdistr &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/distribution&quot; ) var ( // replace sdk distribution AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, ccvstaking.AppModuleBasic{}, // make sure you first swap the staking keeper mint.AppModuleBasic{}, - sdkdistr.AppModuleBasic{}, + ccvdistr.AppModuleBasic{}, ) ) func NewApp(...) { .... app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // connect to sdk StakingKeeper consumertypes.ConsumerRedistributeName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register with the module manager app.MM = module.NewManager( ... - sdkdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), + ccvdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }  ","version":"v4.5.0","tagName":"h3"},{"title":"Interchain Security Parameters","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/introduction/params","content":"","keywords":"","version":"v4.5.0"},{"title":"Time-Based Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#time-based-parameters","content":" ICS relies on the following time-based parameters.  ","version":"v4.5.0","tagName":"h2"},{"title":"ProviderUnbondingPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#providerunbondingperiod","content":" ProviderUnbondingPeriod is the unbonding period on the provider chain as configured during chain genesis. This parameter can later be changed via governance.  ","version":"v4.5.0","tagName":"h3"},{"title":"ConsumerUnbondingPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#consumerunbondingperiod","content":" ConsumerUnbondingPeriod is the unbonding period on the consumer chain.  info ConsumerUnbondingPeriod is set via the ConsumerAdditionProposal governance proposal to add a new consumer chain. It is recommended that every consumer chain set and unbonding period shorter than ProviderUnbondingPeriod Example: ConsumerUnbondingPeriod = ProviderUnbondingPeriod - one day   Unbonding operations (such as undelegations) are completed on the provider only after the unbonding period elapses on every consumer.  ","version":"v4.5.0","tagName":"h3"},{"title":"TrustingPeriodFraction​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#trustingperiodfraction","content":" TrustingPeriodFraction is used to calculate the TrustingPeriod of created IBC clients on both provider and consumer chains.  Setting TrustingPeriodFraction to 0.5 would result in the following:  TrustingPeriodFraction = 0.5 ProviderClientOnConsumerTrustingPeriod = ProviderUnbondingPeriod * 0.5 ConsumerClientOnProviderTrustingPeriod = ConsumerUnbondingPeriod * 0.5   Note that a light clients must be updated within the TrustingPeriod in order to avoid being frozen.  For more details, see the IBC specification of Tendermint clients.  ","version":"v4.5.0","tagName":"h3"},{"title":"CCVTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#ccvtimeoutperiod","content":" CCVTimeoutPeriod is the period used to compute the timeout timestamp when sending IBC packets.  For more details, see the IBC specification of Channel &amp; Packet Semantics.  warning If a sent packet is not relayed within this period, then the packet times out. The CCV channel used by the interchain security protocol is closed, and the corresponding consumer is removed.  CCVTimeoutPeriod may have different values on the provider and consumer chains.  CCVTimeoutPeriod on the provider must be larger than ConsumerUnbondingPeriodCCVTimeoutPeriod on the consumer is initial set via the ConsumerAdditionProposal  ","version":"v4.5.0","tagName":"h3"},{"title":"InitTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#inittimeoutperiod","content":" InitTimeoutPeriod is the maximum allowed duration for CCV channel initialization to execute.  For any consumer chain, if the CCV channel is not established within InitTimeoutPeriod then the consumer chain will be removed and therefore will not be secured by the provider chain.  The countdown starts when the spawn_time specified in the ConsumerAdditionProposal is reached.  ","version":"v4.5.0","tagName":"h3"},{"title":"VscTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#vsctimeoutperiod","content":" VscTimeoutPeriod is the provider-side param that enables the provider to timeout VSC packets even when a consumer chain is not live. If the VscTimeoutPeriod is ever reached for a consumer chain that chain will be considered not live and removed from interchain security.  tip VscTimeoutPeriod MUST be larger than the ConsumerUnbondingPeriod.  ","version":"v4.5.0","tagName":"h3"},{"title":"BlocksPerDistributionTransmission​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#blocksperdistributiontransmission","content":" BlocksPerDistributionTransmission is the number of blocks between rewards transfers from the consumer to the provider.  ","version":"v4.5.0","tagName":"h3"},{"title":"TransferPeriodTimeout​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#transferperiodtimeout","content":" TransferPeriodTimeout is the period used to compute the timeout timestamp when sending IBC transfer packets from a consumer to the provider.  If this timeout expires, then the transfer is attempted again after BlocksPerDistributionTransmission blocks.  TransferPeriodTimeout on the consumer is initial set via the ConsumerAdditionProposal gov proposal to add the consumerTransferPeriodTimeout should be smaller than BlocksPerDistributionTransmission x avg_block_time  ","version":"v4.5.0","tagName":"h3"},{"title":"Reward Distribution Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#reward-distribution-parameters","content":" tip The following chain parameters dictate consumer chain distribution amount and frequency. They are set at consumer genesis and BlocksPerDistributionTransmission, ConsumerRedistributionFractionTransferTimeoutPeriod must be provided in every ConsumerChainAddition proposal.  ","version":"v4.5.0","tagName":"h2"},{"title":"ConsumerRedistributionFraction​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#consumerredistributionfraction","content":" ConsumerRedistributionFraction is the fraction of tokens allocated to the consumer redistribution address during distribution events. The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%.  tip Example: With ConsumerRedistributionFraction set to &quot;0.75&quot; the consumer chain would send 75% of its block rewards and accumulated fees to the consumer redistribution address, and the remaining 25% to the provider chain every BlocksPerDistributionTransmission blocks.  ","version":"v4.5.0","tagName":"h3"},{"title":"BlocksPerDistributionTransmission​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#blocksperdistributiontransmission-1","content":" BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain.  ","version":"v4.5.0","tagName":"h3"},{"title":"TransferTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#transfertimeoutperiod","content":" TransferTimeoutPeriod is the timeout period for consumer chain reward distribution IBC packets.  ","version":"v4.5.0","tagName":"h3"},{"title":"DistributionTransmissionChannel​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#distributiontransmissionchannel","content":" DistributionTransmissionChannel is the provider chain IBC channel used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  ","version":"v4.5.0","tagName":"h3"},{"title":"ProviderFeePoolAddrStr​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#providerfeepooladdrstr","content":" ProviderFeePoolAddrStr is the provider chain fee pool address used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  ","version":"v4.5.0","tagName":"h3"},{"title":"Slash Throttle Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#slash-throttle-parameters","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"SlashMeterReplenishPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#slashmeterreplenishperiod","content":" SlashMeterReplenishPeriod exists on the provider such that once the slash meter becomes not-full, the slash meter is replenished after this period has elapsed.  The meter is replenished to an amount equal to the slash meter allowance for that block, or SlashMeterReplenishFraction * CurrentTotalVotingPower.  ","version":"v4.5.0","tagName":"h3"},{"title":"SlashMeterReplenishFraction​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#slashmeterreplenishfraction","content":" SlashMeterReplenishFraction exists on the provider as the portion (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs.  This param also serves as a maximum fraction of total voting power that the slash meter can hold. The param is set/persisted as a string, and converted to a sdk.Dec when used.  ","version":"v4.5.0","tagName":"h3"},{"title":"MaxThrottledPackets​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#maxthrottledpackets","content":" MaxThrottledPackets exists on the provider as the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value.  This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness.  info MaxThrottledPackets was deprecated in ICS versions &gt;= v3.2.0 due to the implementation of ADR-008.  ","version":"v4.5.0","tagName":"h3"},{"title":"RetryDelayPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#retrydelayperiod","content":" RetryDelayPeriod exists on the consumer for ICS versions &gt;= v3.2.0 (introduced by the implementation of ADR-008) and is the period at which the consumer retries to send a SlashPacket that was rejected by the provider.  ","version":"v4.5.0","tagName":"h3"},{"title":"Epoch Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#epoch-parameters","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"BlocksPerEpoch​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v4.5.0/introduction/params#blocksperepoch","content":" BlocksPerEpoch exists on the provider for ICS versions &gt;= 3.3.0 (introduced by the implementation of ADR-014) and corresponds to the number of blocks that constitute an epoch. This param is set to 600 by default. Assuming we need 6 seconds to commit a block, the duration of an epoch corresponds to 1 hour. This means that a VSCPacket would be sent to a consumer chain once at the end of every epoch, so once every 600 blocks. This parameter can be adjusted via a governance proposal, however careful consideration is needed so that BlocksPerEpoch is not too large. A large BlocksPerEpoch could lead to a delay of VSCPackets and hence potentially lead to unbonding pausing. For setting BlocksPerEpoch, we also need to consider potential slow chain upgrades that could delay the sending of aVSCPacket, as well as potential increases in the time it takes to commit a block (e.g., from 6 seconds to 30 seconds). ","version":"v4.5.0","tagName":"h3"},{"title":"Technical Specification","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/introduction/technical-specification","content":"Technical Specification For a technical deep dive into the replicated security protocol, see the specification.","keywords":"","version":"v4.5.0"},{"title":"ICS Provider Proposals","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/features/proposals","content":"","keywords":"","version":"v4.5.0"},{"title":"ConsumerAdditionProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v4.5.0/features/proposals#consumeradditionproposal","content":" info If you are preparing a ConsumerAdditionProposal you can find more information in the consumer onboarding checklist.  Proposal type used to suggest adding a new consumer chain.  When proposals of this type are passed and the spawn_time specified in the proposal is reached, all provider chain validators are expected to run infrastructure (validator nodes) for the proposed consumer chain.  Minimal example:  { // Time on the provider chain at which the consumer chain genesis is finalized and all validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, &quot;title&quot;: &quot;Add consumer chain&quot;, &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, &quot;chain_id&quot;: &quot;newchain-1&quot;, &quot;initial_height&quot; : { &quot;revision_height&quot;: 0, &quot;revision_number&quot;: 1, }, // Unbonding period for the consumer chain. // It should be smaller than that of the provider. &quot;unbonding_period&quot;: 86400000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 259200000000000, &quot;transfer_timeout_period&quot;: 1800000000000, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;blocks_per_distribution_transmission&quot;: 1000, &quot;historical_entries&quot;: 10000, &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot;, &quot;top_N&quot;: 95, &quot;validators_power_cap&quot;: 0, &quot;validator_set_cap&quot;: 0, &quot;allowlist&quot;: [], &quot;denylist&quot;: [] }   More examples can be found in the interchain security testnet repository here and here.  ","version":"v4.5.0","tagName":"h2"},{"title":"ConsumerRemovalProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v4.5.0/features/proposals#consumerremovalproposal","content":" Proposal type used to suggest removing an existing consumer chain.  When proposals of this type are passed, the consumer chain in question will be gracefully removed from interchain security and validators will no longer be required to run infrastructure for the specified chain. After the consumer chain removal, the chain in question will no longer be secured by the provider's validator set.  info The chain in question my continue to produce blocks, but the validator set can no longer be slashed for any infractions committed on that chain. Additional steps are required to completely offboard a consumer chain, such as re-introducing the staking module and removing the provider's validators from the active set. More information will be made available in the Consumer Offboarding Checklist.  Minimal example:  { // the time on the provider chain at which all validators are responsible to stop their consumer chain validator node &quot;stop_time&quot;: &quot;2023-03-07T12:40:00.000000Z&quot;, // the chain-id of the consumer chain to be stopped &quot;chain_id&quot;: &quot;consumerchain-1&quot;, &quot;title&quot;: &quot;This was a great chain&quot;, &quot;description&quot;: &quot;Here is a .md formatted string specifying removal details&quot; }   ","version":"v4.5.0","tagName":"h2"},{"title":"ConsumerModificationProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v4.5.0/features/proposals#consumermodificationproposal","content":" Proposal type used to change the power shaping parameters of a running consumer chain, as well as to change a Top N running consumer chain to an Opt-In chain and vice versa.  When a ConsumerModificationProposal passes for a running consumer chain, the consumer chain would change all its parameters to the ones passed in the ConsumerModificationProposal.  Assume, a chain-1 is a Top N chain. If the following ConsumerModificationProposal passes, then chain-1 would become an Opt-In chain with a 40% validators power cap, a maximum number of 30 validators, and one denylisted validator.  { &quot;title&quot;: &quot;Modify consumer chain&quot;, &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, &quot;chain_id&quot;: &quot;chain-1&quot;, &quot;top_N&quot;: 0, &quot;validators_power_cap&quot;: 40, &quot;validator_set_cap&quot;: 30, &quot;allowlist&quot;: [], &quot;denylist&quot;: [&quot;cosmosvalcons1qmq08eruchr5sf5s3rwz7djpr5a25f7xw4mceq&quot;] }   warning If top_N, validators_power_cap, or some other argument is not included in the proposal, then it is considered that the default value is set for this argument. For example, if a Top 50% chain wants to only modify validators_power_capfrom 35 to 40, then the ConsumerModificationProposal would still need to include that top_N is 50. Otherwisetop_N would be set to its default value of 0, and the chain would become an Opt-In chain. To be safe, always include top_N and all the power shaping parameters in your ConsumerModificationProposal.  ","version":"v4.5.0","tagName":"h2"},{"title":"ChangeRewardDenomProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v4.5.0/features/proposals#changerewarddenomproposal","content":" Proposal type used to mutate the set of denoms accepted by the provider as rewards.  tip A ChangeRewardDenomProposal will only be accepted on the provider chain if at least one of the denomsToAdd or denomsToRemove fields is populated with at least one denom. Also, a denom cannot be repeated in both sets.  Minimal example:  { &quot;title&quot;: &quot;Add uatom as a reward denom&quot;, &quot;description&quot;: &quot;Here is more information about the proposal&quot;, &quot;denomsToAdd&quot;: [&quot;uatom&quot;], &quot;denomsToRemove&quot;: [] }   tip Besides native provider denoms (e.g., uatom for the Cosmos Hub), please use the ibc/* denom trace format. For example, for untrn transferred over the path transfer/channel-569, the denom trace can be queried using the following command: &gt; gaiad query ibc-transfer denom-hash transfer/channel-569/untrn hash: 0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 Then use the resulting hash in the ChangeRewardDenomProposal, e.g., { &quot;title&quot;: &quot;Add untrn as a reward denom&quot;, &quot;description&quot;: &quot;Here is more information about the proposal&quot;, &quot;denomsToAdd&quot;: [&quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;], &quot;denomsToRemove&quot;: [] }  ","version":"v4.5.0","tagName":"h2"},{"title":"Terminology","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/introduction/terminology","content":"","keywords":"","version":"v4.5.0"},{"title":"Shared Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v4.5.0/introduction/terminology#shared-security","content":" Shared security is a family of technologies that include optimistic rollups, zk-rollups, sharding and Interchain Security. Ie. any protocol or technology that can allow one blockchain to lend/share its proof-of-stake security with another blockchain or off-chain process.  ","version":"v4.5.0","tagName":"h2"},{"title":"Interchain Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v4.5.0/introduction/terminology#interchain-security","content":" Interchain Security is the Cosmos-specific category of Shared Security that uses IBC (Inter-Blockchain Communication), i.e. any shared security protocol built with IBC.  ","version":"v4.5.0","tagName":"h2"},{"title":"Replicated Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v4.5.0/introduction/terminology#replicated-security","content":" A particular protocol/implementation of Interchain Security that fully replicates the security and decentralization of a validator set across multiple blockchains. Replicated security has also been referred to as &quot;Cross Chain Validation&quot; or &quot;Interchain Security V1&quot;, a legacy term for the same protocol. That is, a &quot;provider chain&quot; such as the Cosmos Hub can share its exact validator set with multiple consumer chains by communicating changes in its validator set over IBC.  ","version":"v4.5.0","tagName":"h2"},{"title":"Partial Set Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v4.5.0/introduction/terminology#partial-set-security","content":" A major iteration of Interchain Security, also known as &quot;Interchain Security V2&quot;. Partial Set Security allows a provider chain to share only a subset of its validator set with a consumer chain. This subset can be determined by the top N% validators by voting power, or by validators opting in to validate the consumer chain. Partial Set Security allows for more flexible security tradeoffs than Replicated Security.  ","version":"v4.5.0","tagName":"h2"},{"title":"Mesh security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v4.5.0/introduction/terminology#mesh-security","content":" A protocol built on IBC that allows delegators on a cosmos chain to re-delegate their stake to validators in another chain's own validator set, using the original chain's token (which remains bonded on the original chain). For a deeper exploration of mesh security, see Replicated vs. Mesh Security on the Informal Blog.  ","version":"v4.5.0","tagName":"h2"},{"title":"Consumer Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v4.5.0/introduction/terminology#consumer-chain","content":" Chain that is secured by the validator set of the provider, instead of its own. Interchain Security allows a subset of the provider chain's validator set to validate blocks on the consumer chain.  ","version":"v4.5.0","tagName":"h2"},{"title":"Standalone Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v4.5.0/introduction/terminology#standalone-chain","content":" Chain that is secured by its own validator set. This chain does not participate in Interchain Security.  Standalone chains may sometimes be called &quot;sovereign&quot; - the terms are synonymous.  ","version":"v4.5.0","tagName":"h2"},{"title":"Changeover Procedure​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v4.5.0/introduction/terminology#changeover-procedure","content":" Chains that were not initially launched as consumers of Interchain Security can still participate in the protocol and leverage the economic security of the provider chain. The process where a standalone chain transitions to being a replicated consumer chain is called the changeover procedure and is part of the interchain security protocol. After the changeover, the new consumer chain will retain all existing state, including the IBC clients, connections and channels already established by the chain. ","version":"v4.5.0","tagName":"h2"},{"title":"Validator Instructions for Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/validators/changeover-procedure","content":"","keywords":"","version":"v4.5.0"},{"title":"Timeline​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#timeline","content":" Upgrading standalone chains can be best visualised using a timeline, such as the one available Excalidraw graphic by Stride.  There is some flexibility with regards to how the changeover procedure is executed, so please make sure to follow the guides provided by the team doing the changeover.    ","version":"v4.5.0","tagName":"h2"},{"title":"1. ConsumerAdditionProposal on provider chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#1-consumeradditionproposal-on-provider-chain","content":" This step will add the standalone chain to the list of consumer chains secured by the provider. This step dictates the spawn_time. After spawn_time the CCV state (initial validator set of the provider) will be available to the consumer.  To obtain it from the provider use:  gaiad q provider consumer-genesis stride-1 -o json &gt; ccv-state.json jq -s '.[0].app_state.ccvconsumer = .[1] | .[0]' genesis.json ccv-state.json &gt; ccv.json   Transformation of the exported consumer genesis state to the target version of the consumer might be needed in case the provider and consumer formats are incompatible. Refer to the compatibility notes here to check if data transformation is needed for your case. Instructions on how to transform the exported CCV genesis state (ccv-state.json in the example above) to the required target version can be found here  ","version":"v4.5.0","tagName":"h3"},{"title":"2. SoftwareUpgradeProposal on the standalone/consumer chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#2-softwareupgradeproposal-on-the-standaloneconsumer-chain","content":" This upgrade proposal will introduce ICS to the standalone chain, making it a consumer.  ","version":"v4.5.0","tagName":"h3"},{"title":"3. Assigning a consumer key​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#3-assigning-a-consumer-key","content":" After spawn_time, make sure to assign a consumer key if you intend to use one.  Instructions are available here  ","version":"v4.5.0","tagName":"h3"},{"title":"4. Perform the software upgrade on standalone chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#4-perform-the-software-upgrade-on-standalone-chain","content":" Please use instructions provided by the standalone chain team and make sure to reach out if you are facing issues. The upgrade preparation depends on your setup, so please make sure you prepare ahead of time.  danger The ccv.json from step 1. must be made available on the machine running the standalone/consumer chain at standalone chain upgrade_height. This file contains the initial validator set and parameters required for normal ICS operation. Usually, the file is placed in $NODE_HOME/config but this is not a strict requirement. The exact details are available in the upgrade code of the standalone/consumer chain.  Performing this upgrade will transition the standalone chain to be a consumer chain.  After 3 blocks, the standalone chain will stop using the &quot;old&quot; validator set and begin using the provider validator set.  ","version":"v4.5.0","tagName":"h3"},{"title":"FAQ​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#faq","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"Can I reuse the same validator key for the consumer chain that I am already using on the standalone chain? Will I need to perform a AssignConsumerKey tx with this key before spawn time?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#can-i-reuse-the-same-validator-key-for-the-consumer-chain-that-i-am-already-using-on-the-standalone-chain-will-i-need-to-perform-a-assignconsumerkey-tx-with-this-key-before-spawn-time","content":" Validators must either assign a key or use the same key as on the provider.  If you are validating both the standalone and the provider, you can use your current standalone key with some caveats:  you must submit an AssignConsumerKey tx with your current standalone validator keyit is best to submit AssignConsumerKey tx before spawn_timeif you do not submit the Tx, it is assumed that you will be re-using your provider key to validate the standalone/consumer chain  ","version":"v4.5.0","tagName":"h3"},{"title":"Can I continue using the same node that was validating the standalone chain?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#can-i-continue-using-the-same-node-that-was-validating-the-standalone-chain","content":" Yes.  Please assign your consensus key as stated above.  ","version":"v4.5.0","tagName":"h3"},{"title":"Can I set up a new node to validate the standalone/consumer chain after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#can-i-set-up-a-new-node-to-validate-the-standaloneconsumer-chain-after-it-transitions-to-interchain-security","content":" Yes.  If you are planning to do this please make sure that the node is synced with standalone network and to submit AssignConsumerKey tx before spawn_time.  ","version":"v4.5.0","tagName":"h3"},{"title":"What happens to the standalone validator set after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#what-happens-to-the-standalone-validator-set-after-it-transitions-to-interchain-security","content":" The standalone chain validators will stop being validators after the first 3 blocks are created while using Interchain Security. The standalone validators will become governors and still can receive delegations if the consumer chain is using the consumer-democracy module.  Governors DO NOT VALIDATE BLOCKS.  Instead, they can participate in the governance process and take on other chain-specific roles.  ","version":"v4.5.0","tagName":"h3"},{"title":"Credits​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v4.5.0/validators/changeover-procedure#credits","content":" Thank you Stride team for providing detailed instructions about the changeover procedure. ","version":"v4.5.0","tagName":"h2"},{"title":"Joining Stride","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/validators/joining-stride","content":"","keywords":"","version":"v4.5.0"},{"title":"Note​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v4.5.0/validators/joining-stride#note","content":" Stride re-uses an existing transfer channel to send consumer rewards to the provider chain, in order to preserve existing transfer IBC denom between stride-1 and cosmoshub-4.  ","version":"v4.5.0","tagName":"h2"},{"title":"Resources​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v4.5.0/validators/joining-stride#resources","content":" Stride docsChangeover procedure timelineChangeover upgrade docs ","version":"v4.5.0","tagName":"h2"},{"title":"Joining Neutron","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/validators/joining-neutron","content":"","keywords":"","version":"v4.5.0"},{"title":"Resources​","type":1,"pageTitle":"Joining Neutron","url":"/interchain-security/v4.5.0/validators/joining-neutron#resources","content":" Neutron docs ","version":"v4.5.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/validators/overview","content":"","keywords":"","version":"v4.5.0"},{"title":"Startup sequence overview​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#startup-sequence-overview","content":" Consumer chains cannot start and be secured by the validator set of the provider unless a ConsumerAdditionProposal is passed. Each proposal contains defines a spawn_time - the timestamp when the consumer chain genesis is finalized and the consumer chain clients get initialized on the provider.  tip Validators are required to run consumer chain binaries only after spawn_time has passed.  Please note that any additional instructions pertaining to specific consumer chain launches will be available before spawn time. The chain start will be stewarded by the Cosmos Hub team and the teams developing their respective consumer chains.  The image below illustrates the startup sequence  ","version":"v4.5.0","tagName":"h2"},{"title":"1. Consumer Chain init + 2. Genesis generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#1-consumer-chain-init--2-genesis-generation","content":" Consumer chain team initializes the chain genesis.json and prepares binaries which will be listed in the ConsumerAdditionProposal  ","version":"v4.5.0","tagName":"h3"},{"title":"3. Submit Proposal​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#3-submit-proposal","content":" Consumer chain team (or their advocates) submits a ConsumerAdditionProposal. The most important parameters for validators are:  spawn_time - the time after which the consumer chain must be startedgenesis_hash - hash of the pre-ccv genesis.json; the file does not contain any validator info -&gt; the information is available only after the proposal is passed and spawn_time is reachedbinary_hash - hash of the consumer chain binary used to validate the software builds  ","version":"v4.5.0","tagName":"h3"},{"title":"4. CCV Genesis state generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#4-ccv-genesis-state-generation","content":" After reaching spawn_time the provider chain will automatically create the CCV validator states that will be used to populate the corresponding fields in the consumer chain genesis.json. The CCV validator set consists of the validator set on the provider at spawn_time.  The state can be queried on the provider chain (in this case the Cosmos Hub):   gaiad query provider consumer-genesis &lt;consumer chain ID&gt; -o json &gt; ccvconsumer_genesis.json   This is used by the launch coordinator to create the final genesis.json that will be distributed to validators in step 5.  ","version":"v4.5.0","tagName":"h3"},{"title":"5. Updating the genesis file​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#5-updating-the-genesis-file","content":" Upon reaching the spawn_time the initial validator set state will become available on the provider chain. The initial validator set is included in the final genesis.json of the consumer chain.  ","version":"v4.5.0","tagName":"h3"},{"title":"6. Chain start​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#6-chain-start","content":" info The consumer chain will start producing blocks as soon as 66.67% of the provider chain's voting power comes online (on the consumer chain). The relayer should be started after block production commences.  The new genesis.json containing the initial validator set will be distributed to validators by the consumer chain team (launch coordinator). Each validator should use the provided genesis.json to start their consumer chain node.  tip Please pay attention to any onboarding repositories provided by the consumer chain teams. Recommendations are available in Consumer Onboarding Checklist. Another comprehensive guide is available in the Interchain Security testnet repo.  ","version":"v4.5.0","tagName":"h3"},{"title":"7. Creating IBC connections​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#7-creating-ibc-connections","content":" Finally, to fully establish interchain security an IBC relayer is used to establish connections and create the required channels.  warning The relayer can establish the connection only after the consumer chain starts producing blocks.  hermes create connection --a-chain &lt;consumer chain ID&gt; --a-client 07-tendermint-0 --b-client &lt;client assigned by provider chain&gt; hermes create channel --a-chain &lt;consumer chain ID&gt; --a-port consumer --b-port provider --order ordered --a-connection connection-0 --channel-version 1 hermes start   ","version":"v4.5.0","tagName":"h3"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#downtime-infractions","content":" At present, the consumer chain can report evidence about downtime infractions to the provider chain. The min_signed_per_window and signed_blocks_window can be different on each consumer chain and are subject to changes via consumer chain governance.  info Causing a downtime infraction on any consumer chain will not incur a slash penalty. Instead, the offending validator will be jailed on the provider chain and consequently on all consumer chains. To unjail, the validator must wait for the jailing period to elapse on the provider chain and submit an unjail transaction on the provider chain. After unjailing on the provider, the validator will be unjailed on all consumer chains. More information is available in Downtime Slashing documentation  ","version":"v4.5.0","tagName":"h2"},{"title":"Double-signing Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#double-signing-infractions","content":" To learn more about equivocation handling in interchain security check out the Slashing documentation section.  ","version":"v4.5.0","tagName":"h2"},{"title":"Key assignment​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#key-assignment","content":" Validators can use different consensus keys on the provider and each of the consumer chains. The consumer chain consensus key must be registered on the provider before use.  For more information check out the Key assignment overview and guide  ","version":"v4.5.0","tagName":"h2"},{"title":"References:​","type":1,"pageTitle":"Overview","url":"/interchain-security/v4.5.0/validators/overview#references","content":" Cosmos Hub Validators FAQCosmos Hub Running a validatorStartup SequenceSubmit Unjailing Transaction ","version":"v4.5.0","tagName":"h2"},{"title":"Consumer Initiated Slashing","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/features/slashing","content":"","keywords":"","version":"v4.5.0"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v4.5.0/features/slashing#downtime-infractions","content":" Downtime infractions are reported by consumer chains and are acted upon on the provider as soon as the provider receives the infraction evidence.  Instead of slashing, the provider will only jail offending validator for the duration of time established by the chain parameters.  info Slash throttling (sometimes called jail throttling) mechanism ensures that only a fraction of the validator set can be jailed at any one time to prevent malicious consumer chains from harming the provider.  Note that validators are only jailed for downtime on consumer chains that they opted-in to validate on, or in the case of Top N chains, where they are automatically opted in by being in the Top N% of the validator set on the provider.  ","version":"v4.5.0","tagName":"h2"},{"title":"Equivocation Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v4.5.0/features/slashing#equivocation-infractions","content":" Equivocation infractions are reported by external agents (e.g., relayers) that can submit to the provider evidence of light client or double signing attacks observed on a consumer chain. The evidence is submitted by sending MsgSubmitConsumerMisbehaviour or MsgSubmitConsumerDoubleVoting transactions to the provider. When valid evidence is received, the malicious validators are slashed, jailed, and tombstoned on the provider. This is enabled through the cryptographic verification of equivocation feature. For more details, see ADR-005 and ADR-013.  ","version":"v4.5.0","tagName":"h2"},{"title":"Report equivocation infractions through CLI​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v4.5.0/features/slashing#report-equivocation-infractions-through-cli","content":" The ICS provider module offers two commands for submitting evidence of misbehavior originating from a consumer chain. Below are two examples illustrating the process on Cosmos Hub.  Use the following command to submit evidence of double signing attacks:  gaiad tx provider submit-consumer-double-voting [path/to/evidence.json] [path/to/infraction_header.json] --from node0 --home ../node0 --chain-id $CID   Example of evidence.json { &quot;vote_a&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;tBBWTqjECl31S/clZGoxLdDqs93kTvy3qhpPqET/laY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;ai2qCLgVZAFph4FJ4Cqw5QW1GZKR4zjOv0bI/Um5AIc=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.565207Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;signature&quot;: &quot;y9yILm9hmv45BZwAaaq9mS1FpH7QeAIJ5Jkcc3U2/k5uks9cuqr4NTIwaIrqMSMKwxVyqiR56xmCT59a6AngAA==&quot; }, &quot;vote_b&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;3P06pszgPatuIdLTP5fDWiase4SYHIq9YXGSbRk9/50=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;S+SbOMxFRzfeNNpX9/jyFMz94VwBKk7Dpx6ZyvSYyNU=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.599273Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;validator_index&quot;: 0, &quot;signature&quot;: &quot;DGFcn4Um1t2kXW60+JhMk5cj7ZFdE5goKVOGiZkLwnNv43+6aGmOWjoq0SHYVzM4MwSwOwbhgZNbkWX+EHGUBw==&quot; }, &quot;total_voting_power&quot;: 300, &quot;validator_power&quot;: 100, &quot;timestamp&quot;: &quot;2023-11-20T12:57:51.267308Z&quot; }   Example of infraction_header.json { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: 11, &quot;app&quot;: 2 }, &quot;chain_id&quot;: &quot;consumer&quot;, &quot;height&quot;: 22, &quot;time&quot;: &quot;2023-11-20T12:57:40.479686Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;L63hyLJ+y9+fpb7WYKdmmBhPHwbfEGQEuKmvGzyBPiY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 18, &quot;hash&quot;: &quot;euzRQjN7MjGtM6skXM4B8wOgAldWGfZSJRA9JRlO42s=&quot; } }, &quot;last_commit_hash&quot;: &quot;qdDJwVziW3pPqmf8QDGZG+5HVd3OF7fCVh2Z8KQqNVU=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;next_validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;last_results_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: 22, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;PKrS32IEZoFY2q2S3iQ68HQL751ieBhf5Eu/Y5Z/QPg=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;8UuA7Oqw5AH/KOacpmHVSMOIDe4l2eC8VmdH2mzcpiM=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076538Z&quot;, &quot;signature&quot;: &quot;bSOH4+Vg2I37zeJphOguGOD0GK3JzM1ghSgJd0UlW/DHn1u9Hvv4EekHuCu6qwRLZcuS/ZxNlmr9qYNfxX3bDA==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:07:00Z&quot;, &quot;signature&quot;: &quot;7bXSDtlOwGK/gLEsFpTWOzm2TFoaARrWQUpbgWEwKtLlUs7iE06TOvJ3yPPfTfqqN/qYnvxxgjl0M0EhUWu5Bg==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076519Z&quot;, &quot;signature&quot;: &quot;Pb6G4bCg4wafmV89WNnzXxbSCknZUHnSQfSCE5QMFxPtSUIN4A7SK5m7yltqMJF5zkyenlFiEI4J3OZ4KCjCAw==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.057451Z&quot;, &quot;signature&quot;: &quot;j3EasIHNYA6MxW/PiWyruzHsjVsBV9t11W6Qx800WMm/+P+CkfR+UZAp7MPTvKZEZFuh3GUsBtyfb/vA+jJWCw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 }, { &quot;address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;UgN2JsjPy2WLh7dzJRBkUQtdgNoT4/uGj7kbIVqqHT8=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;5svW8261x+cZosp2xIhqzgt2tyuawrSDyHlpbgS3BC4=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } }, &quot;trusted_height&quot;: { &quot;revision_height&quot;: 18 }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 }, { &quot;address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;FCmIw7hSuiAoWk/2f4LuGQ+3zx5101xiqU8DoC5wGkg=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;2DrZF0roNnnvEy4NS2aY811ncKg=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;MI9c6sphsWlx0RAHCYOjMRXMFkTUaEYwOiOKG/0tsMs=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;73aN0uOc5b/Zfq2Xcjl0kH2r+tw=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;gWNcDup4mdnsuqET4QeFRzVb+FnSP4Vz3iNMj5wvWXk=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } } }   Use the following command to submit evidence of light client attacks:  gaiad tx provider submit-consumer-misbehaviour [path/to/misbehaviour.json] --from node0 --home ../node0 --chain-id $CID   Example of misbehaviour.json { &quot;client_id&quot;: &quot;07-tendermint-0&quot;, &quot;header_1&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;W2xVqzPw03ZQ1kAMpcpht9WohwMzsGnyKKNjPYKDF6U=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;PGTquCtnTNFFY5HfEFz9f9pA7PYqjtQfBwHq6cxF/Ux8OI6nVqyadD9a84Xm7fSm6mqdW+T6YVfqIKmIoRjJDQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;0e39yoBorwORAH/K9qJ7D1N1Yr7CutMiQJ+oiIK39eMhuoK3UWzQyMGRLzDOIDupf8yD99mvGVVAlNIODlV3Dg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;lhc2tkwydag9D1iLQhdDCE8GgrHP94M1LbHFYMoL9tExaEq6RiFW/k71TQH5x96XQ9XYOznMIHKC2BDh4GlnAQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;8xeSBf0nSFs/X/rQ9CZLzwkJJhQBLA2jKdPGP3MlULxm992XxrOsIYq47u1daxvSsn6ql5OVYjzBNU0qbPpvCA==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } }, &quot;header_2&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;IZM8NKS+8FHB7CBmgB8Nz7BRVVXiiyqMQDvHFUvgzxo=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;pLIEZ4WSAtnMsgryujheHSq4+YG3RqTfMn2ZxgEymr0wyi+BNlQAKRtRfesm0vfYxvjzc/jhGqtUqHtSIaCwCQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;XG7iTe/spWyTUkT7XDzfLMpYqrdyqizE4/X4wl/W+1eaQp0WsCHYnvPU3x9NAnYfZzaKdonZiDWs7wacbZTcDg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;TqegK7ORuICSy++wVdPHt8fL2WfPlYsMPv1XW79wUdcjnQkezOM50OSqYaP4ua5frIZsn+sWteDrlqFTdkl3BA==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;dhvp3XlIaCxx5MFDs0TCkAPHSm0PS2EtJzYAx2c/7MWdLwUJFZrAUTeimQE2c9i9ro91cjZn/vI0/oFRXab6Aw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } } }   ","version":"v4.5.0","tagName":"h3"},{"title":"Report equivocation infractions with Hermes​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v4.5.0/features/slashing#report-equivocation-infractions-with-hermes","content":" Ensure you have a well-configured Hermes v1.7.3+ relayer effectively relaying packets between a consumer chain and a provider chain. The following command demonstrates how to run a Hermes instance in evidence mode to detect misbehaviors on a consumer chain and automatically submit the evidence to the provider chain.  hermes evidence --chain &lt;CONSUMER-CHAIN-ID&gt;   tip hermes evidence takes a --check-past-blocks option giving the possibility to look for older evidence (default is 100). ","version":"v4.5.0","tagName":"h3"},{"title":"Joining Interchain Security testnet","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/validators/joining-testnet","content":"","keywords":"","version":"v4.5.0"},{"title":"Introduction​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v4.5.0/validators/joining-testnet#introduction","content":" This short guide will teach you how to join the Interchain Security testnet.  The experience gained in the testnet will prepare you for validating interchain secured chains.  tip Provider and consumer chain represent distinct networks and infrastructures operated by the same validator set. For general information about running cosmos-sdk based chains check out the validator basics and Running a Node section of Cosmos SDK docs  ","version":"v4.5.0","tagName":"h2"},{"title":"Joining the provider chain​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v4.5.0/validators/joining-testnet#joining-the-provider-chain","content":" info At present, all validators of the provider chain must also validate all governance approved consumer chains. The consumer chains cannot have a validator set different than the provider, which means they cannot introduce validators that are not also validating the provider chain.  A comprehensive guide is available here.  ","version":"v4.5.0","tagName":"h2"},{"title":"Initialization​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v4.5.0/validators/joining-testnet#initialization","content":" First, initialize your $NODE_HOME using the provider chain binary.  NODE_MONIKER=&lt;your_node&gt; CHAIN_ID=provider NODE_HOME=&lt;path_to_your_home&gt; gaiad init $NODE_MONIKER --chain-id $CHAIN_ID --home $NODE_HOME   Add your key to the keyring - more details available here.  In this example we will use the test keyring-backend. This option is not safe to use in production.  gaiad keys add &lt;key_moniker&gt; --keyring-backend test # save the address as variable for later use MY_VALIDATOR_ADDRESS=$(gaiad keys show my_validator -a --keyring-backend test)   Before issuing any transactions, use the provider testnet faucet to add funds to your address.  curl https://faucet.rs-testnet.polypore.xyz/request?address=$MY_VALIDATOR_ADDRESS&amp;chain=provider # example output: { &quot;address&quot;: &quot;cosmos17p3erf5gv2436fd4vyjwmudakts563a497syuz&quot;, &quot;amount&quot;: &quot;10000000uatom&quot;, &quot;chain&quot;: &quot;provider&quot;, &quot;hash&quot;: &quot;10BFEC53C80C9B649B66549FD88A0B6BCF09E8FCE468A73B4C4243422E724985&quot;, &quot;status&quot;: &quot;success&quot; }   Then, use the account associated with the keyring to issue a create-validator transaction which will register your validator on chain.  gaiad tx staking create-validator \\ --amount=1000000uatom \\ --pubkey=$(gaiad tendermint show-validator) \\ --moniker=&quot;choose a moniker&quot; \\ --chain-id=$CHAIN_ID&quot; \\ --commission-rate=&quot;0.10&quot; \\ --commission-max-rate=&quot;0.20&quot; \\ --commission-max-change-rate=&quot;0.01&quot; \\ --min-self-delegation=&quot;1000000&quot; \\ --gas=&quot;auto&quot; \\ --gas-prices=&quot;0.0025uatom&quot; \\ --from=&lt;key_moniker&gt;   tip Check this guide to edit your validator.  After this step, your validator is created and you can start your node and catch up to the rest of the network. It is recommended that you use statesync to catch up to the rest of the network.  You can use this script to modify your config.toml with the required statesync parameters.  # create the statesync script $: cd $NODE_HOME $: touch statesync.sh $ chmod 700 statesync.sh # make executable   Paste the following instructions into the statesync.sh:  #!/bin/bash SNAP_RPC=&quot;https://rpc.provider-state-sync-01.rs-testnet.polypore.xyz:443&quot; LATEST_HEIGHT=$(curl -s $SNAP_RPC/block | jq -r .result.block.header.height); \\ BLOCK_HEIGHT=$((LATEST_HEIGHT - 2000)); \\ TRUST_HASH=$(curl -s &quot;$SNAP_RPC/block?height=$BLOCK_HEIGHT&quot; | jq -r .result.block_id.hash) sed -i.bak -E &quot;s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1true| ; \\ s|^(rpc_servers[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$SNAP_RPC,$SNAP_RPC\\&quot;| ; \\ s|^(trust_height[[:space:]]+=[[:space:]]+).*$|\\1$BLOCK_HEIGHT| ; \\ s|^(trust_hash[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$TRUST_HASH\\&quot;|&quot; $NODE_HOME/config/config.toml   Then, you can execute the script:  $: ./statesync.sh # setup config.toml for statesync   Finally, copy the provider genesis and start your node:  $: GENESIS_URL=https://github.com/cosmos/testnets/raw/master/interchain-security/provider/provider-genesis.json $: wget $GENESIS_URL -O genesis.json $: genesis.json $NODE_HOME/config/genesis.json # start the service $: gaiad start --x-crisis-skip-assert-invariants --home $NODE_HOME --p2p.seeds=&quot;08ec17e86dac67b9da70deb20177655495a55407@provider-seed-01.rs-testnet.polypore.xyz:26656,4ea6e56300a2f37b90e58de5ee27d1c9065cf871@provider-seed-02.rs-testnet.polypore.xyz:26656&quot;   Additional scripts to setup your nodes are available here and here. The scripts will configure your node and create the required services - the scripts only work in linux environments.  ","version":"v4.5.0","tagName":"h2"},{"title":"Joining consumer chains​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v4.5.0/validators/joining-testnet#joining-consumer-chains","content":" tip Once you reach the active set on the provider chain, you will be required to validate all available consumer chains. We strongly recommend that you assign a separate key for each consumer chain. Check out this guide to learn more about key assignment in interchain security.  To join consumer chains, simply replicate the steps above for each consumer using the correct consumer chain binaries.  info When running the provider chain and consumers on the same machine please update the PORT numbers for each of them and make sure they do not overlap (otherwise the binaries will not start). Important ports to re-configure: --rpc.laddr--p2p.laddr--api.address--grpc.address--grpc-web.address  ","version":"v4.5.0","tagName":"h2"},{"title":"Re-using consensus key​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v4.5.0/validators/joining-testnet#re-using-consensus-key","content":" To reuse the key on the provider and consumer chains, simply initialize your consumer chain and place the priv_validator_key.json into the home directory of your consumer chain (&lt;consumer_home&gt;/config/priv_validator_key.json).  When you start the chain, the consensus key will be the same on the provider and the consumer chain.  ","version":"v4.5.0","tagName":"h2"},{"title":"Assigning consensus keys​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v4.5.0/validators/joining-testnet#assigning-consensus-keys","content":" Whenever you initialize a new node, it will be configured with a consensus key you can use.  # machine running consumer chain consumerd init &lt;node_moniker&gt; --home &lt;home_path&gt; --chain-id consumer-1 # use the output of this command to get the consumer chain consensus key consumerd tendermint show-validator # output: {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, let the provider know which key you will be using for the consumer chain:  # machine running the provider chain gaiad tx provider assign-consensus-key consumer-1 '&lt;consumer_pubkey&gt;' --from &lt;key_moniker&gt; --home $NODE_HOME --gas 900000 -b sync -y -o json   After this step, you are ready to copy the consumer genesis into your nodes's /config folder, start your consumer chain node and catch up to the network. ","version":"v4.5.0","tagName":"h2"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators","content":"","keywords":"","version":"v4.5.0"},{"title":"Messages​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#messages","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"How to opt in to a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#how-to-opt-in-to-a-consumer-chain","content":" warning A validator is automatically opted in to a Top N chain if the validator belongs to the top N% of the validators on the provider chain.  In a Top N chain, a validator that does not belong to the top N% of the validators on the provider can still choose to opt in to a consumer chain. In other words, validators can opt in, in both Opt-In and Top N chains.  A validator can opt in to a consumer chain by issuing the following message:  interchain-security-pd tx provider opt-in &lt;consumer-chain-id&gt; &lt;optional consumer-pub-key&gt;   where  consumer-chain-id is the string identifier of the consumer chain the validator wants to opt in to;consumer-pub-key corresponds to the public key the validator wants to use on the consumer chain, and it has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}.  A validator can opt in to an existing consumer chain that is already running, or to a proposedconsumer chain that is still being voted on. A validator can use the following command to retrieve the currently existing consumer chains:  interchain-security-pd query provider list-consumer-chains   and this command to see the currently proposed consumer chains:  interchain-security-pd query provider list-proposed-consumer-chains   tip By setting the consumer-pub-key, a validator can both opt in to a chain and assign a public key on a consumer chain. Note that a validator can always assigna new consumer key at a later stage. The key-assignment rulesstill apply when setting consumer-pub-key when opting in.  info A validator is only eligible for consumer rewards from a consumer chain if the validator is opted into that chain.  ","version":"v4.5.0","tagName":"h3"},{"title":"How to opt out from a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#how-to-opt-out-from-a-consumer-chain","content":" A validator can opt out from a consumer by issuing the following message:  interchain-security-pd tx provider opt-out &lt;consumer-chain-id&gt;   where  consumer-chain-id is the string identifier of the consumer chain.  warning A validator cannot opt out from a Top N chain if it belongs to the top N% validators of the provider.  warning If a validator moves from the Top N to outside of the top N% of the validators on the provider, it will notbe automatically opted-out. The validator has to manually opt out.  warning A validator can stop its node on a consumer chain only after opting out and confirming through the has-to-validatequery (see below) that it does not have to validate the consumer chain any longer.  warning If all validators opt out from an Opt-In chain, the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"v4.5.0","tagName":"h3"},{"title":"How to set specific per consumer chain commission rate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#how-to-set-specific-per-consumer-chain-commission-rate","content":" A validator can choose to set a different commission rate on each of the consumer chains. This can be done with the following command:  interchain-security-pd tx provider set-consumer-commission-rate &lt;consumer-chain-id&gt; &lt;commission-rate&gt;   where  consumer-chain-id is the string identifier of the consumer chain;comission-rate decimal in [minRate, 1] where minRate corresponds to the minimum commission rate set on the provider chain (see min_commission_rate in interchain-security-pd query staking params).  If a validator does not set a commission rate on a consumer chain, the commission rate defaults to their commission rate on the provider chain.  tip Validators can set their commission rate even for consumer chains that they are not currently opted in on, and the commission rate will be applied when they opt in. This is particularly useful for Top N chains, where validators might be opted in automatically, so validators can set the commission rate in advance.  tip If a validator opts out and then back in, this will not reset their commission rate back to the default. Instead, their set commission rate still applies.  ","version":"v4.5.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#queries","content":" Partial Set Security introduces a number of queries to assist validators determine which consumer chains they have to validate, their commission rate per chain, etc.  ","version":"v4.5.0","tagName":"h2"},{"title":"Which chains does a validator have to validate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#which-chains-does-a-validator-have-to-validate","content":" Naturally, a validator is aware of the Opt-In chains it has to validate because in order to validate an Opt-In chain, a validator has to manually opt in to the chain. This is not the case for Top N chains where a validator might be required to validate such a chain without explicitly opting in if it belongs to the top N% of the validators on the provider.  We introduce the following query:  interchain-security-pd query provider has-to-validate &lt;provider-validator-address&gt;   that can be used by validator with provider-validator-address address to retrieve the list of chains that it has to validate.  tip As a validator, the list of chains returned by has-to-validate is the list of chains you should be validating to avoid getting jailed for downtime.  ","version":"v4.5.0","tagName":"h3"},{"title":"How do you know how much voting power you need to have to be in the top N for a chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#how-do-you-know-how-much-voting-power-you-need-to-have-to-be-in-the-top-n-for-a-chain","content":" This can be seen as part of the list-consumer-chains query:  interchain-security-pd query provider list-consumer-chains   where the min_power_in_top_N field shows the minimum voting power required to be automatically opted in to the chain.  tip list-consumer-chains shows the minimal voting power right now, but the automatic opt-in happens only when epochs end on the provider. In consequence, a validators power might be large enough to be automatically opted in during an epoch, but if their power is sufficiently decreased before the epoch ends, they will not be opted in automatically.  ","version":"v4.5.0","tagName":"h3"},{"title":"How to retrieve all the opted-in validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-opted-in-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-opted-in-validators &lt;consumer-chain-id&gt;   we can see all the opted-in validators on consumer-chain-id that were manually or automatically opted in.  ","version":"v4.5.0","tagName":"h3"},{"title":"How to retrieve all the consumer validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-consumer-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-validators &lt;consumer-chain-id&gt;   we can see all the consumer validators (i.e., validator set) of consumer-chain-id. The consumer validators are the ones that are currently (or in the future, see warning) validating the consumer chain. A consumer validator is an opted-in validator but not vice versa. For example, an opted-in validator V might not be a consumer validator because V is denylisted or because V is removed due to a validator-set cap.  warning The returned consumer validators from this query do not necessarily correspond to the validator set that is validating the consumer chain at this exact moment. This is because the VSCPacket sent to a consumer chain might be delayed and hence this query might return the validator set that the consumer chain would have at some future point in time.  ","version":"v4.5.0","tagName":"h3"},{"title":"How can we see the commission rate a validator has set on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v4.5.0/validators/partial-set-security-for-validators#how-can-we-see-the-commission-rate-a-validator-has-set-on-a-consumer-chain","content":" Using the following query:  interchain-security-pd query provider validator-consumer-commission-rate &lt;consumer-chain-id&gt; &lt;provider-validator-address&gt;   we retrieve the commission rate set by validator with provider-validator-address address on consumer-chain-id. ","version":"v4.5.0","tagName":"h3"},{"title":"Consumer chain validator rewards","type":0,"sectionRef":"#","url":"/interchain-security/v4.5.0/validators/withdraw_rewards","content":"","keywords":"","version":"v4.5.0"},{"title":"Withdrawing rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v4.5.0/validators/withdraw_rewards#withdrawing-rewards","content":" Here are example steps for withdrawing rewards from consumer chains in the provider chain  info The examples used are from rs-testnet, the Interchain Security persistent testnet. Validator operator address: cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6Self-delegation address: cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf  Prior to withdrawing rewards, query balances for self-delegation address:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;1000000000000&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;   ","version":"v4.5.0","tagName":"h2"},{"title":"Querying validator rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v4.5.0/validators/withdraw_rewards#querying-validator-rewards","content":" Query rewards for the validator address:  gaiad q distribution rewards cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 rewards: - amount: &quot;158.069895000000000000&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;841842390516.072526500000000000&quot; denom: uatom   The ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD denom represents rewards from a consumer chain.  ","version":"v4.5.0","tagName":"h2"},{"title":"Withdrawing rewards and commission​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v4.5.0/validators/withdraw_rewards#withdrawing-rewards-and-commission","content":" ","version":"v4.5.0","tagName":"h2"},{"title":"1. Withdraw rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v4.5.0/validators/withdraw_rewards#1-withdraw-rewards","content":" gaiad tx distribution withdraw-rewards cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 --from cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf --commission --chain-id provider --gas auto --fees 500uatom -b block -y txhash: A7E384FB1958211B43B7C06527FC7D4471FB6B491EE56FDEA9C5634D76FF1B9A   ","version":"v4.5.0","tagName":"h3"},{"title":"2. Confirm withdrawal​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v4.5.0/validators/withdraw_rewards#2-confirm-withdrawal","content":" After withdrawing rewards self-delegation address balance to confirm rewards were withdrawn:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;216&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;2233766225342&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;  ","version":"v4.5.0","tagName":"h3"},{"title":"Interchain Security Docs","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0","content":"Interchain Security Docs Welcome to the official Interchain Security module documentation for Cosmos-SDK based chains. Here you can find information about Interchain Security, consumer chain development and instructions for validator onboarding. Basic Concepts Get started with the basic concepts and ideas. FAQ Frequently asked questions about the protocol and its implications Start Building Click here to start building with Interchain Security Onboarding Checklist Checklist to help you integrate Interchain Security, get support and onboard validators Become an ICS Validator Start validating on consumer chains Assign Consumer Keys Learn how to assign separate key on the consumer chains","keywords":"","version":"v5.2.0"},{"title":"ADR 001: Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#changelog","content":" 2022-12-01: Initial Draft2024-03-01: Updated to take into account they key-assigment-replacement deprecation.  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#status","content":" Accepted  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#context","content":" KeyAssignment is the name of the feature that allows validator operators to use different consensus keys for each consumer chain validator node that they operate.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#decision","content":" It is possible to change the keys at any time by submitting a transaction (i.e., MsgAssignConsumerKey).  ","version":"v5.2.0","tagName":"h2"},{"title":"State required​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#state-required","content":" ValidatorConsumerPubKey - Stores the validator assigned keys for every consumer chain.  ConsumerValidatorsBytePrefix | len(chainID) | chainID | providerConsAddress -&gt; consumerKey   ValidatorByConsumerAddr - Stores the mapping from validator addresses on consumer chains to validator addresses on the provider chain. Needed for the consumer initiated slashing sub-protocol.  ValidatorsByConsumerAddrBytePrefix | len(chainID) | chainID | consumerConsAddress -&gt; providerConsAddress   ConsumerAddrsToPrune - Stores the mapping from VSC ids to consumer validators addresses. Needed for pruning ValidatorByConsumerAddr.  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; []consumerConsAddresses   ","version":"v5.2.0","tagName":"h3"},{"title":"Protocol overview​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#protocol-overview","content":" On receiving a MsgAssignConsumerKey(chainID, providerAddr, consumerKey) message:  // get validator from staking module validator, found := stakingKeeper.GetValidator(providerAddr) if !found { return ErrNoValidatorFound } providerConsAddr := validator.GetConsAddr() // make sure consumer key is not in use consumerAddr := utils.TMCryptoPublicKeyToConsAddr(consumerKey) if _, found := GetValidatorByConsumerAddr(ChainID, consumerAddr); found { return ErrInvalidConsumerConsensusPubKey } // check whether the consumer chain is already registered // i.e., a client to the consumer was already created if _, consumerRegistered := GetConsumerClientId(chainID); consumerRegistered { // get the previous key assigned for this validator on this consumer chain oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr) if found { // mark this old consumer key as prunable once the VSCMaturedPacket // for the current VSC ID is received oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) vscID := GetValidatorSetUpdateId() AppendConsumerAddrsToPrune(chainID, vscID, oldConsumerAddr) } } else { // if the consumer chain is not registered, then remove the previous reverse mapping if oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr); found { oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) DeleteValidatorByConsumerAddr(chainID, oldConsumerAddr) } } // set the mapping from this validator's provider address to the new consumer key SetValidatorConsumerPubKey(chainID, providerConsAddr, consumerKey) // set the reverse mapping: from this validator's new consensus address // on the consumer to its consensus address on the provider SetValidatorByConsumerAddr(chainID, consumerAddr, providerConsAddr)   When a new consumer chain is registered, i.e., a client to the consumer chain is created, the provider constructs the consumer CCV module part of the genesis state (see MakeConsumerGenesis).  func (k Keeper) MakeConsumerGenesis(chainID string) (gen consumertypes.GenesisState, nextValidatorsHash []byte, err error) { // ... // get initial valset from the staking module var updates []abci.ValidatorUpdate{} stakingKeeper.IterateLastValidatorPowers(func(providerAddr sdk.ValAddress, power int64) (stop bool) { validator := stakingKeeper.GetValidator(providerAddr) providerKey := validator.TmConsPublicKey() updates = append(updates, abci.ValidatorUpdate{PubKey: providerKey, Power: power}) return false }) // applies the key assignment to the initial validator for i, update := range updates { providerAddr := utils.TMCryptoPublicKeyToConsAddr(update.PubKey) if consumerKey, found := GetValidatorConsumerPubKey(chainID, providerAddr); found { updates[i].PubKey = consumerKey } } gen.InitialValSet = updates // get a hash of the consumer validator set from the update updatesAsValSet := tendermint.PB2TM.ValidatorUpdates(updates) hash := tendermint.NewValidatorSet(updatesAsValSet).Hash() return gen, hash, nil }   Note that key assignment works hand-in-hand with epochs. For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. Specifically, for each validator in the set we store among others, the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacketwith all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   where DiffValidators internally checks if the consumer public key for a validator has changed since the last epoch and if so generates a validator update. This way, a validator can change its consumer public key for a consumer chain an arbitrary amount of times and only the last set consumer public key would be taken into account.  On receiving a SlashPacket from a consumer chain with id chainID for a infraction of a validator data.Validator:  func HandleSlashPacket(chainID string, data ccv.SlashPacketData) (success bool, err error) { // ... // the slash packet validator address may be known only on the consumer chain; // in this case, it must be mapped back to the consensus address on the provider chain consumerAddr := sdk.ConsAddress(data.Validator.Address) providerAddr, found := GetValidatorByConsumerAddr(chainID, consumerAddr) if !found { // the validator has the same key on the consumer as on the provider providerAddr = consumerAddr } // ... }   On receiving a VSCMatured:  func OnRecvVSCMaturedPacket(packet channeltypes.Packet, data ccv.VSCMaturedPacketData) exported.Acknowledgement { // ... // prune previous consumer validator address that are no longer needed consumerAddrs := GetConsumerAddrsToPrune(chainID, data.ValsetUpdateId) for _, addr := range consumerAddrs { DeleteValidatorByConsumerAddr(chainID, addr) } DeleteConsumerAddrsToPrune(chainID, data.ValsetUpdateId) // ... }   On stopping a consumer chain:  func (k Keeper) StopConsumerChain(ctx sdk.Context, chainID string, closeChan bool) (err error) { // ... // deletes all the state needed for key assignments on this consumer chain // ... }   ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#positive","content":" Validators can use different consensus keys on the consumer chains.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#negative","content":" None  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#neutral","content":" The consensus state necessary to create a client to the consumer chain must use the hash returned by the MakeConsumerGenesis method as the nextValsHash.The consumer chain can no longer check the initial validator set against the consensus state on InitGenesis.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v5.2.0/adrs/adr-001-key-assignment#references","content":" Key assignment issue ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 003: Equivocation governance proposal","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal#changelog","content":" 2023-02-06: Initial draft2023-11-30: Change status to deprecated  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal#status","content":" Deprecated  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal#context","content":" Note: ADR deprecated as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  We want to limit the possibilities of a consumer chain to execute actions on the provider chain to maintain and ensure optimum security of the provider chain.  For instance, a malicious consumer consumer chain can send slash packet to the provider chain, which will slash a validator without the need of providing an evidence.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal#decision","content":" To protect against a malicious consumer chain, slash packets unrelated to downtime are ignored by the provider chain. Thus, an other mechanism is required to punish validators that have committed a double-sign on a consumer chain.  A new kind of governance proposal is added to the provider module, allowing to slash and tombstone a validator for double-signing in case of any harmful action on the consumer chain.  If such proposal passes, the proposal handler delegates to the evidence module to process the equivocation. This module ensures the evidence isn’t too old, or else ignores it (see code). Too old is determined by 2 consensus params :  evidence.max_age_duration number of nanoseconds before an evidence is considered too oldevidence.max_age_numblocks number of blocks before an evidence is considered too old.  On the hub, those parameters are equals to  // From https://cosmos-rpc.polkachu.com/consensus_params?height=13909682 (...) &quot;evidence&quot;: { &quot;max_age_num_blocks&quot;: &quot;1000000&quot;, &quot;max_age_duration&quot;: &quot;172800000000000&quot;, (...) }, (...)   A governance proposal takes 14 days, so those parameters must be big enough so the evidence provided in the proposal is not ignored by the evidence module when the proposal passes and is handled by the hub.  For max_age_num_blocks=1M, the parameter is big enough if we consider the hub produces 12k blocks per day (blocks_per_year/365 = 436,0000/365). The evidence can be up to 83 days old (1,000,000/12,000) and not be ignored.  For max_age_duration=172,800,000,000,000, the parameter is too low, because the value is in nanoseconds so it’s 2 days. Fortunately the condition that checks those 2 parameters uses a AND, so if max_age_num_blocks condition passes, the evidence won’t be ignored.  ","version":"v5.2.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal#positive","content":" Remove the possibility from a malicious consumer chain to “attack” the provider chain by slashing/jailing validators.Provide a more acceptable implementation for the validator community.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal#negative","content":" Punishment action of double-signing isn’t “automated”, a governance proposal is required which takes more time.You need to pay 250ATOM to submit an equivocation evidence.  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal#neutral","content":" ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v5.2.0/adrs/adr-003-equivocation-gov-proposal#references","content":" PR that ignores non downtime slash packet : https://github.com/cosmos/interchain-security/pull/692PR that adds the governance slash proposal: https://github.com/cosmos/interchain-security/pull/703 ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 004: Denom DOS fixes","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes#changelog","content":" 5/9/2023: ADR created  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes#status","content":" Accepted  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes#context","content":" The provider and consumer modules are vulnerable to similar issues involving an attacker sending millions of denoms to certain addresses and causing the chain to halt. This ADR outlines both fixes since they are similar. Both fixes involve processing only denoms that are on a whitelist to avoid iterating over millions of junk denoms but have different requirements and are implemented in different ways.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes#decision","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Provider​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes#provider","content":" Put the distribution module's FeePoolAddress back on the blocklist so that it cannot receive funds from users.Create a new address called ConsumerRewardPool and unblock it, allowing funds to be sent to it.Create a set of strings in the store for allowed ConsumerRewardDenoms.Create an endpoint called RegisterConsumerRewardDenom which deducts a fee from the sender's account, sends it to the community pool and adds a string to the ConsumerRewardDenoms set.Create a parameter called ConsumerRewardDenomRegistrationFee which determines the fee which is charged to register a consumer reward denom in the step above.Create a function called TransferRewardsToFeeCollector which gets the entire ConsumerRewardDenoms set from the store, iterates over it, and for each entry: Gets the balance of this denom for the ConsumerRewardPool accountSends the entire balance out to the FeePoolAddress using SendCoinsFromModuleToModule which is not affected by the blocklist. Run TransferRewardsToFeeCollector in the endblock  Now, nobody can send millions of junk denoms to the FeePoolAddress because it is on the block list. If they send millions of junk denoms to the ConsumerRewardPool, this does not matter because all balances are not iterated over, only those which are in the ConsumerRewardDenoms set.  We also add a new tx: register-consumer-reward-denom, and a new query: registered-consumer-reward-denoms  ","version":"v5.2.0","tagName":"h3"},{"title":"Consumer​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes#consumer","content":" Create a new param RewardDenoms with a list of stringsCreate a new param ProviderRewardDenoms with a list of stringsCreate a function AllowedRewardDenoms which iterates over ProviderRewardDenoms and converts each denom to its ibc-prefixed denom using the provider chain's ibc channel information, then concatenates the RewardDenoms list and returns the combined list of allowed denoms.In SendRewardsToProvider, instead of iterating over the balances of all denoms in the ToSendToProvider address, iterate over AllowedRewardDenoms  Now, if somebody sends millions of junk denoms to ToSendToProvider, they will not be iterated over. Only the RewardDenoms and ProviderRewardDenoms will be iterated over. Since we do not require this feature to be permissionless on the consumer, the registration fee process is not needed.  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes#positive","content":" Denom DOS is no longer possible on either provider or consumer.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v5.2.0/adrs/adr-004-denom-dos-fixes#negative","content":" Consumer chain teams must pay a fee to register a denom for distribution on the provider, and add some extra parameters in their genesis file. ","version":"v5.2.0","tagName":"h3"},{"title":"ADR 007: Pause validator unbonding during equivocation proposal","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#changelog","content":" 2023-05-16: Initial Draft2023-11-30: Change the status to rejected  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#status","content":" Rejected  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#context","content":" Note: ADR rejected as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  Currently, if an equivocation slashing proposal is created after more than one week has passed since the equivocation, it is possible that the validator in question could unbond and get away without being slashed, since the unbonding period is 3 weeks, and the voting period is 2 weeks. For this reason, it might be good to pause unbondings for validators named in an equivocation slashing proposal until the proposal's voting period is over.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#decision","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"How​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#how","content":" Pausing the unbonding period is already possible thanks to the changes in thestaking module of the cosmos-sdk:  stakingKeeper.PutUnbondingOnHold pauses an unbonding periodstakingKeeper.UnbondingCanComplete unpauses an unbonding period  These methods use a reference counter under the hood, that gets incremented every time PutUnbondingOnHold is called, and decreased whenUnbondingCanComplete is called instead. A specific unbonding is considered fully unpaused when its underlying reference counter reaches 0. Therefore, as long as we safeguard consistency - i.e. we make sure we eventually decrement the reference counter for each time we have incremented it - we can safely use this existing mechanism without conflicts with the Completion of Unbonding Operations system.  ","version":"v5.2.0","tagName":"h3"},{"title":"When pause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-pause","content":" The unbonding period (if there is any unbonding) should be paused once an equivocation proposal enters the voting period. For that, the gov module's hook AfterProposalDeposit can be used.  If the hook is triggered with a an equivocation proposal in voting period, then for each equivocation of the proposal, the unbonding operations of the related validator that were initiated after the equivocation block time must be paused  i.e. the underlying reference counter has to be increased.  Note that even after the voting period has started, a proposal can receive additional deposits. The hook is triggered however at arrival of a deposit, so a check to verify that the proposal is not already in voting period is required.  ","version":"v5.2.0","tagName":"h3"},{"title":"When unpause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-unpause","content":" We can use a gov module's hook also here and it isAfterProposalVotingPeriodEnded.  If the hook is triggered with an equivocation proposal, then for each associated equivocation, the unbonding operations of the related validator that were initiated between the equivocation block time and the start of the proposal voting period must be unpaused - i.e. decrease the underlying reference counter - regardless of the proposal outcome.  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#positive","content":" Validators subject to an equivocation proposal cannot finish unbonding their tokens before the end of the voting period.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#negative","content":" A malicious consumer chain could forge slash packets enabling submission of an equivocation proposal on the provider chain, resulting in the freezing of validator's unbondings for an undeterminated amount of time.Misbehavior on a consumer chain can potentially go unpunished, if no one submits an equivocation proposal in time, or if the proposal doesn't pass.  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#neutral","content":" This feature can't be used for social slashing, because an equivocation proposal is only accepted if there's a slash log for the related validator(s), meaning the consumer chain has reported the equivocation to the provider chain.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v5.2.0/adrs/adr-007-pause-unbonding-on-eqv-prop#references","content":" https://github.com/cosmos/interchain-security/issues/747https://github.com/cosmos/interchain-security/pull/791 ","version":"v5.2.0","tagName":"h2"},{"title":"Throttle with retries","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries","content":"","keywords":"","version":"v5.2.0"},{"title":"ADR 008: Throttle with retries​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#adr-008-throttle-with-retries","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#changelog","content":" 6/9/23: Initial draft6/22/23: added note on consumer pending packets storage optimization7/14/23: Added note on upgrade order  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#status","content":" Accepted  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#context","content":" For context on why the throttling mechanism exists, see ADR 002.  Note the terms slash throttling and jail throttling are synonymous, since in Interchain Security a SlashPacket simply jails a validator for downtime infractions.  Currently the throttling mechanism is designed so that provider logic (slash meter, etc.) dictates how many SlashPackets can be handled over time. Throttled SlashPackets are persisted on the provider, leading to multiple possible issues. Namely:  If SlashPackets or VSCMaturedPackets are actually throttled/queued on the provider, state can grow and potentially lead to a DoS attack. We have short term solutions around this, but overall they come with their own weaknesses. See #594.If a jailing attack described in ADR 002 were actually to be carried out with the current throttling design, we'd likely have to halt the provider, and perform an emergency upgrade and/or migration to clear the queues of SlashPackets that were deemed to be malicious. Alternatively, validators would just have to tough it out and wait for the queues to clear, during which all/most validators would be jailed. Right after being jailed, validators would have to unjail themselves promptly to ensure safety. The coordination required to maintain safety in such a scenario is not ideal.  As a solution, we can improve the throttling mechanism to instead queue/persist relevant data on each consumer, and have consumers retry slash requests as needed.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#decision","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Consumer changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#consumer-changes","content":" Note the consumer already queues up both SlashPackets and VSCMaturedPackets via AppendPendingPacket. Those packets are dequeued in every EndBlock in SendPackets and sent to the provider.  Instead, we will now introduce the following logic on EndBlock:  Slash packets will always be sent to the provider once they're at the head of the queue. However, once sent, the consumer will not send any subsequent VSCMaturedPackets from the queue until the provider responds with an acknowledgement that the sent SlashPacket has been handled, i.e., validator was jailed. That is, SlashPackets block the sending of subsequent VSCMaturedPackets in the consumer queue.If two SlashPackets are at the head of the queue, the consumer will send the first SlashPacket, and then wait for a success acknowledgement from the provider before sending the second SlashPacket. This seems like it'd simplify implementation.VSCMaturedPackets at the head of the queue (i.e., NOT following a SlashPacket) can be sent immediately, and do not block any other packets in the queue, since the provider always handles them immediately.  To prevent the provider from having to keep track of what SlashPackets have been rejected, the consumer will have to retry the sending of SlashPackets over some period of time. This can be achieved with an on-chain consumer param, i.e., RetryDelayPeriod. To reduce the amount of redundant re-sends, we recommend setting RetryDelayPeriod ~ SlashMeterReplenishmentPeriod, i.e., waiting for the provider slash meter to be replenished before resending the rejected SlashPacket.  Note to prevent weird edge case behavior, a retry would not be attempted until either a success or failure acknowledgement has been received from the provider.  With the behavior described, we maintain very similar behavior to the previous throttling mechanism regarding the timing that SlashPackets and VSCMaturedPackets are handled on the provider. Obviously the queueing and blocking logic is moved, and the two chains would have to send more messages between one another (only in the case the throttling mechanism is triggered).  In the normal case, when no or a few SlashPackets are being sent, the VSCMaturedPackets will not be delayed, and hence unbonding will not be delayed.  For the implementation of this design, see throttle_retry.go.  Consumer pending packets storage optimization​  In addition to the mentioned consumer changes, an optimization will need to be made to the consumer's pending packets storage to properly implement the feature from this ADR.  The consumer ccv module previously queued &quot;pending packets&quot; to be sent in each EndBlock in SendPackets. These packets are queued in state with a protobuf list of ConsumerPacketData. For a single append operation, the entire list is deserialized, then a packet is appended to that list, and the list is serialized again. See older version of AppendPendingPacket. That is, a single append operation has O(N) complexity, where N is the size of the list.  This poor append performance isn't a problem when the pending packets list is small. But with this ADR being implemented, the pending packets list could potentially grow to the order of thousands of entries when SlashPackets need to be resent.  We can improve the append time for this queue by converting it from a protobuf-esq list, to a queue implemented with sdk-esq code. The idea is to persist a uint64 index that will be incremented each time you queue up a packet. You can think of this as storing the tail of the queue. Then, packet data will be keyed by that index, making the data naturally ordered byte-wise for sdk's iterator. The index will also be stored in the packet data value bytes, so that the index can later be used to delete certain packets from the queue.  Two things are achieved with this approach:  More efficient packet append/enqueue timesThe ability to delete select packets from the queue (previously all packets were deleted at once)  ","version":"v5.2.0","tagName":"h3"},{"title":"Provider changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#provider-changes","content":" The main change needed for the provider is the removal of queuing logic for SlashPackets and VSCMaturedPackets upon being received.  Instead, the provider will consult the slash meter to determine if a SlashPacket can be handled immediately. If not, the provider will return an acknowledgement message to the consumer communicating that the SlashPacket could not be handled, and needs to be sent again in the future (retried).  VSCMaturedPackets will always be handled immediately upon being received by the provider.  Note spec. Specifically the section on VSC Maturity and Slashing Order. Previously the onus was on the provider to maintain this property via queuing packets and handling them FIFO.  Now this property will be maintained by the consumer sending packets in the correct order, and blocking the sending of VSCMaturedPackets as needed. Then, the ordered IBC channel will ensure that SlashPackets and VSCMaturedPackets are received in the correct order on the provider.  The provider's main responsibility regarding throttling will now be to determine if a received SlashPacket can be handled via slash meter etc., and appropriately acknowledge to the sending consumer.  Handling VSCMaturedPackets immediately​  Why the provider can handle VSCMatured packets immediately​  A VSCMaturedPacket communicates to the provider that sufficient time passed on the consumer since the corresponding VSCPacket has been applied (on the consumer) such that infractions committed on the consumer could have been submitted.  If the consumer is following the queuing/blocking protocol described, then no bad behavior occurs and the VSC Maturity and Slashing Order property is maintained.  If a consumer sends VSCMaturedPackets too leniently -- the consumer is malicious and sends duplicate VSCMaturedPackets, or sends the packets sooner than the CCV protocol specifies -- then the provider needs to handle VSCMaturedPackets immediately to prevent DOS, state bloat, or other issues. The only possible negative outcome is that the malicious consumer may not be able to jail a validator who should have been jailed. The malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  If a consumer blocks the sending of VSCMaturedPackets, then unbonding operations on the provider will be delayed, but only until the VSC timeout period has elapsed. At that time, the consumer is removed. Again the malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  ","version":"v5.2.0","tagName":"h3"},{"title":"Splitting of PRs and Upgrade Order​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#splitting-of-prs-and-upgrade-order","content":" This feature will implement consumer changes in #1024.  ❗These changes should be deployed to production for all consumers before the provider changes are deployed to production.  In other words, the consumer changes in #1024 are compatible with the current (&quot;v1&quot;) provider implementation of throttling that's running on the Cosmos Hub as of July 2023.  Once all consumers have deployed the changes in #1024, the provider changes from #1321 can be deployed to production, fully enabling v2 throttling.  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#consequences","content":" Consumers will now have to manage their own queues, and retry logic.Consumers still aren't trustless, but the provider is now less susceptible to mismanaged or malicious consumers.Recovering from the &quot;jailing attack&quot; is more elegant.Some issues like #1001 will now be handled implicitly by the improved throttling mechanism.SlashPackets and VSCMaturedPackets can be handled immediately once received by the provider if the slash meter allows.In general, we reduce the amount of computation that happens in the provider EndBlock.  ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#positive","content":" We no longer have to reason about a &quot;global queue&quot; and a &quot;chain specific queue&quot;, and keeping those all in-sync. Now SlashPackets and VSCMaturedPackets queuing is handled on each consumer individually.Due to the above, the throttling protocol becomes less complex overall.We no longer have to worry about throttle related DoS attack on the provider, since no queuing exists on the provider.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#negative","content":" Increased number of IBC packets being relayed anytime throttling logic is triggered.Consumer complexity increases, since consumers now have manage queuing themselves, and implement packet retry logic.  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#neutral","content":" Core throttling logic on the provider remains unchanged, i.e., slash meter, replenishment cycles, etc.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v5.2.0/adrs/adr-008-throttle-retries#references","content":" EPIC tracking the changes proposed by this ADRADR 002: Jail Throttling#594 ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 005: Cryptographic verification of equivocation evidence","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#changelog","content":" 5/1/2023: First draft7/23/2023: Add light client attacks handling9/6/2023: Add double signing attacks handling11/3/2023: Update limitations to clarify amnesia attacks are ignored  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#status","content":" Accepted  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#context","content":" Currently, we use a governance proposal to slash validators for equivocation (double signing and light client attacks). Every proposal needs to go through a (two weeks) voting period before it can be approved. Given a three-week unbonding period, this means that an equivocation proposal needs to be submitted within one week since the infraction occurred.  This ADR proposes a system to slash validators automatically for equivocation, immediately upon the provider chain's receipt of the evidence. Another thing to note is that we intend to introduce this system in stages, since even the partial ability to slash and/or tombstone is a strict improvement in security. The feature is implemented in two parts, each with its dedicated endpoint. One endpoint handles light client attacks, while the other handles double signing attacks.  ","version":"v5.2.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack","content":" In a nutshell, the light client is a process that solely verifies a specific state machine's consensus without executing the transactions. The light clients get new headers by querying multiple nodes, called primary and witness nodes.  Light clients download new headers committed on chain from a primary. Headers can be verified in two ways: sequentially, where the block height of headers is serial, or using skipping. This second verification method allows light clients to download headers with nonconsecutive block height, where some intermediate headers are skipped (see Tendermint Light Client, Figure 1 and Figure 3). Additionally, light clients are cross-checking new headers obtained from a primary with witnesses to ensure all nodes share the same state.  A light client attack occurs when a Byzantine validator sends invalid headers to a light client. As the light client doesn't execute transactions, it can be deceived into trusting corrupted application state transitions. For instance, if a light client receives header A from the primary and header B from a witness for the same block height H, and both headers are successfully verified, it indicates a light client attack. Note that in this case, either the primary or the witness or both are malicious.  The types of light client attacks are defined by analyzing the differences between the conflicting headers. There are three types of light client attacks: lunatic attack, equivocation attack, and amnesia attack. For details, see the CometBFT specification.  When a light client agent detects two conflicting headers, it will initially verify their traces (see cometBFT detector) using its primary and witness nodes. If these headers pass successful verification, the Byzantine validators will be identified based on the header's commit signatures and the type of light client attack. The agent will then transmit this information to its nodes using a LightClientAttackEvidence evidence to be eventually voted on and added to a block. Note that from a light client agent perspective, it is not possible to establish whether a primary or a witness node, or both, are malicious. Therefore, it will create and send two evidences: one against the primary (sent to the witness), and one against the witness (sent to the primary). Both nodes will then verify it before broadcasting it and adding it to the evidence pool. If an evidence is finally committed to a block, the chain's evidence module will execute it, resulting in the jailing and the slashing of the validators responsible for the light client attack.  Light clients are a core component of IBC. In the event of a light client attack, IBC relayers notify the affected chains by submitting an IBC misbehavior message. A misbehavior message includes the conflicting headers that constitute a light client attack evidence. Upon receiving such a message, a chain will first verify whether these headers would have convinced its light client. This verification is achieved by checking the header states against the light client consensus states (see IBC misbehaviour handler). If the misbehaviour is successfully verified, the chain will then &quot;freeze&quot; the light client, halting any further trust in or updating of its states.  ","version":"v5.2.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack","content":" A double signing attack, also known as equivocation, occurs when a validator votes for two different blocks in the same round of the CometBFT consensus. This consensus mechanism operates with multiple voting rounds at each block height, and it strictly prohibits sending two votes of the same type during a round (see CometBFT State Machine Overview).  When a node observes two votes from the same peer, it will use these two votes to create a DuplicateVoteEvidenceevidence and gossip it to the other nodes in the network (see CometBFT equivocation detection). Each node will then verify the evidence according to the CometBFT rules that define a valid double signing infraction, and based on this verification, they will decide whether to add the evidence to a block. During the evidence verification process, the signatures of the conflicting votes must be verified successfully. Note that this is achieved using the public key of the misbehaving validator, along with the chain ID of the chain where the infraction occurred (see CometBFT equivocation verification).  Once a double signing evidence is committed to a block, the consensus layer will report the equivocation to the evidence module of the Cosmos SDK application layer. The application will, in turn, punish the malicious validator through jailing, tombstoning and slashing (see handleEquivocationEvidence).  ","version":"v5.2.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#decision","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack-1","content":" In the first part of the feature, we introduce a new endpoint: HandleConsumerMisbehaviour(ctx sdk.Context, misbehaviour ibctmtypes.Misbehaviour). The main idea is to leverage the current IBC misbehaviour handling and update it to solely jail and slash the validators that performed a light client attack. Note that in this context, we assume that chains connected via a light client share a subset of the validator set of the provider.  This endpoint reuses the IBC client libraries to verify that the misbehaviour headers would have fooled the light client. Additionally, it’s crucial that the endpoint logic results in the slashing and jailing of validators under the same conditions as a light client agent detector. Therefore, the endpoint ensures that the two conditions are met: the headers in the misbehaviour message have the same block height, and the light client isn’t expired.  After having successfully verified a misbehaviour, the endpoint executes the jailing and slashing of the malicious validators similarly as in the evidence module.  ","version":"v5.2.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack-1","content":" In the second part of the feature, we introduce a new endpoint HandleConsumerDoubleVoting( ctx sdk.Context, evidence *tmtypes.DuplicateVoteEvidence, chainID string, pubkey cryptotypes.PubKey). Simply put, the handling logic verifies a double signing evidence against a provided public key and chain ID and, if successful, executes the jailing of the malicious validator who double voted.  We define a newMsgSubmitConsumerDoubleVoting message to report a double voting evidence observed on a consumer chain to the endpoint of the provider chain. This message contains two fields: a double signing evidenceduplicate_vote_evidence and a light client header for the infraction block height, referred to as infraction_block_header. The latter provides the malicious validator's public key and the chain ID required to verify the signature of the votes contained in the evidence.  Note that double signing evidence is not verified using the same conditions as in the implementation CometBFT (seeverify(evidence types.Evidence) method). Specifically, we do not check that the evidence hasn't expired. More details can be found in the &quot;Current limitations&quot; section below.  Upon a successful equivocation verification, the misbehaving validator is jailed for the maximum time (see DoubleSignJailEndTimein the SDK evidence module).  ","version":"v5.2.0","tagName":"h3"},{"title":"Current limitations:​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#current-limitations","content":" We cannot derive an infraction height from the evidence, so it is only possible to jail validators, not actually slash them. To explain the technical reasons behind this limitation, let's recap the initial consumer initiated slashing logic. In a nutshell, consumer heights are mapped to provider heights through VSCPackets, namely through the so called vscIDs. When an infraction occurs on the consumer, a SlashPacket containing the vscID obtained from mapping the consumer infraction height is sent to the provider. Upon receiving the packet, the provider maps the consumer infraction height to a local infraction height, which is used to slash the misbehaving validator. In the context of untrusted consumer chains, all their states, including vscIDs, could be corrupted and therefore cannot be used for slashing purposes. For the same reasons explained above, the age of a consumer double signing evidence can't be verified, either using its infraction height or its unsigned timestamp. Note that changes the jailing behaviour, potentially leading to a validator's jailing based on some &quot;old&quot; evidence from a consumer, which wouldn't occur if the consumer were a standalone chain. In the first stage of this feature, validators are jailed indefinitely without being tombstoned. The underlying reason is that a malicious validator could take advantage of getting tombstoned to avoid being slashed on the provider (see comment). Currently, the endpoint can only handle equivocation light client attacks. This is because the lunatic attacks require the endpoint to possess the ability to dissociate which header is conflicted or trusted upon receiving a misbehavior message. Without this information, it's not possible to extract the Byzantine validators from the conflicting headers (see comment). In addition, &quot;amnesia&quot; attacks are ignored, similar to CometBFT (see ADR-056).  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#positive","content":" It is now possible for the provider chain to jail validators who committed light client or double signing attacks on a consumer chain.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#negative","content":" N/A  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v5.2.0/adrs/adr-005-cryptographic-equivocation-verification#references","content":" ICS misbehaviour handling PRConsumer double voting handler PRArchitectural diagramsADR on equivocation slashing ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 002: Jail Throttling","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#changelog","content":" 2023-01-26: Initial Draft2023-02-07: Property refined, ADR ready to review/merge2023-11-22: Refactor for better understanding  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#status","content":" Accepted  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#context","content":" The CCV spec is based around the assumption that the provider binary and all consumers binaries are non-malicious, and follow the defined protocols. In practice, this assumption may not hold. A malicious consumer binary could potentially include code which is able to send many slash/jail packets at once to the provider.  Before the throttling feature was implemented, the following attack was possible. Attacker(s) would create provider validators just below the provider's active set. Using a malicious consumer binary, slash packets would be relayed to the provider, that would slash/jail a significant portion (or all) of honest validator at once. Control of the provider would then pass over to the attackers' validators. This enables the attacker(s) to halt the provider. Or even worse, commit arbitrary state on the provider, potentially stealing all tokens bridged to the provider over IBC.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#decision","content":" The throttling feature was designed to slow down the mentioned attack from above, allowing validators and the community to appropriately respond to the attack, i.e., this feature limits (enforced by on-chain params) the rate that the provider validator set can be jailed over time.  ","version":"v5.2.0","tagName":"h2"},{"title":"Required State​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#required-state","content":" Slash meter: There exists one slash meter on the provider which stores an amount of voting power (integer), corresponding to an allowance of validators that can be jailed over time. This meter is initialized to a certain value on genesis, decremented by the amount of voting power jailed whenever a slash packet is handled, and periodically replenished as decided by on-chain params.  Global entry queue: There exists a single queue which stores &quot;global slash entries&quot;. These entries allow the provider to appropriately handle slash packets sent from any consumer in FIFO ordering. This queue is responsible for coordinating the order that slash packets (from multiple chains) are handled over time.  Per-chain data queue: For each established consumer, there exists a queue which stores &quot;throttled packet data&quot;, i.e.,pending slash packet data is queued together with pending VSC matured packet data in FIFO ordering. Order is enforced by IBC sequence number. These &quot;per-chain&quot; queues are responsible for coordinating the order that slash packets are handled in relation to VSC matured packets from the same chain.  Note: The reason for a multiple-queue design is the VSC Maturity and Slashing Order property (see spec). There are other ways to ensure such a property (like a queue of linked lists, etc.), but the proposed approach seemed to be the most understandable and easiest to implement with a KV store.  ","version":"v5.2.0","tagName":"h3"},{"title":"Params​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#params","content":" SlashMeterReplenishPeriod -- the period after which the slash meter is replenished.  SlashMeterReplenishFraction -- the portion (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs. This param also serves as a maximum fraction of total voting power that the slash meter can hold.  MaxThrottledPackets -- the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value. This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness.  ","version":"v5.2.0","tagName":"h3"},{"title":"Protocol Overview​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#protocol-overview","content":" OnRecvSlashPacket​  Upon the provider receiving a slash packet from any of the established consumers during block execution, two things occur:  A global slash entry is queued.The data of such a packet is added to the per-chain queue.  OnRecvVSCMaturedPacket​  Upon the provider receiving a VSCMatured packet from any of the established consumers during block execution, the VSCMatured packet data is added to the per-chain queue.  Endblocker​  In the EndBlock of the provider CCV module, there are three actions performed:  replenish the slash meter;handle the leading VSCMaturedPackets;and handle the throttle queues.  Slash Meter Replenishment​  Once the slash meter becomes not full, it'll be replenished after SlashMeterReplenishPeriod by incrementing the meter with its allowance for the replenishment block, where allowance = SlashMeterReplenishFraction * currentTotalVotingPower. The slash meter will never exceed its current allowance (function of the total voting power for the block) in value.  Note a few things:  The slash meter can go negative in value, and will do so when handling a single slash packet that jails a validator with significant voting power. In such a scenario, the slash meter may take multiple replenishment periods to once again reach a positive value (or 0), meaning no other slash packets may be handled for multiple replenishment periods.Total voting power of a chain changes over time, especially as validators are jailed. As validators are jailed, total voting power decreases, and so does the jailing allowance. See below for more detailed throttling property discussion.The voting power allowance added to the slash meter during replenishment will always be greater than or equal to 1. If the SlashMeterReplenishFraction is set too low, integer rounding will put this minimum value into effect. That is, if SlashMeterReplenishFraction * currentTotalVotingPower &lt; 1, then the effective allowance would be 1. This min value of allowance ensures that there's some packets handled over time, even if that is a very long time. It's a crude solution to an edge case caused by too small of a replenishment fraction.  The behavior described above is achieved by executing CheckForSlashMeterReplenishment() every EndBlock, BEFORE HandleThrottleQueues() is executed.  Handle Leading VSCMaturedPackets​  In every block, it is possible that VSCMaturedPacket data was queued before any slash packet data. Since this &quot;leading&quot; VSCMatured packet data does not have to be throttled (see VSC Maturity and Slashing Order), we can handle all VSCMatured packet data at the head of the queue, before the any throttling or packet data handling logic executes.  Handle Throttle Queues​  In every EndBlock, the following logic is executed to handle data from the throttle queues.  meter := getSlashMeter() // Keep iterating as long as the meter has a positive (or 0) value, and global slash entries exist while meter.IsPositiveOrZero() &amp;&amp; entriesExist() { // Get next entry in queue entry := getNextGlobalSlashEntry() // Decrement slash meter by the voting power that will be removed from the valset from handling this slash packet valPower := entry.getValPower() meter = meter - valPower // Using the per-chain queue, handle the single slash packet using its queued data, // then handle all trailing VSCMatured packets for this consumer handleSlashPacketAndTrailingVSCMaturedPackets(entry) // Delete entry in global queue, delete handled data entry.Delete() deleteThrottledSlashPacketData() deleteTrailingVSCMaturedPacketData() }   ","version":"v5.2.0","tagName":"h3"},{"title":"System Properties​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#system-properties","content":" All CCV system properties should be maintained by implementing this feature, see CCV spec - Consumer Initiated Slashing.  One implementation-specific property introduced is that if any of the chain-specific packet data queues become larger than MaxThrottledPackets, then the provider binary will panic, and the provider chain will halt. Therefore this param should be set carefully. See SetThrottledPacketDataSize. This behavior ensures that if the provider binaries are queuing up more packet data than machines can handle, the provider chain halts deterministically between validators.  ","version":"v5.2.0","tagName":"h3"},{"title":"Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#main-throttling-property","content":" Using on-chain params and the sub protocol defined, slash packet throttling is implemented such that the following property holds under some conditions.  First, we introduce the following definitions:  A consumer initiated slash attack &quot;starts&quot; when the first slash packet from such an attack is received by the provider.The &quot;initial validator set&quot; for the attack is the validator set that existed on the provider when the attack started.There is a list of honest validators such that if they are jailed, X% of the initial validator set will be jailed.  For the Throttling Property to hold, the following assumptions must be true:  We assume the total voting power of the chain (as a function of delegations) does not increase over the course of the attack.No validator has more than SlashMeterReplenishFraction of total voting power on the provider.SlashMeterReplenishFraction is large enough that SlashMeterReplenishFraction * currentTotalVotingPower &gt; 1, i.e., the replenish fraction is set high enough that we can ignore the effects of rounding.SlashMeterReplenishPeriod is sufficiently longer than the time it takes to produce a block.  Note if these assumptions do not hold, throttling will still slow down the described attack in most cases, just not in a way that can be succinctly described. It's possible that more complex properties can be defined.  Throttling Property: The time it takes to jail/tombstone X% of the initial validator set will be greater than or equal toSlashMeterReplenishPeriod⋅XSlashMeterReplenishFraction−2⋅SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod} \\cdot \\frac{X}{\\mathit{SlashMeterReplenishFraction}} - 2 \\cdot \\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriod⋅SlashMeterReplenishFractionX​−2⋅SlashMeterReplenishPeriod.  Intuition Let's use the following notation: CCC: Number of replenishment cyclesPPP: SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriodFFF: SlashMeterReplenishFraction\\mathit{SlashMeterReplenishFraction}SlashMeterReplenishFractionVmaxV_{\\mathit{max}}Vmax​: Max power of a validator as a fraction of total voting power In CCC number of replenishment cycles, the fraction of total voting power that can be removed, aaa, is a≤F⋅C+Vmaxa \\leq F \\cdot C + V_{\\mathit{max}}a≤F⋅C+Vmax​ (where VmaxV_{\\mathit{max}}Vmax​ is there to account for the power fraction of the last validator removed, one which pushes the meter to the negative value). So, we need at least C≥a−VmaxFC \\geq \\frac{a - V_{\\mathit{max}}}{F}C≥Fa−Vmax​​ cycles to remove aaa fraction of the total voting power. Since we defined the start of the attack to be the moment when the first slash request arrives, then FFF fraction of the initial validator set can be jailed immediately. For the remaining X−FX - FX−F fraction of the initial validator set to be jailed, it takes at least C≥(X−F)−VmaxFC \\geq \\frac{(X - F) - V_{\\mathit{max}}}{F}C≥F(X−F)−Vmax​​ cycles. Using the assumption that Vmax≤FV_{\\mathit{max}} \\leq FVmax​≤F (assumption 2), we get C≥X−2FFC \\geq \\frac{X - 2F}{F}C≥FX−2F​ cycles. In order to execute CCC cycles, we need C⋅PC \\cdot PC⋅P time. Thus, jailing the remaining X−FX - FX−F fraction of the initial validator set corresponds to P⋅(X−2F)F\\frac{P \\cdot (X - 2F)}{F}FP⋅(X−2F)​ time. In other words, the attack must take at least P⋅XF−2P\\frac{P \\cdot X}{F} - 2PFP⋅X​−2P time (in the units of replenish period PPP).  This property is useful because it allows us to reason about the time it takes to jail a certain percentage of the initial provider validator set from consumer initiated slash requests. For example, if SlashMeterReplenishFraction is set to 0.06, then it takes no less than 4 replenishment periods to jail 33% of the initial provider validator set on the Cosmos Hub. Note that as of writing this on 11/29/22, the Cosmos Hub does not have a validator with more than 6% of total voting power.  Note also that 4 replenishment period is a worst case scenario that depends on well crafted attack timings.  ","version":"v5.2.0","tagName":"h3"},{"title":"How Unjailing Affects the Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#how-unjailing-affects-the-main-throttling-property","content":" Note that the jailing allowance is directly proportional to the current total voting power of the provider chain. Therefore, if honest validators don't unjail themselves during the attack, the total voting power of the provider chain will decrease over the course of the attack, and the attack will be slowed down, main throttling property is maintained.  If honest validators do unjail themselves, the total voting power of the provider chain will still not become higher than when the attack started (unless new token delegations happen), therefore the main property is still maintained. Moreover, honest validators unjailing themselves helps prevent the attacking validators from gaining control of the provider.  In summary, the throttling mechanism as designed has desirable properties whether or not honest validators unjail themselves over the course of the attack.  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#positive","content":" The described attack is slowed down in seemingly all cases.If certain assumptions hold, the described attack is slowed down in a way that can be precisely time-bounded.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#negative","content":" Throttling introduces a vector for a malicious consumer chain to halt the provider, see issue below. However, this is sacrificing liveness in a edge case scenario for the sake of security. As an improvement, using retries would fully prevent this attack vector.  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#neutral","content":" Additional state is introduced to the provider chain.VSCMatured and slash packet data is not always handled in the same block that it is received.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v5.2.0/adrs/adr-002-throttle#references","content":" Original issue inspiring throttling featureIssue on DOS vectorConsideration of another attack vector ","version":"v5.2.0","tagName":"h2"},{"title":"Soft Opt-Out","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out","content":"","keywords":"","version":"v5.2.0"},{"title":"ADR 009: Soft Opt-Out​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#adr-009-soft-opt-out","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#changelog","content":" 6/13/23: Initial draft of ADR. Feature already implemented and in production.6/19/24: Change status to deprecated  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#status","content":" Deprecated Deprecated by Partial Set Security  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#context","content":" Some small validators may not have the resources needed to validate all consumer chains. Therefore a need exists to allow the bottom x% of validators to opt-out of validating a consumer chain. Meaning downtime infractions for these validators are dropped without ever reaching the provider.  This document specifies a modification to the ccv protocol which allows the bottom x% of the validator set by power to opt out of validating consumer chains without being jailed or otherwise punished for it. The feature is implemented with entirely consumer-side code.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#decision","content":" A consumer param exists, known as SoftOptOutThreshold, which is a string decimal in the range of [0, 0.2], that determines the portion of validators which are allowed to opt out of validating that specific consumer.  In every consumer beginblocker, a function is ran which determines the so called smallest non opt-out voting power. Validators with voting power greater than or equal to this value must validate the consumer chain, while validators below this value may opt out of validating the consumer chain.  The smallest non opt-out voting power is recomputed every beginblocker in UpdateSmallestNonOptOutPower(). In a nutshell, the method obtains the total voting power of the consumer, iterates through the full valset (ordered power ascending) keeping track of a power sum, and when powerSum / totalPower &gt; SoftOptOutThreshold, the SmallestNonOptOutPower is found and persisted.  Then, whenever the Slash() interface is executed on the consumer, if the voting power of the relevant validator being slashed is less than SmallestNonOptOutPower for that block, the slash request is dropped and never sent to the provider.  ","version":"v5.2.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#positive","content":" Small validators can opt out of validating specific consumers without being punished for it.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#negative","content":" The bottom x% is still part of the total voting power of the consumer chain. This means that if the soft opt-out threshold is set to 10% for example, and every validator in the bottom 10% opts out from validating the consumer, then a 24% downtime of the remaining voting power would halt the chain. This may be especially problematic during consumer upgrades.In nominal scenarios, consumers with soft opt out enabled will be constructing slash packets for small vals, which may be dropped. This is wasted computation, but necessary to keep implementation simple. Note that the sdk's full downtime logic is always executed on the consumer, which can be computationally expensive and slow down certain blocks.In a consumer chain, when a validator that has opted out becomes the proposer, there will naturally be no proposal made and validators would need to move to the next consensus round for the same height to reach a decision. As a result, we would need more time to finalize blocks on a consumer chain.  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#neutral","content":" Validators in the bottom of the valset who don't have to validate, may receive large delegation(s) which suddenly boost the validator to the subset that has to validate. This may catch the validator off guard.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v5.2.0/adrs/adr-009-soft-opt-out#references","content":" Original issue with some napkin math #784 ","version":"v5.2.0","tagName":"h2"},{"title":"Standalone to Consumer Changeover","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover","content":"","keywords":"","version":"v5.2.0"},{"title":"ADR 010: Standalone to Consumer Changeover​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#adr-010-standalone-to-consumer-changeover","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#changelog","content":" 6/30/23: Feature completed, first draft of ADR.  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#status","content":" Implemented  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#context","content":" Stride will be the first consumer to &quot;changeover&quot; from a standalone cosmos blockchain, to a consumer chain secured by the Cosmos Hub. This document outlines the changes made to support this changeover process.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#decision","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Process​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#process","content":" Prior to the changeover, the consumer chain will have an existing staking keeper and validator set, these may be referred to as the &quot;standalone staking keeper&quot; and &quot;standalone validator set&quot; respectively.  The first step in the changeover process is to submit a ConsumerAdditionProposal. If the proposal passes, the provider will create a new IBC client for the consumer at spawn time, with the provider's validator set. A consumer genesis will also be constructed by the provider for validators to query. Within this consumer genesis contains the initial validator set for the consumer to apply after the changeover.  Next, the standalone consumer chain runs an upgrade which adds the CCV module, and is properly setup to execute changeover logic.  The consumer upgrade height must be reached after the provider has created the new IBC client. Any Interchain Security validators who will run the consumer, but are not a part of the sovereign validator set, must sync up a full node before the consumer upgrade height is reached. The disk state of said full node will be used to run the consumer chain after the changeover has completed.  The meat of the changeover logic is that the consumer chain validator set is updated to that which was specified by the provider via the queried consumer genesis. Validators which were a part of the old set, but not the new set, are given zero voting power. Once these validator updates are given to Comet, the set is committed, and in effect 2 blocks later (see FirstConsumerHeight).  A relayer then establishes the new IBC connection between the provider and consumer. The CCV channel handshake is started on top of this connection. Once the CCV channel is established and VSC packets are being relayed, the consumer chain is secured by the provider.  ","version":"v5.2.0","tagName":"h3"},{"title":"Changes to CCV Protocol​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#changes-to-ccv-protocol","content":" Consumer Genesis state is updated to include a PreCCV boolean. When this boolean is set true in the consumer genesis JSON, special logic is executed on InitGenesis to trigger the changeover process on the consumer's first endblocker after the upgrade which adds the CCV module. Note that InitGenesis is not automatically called during chain upgrades, so the consumer must manually call the consumer's InitGenesis method in an upgrade handler.The ConsumerAdditionProposal type is updated to include a DistributionTransmissionChannel field. This field allows the consumer to use an existing IBC transfer channel to send rewards as a part of the CCV protocol. Consumers that're not changing over from a standalone chain will leave this field blank, indicating that a new transfer channel should be created on top of the same connection as the CCV channel.The CCV consumer keeper is updated to contain an optional reference to the standalone staking keeper. The standalone staking keeper is used to slash for infractions that happened before the changeover was completed. Ie. any infraction from a block height before the changeover, that is submitted after the changeover, will call the standalone staking keeper's slash method. Note that a changeover consumer's standalone staking keeper becomes a democracy module keeper, so it is possible for a governance token to be slashed.  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#positive","content":" Existing cosmos chains are now able to onboard over to a consumer chain secured by a provider.The previous staking keepers for such chains can be transitioned to democracy staking module keepers.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#negative","content":" The delineation between different types of consumers in this repo becomes less clear. Ie. there is code in the democracy consumer's app.go that only applies to a previously standalone chain, but that file also serves as the base for a normal democracy consumer launched with RS from genesis.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v5.2.0/adrs/adr-010-standalone-changeover#references","content":" EPIC: Standalone to Consumer Changeover #756Changeover diagram from Stride ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 011: Improving testing and increasing confidence","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#changelog","content":" 2023-08-11: Proposed, first draft of ADR.  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#status","content":" Proposed  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#context","content":" Testing, QA, and maintenance of interchain-security libraries is an ever-evolving area of software engineering we have to keep incrementally improving. The purpose of the QA process is to catch bugs as early as possible. In an ideal development workflow a bug should never reach production. A bug found in the specification stage is a lot cheaper to resolve than a bug discovered in production (or even in testnet). Ideally, all bugs should be found during the CI execution, and we hope that no bugs will ever even reach the testnet (although nothing can replace actual system stress test under load interacting with users).  During development and testnet operation the following types of bugs were the most commonly found:  improper iterator usageunbounded array access/iterationimproper input handling and validationimproper cached context usagenon-determinism check (improper use of maps in go, relying on random values)KV store management and/or how keys are defineddeserialization issues arising from consumer/provider versioning mismatch  Such bugs can be discovered earlier with better tooling. Some of these bugs can induce increases in block times, chain halts, state corruption, or introduce an attack surface which is difficult to remove if other systems have started depending on that behavior.  Current state of testing​  Our testing suites consist of multiple parts, each with their own trade-offs and benefits with regards to code coverage, complexity and confidence they provide.  ","version":"v5.2.0","tagName":"h2"},{"title":"Unit testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#unit-testing","content":" Unit testing is employed mostly for testing single-module functionality. It is the first step in testing and often the most practical. While highly important, unit tests often test a single piece of code and don't test relationships between different moving parts, this makes them less valuable when dealing with multi-module interactions.  Unit tests often employ mocks to abstract parts of the system that are not under test. Mocks are not equivalent to actual models and should not be treated as such.  Out of all the approaches used, unit testing has the most tools available and the coverage can simply be displayed as % of code lines tested. Although this is a very nice and very easy to understand metric, it does not speak about the quality of the test coverage.  Since distributed systems testing is a lot more involved, unit tests are oftentimes not sufficient to cover complex interactions. Unit tests are still necessary and helpful, but in cases where unit tests are not helpful e2e or integration tests should be favored.  ","version":"v5.2.0","tagName":"h3"},{"title":"Integration testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#integration-testing","content":" With integration testing we test the multi-module interactions while isolating them from the remainder of the system. Integration tests can uncover bugs that are often missed by unit tests.  It is very difficult to gauge the actual test coverage imparted by integration tests and the available tooling is limited. In interchain-security we employ the ibc-go/testing framework to test interactions in-memory.  At present, integration testing does not involve the consensus layer - it is only concerned with application level state and logic.  ","version":"v5.2.0","tagName":"h3"},{"title":"End-to-end testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#end-to-end-testing","content":" In our context end-to-end testing comprises of tests that use the actual application binaries in an isolated environment (e.g. docker container). During test execution the inputs are meant to simulate actual user interaction, either by submitting transactions/queries using the command line or using gRPC/REST APIs and checking for state changes after an action has been performed. With this testing strategy we also include the consensus layer in all of our runs. This is the closest we can get to testing user interactions without starting a full testnet.  End-to-end testing strategies vary between different teams and projects and we strive to unify our approach to the best of our ability (at least for ICS and gaia).  The available tooling does not give us significant (or relevant) line of code coverage information since most of the tools are geared towards analyzing unit tests and simple code branch evaluation.  We aim to adapt our best practices by learning from other similar systems and projects such as cosmos-sdk, ibc-go and CometBFT.  ","version":"v5.2.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#decision","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"1. Connect specifications to code and tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#1-connect-specifications-to-code-and-tooling","content":" Oftentimes, specifications are disconnected from the development and QA processes. This gives rise to problems where the specification does not reflect the actual state of the system and vice-versa. Usually specifications are just text files that are rarely used and go unmaintained after a while, resulting in consistency issues and misleading instructions/expectations about system behavior.  Decision context and hypothesis​  Specifications written in a dedicated and executable specification language are easier to maintain than the ones written entirely in text. Additionally, we can create models based on the specification OR make the model equivalent to a specification.  Models do not care about the intricacies of implementation and neither do specifications. Since both models and specifications care about concisely and accurately describing a system (such as a finite state machine), we see a benefit of adding model based tools (such as quint) to our testing and development workflows.  Main benefit​  MBT tooling can be used to generate test traces that can be executed by multiple different testing setups.  ","version":"v5.2.0","tagName":"h3"},{"title":"2. Improve e2e tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#2-improve-e2e-tooling","content":" Matrix tests​  Instead of only running tests against current main branch we should adopt an approach where we also:  run regression tests against different released software versions (ICS v1 vs v2 vs v3)run non-determinism tests to uncover issues quickly  Matrix tests can be implemented using CometMock and refactoring our current e2e CI setup.  Introducing e2e regression testing​  This e2e test suite would execute using a cronjob in our CI (nightly, multiple times a day etc.)  Briefly, the same set of traces is run against different maintained versions of the software and the main branch. This would allow us to discover potential issues during development instead of in a testnet scenarios.  The most valuable issues that can be discovered in this way are state breaking changes, regressions and version incompatibilities.  The setup is illustrated by the image below.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  USES: ICS v1 PROVIDER\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv1 consumer (sdk45,ibc4.3)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v2 consumer (sdk45, ibc4.4)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v3 consumer (sdk47, ibc7)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main consumer\t❌\t❌\t❌\t❌\t❌\t❌\t❌\t❌ neutron\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌ stride\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌  Introducing e2e CometMock tests​  CometMock is a mock implementation of the CometBFT consensus engine. It supports most operations performed by CometBFT while also being lightweight and relatively easy to use.  CometMock tests allow more nuanced control of test scenarios because CometMock can &quot;fool&quot; the blockchain app into thinking that a certain number of blocks had passed.This allows us to test very nuanced scenarios, difficult edge cases and long-running operations (such as unbonding operations).  Examples of tests made easier with CometMock are listed below:  regression testsnon-determinism testsupgrade testsstate-breaking changes  With CometMock, the matrix test approach can also be used. The image below illustrates a CometMock setup that can be used to discover non-deterministic behavior and state-breaking changes.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  SCENARIO\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv3 provi + v3 consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main provi + main consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ commit provi + commit consu\t✅\t❌\t✅\t❌\t✅\t✅\t❌\t❌  Briefly; multiple versions of the application are run against the same CometMock instance and any deviations in app behavior would result in app hash errors (the apps would be in different states after performing the same set of actions).  ","version":"v5.2.0","tagName":"h3"},{"title":"3. Introduce innovative testing approaches​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#3-introduce-innovative-testing-approaches","content":" When discussing e2e testing, some very important patterns emerge - especially if test traces are used instead of ad-hoc tests written by hand.  We see a unique opportunity to clearly identify concerns and modularize the testing architecture.  The e2e testing frameworks can be split into a pipeline consisting of 3 parts: model, driver and harness.  Model​  Model is the part of the system that can emulate the behavior of the system under test. Ideally, it is very close to the specification and is written in a specification language such as quint, TLA+ or similar. One of the purposes of the model is that it can be used to generate test traces.  Driver​  The purpose of the driver is to accept test traces (generated by the model or written by hand), process them and provide inputs to the next part of the pipeline.  Basically, the driver sits between the model and the actual infrastructure on which the test traces are being executed on.  Harness​  Harness is the infrastructure layer of the pipeline that accepts inputs from the driver.  There can be multiple harnesses as long as they can perform four things:  bootstrap a test execution environment (local, docker, k8s…)accept inputs from driversperform the action specified by the driverreport results after performing actions  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#consequences","content":" The procedure outlined in this ADR is not an all-or-nothing approach. Concepts introduced here do not rely on each other, so this ADR may only be applied partially without negative impact on test coverage and code confidence.  ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#positive","content":" introduction of maintainable MBT solutions  improvement over the current &quot;difftest&quot; setup that relies on an opinionated typescript model and go driver  increased code coverage and confidence  using CometMock allows us to run more tests in less timeadding matrix e2e tests allows us to quickly pinpoint differences between code versions  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#negative","content":" It might be easier to forgo the MBT tooling and instead focus on pure property based testing  PBT proof of conceptproperty based testing in go  The solutions are potentially expensive if we increase usage of the CI pipeline - this is fixed by running &quot;expensive&quot; tests using a cronjob, instead of running them on every commit.  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#neutral","content":" The process of changing development and testing process is not something that can be thought of and delivered quickly. Luckily, the changes can be rolled out incrementally without impacting existing workflows.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v5.2.0/adrs/adr-011-improving-test-confidence#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  https://github.com/cosmos/gaia/issues/2427https://github.com/cosmos/gaia/issues/2420ibc-go e2e tests ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 012: Separate Releasing","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#changelog","content":" 0.0202020202020202: Initial draft of idea in #8010.01652892561983471: Put idea in this ADR0.05: Reject this ADR  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#status","content":" Rejected  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#context","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Spike results​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#spike-results","content":" I explored the idea of #801 with this spike branch. Here's my conclusions:  Splitting this repo to have multiple go.mods is possible. However there are various intricacies involved in decoupling the package hierarchy to have x/ccv/types as the lowest level dep, with x/ccv/consumer and x/ccv/provider being one dep layer above, with high-level tests depending on all three of the mentioned packages. I'd estimate this decoupling would take 2-5 workdays to finish, and require significant review effort.  ","version":"v5.2.0","tagName":"h3"},{"title":"Why go.mod split is not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#why-gomod-split-is-not-the-way-to-go","content":" Let's take a step back and remember the issue we're trying to solve - We need a clean way to decouple semver/releasing for the consumer and provider modules. After more consideration, splitting up go.mods gives us little benefit in achieving this. Reasons:  The go.mod dependency system is tied to git tags for the entire repo (ex: require github.com/cometbft/cometbft v0.37.2 refers to a historical tag for the entire cometbft repo).It'd be an odd dev experience to allow modules to reference past releases of other modules in the same repo. When would we ever want the consumer module to reference a past release of the types module for example?If we allow for go.mod replace statements to build from local source code, why split up the package deps at all?Splitting go.mods adds a bunch of complexity with go.work files and all that shiz. VSCode does not play well with multiple module repos either.  ","version":"v5.2.0","tagName":"h3"},{"title":"Why separate repos is cool but also not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#why-separate-repos-is-cool-but-also-not-the-way-to-go","content":" All this considered, the cleanest solution to decoupling semver/releasing for the consumer and provider modules would be to have multiple repos, each with their own go.mod (3-4 repos total including high level tests). With this scheme we could separately tag each repo as changes are merged, they could share some code from types being an external dep, etc.  I don't think any of us want to split up the monorepo, that's a lot of work and seems like bikeshedding. There's another solution that's very simple..  ","version":"v5.2.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#decision","content":" Slightly adapting the current semver ruleset:  A library API breaking change to EITHER the provider or consumer module will result in an increase of the MAJOR version number for BOTH modules (X.y.z-provider AND X.y.z-consumer).A state breaking change (change requiring coordinated upgrade and/or state migration) will result in an increase of the MINOR version number for the AFFECTED module(s) (x.Y.z-provider AND/OR x.Y.z-consumer).Any other changes (including node API breaking changes) will result in an increase of the PATCH version number for the AFFECTED module(s) (x.y.Z-provider AND/OR x.y.Z-consumer).  ","version":"v5.2.0","tagName":"h2"},{"title":"Example release flow​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#example-release-flow","content":" We upgrade main to use a new version of SDK. This is a major version bump, triggering a new release for both the provider and consumer modules, v5.0.0-provider and v5.0.0-consumer.  A state breaking change is merged to main for the provider module. We release only a v5.1.0-provider off main.Another state breaking change is merged to main for the provider module. We release only a v5.2.0-provider off main.At this point, the latest consumer version is still v5.0.0-consumer. We now merge a state breaking change for the consumer module to main, and consequently release v5.1.0-consumer. Note that v5.1.0-consumer is tagged off a LATER commit from main than v5.2.0-provider. This is fine, as the consumer module should not be affected by the provider module's state breaking changes.Once either module sees a library API breaking change, we bump the major version for both modules. For example, we merge a library API breaking change to main for the provider module. We release v6.0.0-provider and v6.0.0-consumer off main. Note that most often, a library API breaking change will affect both modules simultaneously (example being bumping sdk version).  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#positive","content":" Consumer repos have clear communication of what tagged versions are relevant to them. Consumer devs should know to never reference an ICS version that starts with provider, even if it'd technically build.Consumer and provider modules do not deviate as long as we continually release off a shared main branch. Backporting remains relatively unchanged besides being explicit about what module(s) your changes should affect.No code changes, just changes in process. Very simple.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#negative","content":" ~~Slightly more complexity.~~Considerably more complex to manage the ICS library. This is because ICS needs to support multiple versions of SDK (e.g., 0.45, 0.47, 0.50). In addition, ICS needs to support a special fork of SDK (with LSM included) for the Cosmos Hub. This means that instead of focusing on main the development team needs to manage multiple release branches with different dependency trees.This solution does not allow having provider and consumer on separate versions of e.g. the Cosmos SDK.  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#neutral","content":" ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v5.2.0/adrs/adr-012-separate-releasing#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  #801#801 comment ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 013: Slashing on the provider for consumer equivocation","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#changelog","content":" 1st Sept. 2023: Initial draft  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#status","content":" Accepted  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#context","content":" This ADR presents some approaches on how to slash on the provider chain validators that performed equivocations on consumer chains. Currently, the provider chain can receive and verify evidence of equivocation, but it cannot slash the misbehaving validator.  In the remainder of this section, we explain how slashing is performed on a single chain and show why slashing on the provider for equivocation on the consumer is challenging.  Note that future versions of the Cosmos SDK, CometBFT, and ibc-go could modify the way we slash, etc. Therefore, a future reader of this ADR, should note that when we refer to Cosmos SDK, CometBFT, and ibc-go we specifically refer to their v0.47, v0.37 and v7.3.0 versions respectively.  ","version":"v5.2.0","tagName":"h2"},{"title":"Single-chain slashing​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#single-chain-slashing","content":" Slashing is implemented across the slashingand staking modules. The slashing module's keeper calls the staking module's Slash() method, passing among others, the infractionHeight (i.e., the height when the equivocation occurred), the validator's power at the infraction height, and the slashFactor (currently set to 5% in case of equivocation on the Cosmos Hub).  Slashing undelegations and redelegations​  To slash undelegations, Slash goes through all undelegations and checks whether they started before or after the infraction occurred. If an undelegation started before the infractionHeight, then it is not slashed, otherwise it is slashed by slashFactor.  The slashing of redelegations happens in a similar way, meaning that Slash goes through all redelegations and checks whether the redelegations started before or after the infractionHeight.  Slashing delegations​  Besides undelegations and redelegations, the validator's delegations need to also be slashed. This is performed by deducting the appropriate amount of tokens from the validator. Note that this deduction is computed based on the voting power the misbehaving validator had at the height of the equivocation. As a result of the tokens deduction, the tokens per sharereduce and hence later on, when delegators undelegate or redelegate, the delegators retrieve back less tokens, effectively having their tokens slashed. The rationale behind this slashing mechanism, as mentioned in the Cosmos SDK documentation  [...] is to simplify the accounting around slashing. Rather than iteratively slashing the tokens of every delegation entry, instead the Validators total bonded tokens can be slashed, effectively reducing the value of each issued delegator share.  This approach of slashing delegations does not utilize theinfractionHeight in any way and hence the following scenario could occur:  a validator V performs an equivocation at a height Hia new delegator D delegates to V after height Hievidence of the equivocation by validator V is receivedthe tokens of delegator D are slashed  In the above scenario, delegator D is slashed, even though D's voting power did not contribute to the infraction.  Old evidence​  In the single-chain case, old evidence (e.g., from 3 years ago) is ignored. This is achieved throughCometBFT that ignores old evidence based on the parameters MaxAgeNumBlocks and MaxAgeDuration (see here). Additionally, note that when the evidence is sent by CometBFT to the application, the evidence is rechecked in the evidence module of Cosmos SDK and if it is old, the evidence is ignored. In Cosmos Hub, the MaxAgeNumBlocks is set to 1000000 (i.e., ~70 days if we assume we need ~6 sec per block) and MaxAgeDuration is set to 172800000000000 ns (i.e., 2 days). Because of this check, we can easily exclude old evidence.  ","version":"v5.2.0","tagName":"h3"},{"title":"Slashing for equivocation on the consumer​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#slashing-for-equivocation-on-the-consumer","content":" In the single-chain case, slashing requires both the infractionHeight and the voting power. In order to slash on the provider for an equivocation on a consumer, we need to have both the provider's infractionHeight and voting power. Note that the infractionHeight on the consumer chain must be mapped to a height on the provider chain. Unless we have a way to find the corresponding infractionHeight and power on the provider chain, we cannot slash for equivocation on the consumer in the same way as we would slash in the single-chain case.  The challenge of figuring out the corresponding infractionHeight and power values on the provider chain is due to the following trust assumption:  We trust the consensus layer and validator set of the consumer chains, but we do not trust the application layer.  As a result, we cannot trust anything that stems from the application state of a consumer chain.  Note that when a relayer or a user sends evidence through a MsgSubmitConsumerDoubleVoting message, the provider gets access to DuplicateVoteEvidence:  type DuplicateVoteEvidence struct { VoteA *Vote `json:&quot;vote_a&quot;` VoteB *Vote `json:&quot;vote_b&quot;` // abci specific information TotalVotingPower int64 ValidatorPower int64 Timestamp time.Time }   The &quot;abci specific information&quot; fields cannot be trusted because they are not signed. Therefore, we can use neither ValidatorPower for slashing on the provider chain, nor the Timestamp to check the evidence age. We can get the infractionHeight from the votes, but this infractionHeight corresponds to the infraction height on the consumer and not on the provider chain. Similarly, when a relayer or a user sends evidence through a MsgSubmitConsumerMisbehaviour message, the provider gets access to Misbehaviour that we cannot use to extract the infraction height, power, or the time on the provider chain.  ","version":"v5.2.0","tagName":"h3"},{"title":"Proposed solution​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#proposed-solution","content":" As a first iteration, we propose the following approach. At the moment the provider receives evidence of equivocation on a consumer:  slash all the undelegations and redelegations using slashFactor;slash all delegations using as voting power the sum of the voting power of the misbehaving validator and the power of all the ongoing undelegations and redelegations.  Evidence expiration: Additionally, because we cannot infer the actual time of the evidence (i.e., the timestamp of the evidence cannot be trusted), we do not consider evidence expiration and hence old evidence is never ignored (e.g., the provider would act on 3 year-old evidence of equivocation on a consumer). Additionally, we do not need to store equivocation evidence to avoid slashing a validator more than once, because we do not slash tombstoned validators and we tombstone a validator when slashed.  We do not act on evidence that was signed by a validator consensus key that is pruned when we receive the evidence. We prune a validator's consensus key if the validator has assigned a new consumer key (using MsgAssignConsumerKey) and an unbonding period on the consumer chain has elapsed (see key assignment ADR). Note that the provider chain is informed that the unbonding period has elapsed on the consumer when the provider receives a VSCMaturedPacket and because of this, if the consumer delays the sending of a VSCMaturedPacket, we would delay the pruning of the key as well.  ","version":"v5.2.0","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#implementation","content":" The following logic needs to be added to the HandleConsumerDoubleVoting and HandleConsumerMisbehaviour methods:  undelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetUnbondingDelegationsFromValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // undelegation no longer eligible for slashing, skip it continue } undelegationsInTokens = undelegationsInTokens.Add(entry.InitialBalance) } } redelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetRedelegationsFromSrcValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // redelegation no longer eligible for slashing, skip it continue } redelegationsInTokens = redelegationsInTokens.Add(entry.InitialBalance) } } infractionHeight := 0 undelegationsAndRedelegationsInPower = sdk.TokensToConsensusPower(undelegationsInTokens.Add(redelegationsInTokens)) totalPower := validator's voting power + undelegationsAndRedelegationsInPower slashFraction := k.slashingKeeper.SlashFractionDoubleSign(ctx) k.stakingKeeper.Slash(ctx, validatorConsAddress, infractionHeight, totalPower, slashFraction, DoubleSign)   Infraction height: We provide a zero infractionHeight to the Slash method in order to slash all ongoing undelegations and redelegations (see checks in Slash, SlashUnbondingDelegation, and SlashRedelegation).  Power: We pass the sum of the voting power of the misbehaving validator when the evidence was received (i.e., at evidence height) and the power of all the ongoing undelegations and redelegations. If we assume that the slashFactor is 5%, then the voting power we pass is power + totalPower(undelegations) + totalPower(redelegations). Hence, when the Slash method slashes all the undelegations and redelegations it would end up with 0.05 * power + 0.05 * totalPower(undelegations) + 0.05 * totalPower(redelegations) - 0.05 * totalPower(undelegations) - 0.05 * totalPower(redelegations) = 0.05 * power and hence it would slash 5% of the validator's power when the evidence is received.  ","version":"v5.2.0","tagName":"h3"},{"title":"Positive​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#positive","content":" With the proposed approach we can quickly implement slashing functionality on the provider chain for consumer chain equivocations. This approach does not need to change the staking module and therefore does not change in any way how slashing is performed today for a single chain.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#negative","content":" We definitely slash more when it comes to undelegations and redelegations because we slash for all of them without considering an infractionHeight.We potentially slash more than what we would have slashed if we knew the voting power at the corresponding infractionHeight in the provider chain.We slash on old evidence of equivocation on a consumer.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v5.2.0/adrs/adr-013-equivocation-slashing#references","content":" ADR 005: Cryptographic verification of equivocation evidenceEPIC tracking cryptographic equivocation featureCosmos Hub Forum discussion on cryptographic equivocation slashing ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 014: Epochs","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs#changelog","content":" 2024-01-05: Proposed, first draft of ADR.2024-02-29: Updated so that it describes the implementation where we store the whole consumer validator set.  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs#status","content":" Accepted  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs#context","content":" In every block that the provider valset changes, a VSCPacket must be sent to every consumer and a corresponding VSCMaturedPacket sent back. Given that the validator powers may change very often on the provider chain (e.g., the Cosmos Hub), this approach results in a large workload for the relayers. Although the validator powers may change very often, these changes are usually small and have an insignificant impact on the chain's security. In other words, the valset on the consumers can be slightly outdated without affecting security. As a matter of fact, this already happens due to relaying delays.  As a solution, this ADR introduces the concept of epochs. An epoch consists of multiple blocks. The provider sends VSCPackets once per epoch. A VSCPacket contains all the validator updates that are needed by a consumer chain.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs#decision","content":" The implementation of epochs requires the following changes:  For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. For each validator in the set we store i) its voting power, and ii) the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. The initial consumer validator set for a chain is set during the creation of the consumer genesis.We introduce the BlocksPerEpoch param that sets the number of blocks in an epoch. By default, BlocksPerEpoch is set to be 600 which corresponds to 1 hour, assuming 6 seconds per block. This param can be changed through a governance proposal. In the provider EndBlock we check BlockHeight() % BlocksPerEpoch() == 0to decide when an epoch has ended.At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacket with all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   Note that a validator can change its consumer public key for a specific consumer chain an arbitrary amount of times during a block and during an epoch. Then, when we generate the validator updates in DiffValidators, we have to check whether the current consumer public key (retrieved by calling GetValidatorConsumerPubKey) is different from the consumer public key the validator was using in the current epoch.  ","version":"v5.2.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs#positive","content":" Reduce the cost of relaying.Reduce the amount of IBC packets needed for ICS.Simplifies key-assignment code because we only need to check if the consumer_public_key has been modified since the last epoch to generate an update.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs#negative","content":" Increase the delay in the propagation of validator set changes (but for reasonable epoch lengths on the order of ~hours or less, this is unlikely to be significant).  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs#neutral","content":" N/A  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v5.2.0/adrs/adr-014-epochs#references","content":" EPIC ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 015: Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#changelog","content":" 2024-01-22: Proposed, first draft of ADR.  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#status","content":" Accepted  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#context","content":" Currently, in Replicated Security, the entire validator set of the provider chain is used to secure consumer chains. There are at least three concerns with this approach. First, a large number of validators might be forced to validate consumer chains they are not interested in securing. Second, it is costly for small validators to secure additional chains. This concern is only partially addressed through soft opt-out that allows small validators to opt out from validating consumer chains. Third and for the above reasons, it is challenging for a new consumer chain to join Replicated Security.  As a solution, we present Partial Set Security (PSS). As the name suggests, PSS allows for every consumer chain to be secured by only a subset of the provider validator set. In what follows we propose the exact steps we need to take to implement PSS. This is a first iteration of PSS, and therefore we present the most minimal solution that make PSS possible.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#decision","content":" In Replicated Security, all the provider validators have to secure every consumer chain (with the exception of those validators allowed to opt out through the soft opt-out feature).  In PSS, we allow validators to opt in and out of validating any given consumer chain. This has one exception: we introduce a parameter N for each consumer chain and require that the validators in top N% of the provider's voting power have to secure the consumer chain. Validators outside of the top N% can dynamically opt in if they want to validate on the consumer chain.  For example, if a consumer chain has N = 95%, then it ultimately receives the same security it receives today with Replicated Security (with a default SoftOptOutThreshold of 5%). On the other hand, if a consumer chain has N = 0%, then no validator is forced to validate the chain, but validators can opt in to do so instead.  For the remainder of this ADR, we call a consumer chain Top N if it has joined as a Top N chain with N &gt; 0 and Opt In chain otherwise. An Opt In consumer chain is secured only by the validators that have opted in to secure that chain.  We intend to implement PSS using a feature branch off v4.0.0 interchain security.  ","version":"v5.2.0","tagName":"h2"},{"title":"How do consumer chains join?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#how-do-consumer-chains-join","content":" As a simplification and to avoid chain id squatting, a consumer chain can only join PSS through a governance proposal and not in a permissionless way.  However, this proposal type will be modified so that it requires a lower quorum percentage than normal proposal, and every validator who voted &quot;YES&quot; on the proposal will form the consumer chain's initial validator set.  Consumer chains join PSS the same way chains now join Replicated Security, namely through a ConsumerAdditionProposal proposal. We extend ConsumerAdditionProposal with one optional field:  uint32 top_N: Corresponds to the percentage of validators that join under the Top N case. For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators have to validate the proposed consumer chain.top_N can be 0 or include any value in [50, 100]. A chain can join with top_N == 0 as an Opt In, or with top_N ∈ [50, 100] as a Top N chain.  In case of a Top N chain, we restrict the possible values of top_N from (0, 100] to [50, 100]. By having top_N &gt;= 50 we can guarantee that we cannot have a successful attack, assuming that at most 1/3 of provider validators can be malicious. This is because, a Top N chain with N &gt;= 50% would have at least 1/3 honest validators, which is sufficient to stop attacks. Additionally, by having N &gt;= 50% (and hence N &gt; (VetoThreshold = 33.4%)) we enable the top N validators to Veto any ConsumerAdditionProposal for consumer chains they do not want to validate.  If a proposal has the top_N argument wrongly set, it should get rejected in [ValidateBasic] (https://github.com/cosmos/interchain-security/blob/v4.0.0/x/ccv/provider/types/proposal.go#L86).  In the code, we distinguish whether a chain is Top N or Opt In by checking whether top_N is zero or not.  In a future version of PSS, we intend to introduce a ConsumerModificationProposal so that we can modify the parameters of a consumer chain, e.g, a chain that is Opt In to become Top N, etc.  State &amp; Query​  We augment the provider module’s state to keep track of the top_N value for each consumer chain. The key to store this information would be:  topNBytePrefix | len(chainID) | chainID   To create the above key, we can use ChainIdWithLenKey.  Then in the keeper we introduce methods as follows:  func (k Keeper) SetTopN(ctx sdk.Context, chainID string, topN uint32) func (k Keeper) IsTopN(ctx sdk.Context, chainID string) bool func (k Keeper) IsOptIn(ctx sdk.Context, chainID string) bool // returns the N if Top N chain, otherwise an error func (k Keeper) GetTopN(ctx sdk.Context, chainID string) (uint32, error)   We also extend the interchain-security-pd query provider list-consumer-chains query to return information on whether a consumer chain is an Opt In or a Top N chain and with what N. This way, block explorers can present informative messages such as &quot;This chain is secured by N% of the provider chain&quot; for consumer chains.  ","version":"v5.2.0","tagName":"h3"},{"title":"How do validators opt in?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#how-do-validators-opt-in","content":" A validator can opt in by sending a new type of message that we introduce in tx.proto.  message MsgOptIn { // the chain id of the consumer chain to opt in to string chainID = 1; // the provider address of the validator string providerAddr = 2; // (optional) the consensus public key to use on the consumer optional string consumerKey = 3; }   Note that in a Top N consumer chain, the top N% provider validators have to validate the consumer chain. Nevertheless, validators in the bottom (100 - N)% can opt in to validate as well. Provider validators that belong or enter the top N% validators are automatically opted in to validate a Top N consumer chain. This means that if a validator V belongs to the top N% validators but later falls (e.g., due to undelegations) to the bottom (100 - N)%, V is still considered opted in and has to validate unless V sends a MsgOptOut message (see below). By automatically opting in validators when they enter the top N% validators and by forcing top N% validators to explicitly opt out in case they fall to the (100 - N)% bottom validators we simplify the design of PSS.  Note that a validator can send a MsgOptIn message even if the consumer chain is not yet running. To do this we reuse the IsConsumerProposedOrRegistered. If the chainID does not exist, the MsgOptIn should fail, as well as if the provider address does not exist.  Optionally, a validator that opts in can provide a consumerKey so that it assigns a different consumer key (from the provider) to the consumer chain. Naturally, a validator can always change the consumer key on a consumer chain by sending a MsgAssignConsumerKey message at a later point in time, as is done in Replicated Security.  State &amp; Query​  For each validator, we store a pair (blockHeight, isOptedIn) that contains the block height the validator opted in and whether the validator is currently opted in or not, under the key:  optedInBytePrefix | len(chainID) | chainID | addr   By using a prefix iterator on optedInBytePrefix | len(chainID) | chainID we retrieve all the opted in validators.  We introduce the following Keeper methods.  // returns all the validators that have opted in on chain `chainID` func (k Keeper) GetOptedInValidators(ctx sdk.Context, chainID string) []Validators func (k Keeper) IsValidatorOptedIn(ctx sdk.Context, chainID string, val Validator) bool   We introduce the following two queries:  interchain-security-pd query provider optedInValidators $chainID interchain-security-pd query provider hasToValidate $providerAddr   One query to retrieve the validators that are opted in and hence the validators that need to validate the consumer chain and one query that given a validator's address returns all the chains this validator has to validate.  When do validators opt in?​  As described earlier, validators can manually opt in by sending a MsgOptIn message. Additionally, in a Top N chain, a validator is automatically opted in when it moves from the bottom (100 - N)% to the top N% validators.  Lastly, validators can also opt in if they vote Yes during the ConsumerAdditionProposal that introduces a consumer chain. This simplifies validators operations because they do not have to send an additional message to opt in.  Because the Tally method deletes the votes after reading them, we cannot check the votes of the validators after the votes have been tallied. To circumvent this, we introduce a hook for AfterProposalVote and keep track of all the votes cast by a validator. If a validator casts more than one vote, we only consider the latest vote. Finally, we only consider a validator has opted in if it casts a 100% Yes vote in case of a weighted vote.  ","version":"v5.2.0","tagName":"h3"},{"title":"How do validators opt out?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#how-do-validators-opt-out","content":" Validators that have opted in on a chain can opt out by sending the following message:  message MsgOptOut { // the chain id of the consumer chain to opt out from string chainID = 1; // the provider address of the validator string providerAddr = 2; }   Validators can only opt out after a consumer chain has started and hence the above message returns an error if the chain with chainID is not running. Additionally, a validator that belongs to the top N% validators cannot opt out from a Top N chain and hence a MsgOptOut would error in such a case.  State &amp; Query​  We also update the state of the opted-in validators when a validator has opted out by removing the opted-out validator.  Note that only opted-in validators can be punished for downtime on a consumer chain. For this, we use historical info of all the validators that have opted in; We can examine the blockHeight stored under the key optedInBytePrefix | len(chainID) | chainID | addr to see if a validator was opted in. This way we can jail validators for downtime knowing that indeed the validators have opted in at some point in the past. Otherwise, we can think of a scenario where a validator V is down for a period of time, but before V gets punished for downtime, validator V opts out, and then we do not know whether V should be punished or not.  ","version":"v5.2.0","tagName":"h3"},{"title":"When does a consumer chain start?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#when-does-a-consumer-chain-start","content":" A Top N consumer chain always starts at the specified date (spawn_time) if the ConsumerAdditionProposal has passed. An Opt In consumer chain only starts if at least one validator has opted in. We check this in BeginBlockInit:  func (k Keeper) BeginBlockInit(ctx sdk.Context) { propsToExecute := k.GetConsumerAdditionPropsToExecute(ctx) for _, prop := range propsToExecute { chainID := prop.ChainId if !k.IsTopN(ctx, chainID) &amp;&amp; len(k.GetOptedInValidators(ctx, chainID)) == 0 { // drop the proposal ctx.Logger().Info(&quot;could not start chain because no validator has opted in&quot;) continue } ...   ","version":"v5.2.0","tagName":"h3"},{"title":"How do we send the partial validator sets to the consumer chains?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#how-do-we-send-the-partial-validator-sets-to-the-consumer-chains","content":" A consumer chain should only be validated by opted in validators. We introduce logic to do this when we queue the VSCPackets. The logic behind this, is not as straightforward as it seems because CometBFT does not receive the validator set that has to validate a chain, but rather a delta of validator updates. For example, to remove an opted-out validator from a consumer chain, we have to send a validator update with a power of 0, similarly to what is done in the assignment of consumer keys. We intend to update this ADR at a later stage on how exactly we intend to implement this logic.  ","version":"v5.2.0","tagName":"h3"},{"title":"How do we distribute rewards?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#how-do-we-distribute-rewards","content":" Currently, rewards are distributed as follows: The consumer periodically sends rewards on the provider ConsumerRewardsPool address. The provider then transfers those rewards to the fee collector address and those transferred rewards are distributed to validators and delegators.  In PSS, we distribute rewards only to validators that actually validate the consumer chain. To do this, we have a pool associated with each consumer chain and consumers IBC transfer the rewards to this pool. We then extract the rewards from each consumer pool and distribute them to the opted in validators.  Note that we only distribute rewards to validators that have been opted in for some time (e.g., 10000 blocks) to avoid cases where validators opt in just to receive rewards and then opt out immediately afterward.  ","version":"v5.2.0","tagName":"h3"},{"title":"Misbehaviour​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#misbehaviour","content":" Fraud votes​  In an Opt In chain, a set of validators might attempt to perform an attack. To deter such potential attacks, PSS allows for the use of fraud votes. A fraud vote is a governance proposal that enables the slashing of validators that performed an attack. Due to their inherent complexity, we intend to introduce fraud votes in a different ADR and at a future iteration of PSS.  Double signing​  We do not change the way slashing for double signing and light client attacks functions. If a validator misbehaves on a consumer, then we slash that validator on the provider.  Downtime​  We do not change the way downtime jailing functions. If a validator is down on a consumer chain for an adequate amount of time, we jail this validator on the provider but only if the validator was opted in on this consumer chain in the recent past.  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#positive","content":" Easier for new consumer chains to consume the provider's chain economic security because proposals are more likely to pass if not everyone is forced to validate. Smaller validators are not forced to validate chains anymore if they do not want to. We can deprecate the soft opt-out implementation.  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#negative","content":" A consumer chain does not receive the same economic security as with Replicated Security (assuming the value of SoftOptOutThreshold is 5%), unless it is a Top N chain with N &gt;= 95%.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v5.2.0/adrs/adr-015-partial-set-security#references","content":" PSS: Permissionless vs premissioned-lite opt-in consumer chainsCHIPs discussion phase: Partial Set Security (updated)PSS: Exclusive vs Inclusive Top-NInitial PSS ADR and notes #1518Replicated vs. Mesh Security ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 016: Security aggregation","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#changelog","content":" 2024-04-24: Initial draft of ADR  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#status","content":" Proposed  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#context","content":" Security Aggregation enables staking of tokens from external sources such as Ethereum or Bitcoin to Cosmos blockchains. By integrating Security Aggregation, a Cosmos blockchain can be secured by both native tokens and external tokens (e.g. ETH, BTC).  Security Aggregation consists of the following parts:  A mechanism for delegating external tokens to Cosmos validators, such as Babylon or EigenLayer AVS contract.An oracle that tracks how much external stake has been delegated to each Cosmos validator and provides price feeds for external tokens.Power mixing: a mechanism to combine external and native stake to derive the power of each validator.A reward distribution protocol that enables sending back rewards to the external source.  External staking information is received from an oracle together with price information of related stakes. The CosmosLayer derives validator powers based on external and native staking information and initiates rewarding of external depositors.  This ADR describes the Cosmos modules of the solution.  ","version":"v5.2.0","tagName":"h2"},{"title":"Alternative Approaches​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#alternative-approaches","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Rewards​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#rewards","content":" As an alternative to sending rewards back to the external chains, stakers could be rewarded on the Cosmos chain. This would require a mapping of external addresses to addresses on Cosmos chain for each staker on external source. In addition detailed external staking information such as staking addresses, amount of stakes per staker and validator, etc. have to be provided by the oracle.  ","version":"v5.2.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#decision","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#rewards-will-be-sent-back-to-external-chains-instead-of-paying-rewards-for-external-stakers-on-cosmos-chain","content":" Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain  due to amount of additional staking information to be sent and tracked by the oracledue to the additional complexity of managing external and Cosmos addresses  ","version":"v5.2.0","tagName":"h3"},{"title":"Detailed Design​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#detailed-design","content":" The Power Mixing feature and Reward Distribution protocol are an integral part of the Security Aggregation solution. The Power Mixing module provides the capability of deriving validator power based on stake originated from external sources such as Ethereum/Bitcoin and the native staking module. The Reward Distribution manages the process of sending rewards to external stakers.  ","version":"v5.2.0","tagName":"h2"},{"title":"Power Mixing​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#power-mixing","content":" Power Mixing provides the final validator powers based on staking information of the native chain and the external stakes. The information about external staking and related price feeds are received from an oracle. Once the final validator powers are determined the result is submitted to the underlying CometBFT consensus layer by updating the validator set.  Requirements:  validator updates are performed on each EndBlocka validator's power is determined based on its native on-chain stakes and external stakesprice information of staked tokens is used to determine a validator’s power, e.g. price ratio (price of native on-chain token / price of external stake)price information of native/external tokens are received from an oraclestaking information from external sources received from the oraclenative staking information are received from the Cosmos SDK Staking Moduleset of validator stakes from oracle always have the current price, full set of validators, and current stakes  The Power Mixing implementation  queries current validators and their powers from x/stakingand from oracle (see below).calculates power updates by mixing power values of external and internal sources Following pseudocode snippet shows a possible implementation of how power mixing feature works.  // PowerSource is an abstract entity providing validator powers which // are used by the mixer. This can be an oracle, staking module or an // IBC connected bridge. type PowerSource interface { GetValidatorUpdates() []abci.ValidatorUpdate } // MixPowers calculates power updates by mixing validator powers from different sources func (k *Keeper) MixPowers(source ...PowerSource) []abci.ValidatorUpdate { var valUpdate []abci.ValidatorUpdate for _, ps := range source { // mix powers from two sets of validator updates an return set of validator updates // with aggregated powers valUpdate = mixPower(valUpdate, ps.GetValidatorUpdates()) } return valUpdate } func (k *keeper) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { // GetPowerSources (including local staking module) registeredPowerSource := GetPowerSources() return k.MixPowers(registeredPowerSource...) }   Integration with ICS provider​  The provider module updates the validator set on CometBFT instead of the SDK staking module (x/staking). The provider implementation will intervene in this behavior and ensure that the validator updates are taken from the Power Mixing feature.  External power sources are managed by the provider module. Only registered power sources can provide input to the Power Mixing feature. Power sources will be assigned a unique identifier which will be used by the oracle, provider module and the power mixing and rewarding feature.  Updates with the next validator set are sent to consumer chains on each epoch (see EndBlockVSU()). When collecting the validator updates for each consumer chain (see QueueVSCPackets()), the validator powers of the bonded validators will be updated with the validator powers from the external sources using the Power Mixing module. These updates are sent as part of the VSC packets to all registered consumer chains.  Integration with ICS consumer​  Consumer chains receive validator updates as part of VSC packets from the provider. These packets contain validator powers which were already mixed with external staked powers.  ","version":"v5.2.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#queries","content":" // GetValidatorUpdates returns the power mixed validator results from the provided sources service Query { rpc GetValidatorUpdates(PowerMixedValUpdateRequest) PowerMixedValUpdateResponse {}; } // PowerMixedValUpdateRequest contains the list of power sources on which the // power mixing should be based on message PowerMixedValUpdateRequest { repeated PowerSource sources; } // PowerMixedValUpdateResponse returns the validator set with the updated powers // from the power mixing feature message PowerMixedValUpdateResponse { repeated abci.ValidatorUpdate val_set }   The following queries will be provided by the oracle  service Query { rpc GetExtValidators(GetExtValidatorRequest) returns (ExtValidatorsResponse) { option (google.api.http).get = &quot;oracle/v1/get_validators&quot;; }; } message GetExtValidatorRequest {} // ExtValidatorsResponse is the response from GetExtValidators queries message ExtValidatorsResponse { repeated ExtValPower powers; } // ExtValPower represents a validator with its staking and token information, // where: // `power_source_identifier` is the identifier of the registered power source // `validator_address` is the address of the validator // `stakes` is the total amount of stakes for a validator // `denom` is the source token of the stake e.g. ETH,BTC // `price_ratio` is the ratio of price of the external token to the price of the 'local' token message ExtValPower { string power_source_identifier; string validator_address; uint64 stakes; string denom; float price_ratio; } // GetPrice returns a price feed for a given token service Query { rpc GetPrice(GetPriceRequest) returns (GetPriceResponse) { option (google.api.http).get = &quot;/oracle/v1/get_price&quot;; }; }   For security reasons the amount of external stakes needs to be limited. Limitation of external staking could be driven by governance and is not subject of this version of the ADR.  ","version":"v5.2.0","tagName":"h3"},{"title":"Reward Handler​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#reward-handler","content":" For native staked tokens the Distribution Module of the Cosmos SDK is taking care of sending the rewards to stakers. For stakes originated from external chains (Ethereum/Bitcoin) the Reward Handler module sends rewards to EigenLayer/Babylon. The transfer of rewards is done using a bridge between the Cosmos chain and the external provider chain.  Note: currently there's no support paying rewards on EigenLayer (see here)  ","version":"v5.2.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#positive","content":" Allow external depositors to stake their tokens to secure a Cosmos chain  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#negative","content":" Dependency to external sources e.g (price feeds) for validator power calculationSecurity impact  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#neutral","content":" Additional complexity for staking  ","version":"v5.2.0","tagName":"h3"},{"title":"Questions:​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#questions","content":" Slashing: subject of this ADR? (Defined but not activated currently on EigenLayer).  ","version":"v5.2.0","tagName":"h2"},{"title":"References​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v5.2.0/adrs/adr-016-securityaggregation#references","content":" EigenLayerBabylon ","version":"v5.2.0","tagName":"h2"},{"title":"ADR 017: ICS with Inactive Provider Validators","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators","content":"","keywords":"","version":"v5.2.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#changelog","content":" 15th May 2024: Initial draft  ","version":"v5.2.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#status","content":" Proposed  ","version":"v5.2.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#context","content":" Currently, only validators in the active set on the provider can validate on consumer chains, which limits the number of validators that can participate in Interchain Security (ICS). Validators outside of the active set might be willing to validate on consumer chains, but we might not want to make the provider validator set larger, e.g. to not put more strain on the consensus engine. This runs the risk of leaving consumer chains with too few validators.  The purpose of this ADR is to allow validators that are not part of the consensus process on the provider chain (because they are inactive) to validate on consumer chains.  In the context of this ADR, &quot;consensus validator set&quot; is the set of validators participating in the consensus protocol, and &quot;staking validator set&quot; is the set of validators viewed as active by the staking module.  Currently, the staking module, provider module, and CometBFT interact in this way:    The staking module keeps a list of validators. The MaxValidators validators with the largest amount of stake are &quot;active&quot; validators. MaxValidators is a parameter of the staking module. The staking module sends these validators to CometBFT to inform which validators make up the next consensus validators, that is, the set of validators participating in the consensus process. Separately, the provider module reads the list of bonded validators and sends this to the consumer chain, after shaping it according to which validators are opted in and the parameters set by the consumer chain for allowlist, denylist, etc.  ","version":"v5.2.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#decision","content":" The proposed solution to allow validators that are not participating in the consensus process on the provider (inactive validators) is to change 3 main things:  a) increase the MaxValidators parameter of the staking module  b) do not take the updates for CometBFT directly from the bonded validators in the staking module, by wrapping the staking modules EndBlocker with a dummy EndBlocker that doesn't return any validator updates. Instead, we adjust the provider module to return validator updates on its EndBlocker. These validator updates are obtained by filtering the bonded validators to send only the first MaxProviderConsensusValidators (sorted by largest amount of stake first) many validators to CometBFT  c) use the enlarged list of bonded validators from the staking module as basis for the validator set that the provider module sends to consumer chains (again after applying power shaping and filtering out validatiors that are not opted in).  In consequence, the provider chain can keep a reasonably-sized consensus validator set, while giving consumer chains a much larger pool of potential validators.    Some additional considerations:  Migration: In the migration, the last consensus validator set will be set to the last active validator set from the view of the staking module. Existing consumer chains are migrated to have a validator set size cap (otherwise, they could end up with a huge validator set including all the staking-but-not-consensus-active validators from the provider chain)Slashing: Validators that are not part of the active set on the provider chain can still be jailed for downtime on a consumer chain (via an Interchain Security SlashPacket sent to the provider, who will then jail the validator), but they are not slashed for downtime on the provider chain. This is achieved without any additional changes to the slashing module, because the slashing module checks for downtime by looking at the consensus participants reported by CometBFT, and thus with the proposed solution, validators that are not part of the consensus validators on the provider chain are not considered for downtime slashing (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/slashing/abci.go#L22).Rewards: Validators that are not part of the active set on the provider chain can still receive rewards on the consumer chain, but they do not receive rewards from the provider chain. This change is achieved without further changes to staking or reward distributions, because similar to downtime, rewards are based on the consensus validator set (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/distribution/abci.go#L28)  ","version":"v5.2.0","tagName":"h2"},{"title":"Changes to the state​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#changes-to-the-state","content":" The following changes to the state are required:  Introduce the MaxProviderConsensusValidators parameter to the provider module, which is the number of validators that the provider module will send to consumer chains.Store the provider consensus validator set in the provider module state under the LastProviderConsensusValsPrefix key. This is the last set of validators that the provider sent to the consensus engine. This is needed to compute the ValUpdates to send to the consensus engine (by diffing the current set with this last sent set).Increase the MaxValidators parameter of the staking module to the desired size of the potential validator set of consumer chains.  ","version":"v5.2.0","tagName":"h3"},{"title":"Risk Mitigations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#risk-mitigations","content":" To mitigate risks from validators with little stake, we introduce a minimum stake requirement for validators to be able to validate on consumer chains, which can be set by each consumer chain independently, with a default value set by the provider chain.  Additionally, we independently allow individual consumer chains to disable this feature, which will disallow validators from outside the provider active set from validating on the consumer chain and revert them to the previous behaviour of only considering validators of the provider that are part of the active consensus validator set.  Additional risk mitigations are to increase the active set size slowly, and to monitor the effects on the network closely. For the first iteration, we propose to increase the active set size to 200 validators (while keeping the consensus validators to 180), thus letting the 20 validators with the most stake outside of the active set validate on consumer chains.  ","version":"v5.2.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#consequences","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#positive","content":" Validators outside of the active set can validate on consumer chains without having an impact on the consensus engine of the provider chainConsumer chains can have a much larger validator set than the provider chain if they prefer this e.g. for decentralization reasonsConsumer chain teams can, with much less cost than today, start up their own consumer chain node to keep the chain running (in a centralized manner) even if no hub validators have opted in to validate on the chain. This is useful to stop the chain from ending up with an empty validator set and becoming recoverable only with a hardfork  ","version":"v5.2.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#negative","content":" Allowing validators from the inactive set brings with it some additional risks. In general, consumer chains will now face some of the problems also faced by standalone chains. It’s reasonable to assume that the validator set on the hub has a minimum amount of operational quality due to being battle tested and decentralized, and consumer chains with validators from outside the hub active set cannot rely on this as much anymore.  Sybil attacks​  With the restricted size of the active set today, it’s clear that the set is at least minimally competitive and it is not trivial to spin up multiple nodes as a validator.  When we make the “potential validator set” much larger, we should assume that it becomes much less competitive to be part of that set, and thus trivial for single entities to control many of those validators.  Reputational damage is not a deterrent​  For validators in the active set, we typically assume that if they would misbehave, they pay a large reputational cost. This represents delegators deciding to switch validators (potentially even on chains other than the one the misbehaviour happened on), and loss of credibility in the ecosystem. With the much larger active set, it seems prudent to assume that reputational damage is not a deterrent for many validators. They might only have minimal amounts of delegated stake and control most of it themselves, so they might not be deterred from performing actions that would usually bring reputational damage.  Additional negative consequences​  The provider keeper will need to implement the staking keeper interface, and modules need to be wired up to either the staking or provider keeper, depending on whether they need the consensus or staking validator setThis will impact how future modules are integrated, since we will need to consider whether those modules should consider the consensus validators or the bonded validators (which other modules might assume to be the same)  ","version":"v5.2.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#neutral","content":" There might be validators that are bonded, but not validating on any chain at all. This is not a problem, but it might be a bit confusing.  ","version":"v5.2.0","tagName":"h3"},{"title":"Alternative considerations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#alternative-considerations","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Modifying the staking module​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#modifying-the-staking-module","content":" We could instead adapt the staking module with a similar change. This might be better if it turns out that the staking module active set is used in many other places.  ","version":"v5.2.0","tagName":"h3"},{"title":"Allowing unbonding validators to validate​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#allowing-unbonding-validators-to-validate","content":" Instead of increasing the active set size, we could allow validators that are unbonded (but still exist on the provider) to validate consumer chains. For this, we would need to:  Modify the VSC updates to consider the set of all validators, even unbonded ones, instead of just active onesAdjust our downtime jailing/equivocation slashing logic to work correctly with unbonded validators. This is very hard, because redelegations are not usually tracked for unbonded validators.  ","version":"v5.2.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v5.2.0/adrs/adr-017-allowing-inactive-validators#references","content":" Security Aggregation has similar concerns where the staking validator set will differ from the consensus validator set ","version":"v5.2.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/adrs/intro","content":"","keywords":"","version":"v5.2.0"},{"title":"Table of Contents​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/adrs/intro#table-of-contents","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Accepted​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/adrs/intro#accepted","content":" ADR 001: Key AssignmentADR 002: Jail ThrottlingADR 004: Denom DOS fixesADR 005: Cryptographic verification of equivocation evidenceADR 008: Throttle with retriesADR 010: Standalone to Consumer ChangeoverADR 013: Slashing on the provider for consumer equivocationADR 014: EpochsADR 015: Partial Set Security  ","version":"v5.2.0","tagName":"h3"},{"title":"Proposed​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/adrs/intro#proposed","content":" ADR 011: Improving testing and increasing confidenceADR 016: Security aggregationADR 017: ICS with Inactive Provider Validators  ","version":"v5.2.0","tagName":"h3"},{"title":"Rejected​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/adrs/intro#rejected","content":" ADR 007: Pause validator unbonding during equivocation proposalADR 012: Separate Releasing  ","version":"v5.2.0","tagName":"h3"},{"title":"Deprecated​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/adrs/intro#deprecated","content":" ADR 003: Equivocation governance proposalADR 009: Soft Opt-Out ","version":"v5.2.0","tagName":"h3"},{"title":"Developing an ICS consumer chain","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/consumer-development/app-integration","content":"","keywords":"","version":"v5.2.0"},{"title":"Basic consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v5.2.0/consumer-development/app-integration#basic-consumer-chain","content":" The source code for the example app can be found here.  Please note that consumer chains do not implement the staking module - part of the validator set of the provider is replicated over to the consumer, meaning that the consumer uses a subset of provider validator set and the stake of the validators on the provider determines their stake on the consumer. Note that after the introduction of Partial Set Security, not all the provider validators have to validate a consumer chain (e.g., if top_N != 100).  Your chain should import the consumer module from x/consumer and register it in the correct places in your app.go. The x/consumer module will allow your chain to communicate with the provider using the ICS protocol. The module handles all IBC communication with the provider, and it is a simple drop-in. You should not need to manage or override any code from the x/consumer module.  ","version":"v5.2.0","tagName":"h2"},{"title":"Democracy consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v5.2.0/consumer-development/app-integration#democracy-consumer-chain","content":" The source code for the example app can be found here.  This type of consumer chain wraps the basic CosmosSDK x/distribution, x/staking and x/governance modules allowing the consumer chain to perform democratic actions such as participating and voting within the chain's governance system.  This allows the consumer chain to leverage those modules while also using the x/consumer module.  With these modules enabled, the consumer chain can mint its own governance tokens, which can then be delegated to prominent community members which are referred to as &quot;representatives&quot; (as opposed to &quot;validators&quot; in standalone chains). The token may have different use cases besides just voting on governance proposals.  ","version":"v5.2.0","tagName":"h2"},{"title":"Standalone chain to consumer chain changeover​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v5.2.0/consumer-development/app-integration#standalone-chain-to-consumer-chain-changeover","content":" See the standalone chain to consumer chain changeover guide for more information on how to transition your standalone chain to a consumer chain. ","version":"v5.2.0","tagName":"h2"},{"title":"Consumer Chain Governance","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/consumer-development/consumer-chain-governance","content":"","keywords":"","version":"v5.2.0"},{"title":"Democracy module​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v5.2.0/consumer-development/consumer-chain-governance#democracy-module","content":" The democracy module provides a governance experience identical to what exists on a standalone Cosmos chain, with one small but important difference. On a standalone Cosmos chain validators can act as representatives for their delegators by voting with their stake, but only if the delegator themselves does not vote. This is a lightweight form of liquid democracy.  Using the democracy module on a consumer chain is the exact same experience, except for the fact that it is not the actual validator set of the chain (since it is a consumer chain, these are the Cosmos Hub validators) acting as representatives. Instead, there is a separate representative role who token holders can delegate to and who can perform the functions that validators do in Cosmos governance, without participating in proof of stake consensus.  For an example, see the Democracy Consumer  ","version":"v5.2.0","tagName":"h2"},{"title":"CosmWasm​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v5.2.0/consumer-development/consumer-chain-governance#cosmwasm","content":" There are several great DAO and governance frameworks written as CosmWasm contracts. These can be used as the main governance system for a consumer chain. Actions triggered by the CosmWasm governance contracts are able to affect parameters and trigger actions on the consumer chain.  For an example, see Neutron.  ","version":"v5.2.0","tagName":"h2"},{"title":"The Whitelist​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v5.2.0/consumer-development/consumer-chain-governance#the-whitelist","content":" Not everything on a consumer chain can be changed by the consumer's governance. Some settings having to do with consensus etc. can only be changed by the provider chain. Consumer chains include a whitelist of parameters that are allowed to be changed by the consumer chain governance. For an example, see Neutron's whitelist. ","version":"v5.2.0","tagName":"h2"},{"title":"Consumer Offboarding","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/consumer-development/offboarding","content":"Consumer Offboarding To offboard a consumer chain simply submit a ConsumerRemovalProposal governance proposal listing a stop_time. After stop time passes, the provider chain will remove the chain from the ICS protocol (it will stop sending validator set updates). // ConsumerRemovalProposal is a governance proposal on the provider chain to remove (and stop) a consumer chain. // If it passes, all the consumer chain's state is removed from the provider chain. The outstanding unbonding // operation funds are released. { // the title of the proposal &quot;title&quot;: &quot;This was a great chain&quot;, &quot;description&quot;: &quot;Here is a .md formatted string specifying removal details&quot;, // the chain-id of the consumer chain to be stopped &quot;chain_id&quot;: &quot;consumerchain-1&quot;, // the time on the provider chain at which all validators are responsible to stop their consumer chain validator node &quot;stop_time&quot;: &quot;2023-03-07T12:40:00.000000Z&quot;, } More information will be listed in a future version of this document.","keywords":"","version":"v5.2.0"},{"title":"Consumer Genesis Transformation","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/consumer-development/consumer-genesis-transformation","content":"","keywords":"","version":"v5.2.0"},{"title":"1. Prerequisite​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v5.2.0/consumer-development/consumer-genesis-transformation#1-prerequisite","content":" used provider and consumer versions require transformation step as indicated in in the compatibility notesinterchain-security-cd application supports the versions used by the consumer and provider  ","version":"v5.2.0","tagName":"h2"},{"title":"2. Export the CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v5.2.0/consumer-development/consumer-genesis-transformation#2-export-the-ccv-data","content":" Export the CCV data from the provider chain as described in the Onboarding and Changeover your following. As a result the CCV data will be stored in a file in JSON format.  ","version":"v5.2.0","tagName":"h2"},{"title":"3. Transform CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v5.2.0/consumer-development/consumer-genesis-transformation#3-transform-ccv-data","content":" To transform the CCV data  to the format supported by the current version of the consumer run the following command: interchain-security-cd genesis transform [genesis-file] where 'genesis-file' is the path to the file containing the CCV data exported in step 2. As a result the CCV data in the new format will be written to standard output.a specific target version of a consumer run the following command: interchain-security-cd genesis transform --to &lt;target_version&gt; [genesis-file] where &lt;target_version is the ICS version the consumer chain is running. Use interchain-security-cd genesis transform --help to get more details about supported target versions and more.  Use the new CCV data as described in the procedure you're following. ","version":"v5.2.0","tagName":"h2"},{"title":"Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure","content":"","keywords":"","version":"v5.2.0"},{"title":"Overview​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#overview","content":" Standalone to consumer changeover procedure can roughly be separated into 4 parts:  ","version":"v5.2.0","tagName":"h2"},{"title":"1. ConsumerAddition proposal submitted to the provider chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#1-consumeraddition-proposal-submitted-to-the-provider-chain","content":" The proposal is equivalent to the &quot;normal&quot; ConsumerAddition proposal submitted by new consumer chains.  However, here are the most important notes and differences between a new consumer chain and a standalone chain performing a changeover:  chain_id must be equal to the standalone chain idinitial_height field has additional rules to abide by:  caution { ... &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. stride-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_height&quot;: 1, }, ... } RevisionNumber: 0, RevisionHeight: 111  genesis_hash can be safely ignored because the chain is already running. A hash of the standalone chain's initial genesis may be used binary_hash may not be available ahead of time. All chains performing the changeover go through rigorous testing - if bugs are caught and fixed the hash listed in the proposal may not be the most recent one. spawn_time listed in the proposal MUST be before the upgrade_height listed in the upgrade proposal on the standalone chain.  caution spawn_time must occur before the upgrade_height on the standalone chain is reached because the provider chain must generate the ConsumerGenesis that contains the validator set that will be used after the changeover.  unbonding_period must correspond to the value used on the standalone chain. Otherwise, the clients used for the ccv protocol may be incorrectly initialized. distribution_transmission_channel should be set.  note Populating distribution_transmission_channel will enable the standalone chain to reuse one of the existing channels to the provider for consumer chain rewards distribution. This will preserve the ibc denom that may already be in use. If the parameter is not set, a new channel will be created.  ccv_timeout_period has no important notes transfer_timeout_period has no important notes consumer_redistribution_fraction has no important notes blocks_per_distribution_transmission has no important notes historical_entries has no important notes  ","version":"v5.2.0","tagName":"h3"},{"title":"2. upgrade proposal on standalone chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#2-upgrade-proposal-on-standalone-chain","content":" The standalone chain creates an upgrade proposal to include the interchain-security/x/ccv/consumer module.  caution The upgrade height in the proposal should correspond to a height that is after the spawn_time in the consumer addition proposal submitted to the provider chain.  Otherwise, the upgrade is indistinguishable from a regular on-chain upgrade proposal.  ","version":"v5.2.0","tagName":"h3"},{"title":"3. spawn time is reached​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#3-spawn-time-is-reached","content":" When the spawn_time is reached on the provider it will generate a ConsumerGenesis that contains the validator set that will supersede the standalone validator set.  This ConsumerGenesis must be available on the standalone chain during the on-chain upgrade.  ","version":"v5.2.0","tagName":"h3"},{"title":"4. standalone chain upgrade​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#4-standalone-chain-upgrade","content":" Performing the on-chain upgrade on the standalone chain will add the ccv/consumer module and allow the chain to become a consumer of Interchain Security.  caution The ConsumerGenesis must be exported to a file and placed in the correct folder on the standalone chain before the upgrade. The file must be placed at the exact specified location, otherwise the upgrade will not be executed correctly. Usually the file is placed in $NODE_HOME/config, but the file name and the exact directory is dictated by the upgrade code on the standalone chain. please check exact instructions provided by the standalone chain team  After the genesis.json file has been made available, the process is equivalent to a normal on-chain upgrade. The standalone validator set will sign the next couple of blocks before transferring control to provider validator set.  The standalone validator set can still be slashed for any infractions if evidence is submitted within the unboding_period.  Notes​  The changeover procedure may be updated in the future to create a seamless way of providing the validator set information to the standalone chain.  ","version":"v5.2.0","tagName":"h3"},{"title":"Onboarding Checklist​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#onboarding-checklist","content":" This onboarding checklist is slightly different from the one under Onboarding  Additionally, you can check the testnet repo for a comprehensive guide on preparing and launching consumer chains.  ","version":"v5.2.0","tagName":"h2"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.4.1) test the changeover procedure reach out to the ICS team if you are facing issues  ","version":"v5.2.0","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json with CCV data (after spawn time passes). Check if CCV data needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) copy of your governance proposal (as JSON) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"v5.2.0","tagName":"h2"},{"title":"3. Submit a ConsumerChainAddition Governance Proposal to the provider​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#3-submit-a-consumerchainaddition-governance-proposal-to-the-provider","content":" Before you submit a ConsumerChainAddition proposal, please provide a spawn_time that is before the upgrade_height of the upgrade that will introduce the ccv module to your chain.  danger If the spawn_time happens after your upgrade_height the provider will not be able to communicate the new validator set to be used after the changeover.  Additionally, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters to be put in the proposal take note to include a link to your onboarding repository  Example of a consumer chain addition proposal (compare with the ConsumerAdditionProposal in the ICS Provider Proposals section for chains that launch as consumers):  // ConsumerAdditionProposal is a governance proposal on the provider chain to spawn a new consumer chain or add a standalone chain. // If it passes, then a subset (i.e., depends on `top_N` and on the power shaping parameters) of validators on the provider chain are expected // to validate the consumer chain at spawn time. It is recommended that spawn time occurs after the proposal end time and that it is // scheduled to happen before the standalone chain upgrade that sill introduce the ccv module. { // Title of the proposal &quot;title&quot;: &quot;Changeover Standalone chain&quot;, // Description of the proposal // format the text as a .md file and include the file in your onboarding repository &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, // Proposed chain-id of the new consumer chain. // Must be unique from all other consumer chain ids of the executing provider chain. &quot;chain_id&quot;: &quot;standalone-1&quot;, // Initial height of new consumer chain. &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. standalone-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_number&quot;: 1, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // =&gt; not relevant for changeover procedure &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on standalone chain upgrade // =&gt; not relevant for changeover procedure as it may become stale &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and all validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should should be smaller than that of the provider. &quot;unbonding_period&quot;: 86400000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 259200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot; // NOTE: use existing transfer channel if available // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. &quot;top_N&quot;: 95, // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis. &quot;validators_power_cap&quot;: 0, // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. &quot;validator_set_cap&quot;: 0, // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate // the consumer chain. &quot;allowlist&quot;: [], // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. &quot;denylist&quot;: [] }   info As seen in the ConsumerAdditionProposal example above, the changeover procedure can be used together with Partial Set Security. This means, that a standalone chain can choose to only be validated by some of the validators of the provider chain by setting top_N appropriately, or by additionally setting a validators-power cap, validator-set cap, etc. by using the power-shaping parameters.  ","version":"v5.2.0","tagName":"h2"},{"title":"3. Submit an Upgrade Proposal & Prepare for Changeover​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#3-submit-an-upgrade-proposal--prepare-for-changeover","content":" This proposal should add the ccv consumer module to your chain.   proposal upgrade_height must happen after spawn_time in the ConsumerAdditionProposal advise validators about the exact procedure for your chain and point them to your onboarding repository  ","version":"v5.2.0","tagName":"h2"},{"title":"4. Upgrade time 🚀​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v5.2.0/consumer-development/changeover-procedure#4-upgrade-time-","content":"  after spawn_time, request ConsumerGenesis from the provider and place it in &lt;CURRENT_USER_HOME_DIR&gt;/.sovereign/config/genesis.json upgrade the binary to the one listed in your UpgradeProposal  The chain starts after at least 66.67% of standalone voting power comes online. The consumer chain is considered interchain secured once the &quot;old&quot; validator set signs a couple of blocks and transfers control to the provider validator set.   provide a repo with onboarding instructions for validators (it should already be listed in the proposal) genesis.json after spawn_time obtained from provider (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) ","version":"v5.2.0","tagName":"h2"},{"title":"Consumer Onboarding Checklist","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/consumer-development/onboarding","content":"","keywords":"","version":"v5.2.0"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v5.2.0/consumer-development/onboarding#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.4.1) reach out to the ICS team if you are facing issues  ","version":"v5.2.0","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v5.2.0/consumer-development/onboarding#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json without CCV data (before the proposal passes) genesis.json with CCV data (after spawn time passes). Check if CCV data needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) copy of your governance proposal (as JSON) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"v5.2.0","tagName":"h2"},{"title":"3. Submit a Governance Proposal​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v5.2.0/consumer-development/onboarding#3-submit-a-governance-proposal","content":" Before you submit a ConsumerChainAddition proposal, please consider allowing at least a day between your proposal passing and the chain spawn time. This will allow the validators, other node operators and the community to prepare for the chain launch. If possible, please set your spawn time so people from different parts of the globe can be available in case of emergencies. Ideally, you should set your spawn time to be between 12:00 UTC and 20:00 UTC so most validator operators are available and ready to respond to any issues.  Additionally, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters to be put in the proposal take note to include a link to your onboarding repository describe the purpose and benefits of running your chain determine whether your chain should be an Opt-In chain or a Top N chain (see Partial Set Security) if desired, decide on power-shaping parameters (see Power Shaping)  Example of a consumer chain addition proposal.  // ConsumerAdditionProposal is a governance proposal on the provider chain to spawn a new consumer chain. // If it passes, if the top_N parameter is not equal to 0, the top N% of validators by voting power on the provider chain are expected to validate the consumer chain at spawn time. // Otherwise, only validators that opted in during the proposal period are expected to validate the consumer chain at spawn time. // It is recommended that spawn time occurs after the proposal end time. { // Title of the proposal &quot;title&quot;: &quot;Add consumer chain&quot;, // Description of the proposal // format the text as a .md file and include the file in your onboarding repository &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, // Proposed chain-id of the new consumer chain. // Must be unique from all other consumer chain ids of the executing provider chain. &quot;chain_id&quot;: &quot;newchain-1&quot;, // Initial height of new consumer chain. // For a completely new chain, this will be {0,1}. &quot;initial_height&quot; : { &quot;revision_height&quot;: 0, &quot;revision_number&quot;: 1, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // It is used for off-chain confirmation of genesis.json validity by validators and other parties. &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on chain initialization. // It is used for off-chain confirmation of binary validity by validators and other parties. &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should be smaller than that of the provider. &quot;unbonding_period&quot;: 86400000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 259200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot;, // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. &quot;top_N&quot;: 95, // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis. &quot;validators_power_cap&quot;: 0, // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. &quot;validator_set_cap&quot;: 0, // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate // the consumer chain. &quot;allowlist&quot;: [], // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. &quot;denylist&quot;: [] }   ","version":"v5.2.0","tagName":"h2"},{"title":"4. Launch​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v5.2.0/consumer-development/onboarding#4-launch","content":" The consumer chain starts after at least 66.67% of its voting power comes online. Note that this means 66.67% of the voting power in the consumer validator set, which will be comprised of all validators that either opted in to the chain or are part of the top N% of the provider chain (and are thus automatically opted in). The consumer chain is considered interchain secured once the appropriate CCV channels are established and the first validator set update is propagated from the provider to the consumer   provide a repo with onboarding instructions for validators (it should already be listed in the proposal) genesis.json with ccv data populated (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) have a block explorer in place to track chain activity &amp; health ","version":"v5.2.0","tagName":"h2"},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/faq","content":"","keywords":"","version":"v5.2.0"},{"title":"What is a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#what-is-a-consumer-chain","content":" Consumer chain is a blockchain operated by (a subset of) the validators of the provider chain. The ICS protocol ensures that the consumer chain gets information about which validators should run it (informs consumer chain about the current state of the validator set and the opted in validators for this consumer chain on the provider).  Consumer chains are run on infrastructure (virtual or physical machines) distinct from the provider, have their own configurations and operating requirements.  ","version":"v5.2.0","tagName":"h2"},{"title":"What happens to consumer if provider is down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#what-happens-to-consumer-if-provider-is-down","content":" In case the provider chain halts or experiences difficulties the consumer chain will keep operating - the provider chain and consumer chains represent different networks, which only share the validator set.  The consumer chain will not halt if the provider halts because they represent distinct networks and distinct infrastructures. Provider chain liveness does not impact consumer chain liveness.  However, if the trusting_period (currently 5 days for protocol safety reasons) elapses without receiving any updates from the provider, the consumer chain will essentially transition to a Proof of Authority chain. This means that the validator set on the consumer will be the last validator set of the provider that the consumer knows about.  Steps to recover from this scenario and steps to &quot;release&quot; the validators from their duties will be specified at a later point. At the very least, the consumer chain could replace the validator set, remove the ICS module and perform a genesis restart. The impact of this on the IBC clients and connections is currently under careful consideration.  ","version":"v5.2.0","tagName":"h2"},{"title":"What happens to provider if consumer is down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#what-happens-to-provider-if-consumer-is-down","content":" Consumer chains do not impact the provider chain. The ICS protocol is concerned only with validator set management, and the only communication that the provider requires from the consumer is information about validator activity (essentially keeping the provider informed about slash events).  ","version":"v5.2.0","tagName":"h2"},{"title":"Can I run the provider and consumer chains on the same machine?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-i-run-the-provider-and-consumer-chains-on-the-same-machine","content":" Yes, but you should favor running them in separate environments so failure of one machine does not impact your whole operation.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can the consumer chain have its own token?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-the-consumer-chain-have-its-own-token","content":" As any other cosmos-sdk chain the consumer chain can issue its own token, manage inflation parameters and use them to pay gas fees.  ","version":"v5.2.0","tagName":"h2"},{"title":"How are Tx fees paid on consumer?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#how-are-tx-fees-paid-on-consumer","content":" The consumer chain operates as any other cosmos-sdk chain. The ICS protocol does not impact the normal chain operations.  ","version":"v5.2.0","tagName":"h2"},{"title":"Are there any restrictions the consumer chains need to abide by?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#are-there-any-restrictions-the-consumer-chains-need-to-abide-by","content":" No. Consumer chains are free to choose how they wish to operate, which modules to include, use CosmWASM in a permissioned or a permissionless way. The only thing that separates consumer chains from standalone chains is that they share their validator set with the provider chain.  ","version":"v5.2.0","tagName":"h2"},{"title":"What's in it for the validators and stakers?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#whats-in-it-for-the-validators-and-stakers","content":" The consumer chains sends a portion of its fees and inflation as reward to the provider chain as defined by ConsumerRedistributionFraction. The rewards are distributed (sent to the provider) every BlocksPerDistributionTransmission.  note ConsumerRedistributionFraction and BlocksPerDistributionTransmission are parameters defined in the ConsumerAdditionProposal used to create the consumer chain. These parameters can be changed via consumer chain governance.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can the consumer chain have its own governance?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-the-consumer-chain-have-its-own-governance","content":" Yes.  In that case the validators are not necessarily part of the governance structure. Instead, their place in governance is replaced by &quot;representatives&quot; (governors). The representatives do not need to run validators, they simply represent the interests of a particular interest group on the consumer chain.  Validators can also be representatives but representatives are not required to run validator nodes.  This feature discerns between validator operators (infrastructure) and governance representatives which further democratizes the ecosystem. This also reduces the pressure on validators to be involved in on-chain governance.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can validators opt out of validating a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-validators-opt-out-of-validating-a-consumer-chain","content":" A validator can always opt out from an Opt-In consumer chain. A validator can only opt out from a Top N chain if the validator does not belong to the top N% validators.  ","version":"v5.2.0","tagName":"h2"},{"title":"How does Slashing work?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#how-does-slashing-work","content":" Validators that perform an equivocation or a light-client attack on a consumer chain are slashed on the provider chain. We achieve this by submitting the proof of the equivocation or the light-client attack to the provider chain (see slashing).  ","version":"v5.2.0","tagName":"h2"},{"title":"Can Consumer Chains perform Software Upgrades?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-consumer-chains-perform-software-upgrades","content":" Consumer chains are standalone chains, in the sense that they can run arbitrary logic and use any modules they want (ie CosmWASM).  Consumer chain upgrades are unlikely to impact the provider chain, as long as there are no changes to the ICS module.  ","version":"v5.2.0","tagName":"h2"},{"title":"How can I connect to the testnets?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#how-can-i-connect-to-the-testnets","content":" Check out the Joining Interchain Security testnet section.  ","version":"v5.2.0","tagName":"h2"},{"title":"How do I start using ICS?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#how-do-i-start-using-ics","content":" To become a consumer chain use this checklist and check the App integration section  ","version":"v5.2.0","tagName":"h2"},{"title":"Which relayers are supported?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#which-relayers-are-supported","content":" Currently supported versions:  Hermes 1.8.0  ","version":"v5.2.0","tagName":"h2"},{"title":"How does key delegation work in ICS?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#how-does-key-delegation-work-in-ics","content":" You can check the Key Assignment Guide for specific instructions.  ","version":"v5.2.0","tagName":"h2"},{"title":"How does Partial Set Security work?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#how-does-partial-set-security-work","content":" Partial Set Security allows a provider chain to share only a subset of its validator set with a consumer chain. This subset can be determined by the top N% validators by voting power, or by validators opting in to validate the consumer chain. Partial Set Security allows for flexible tradeoffs between security, decentralization, and the budget a consumer chain spends on rewards to validators.  See the Partial Set Security section for more information.  ","version":"v5.2.0","tagName":"h2"},{"title":"How does a validator know which consumers chains it has to validate?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#how-does-a-validator-know-which-consumers-chains-it-has-to-validate","content":" In order for a validator to keep track of all the chains it has to validate, the validator can use thehas-to-validate query.  ","version":"v5.2.0","tagName":"h2"},{"title":"How many chains can a validator opt in to?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#how-many-chains-can-a-validator-opt-in-to","content":" There is no limit in the number of consumers chains a validator can choose to opt in to.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can validators assign a consensus keys while a consumer-addition proposal is in voting period?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-validators-assign-a-consensus-keys-while-a-consumer-addition-proposal-is-in-voting-period","content":" Yes, see the Key Assignment Guide for more information.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can validators assign a consensus key during the voting period for a consumer-addition proposal if they are not in the top N?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-validators-assign-a-consensus-key-during-the-voting-period-for-a-consumer-addition-proposal-if-they-are-not-in-the-top-n","content":" Yes.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can validators opt in to an Opt-in or Top N chain after its consumer-addition proposal voting period is over but before the spawn time?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-validators-opt-in-to-an-opt-in-or-top-n-chain-after-its-consumer-addition-proposal-voting-period-is-over-but-before-the-spawn-time","content":" Yes.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can validators opt in to an Opt-in chain after the spawn time if nobody else opted in?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-validators-opt-in-to-an-opt-in-chain-after-the-spawn-time-if-nobody-else-opted-in","content":" No, the consumer chain will not be added if nobody opted in by the spawn time. At least one validator, regardless of its voting power, must opt in before the spawn time arrives in order for the chain can start.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can all validators opt out of an Opt-in chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-all-validators-opt-out-of-an-opt-in-chain","content":" Yes, the consumer chain will halt with an ERR CONSENSUS FAILURE error after the opt-out message for the last validator is received.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can validators set a commission rate for chains they have not opted in to?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-validators-set-a-commission-rate-for-chains-they-have-not-opted-in-to","content":" Yes, and this is useful for validators that are not in the top N% of the provider chain, but might move into the top N% in the future. By setting the commission rate ahead of time, they can make sure that they immediately have a commission rate of their choosing as soon as they are in the top N%.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can a consumer chain modify its power shaping parameters?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-a-consumer-chain-modify-its-power-shaping-parameters","content":" Yes, by issuing a ConsumerModificationProposal.  ","version":"v5.2.0","tagName":"h2"},{"title":"Can a Top N consumer chain become Opt-In or vice versa?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v5.2.0/faq#can-a-top-n-consumer-chain-become-opt-in-or-vice-versa","content":" Yes, by issuing a ConsumerModificationProposal. ","version":"v5.2.0","tagName":"h2"},{"title":"Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/features/key-assignment","content":"","keywords":"","version":"v5.2.0"},{"title":"Rules​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v5.2.0/features/key-assignment#rules","content":" a key can be assigned as soon as the consumer addition proposal is submitted to the providervalidator A cannot assign consumer key K to consumer chain X if there is already a validator B (B!=A) using K on the providervalidator A cannot assign consumer key K to consumer chain X if there is already a validator B using K on Xa new validator on the provider cannot use a consensus key K if K is already used by any validator on any consumer chain  tip Validators can use a different key for each consumer chain.  ","version":"v5.2.0","tagName":"h2"},{"title":"Adding a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v5.2.0/features/key-assignment#adding-a-key","content":" First, create a new node on the consumer chain using the equivalent:  consumerd init &lt;moniker&gt;   Then query your node for the consensus key.  consumerd tendermint show-validator # {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, make an assign-consensus-key transaction on the provider chain in order to inform the provider chain about the consensus key you will be using for a specific consumer chain.  gaiad tx provider assign-consensus-key &lt;consumer-chain-id&gt; '&lt;pubkey&gt;' --from &lt;tx-signer&gt; --home &lt;home_dir&gt; --gas 900000 -b sync -y -o json   consumer-chain-id is the string identifier of the consumer chain, as assigned on the provider chainconsumer-pub-key has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}  Check that the key was assigned correctly by querying the provider:  gaiad query provider validator-consumer-key &lt;consumer-chain-id&gt; cosmosvalcons1e....3xsj3ayzf4uv6   You must use a valcons address. You can obtain it by querying your node on the provider gaiad tendermint show-address  OR  gaiad query provider validator-provider-key &lt;consumer-chain-id&gt; consumervalcons1e....123asdnoaisdao   You must use a valcons address. You can obtain it by querying your node on the consumer consumerd tendermint show-address  OR  gaiad query provider all-pairs-valconsensus-address &lt;consumer-chain-id&gt;   You just need to use the chainId of consumer to query all pairs valconsensus address with consumer-pub-key for each of pair  ","version":"v5.2.0","tagName":"h2"},{"title":"Changing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v5.2.0/features/key-assignment#changing-a-key","content":" To change your key, simply repeat all of the steps listed above. Take note that your old key will be remembered for at least the unbonding period of the consumer chain so any slashes can be correctly applied  ","version":"v5.2.0","tagName":"h2"},{"title":"Removing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v5.2.0/features/key-assignment#removing-a-key","content":" To remove a key, simply switch it back to the consensus key you have assigned on the provider chain by following steps in the Adding a key section and using your provider consensus key.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  ","version":"v5.2.0","tagName":"h2"},{"title":"Querying proposed consumer chains​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v5.2.0/features/key-assignment#querying-proposed-consumer-chains","content":" To query the consumer addition proposals that are in the voting period, you can use the following command on the provider:  gaiad query provider list-proposed-consumer-chains   This query is valuable for staying informed about when keys can be assigned to newly proposed consumer chains. ","version":"v5.2.0","tagName":"h2"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/features/partial-set-security","content":"Partial Set Security Partial Set Security (PSS) allows consumer chains to leverage only a subset of validators from the provider chain, which offers more flexibility than the traditional Replicated Security model. By introducing the top_N parameter, each consumer chain can choose the extent of security needed: Top N: Requires the top N% validators from the provider chain to secure the consumer chain. This guarantees that the validators with the most power on the provider will validate the consumer chain, while others can voluntarily opt in. Opt-In: If the top_N parameter is set to zero, no validator is mandated to secure the consumer chain. Instead, any validator from the provider chain can opt in using a dedicated transaction. An advantage of a Top N chain is that the consumer chain is guaranteed to receive at least a certain fraction of the market cap of the provider chain in security. In turn, this chain needs to be approved by governance, since validators will be forced to run the chain. Thus, Top N chains should typically expect to need to provide a strong case for why they should be added to the provider chain, and they should make sure they offer enough rewards to incentivize validators and delegators to vote for their proposal. Opt-In chains, on the other hand, are more flexible. While for technical reasons, they are also currently added via governance proposals, since validators are never forced to validate these chains and simply opt in if they want to, they should typically expect to get their proposals approved much more easily compared to Top N chains, since validators that do not want to validate the chain can simply choose not to opt in. However, opt in chains do not get a fixed amount of security as a relation of the market cap of the provider as top N chains do, so opt in chains might want to keep an eye on how many validators have opted in to validate their chain and adjust their reward emissions accordingly to incentivize validators. tip Partial Set Security is handled only by the provider chain - the consumer chains are simply sent validator sets, and they are not aware that this represents only a subset of the provider chain's validator set. caution Both Opt In and Top N chains currently require a governance proposal to be added to the provider chain. For Top N chains, this is also the long term vision for how they are launched. For Opt In chains, this is a temporary measure to prevent issues around chain ID squatting, i.e. someone could spuriously register many desirable chain IDs of upcoming consumer chain and simply deny legitimate consumer chains from using them. Eventually, the plan is to allow launching Opt In chains permissionlessly without going through governance, with quality control being handled by the market of validators deciding which chains they would like to validate on. tip A running Top N consumer chain might want to become an Opt-In chain or vice versa. This can be achieved by issuing a ConsumerModificationProposal.","keywords":"","version":"v5.2.0"},{"title":"Democracy modules","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/features/democracy-modules","content":"","keywords":"","version":"v5.2.0"},{"title":"Staking​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v5.2.0/features/democracy-modules#staking","content":" The democracy staking module allows the cosmos-sdk x/staking module to be used alongside the interchain security consumer module.  The module uses overrides that allow the full x/staking functionality with one notable difference - the staking module will no longer be used to provide the consensus validator set.  ","version":"v5.2.0","tagName":"h2"},{"title":"Implications for consumer chains​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v5.2.0/features/democracy-modules#implications-for-consumer-chains","content":" The x/ccv/democracy/staking allows consumer chains to separate governance from block production.  info The validator set coming from the provider chain does not need to participate in governance - they only provide infrastructure (create blocks and maintain consensus).  Governators (aka. Governors)​  Validators registered with the x/staking module become &quot;Governators&quot;.  Unlike Validators, Governators are not required to run any chain infastructure since they are not signing any blocks.  However, Governators retain a subset of the validator properties:  new Governators can be created (via MsgCreateValidator)Governators can accept delegationsGovernators can vote on governance proposals (with their self stake and delegations)Governators earn token rewards  With these changes, Governators can become community advocates that can specialize in chain governance and they get rewarded for their participation the same way the validators do.  Additionally, Governators can choose to provide additional infrastructure such as RPC/API access points, archive nodes, indexers and similar software.  Tokenomics​  The consumer chain's token will remain a governance and reward token. The token's parameters (inflation, max supply, burn rate) are not affected.  info Staking rewards are distributed to all Governators and their delegators after distributing the rewards to the provider chain's validator set.  ","version":"v5.2.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v5.2.0/features/democracy-modules#integration","content":" The x/ccv/democracy/staking module provides these x/staking overrides:   // InitGenesis delegates the InitGenesis call to the underlying x/staking module, // however, it returns no validator updates as validators are tracked via the // consumer chain's x/cvv/consumer module and so this module is not responsible for returning the initial validator set. func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run staking InitGenesis return []abci.ValidatorUpdate{} // do not return validator updates } // EndBlock delegates the EndBlock call to the underlying x/staking module. // However, no validator updates are returned as validators are tracked via the // consumer chain's x/cvv/consumer module. func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates return []abci.ValidatorUpdate{} // do not return validator updates }   To integrate the democracy/staking follow this guide:  1. confirm that no modules are returning validator updates​  tip Only the x/ccv/consumer module should be returning validator updates.  If some of your modules are returning validator updates please disable them while maintaining your business logic:  func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) -\treturn am.keeper.InitGenesis(ctx, &amp;genesisState) + _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run InitGenesis but drop the result +\treturn []abci.ValidatorUpdate{} // return empty validator updates } func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { -\treturn am.keeper.BlockValidatorUpdates(ctx) + _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates +\treturn []abci.ValidatorUpdate{} // return empty validator updates }   2. wire the module in app.go​  You do not need to remove the cosmos-sdk StakingKeeper from your wiring.  import ( ... + ccvstaking &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/staking&quot; ) var ( // replace the staking.AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, - sdkstaking.AppModuleBasic{}, + ccvstaking.AppModuleBasic{}, // replace sdkstaking ... ) ) func NewApp(...) { ... // use sdk StakingKeepeer app.StakingKeeper = stakingkeeper.NewKeeper( appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.MintKeeper = mintkeeper.NewKeeper( appCodec, keys[minttypes.StoreKey], app.StakingKeeper, app.AccountKeeper, app.BankKeeper, authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // no changes required for the distribution keeper app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // keep StakingKeeper! authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) + // pre-initialize ConsumerKeeper to satsfy ibckeeper.NewKeeper +\tapp.ConsumerKeeper = consumerkeeper.NewNonZeroKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), +\t) + +\tapp.IBCKeeper = ibckeeper.NewKeeper( + appCodec, + keys[ibchost.StoreKey], + app.GetSubspace(ibchost.ModuleName), + &amp;app.ConsumerKeeper, + app.UpgradeKeeper, + scopedIBCKeeper, +\t) + +\t// Create CCV consumer and modules +\tapp.ConsumerKeeper = consumerkeeper.NewKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), + scopedIBCConsumerKeeper, + app.IBCKeeper.ChannelKeeper, + &amp;app.IBCKeeper.PortKeeper, + app.IBCKeeper.ConnectionKeeper, + app.IBCKeeper.ClientKeeper, + app.SlashingKeeper, + app.BankKeeper, + app.AccountKeeper, + &amp;app.TransferKeeper, + app.IBCKeeper, + authtypes.FeeCollectorName, +\t) + +\t// Setting the standalone staking keeper is only needed for standalone to consumer changeover chains + // New chains using the democracy/staking do not need to set this +\tapp.ConsumerKeeper.SetStandaloneStakingKeeper(app.StakingKeeper) // change the slashing keeper dependency app.SlashingKeeper = slashingkeeper.NewKeeper( appCodec, legacyAmino, keys[slashingtypes.StoreKey], - app.StakingKeeper, + &amp;app.ConsumerKeeper, // ConsumerKeeper implements StakingKeeper interface authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register slashing module StakingHooks to the consumer keeper +\tapp.ConsumerKeeper = *app.ConsumerKeeper.SetHooks(app.SlashingKeeper.Hooks()) +\tconsumerModule := consumer.NewAppModule(app.ConsumerKeeper, app.GetSubspace(consumertypes.ModuleName)) // register the module with module manager // replace the x/staking module app.MM = module.NewManager( ... - sdkstaking.NewAppModule(appCodec, &amp;app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), + ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }   ","version":"v5.2.0","tagName":"h3"},{"title":"Governance​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v5.2.0/features/democracy-modules#governance","content":" The x/ccv/democracy/governance module extends the x/governance module with the functionality to filter proposals.  tip Consumer chains can limit in the types of governance proposals that can be executed on chain to avoid inadvertent changes to interchain security protocol that could affect security properties.  The module uses AnteHandler to limit the types of proposals that can be executed.  ","version":"v5.2.0","tagName":"h2"},{"title":"Integration​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v5.2.0/features/democracy-modules#integration-1","content":" Add new AnteHandler to your app.   // app/ante/forbidden_proposals.go package ante import ( &quot;fmt&quot; sdk &quot;github.com/cosmos/cosmos-sdk/types&quot; govv1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1&quot; govv1beta1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; ibctransfertypes &quot;github.com/cosmos/ibc-go/v7/modules/apps/transfer/types&quot; &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; &quot;github.com/cosmos/cosmos-sdk/x/params/types/proposal&quot; ) type ForbiddenProposalsDecorator struct { isLegacyProposalWhitelisted func(govv1beta1.Content) bool isModuleWhiteList func(string) bool } func NewForbiddenProposalsDecorator( whiteListFn func(govv1beta1.Content) bool, isModuleWhiteList func(string) bool, ) ForbiddenProposalsDecorator { return ForbiddenProposalsDecorator{ isLegacyProposalWhitelisted: whiteListFn, isModuleWhiteList: isModuleWhiteList, } } func (decorator ForbiddenProposalsDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (newCtx sdk.Context, err error) { currHeight := ctx.BlockHeight() for _, msg := range tx.GetMsgs() { // if the message is MsgSubmitProposal, check if proposal is whitelisted submitProposalMgs, ok := msg.(*govv1.MsgSubmitProposal) if !ok { continue } messages := submitProposalMgs.GetMessages() for _, message := range messages { if sdkMsg, isLegacyProposal := message.GetCachedValue().(*govv1.MsgExecLegacyContent); isLegacyProposal { // legacy gov proposal content content, err := govv1.LegacyContentFromMessage(sdkMsg) if err != nil { return ctx, fmt.Errorf(&quot;tx contains invalid LegacyContent&quot;) } if !decorator.isLegacyProposalWhitelisted(content) { return ctx, fmt.Errorf(&quot;tx contains unsupported proposal message types at height %d&quot;, currHeight) } continue } // not legacy gov proposal content and not whitelisted if !decorator.isModuleWhiteList(message.TypeUrl) { return ctx, fmt.Errorf(&quot;tx contains unsupported proposal message types at height %d&quot;, currHeight) } } } return next(ctx, tx, simulate) } func IsProposalWhitelisted(content v1beta1.Content) bool { switch c := content.(type) { case *proposal.ParameterChangeProposal: return isLegacyParamChangeWhitelisted(c.Changes) default: return false } } func isLegacyParamChangeWhitelisted(paramChanges []proposal.ParamChange) bool { for _, paramChange := range paramChanges { _, found := LegacyWhitelistedParams[legacyParamChangeKey{Subspace: paramChange.Subspace, Key: paramChange.Key}] if !found { return false } } return true } type legacyParamChangeKey struct { Subspace, Key string } // Legacy params can be whitelisted var LegacyWhitelistedParams = map[legacyParamChangeKey]struct{}{ {Subspace: ibctransfertypes.ModuleName, Key: &quot;SendEnabled&quot;}: {}, {Subspace: ibctransfertypes.ModuleName, Key: &quot;ReceiveEnabled&quot;}: {}, } // New proposal types can be whitelisted var WhiteListModule = map[string]struct{}{ &quot;/cosmos.gov.v1.MsgUpdateParams&quot;: {}, &quot;/cosmos.bank.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.staking.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.distribution.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.mint.v1beta1.MsgUpdateParams&quot;: {}, } func IsModuleWhiteList(typeUrl string) bool { _, found := WhiteListModule[typeUrl] return found }   Add the AnteHandler to the list of supported antehandlers:  // app/ante_handler.go package app import ( ... +\tdemocracyante &quot;github.com/cosmos/interchain-security/v4/app/consumer-democracy/ante&quot; +\tconsumerante &quot;github.com/cosmos/interchain-security/v4/app/consumer/ante&quot; +\ticsconsumerkeeper &quot;github.com/cosmos/interchain-security/v4/x/ccv/consumer/keeper&quot; ) type HandlerOptions struct { ante.HandlerOptions IBCKeeper *ibckeeper.Keeper +\tConsumerKeeper ibcconsumerkeeper.Keeper } func NewAnteHandler(options HandlerOptions) (sdk.AnteHandler, error) { .... anteDecorators := []sdk.AnteDecorator{ ... + consumerante.NewMsgFilterDecorator(options.ConsumerKeeper), + consumerante.NewDisabledModulesDecorator(&quot;/cosmos.evidence&quot;, &quot;/cosmos.slashing&quot;), + democracyante.NewForbiddenProposalsDecorator(IsProposalWhitelisted, IsModuleWhiteList), ... } return sdk.ChainAnteDecorators(anteDecorators...), nil }   Wire the module in app.go.  // app/app.go package app import ( ... sdkgov &quot;github.com/cosmos/cosmos-sdk/x/gov&quot; govkeeper &quot;github.com/cosmos/cosmos-sdk/x/gov/keeper&quot; govtypes &quot;github.com/cosmos/cosmos-sdk/x/gov/types&quot; govv1beta1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; +\tccvgov &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/governance&quot; ) var ( // use sdk governance module ModuleBasics = module.NewBasicManager( ... sdkgov.NewAppModuleBasic( []govclient.ProposalHandler{ paramsclient.ProposalHandler, upgradeclient.LegacyProposalHandler, upgradeclient.LegacyCancelProposalHandler, }, ), ) ) func NewApp(...) { // retain sdk gov router and keeper registrations sdkgovRouter := govv1beta1.NewRouter() sdkgovRouter. AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler). AddRoute(paramproposal.RouterKey, params.NewParamChangeProposalHandler(app.ParamsKeeper)). AddRoute(upgradetypes.RouterKey, upgrade.NewSoftwareUpgradeProposalHandler(&amp;app.UpgradeKeeper)) govConfig := govtypes.DefaultConfig() app.GovKeeper = *govkeeper.NewKeeper( appCodec, keys[govtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, app.MsgServiceRouter(), govConfig, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.GovKeeper.SetLegacyRouter(sdkgovRouter) // register the module with module manager // replace the x/gov module app.MM = module.NewManager( - sdkgov.NewAppModule(appCodec, app.GovKeeper, app.AccountKeeper, app.BankKeeper, IsProposalWhitelisted, app.GetSubspace(govtypes.ModuleName), IsModuleWhiteList), + ccvgov.NewAppModule(appCodec, app.GovKeeper, app.AccountKeeper, app.BankKeeper, IsProposalWhitelisted, app.GetSubspace(govtypes.ModuleName), IsModuleWhiteList), ... ) }   ","version":"v5.2.0","tagName":"h3"},{"title":"Distribution​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v5.2.0/features/democracy-modules#distribution","content":" tip The democracy/distribution module allows the consumer chain to send rewards to the provider chain while retaining the x/distribution module for internal reward distribution to Governators and stakers.  ","version":"v5.2.0","tagName":"h2"},{"title":"How it works​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v5.2.0/features/democracy-modules#how-it-works","content":" First, a % of rewards to be distributed to the provider chain's validator set is calculated and sent to the provider chain. Only opted-in validators from the provider chain will receive the consumer rewards.  Second, the remaining rewards get distributed to the consumer chain's Governators and their delegators.  info The % that is sent to the provider chain corresponds to 1 - ConsumerRedistributionFraction. e.g. ConsumerRedistributionFraction = &quot;0.75&quot; means that the consumer chain retains 75% of the rewards, while 25% gets sent to the provider chain to be distributed as rewards to provider chain validators.  ","version":"v5.2.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v5.2.0/features/democracy-modules#integration-2","content":" Change the wiring in app.go  import ( ... distrkeeper &quot;github.com/cosmos/cosmos-sdk/x/distribution/keeper&quot; distrtypes &quot;github.com/cosmos/cosmos-sdk/x/distribution/types&quot; sdkdistr &quot;github.com/cosmos/cosmos-sdk/x/distribution&quot; + ccvdistr &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/distribution&quot; ) var ( // replace sdk distribution AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, ccvstaking.AppModuleBasic{}, // make sure you first swap the staking keeper mint.AppModuleBasic{}, - sdkdistr.AppModuleBasic{}, + ccvdistr.AppModuleBasic{}, ) ) func NewApp(...) { .... app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // connect to sdk StakingKeeper consumertypes.ConsumerRedistributeName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register with the module manager app.MM = module.NewManager( ... - sdkdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), + ccvdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }  ","version":"v5.2.0","tagName":"h3"},{"title":"Power Shaping","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/features/power-shaping","content":"","keywords":"","version":"v5.2.0"},{"title":"Guidelines for setting power shaping parameters​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v5.2.0/features/power-shaping#guidelines-for-setting-power-shaping-parameters","content":" When setting power shaping parameters, please consider the following guidelines:  Do not cap the validator set size too low: Notice that this number is the *maximum number of validators that will ever validate the consumer chain. If this number is too low, the chain will be very limited in the amount of stake that secures it. The validator set size cap should only be used if there are strong reasons to prefer fewer validators. Consider that setting the cap will mean that even if the whole validator set of the provider wants to validate on the chain, some validators will simply not be able to.Capping the fraction of power any single validator can have is a decent security measure, but it's good to be aware of the interactions with the size of the validator set. For example, if there are only 3 validators, and the cap is 20%, this will not be possible (since even splitting the power fairly would mean that each validator has 33% of the power, so is above the cap). However, the cap can be a good measure to prevent a single large validator from essentially taking over the chain. In general, values under 33% make sense (since a validator that has 33% of the chains power would halt the chain if they go offline). Notice that the smaller this value is, the more the original voting power gets distorted, which could discourage large validators from deciding to opt in to the chain.If the allowlist is empty, all validators can validate the chain. If it is non empty, then only validators on the allowlist can validate the chain. Thus, an allowlist containing too few validators is a security risk. In particular, consider that if the validators on the allowlist lose a lot of stake or stop being validators, an allowlist that is too short can very quickly become outdated and leave too few validators, or validators with too little stake, to secure the chain in a decentralized way.If the denylist is too full, this can likewise be problematic. If too many large validators are denylisted, the chain might not be secured by a large enough fraction of the provider's power, in particular when the power distribution on the provider shifts and the denylisted validators gain more power.  In general, when setting these parameters, consider that the voting power distribution in the future might be very different from the one right now, and that the chain should be secure even if the power distribution changes significantly.  tip The power shaping parameters of a running consumer chain can be changed through a ConsumerModificationProposal. ","version":"v5.2.0","tagName":"h2"},{"title":"Reward Distribution","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/features/reward-distribution","content":"","keywords":"","version":"v5.2.0"},{"title":"Whitelisting Reward Denoms​","type":1,"pageTitle":"Reward Distribution","url":"/interchain-security/v5.2.0/features/reward-distribution#whitelisting-reward-denoms","content":" The ICS distribution system works by allowing consumer chains to send rewards to a module address on the provider called the ConsumerRewardsPool. To avoid spam, the provider must whitelist denoms before accepting them as ICS rewards. Only whitelisted denoms are transferred from the ConsumerRewardsPool to the FeePoolAddress, to be distributed to delegators and validators. The whitelisted denoms can be adjusted through governance by sending a ChangeRewardDenomProposal.  To query the list of whitelisted reward denoms on the Cosmos Hub, use the following command:  &gt; gaiad q provider registered-consumer-reward-denoms denoms: - ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 - ibc/6B8A3F5C2AD51CD6171FA41A7E8C35AD594AB69226438DB94450436EA57B3A89 - uatom   tip Use the following command to get a human readable denom from the ibc/* denom trace format: &gt; gaiad query ibc-transfer denom-trace ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 denom_trace: base_denom: untrn path: transfer/channel-569  ","version":"v5.2.0","tagName":"h2"},{"title":"ICS Provider Proposals","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/features/proposals","content":"","keywords":"","version":"v5.2.0"},{"title":"ConsumerAdditionProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v5.2.0/features/proposals#consumeradditionproposal","content":" info If you are preparing a ConsumerAdditionProposal you can find more information in the consumer onboarding checklist.  Proposal type used to suggest adding a new consumer chain.  When proposals of this type are passed and the spawn_time specified in the proposal is reached, all provider chain validators are expected to run infrastructure (validator nodes) for the proposed consumer chain.  Minimal example:  { // Time on the provider chain at which the consumer chain genesis is finalized and all validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, &quot;title&quot;: &quot;Add consumer chain&quot;, &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, &quot;chain_id&quot;: &quot;newchain-1&quot;, &quot;initial_height&quot; : { &quot;revision_height&quot;: 0, &quot;revision_number&quot;: 1, }, // Unbonding period for the consumer chain. // It should be smaller than that of the provider. &quot;unbonding_period&quot;: 86400000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 259200000000000, &quot;transfer_timeout_period&quot;: 1800000000000, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;blocks_per_distribution_transmission&quot;: 1000, &quot;historical_entries&quot;: 10000, &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot;, &quot;top_N&quot;: 95, &quot;validators_power_cap&quot;: 0, &quot;validator_set_cap&quot;: 0, &quot;allowlist&quot;: [], &quot;denylist&quot;: [] }   More examples can be found in the interchain security testnet repository here and here.  ","version":"v5.2.0","tagName":"h2"},{"title":"ConsumerRemovalProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v5.2.0/features/proposals#consumerremovalproposal","content":" Proposal type used to suggest removing an existing consumer chain.  When proposals of this type are passed, the consumer chain in question will be gracefully removed from interchain security and validators will no longer be required to run infrastructure for the specified chain. After the consumer chain removal, the chain in question will no longer be secured by the provider's validator set.  info The chain in question my continue to produce blocks, but the validator set can no longer be slashed for any infractions committed on that chain. Additional steps are required to completely offboard a consumer chain, such as re-introducing the staking module and removing the provider's validators from the active set. More information will be made available in the Consumer Offboarding Checklist.  Minimal example:  { // the time on the provider chain at which all validators are responsible to stop their consumer chain validator node &quot;stop_time&quot;: &quot;2023-03-07T12:40:00.000000Z&quot;, // the chain-id of the consumer chain to be stopped &quot;chain_id&quot;: &quot;consumerchain-1&quot;, &quot;title&quot;: &quot;This was a great chain&quot;, &quot;description&quot;: &quot;Here is a .md formatted string specifying removal details&quot; }   ","version":"v5.2.0","tagName":"h2"},{"title":"ConsumerModificationProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v5.2.0/features/proposals#consumermodificationproposal","content":" Proposal type used to change the power shaping parameters of a running consumer chain, as well as to change a Top N running consumer chain to an Opt-In chain and vice versa.  When a ConsumerModificationProposal passes for a running consumer chain, the consumer chain would change all its parameters to the ones passed in the ConsumerModificationProposal.  Assume, a chain-1 is a Top N chain. If the following ConsumerModificationProposal passes, then chain-1 would become an Opt-In chain with a 40% validators power cap, a maximum number of 30 validators, and one denylisted validator.  { &quot;title&quot;: &quot;Modify consumer chain&quot;, &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, &quot;chain_id&quot;: &quot;chain-1&quot;, &quot;top_N&quot;: 0, &quot;validators_power_cap&quot;: 40, &quot;validator_set_cap&quot;: 30, &quot;allowlist&quot;: [], &quot;denylist&quot;: [&quot;cosmosvalcons1qmq08eruchr5sf5s3rwz7djpr5a25f7xw4mceq&quot;] }   warning If top_N, validators_power_cap, or some other argument is not included in the proposal, then it is considered that the default value is set for this argument. For example, if a Top 50% chain wants to only modify validators_power_capfrom 35 to 40, then the ConsumerModificationProposal would still need to include that top_N is 50. Otherwisetop_N would be set to its default value of 0, and the chain would become an Opt-In chain. To be safe, always include top_N and all the power shaping parameters in your ConsumerModificationProposal.  ","version":"v5.2.0","tagName":"h2"},{"title":"ChangeRewardDenomProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v5.2.0/features/proposals#changerewarddenomproposal","content":" Proposal type used to mutate the set of denoms accepted by the provider as rewards.  tip A ChangeRewardDenomProposal will only be accepted on the provider chain if at least one of the denomsToAdd or denomsToRemove fields is populated with at least one denom. Also, a denom cannot be repeated in both sets.  Minimal example:  { &quot;title&quot;: &quot;Add uatom as a reward denom&quot;, &quot;description&quot;: &quot;Here is more information about the proposal&quot;, &quot;denomsToAdd&quot;: [&quot;uatom&quot;], &quot;denomsToRemove&quot;: [] }   tip Besides native provider denoms (e.g., uatom for the Cosmos Hub), please use the ibc/* denom trace format. For example, for untrn transferred over the path transfer/channel-569, the denom trace can be queried using the following command: &gt; gaiad query ibc-transfer denom-hash transfer/channel-569/untrn hash: 0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 Then use the resulting hash in the ChangeRewardDenomProposal, e.g., { &quot;title&quot;: &quot;Add untrn as a reward denom&quot;, &quot;description&quot;: &quot;Here is more information about the proposal&quot;, &quot;denomsToAdd&quot;: [&quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;], &quot;denomsToRemove&quot;: [] }  ","version":"v5.2.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/introduction/overview","content":"","keywords":"","version":"v5.2.0"},{"title":"Why Interchain Security?​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/introduction/overview#why-interchain-security","content":" The right amount of security for each application. Consumer chains can choose to inherit the whole validator set from the provider, or they can launch as an opt in chain where only a subset of the provider validators validate the consumer chain. This allows for a wide range of security tradeoffs.Independent block-space. Transactions on consumer chains do not compete with any other applications. This means that there will be no unexpected congestion, and performance will generally be much better than on a shared smart contract platform such as Ethereum.Projects keep majority of gas fees. Depending on configuration, these fees either go to the project’s community DAO, or can be used in the protocol in other ways.No validator search. Consumer chains do not have their own validator sets, and so do not need to find validators one by one. Validators from the provider chain validate on the consumer chain with their stake on the provider chain, earning additional rewards. For the consumer chain, this comes with the benefit of exposing their chain to the wider audience of the provider chain.Instant sovereignty. Consumers can run arbitrary app logic similar to standalone chains. At any time in the future, a consumer chain can elect to become a completely standalone chain, with its own validator set.  ","version":"v5.2.0","tagName":"h2"},{"title":"Core protocol​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/introduction/overview#core-protocol","content":" info Protocol specification is available as ICS-028 in the IBC repository.  Once an IBC connection and proper channel is established between a provider and consumer chain, the provider will continually send validator set updates to the consumer over IBC. The consumer uses these validator set updates to update its own validator set in Comet. Thus, the provider validator set is effectively replicated on the consumer.  To ensure the security of the consumer chain, provider delegators cannot unbond their tokens until the unbonding periods of each consumer chain has passed. In practice this will not be noticeable to the provider delegators, since consumer chains will be configured to have a slightly shorter unbonding period than the provider.  ","version":"v5.2.0","tagName":"h2"},{"title":"Downtime Slashing​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/introduction/overview#downtime-slashing","content":" If downtime is initiated by a validator on a consumer chain, a downtime packet will be relayed to the provider to jail that validator for a set amount of time. The validator who committed downtime will then miss out on staking rewards for the configured jailing period.  ","version":"v5.2.0","tagName":"h3"},{"title":"Tokenomics and Rewards​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/introduction/overview#tokenomics-and-rewards","content":" Consumer chains are free to create their own native token which can be used for fees, and can be created on the consumer chain in the form of inflationary rewards. These rewards can be used to incentivize user behavior, for example, LPing or staking. A portion of these fees and rewards will be sent to provider chain stakers, but that proportion is completely customizable by the developers, and subject to governance. ","version":"v5.2.0","tagName":"h3"},{"title":"Technical Specification","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/introduction/technical-specification","content":"Technical Specification For a technical deep dive into the replicated security protocol, see the specification.","keywords":"","version":"v5.2.0"},{"title":"Interchain Security Parameters","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/introduction/params","content":"","keywords":"","version":"v5.2.0"},{"title":"Time-Based Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#time-based-parameters","content":" ICS relies on the following time-based parameters.  ","version":"v5.2.0","tagName":"h2"},{"title":"ProviderUnbondingPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#providerunbondingperiod","content":" ProviderUnbondingPeriod is the unbonding period on the provider chain as configured during chain genesis. This parameter can later be changed via governance.  ","version":"v5.2.0","tagName":"h3"},{"title":"ConsumerUnbondingPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#consumerunbondingperiod","content":" ConsumerUnbondingPeriod is the unbonding period on the consumer chain.  info ConsumerUnbondingPeriod is set via the ConsumerAdditionProposal governance proposal to add a new consumer chain. It is recommended that every consumer chain set and unbonding period shorter than ProviderUnbondingPeriod Example: ConsumerUnbondingPeriod = ProviderUnbondingPeriod - one day   Unbonding operations (such as undelegations) are completed on the provider only after the unbonding period elapses on every consumer.  ","version":"v5.2.0","tagName":"h3"},{"title":"TrustingPeriodFraction​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#trustingperiodfraction","content":" TrustingPeriodFraction is used to calculate the TrustingPeriod of created IBC clients on both provider and consumer chains.  Setting TrustingPeriodFraction to 0.5 would result in the following:  TrustingPeriodFraction = 0.5 ProviderClientOnConsumerTrustingPeriod = ProviderUnbondingPeriod * 0.5 ConsumerClientOnProviderTrustingPeriod = ConsumerUnbondingPeriod * 0.5   Note that a light clients must be updated within the TrustingPeriod in order to avoid being frozen.  For more details, see the IBC specification of Tendermint clients.  ","version":"v5.2.0","tagName":"h3"},{"title":"CCVTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#ccvtimeoutperiod","content":" CCVTimeoutPeriod is the period used to compute the timeout timestamp when sending IBC packets.  For more details, see the IBC specification of Channel &amp; Packet Semantics.  warning If a sent packet is not relayed within this period, then the packet times out. The CCV channel used by the interchain security protocol is closed, and the corresponding consumer is removed.  CCVTimeoutPeriod may have different values on the provider and consumer chains.  CCVTimeoutPeriod on the provider must be larger than ConsumerUnbondingPeriodCCVTimeoutPeriod on the consumer is initial set via the ConsumerAdditionProposal  ","version":"v5.2.0","tagName":"h3"},{"title":"InitTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#inittimeoutperiod","content":" InitTimeoutPeriod is the maximum allowed duration for CCV channel initialization to execute.  For any consumer chain, if the CCV channel is not established within InitTimeoutPeriod then the consumer chain will be removed and therefore will not be secured by the provider chain.  The countdown starts when the spawn_time specified in the ConsumerAdditionProposal is reached.  ","version":"v5.2.0","tagName":"h3"},{"title":"VscTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#vsctimeoutperiod","content":" VscTimeoutPeriod is the provider-side param that enables the provider to timeout VSC packets even when a consumer chain is not live. If the VscTimeoutPeriod is ever reached for a consumer chain that chain will be considered not live and removed from interchain security.  tip VscTimeoutPeriod MUST be larger than the ConsumerUnbondingPeriod.  ","version":"v5.2.0","tagName":"h3"},{"title":"BlocksPerDistributionTransmission​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#blocksperdistributiontransmission","content":" BlocksPerDistributionTransmission is the number of blocks between rewards transfers from the consumer to the provider.  ","version":"v5.2.0","tagName":"h3"},{"title":"TransferPeriodTimeout​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#transferperiodtimeout","content":" TransferPeriodTimeout is the period used to compute the timeout timestamp when sending IBC transfer packets from a consumer to the provider.  If this timeout expires, then the transfer is attempted again after BlocksPerDistributionTransmission blocks.  TransferPeriodTimeout on the consumer is initial set via the ConsumerAdditionProposal gov proposal to add the consumerTransferPeriodTimeout should be smaller than BlocksPerDistributionTransmission x avg_block_time  ","version":"v5.2.0","tagName":"h3"},{"title":"Reward Distribution Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#reward-distribution-parameters","content":" tip The following chain parameters dictate consumer chain distribution amount and frequency. They are set at consumer genesis and BlocksPerDistributionTransmission, ConsumerRedistributionFractionTransferTimeoutPeriod must be provided in every ConsumerChainAddition proposal.  ","version":"v5.2.0","tagName":"h2"},{"title":"ConsumerRedistributionFraction​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#consumerredistributionfraction","content":" ConsumerRedistributionFraction is the fraction of tokens allocated to the consumer redistribution address during distribution events. The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%.  tip Example: With ConsumerRedistributionFraction set to &quot;0.75&quot; the consumer chain would send 75% of its block rewards and accumulated fees to the consumer redistribution address, and the remaining 25% to the provider chain every BlocksPerDistributionTransmission blocks.  ","version":"v5.2.0","tagName":"h3"},{"title":"BlocksPerDistributionTransmission​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#blocksperdistributiontransmission-1","content":" BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain.  ","version":"v5.2.0","tagName":"h3"},{"title":"TransferTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#transfertimeoutperiod","content":" TransferTimeoutPeriod is the timeout period for consumer chain reward distribution IBC packets.  ","version":"v5.2.0","tagName":"h3"},{"title":"DistributionTransmissionChannel​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#distributiontransmissionchannel","content":" DistributionTransmissionChannel is the provider chain IBC channel used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  ","version":"v5.2.0","tagName":"h3"},{"title":"ProviderFeePoolAddrStr​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#providerfeepooladdrstr","content":" ProviderFeePoolAddrStr is the provider chain fee pool address used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  ","version":"v5.2.0","tagName":"h3"},{"title":"Slash Throttle Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#slash-throttle-parameters","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"SlashMeterReplenishPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#slashmeterreplenishperiod","content":" SlashMeterReplenishPeriod exists on the provider such that once the slash meter becomes not-full, the slash meter is replenished after this period has elapsed.  The meter is replenished to an amount equal to the slash meter allowance for that block, or SlashMeterReplenishFraction * CurrentTotalVotingPower.  ","version":"v5.2.0","tagName":"h3"},{"title":"SlashMeterReplenishFraction​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#slashmeterreplenishfraction","content":" SlashMeterReplenishFraction exists on the provider as the portion (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs.  This param also serves as a maximum fraction of total voting power that the slash meter can hold. The param is set/persisted as a string, and converted to a sdk.Dec when used.  ","version":"v5.2.0","tagName":"h3"},{"title":"MaxThrottledPackets​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#maxthrottledpackets","content":" MaxThrottledPackets exists on the provider as the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value.  This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness.  info MaxThrottledPackets was deprecated in ICS versions &gt;= v3.2.0 due to the implementation of ADR-008.  ","version":"v5.2.0","tagName":"h3"},{"title":"RetryDelayPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#retrydelayperiod","content":" RetryDelayPeriod exists on the consumer for ICS versions &gt;= v3.2.0 (introduced by the implementation of ADR-008) and is the period at which the consumer retries to send a SlashPacket that was rejected by the provider.  ","version":"v5.2.0","tagName":"h3"},{"title":"Epoch Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#epoch-parameters","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"BlocksPerEpoch​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v5.2.0/introduction/params#blocksperepoch","content":" BlocksPerEpoch exists on the provider for ICS versions &gt;= 3.3.0 (introduced by the implementation of ADR-014) and corresponds to the number of blocks that constitute an epoch. This param is set to 600 by default. Assuming we need 6 seconds to commit a block, the duration of an epoch corresponds to 1 hour. This means that a VSCPacket would be sent to a consumer chain once at the end of every epoch, so once every 600 blocks. This parameter can be adjusted via a governance proposal, however careful consideration is needed so that BlocksPerEpoch is not too large. A large BlocksPerEpoch could lead to a delay of VSCPackets and hence potentially lead to unbonding pausing. For setting BlocksPerEpoch, we also need to consider potential slow chain upgrades that could delay the sending of aVSCPacket, as well as potential increases in the time it takes to commit a block (e.g., from 6 seconds to 30 seconds). ","version":"v5.2.0","tagName":"h3"},{"title":"Terminology","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/introduction/terminology","content":"","keywords":"","version":"v5.2.0"},{"title":"Shared Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v5.2.0/introduction/terminology#shared-security","content":" Shared security is a family of technologies that include optimistic rollups, zk-rollups, sharding and Interchain Security. Ie. any protocol or technology that can allow one blockchain to lend/share its proof-of-stake security with another blockchain or off-chain process.  ","version":"v5.2.0","tagName":"h2"},{"title":"Interchain Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v5.2.0/introduction/terminology#interchain-security","content":" Interchain Security is the Cosmos-specific category of Shared Security that uses IBC (Inter-Blockchain Communication), i.e. any shared security protocol built with IBC.  ","version":"v5.2.0","tagName":"h2"},{"title":"Replicated Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v5.2.0/introduction/terminology#replicated-security","content":" A particular protocol/implementation of Interchain Security that fully replicates the security and decentralization of a validator set across multiple blockchains. Replicated security has also been referred to as &quot;Cross Chain Validation&quot; or &quot;Interchain Security V1&quot;, a legacy term for the same protocol. That is, a &quot;provider chain&quot; such as the Cosmos Hub can share its exact validator set with multiple consumer chains by communicating changes in its validator set over IBC.  ","version":"v5.2.0","tagName":"h2"},{"title":"Partial Set Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v5.2.0/introduction/terminology#partial-set-security","content":" A major iteration of Interchain Security, also known as &quot;Interchain Security V2&quot;. Partial Set Security allows a provider chain to share only a subset of its validator set with a consumer chain. This subset can be determined by the top N% validators by voting power, or by validators opting in to validate the consumer chain. Partial Set Security allows for more flexible security tradeoffs than Replicated Security.  ","version":"v5.2.0","tagName":"h2"},{"title":"Mesh security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v5.2.0/introduction/terminology#mesh-security","content":" A protocol built on IBC that allows delegators on a cosmos chain to re-delegate their stake to validators in another chain's own validator set, using the original chain's token (which remains bonded on the original chain). For a deeper exploration of mesh security, see Replicated vs. Mesh Security on the Informal Blog.  ","version":"v5.2.0","tagName":"h2"},{"title":"Consumer Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v5.2.0/introduction/terminology#consumer-chain","content":" Chain that is secured by the validator set of the provider, instead of its own. Interchain Security allows a subset of the provider chain's validator set to validate blocks on the consumer chain.  ","version":"v5.2.0","tagName":"h2"},{"title":"Standalone Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v5.2.0/introduction/terminology#standalone-chain","content":" Chain that is secured by its own validator set. This chain does not participate in Interchain Security.  Standalone chains may sometimes be called &quot;sovereign&quot; - the terms are synonymous.  ","version":"v5.2.0","tagName":"h2"},{"title":"Changeover Procedure​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v5.2.0/introduction/terminology#changeover-procedure","content":" Chains that were not initially launched as consumers of Interchain Security can still participate in the protocol and leverage the economic security of the provider chain. The process where a standalone chain transitions to being a replicated consumer chain is called the changeover procedure and is part of the interchain security protocol. After the changeover, the new consumer chain will retain all existing state, including the IBC clients, connections and channels already established by the chain. ","version":"v5.2.0","tagName":"h2"},{"title":"Joining Neutron","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/validators/joining-neutron","content":"","keywords":"","version":"v5.2.0"},{"title":"Resources​","type":1,"pageTitle":"Joining Neutron","url":"/interchain-security/v5.2.0/validators/joining-neutron#resources","content":" Neutron docs ","version":"v5.2.0","tagName":"h2"},{"title":"Validator Instructions for Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/validators/changeover-procedure","content":"","keywords":"","version":"v5.2.0"},{"title":"Timeline​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#timeline","content":" Upgrading standalone chains can be best visualised using a timeline, such as the one available Excalidraw graphic by Stride.  There is some flexibility with regards to how the changeover procedure is executed, so please make sure to follow the guides provided by the team doing the changeover.    ","version":"v5.2.0","tagName":"h2"},{"title":"1. ConsumerAdditionProposal on provider chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#1-consumeradditionproposal-on-provider-chain","content":" This step will add the standalone chain to the list of consumer chains secured by the provider. This step dictates the spawn_time. After spawn_time the CCV state (initial validator set of the provider) will be available to the consumer.  To obtain it from the provider use:  gaiad q provider consumer-genesis stride-1 -o json &gt; ccv-state.json jq -s '.[0].app_state.ccvconsumer = .[1] | .[0]' genesis.json ccv-state.json &gt; ccv.json   Transformation of the exported consumer genesis state to the target version of the consumer might be needed in case the provider and consumer formats are incompatible. Refer to the compatibility notes here to check if data transformation is needed for your case. Instructions on how to transform the exported CCV genesis state (ccv-state.json in the example above) to the required target version can be found here  ","version":"v5.2.0","tagName":"h3"},{"title":"2. SoftwareUpgradeProposal on the standalone/consumer chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#2-softwareupgradeproposal-on-the-standaloneconsumer-chain","content":" This upgrade proposal will introduce ICS to the standalone chain, making it a consumer.  ","version":"v5.2.0","tagName":"h3"},{"title":"3. Assigning a consumer key​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#3-assigning-a-consumer-key","content":" After spawn_time, make sure to assign a consumer key if you intend to use one.  Instructions are available here  ","version":"v5.2.0","tagName":"h3"},{"title":"4. Perform the software upgrade on standalone chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#4-perform-the-software-upgrade-on-standalone-chain","content":" Please use instructions provided by the standalone chain team and make sure to reach out if you are facing issues. The upgrade preparation depends on your setup, so please make sure you prepare ahead of time.  danger The ccv.json from step 1. must be made available on the machine running the standalone/consumer chain at standalone chain upgrade_height. This file contains the initial validator set and parameters required for normal ICS operation. Usually, the file is placed in $NODE_HOME/config but this is not a strict requirement. The exact details are available in the upgrade code of the standalone/consumer chain.  Performing this upgrade will transition the standalone chain to be a consumer chain.  After 3 blocks, the standalone chain will stop using the &quot;old&quot; validator set and begin using the provider validator set.  ","version":"v5.2.0","tagName":"h3"},{"title":"FAQ​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#faq","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Can I reuse the same validator key for the consumer chain that I am already using on the standalone chain? Will I need to perform a AssignConsumerKey tx with this key before spawn time?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#can-i-reuse-the-same-validator-key-for-the-consumer-chain-that-i-am-already-using-on-the-standalone-chain-will-i-need-to-perform-a-assignconsumerkey-tx-with-this-key-before-spawn-time","content":" Validators must either assign a key or use the same key as on the provider.  If you are validating both the standalone and the provider, you can use your current standalone key with some caveats:  you must submit an AssignConsumerKey tx with your current standalone validator keyit is best to submit AssignConsumerKey tx before spawn_timeif you do not submit the Tx, it is assumed that you will be re-using your provider key to validate the standalone/consumer chain  ","version":"v5.2.0","tagName":"h3"},{"title":"Can I continue using the same node that was validating the standalone chain?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#can-i-continue-using-the-same-node-that-was-validating-the-standalone-chain","content":" Yes.  Please assign your consensus key as stated above.  ","version":"v5.2.0","tagName":"h3"},{"title":"Can I set up a new node to validate the standalone/consumer chain after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#can-i-set-up-a-new-node-to-validate-the-standaloneconsumer-chain-after-it-transitions-to-interchain-security","content":" Yes.  If you are planning to do this please make sure that the node is synced with standalone network and to submit AssignConsumerKey tx before spawn_time.  ","version":"v5.2.0","tagName":"h3"},{"title":"What happens to the standalone validator set after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#what-happens-to-the-standalone-validator-set-after-it-transitions-to-interchain-security","content":" The standalone chain validators will stop being validators after the first 3 blocks are created while using Interchain Security. The standalone validators will become governors and still can receive delegations if the consumer chain is using the consumer-democracy module.  Governors DO NOT VALIDATE BLOCKS.  Instead, they can participate in the governance process and take on other chain-specific roles.  ","version":"v5.2.0","tagName":"h3"},{"title":"Credits​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v5.2.0/validators/changeover-procedure#credits","content":" Thank you Stride team for providing detailed instructions about the changeover procedure. ","version":"v5.2.0","tagName":"h2"},{"title":"Consumer Initiated Slashing","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/features/slashing","content":"","keywords":"","version":"v5.2.0"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v5.2.0/features/slashing#downtime-infractions","content":" Downtime infractions are reported by consumer chains and are acted upon on the provider as soon as the provider receives the infraction evidence.  Instead of slashing, the provider will only jail offending validator for the duration of time established by the chain parameters.  info Slash throttling (sometimes called jail throttling) mechanism ensures that only a fraction of the validator set can be jailed at any one time to prevent malicious consumer chains from harming the provider.  Note that validators are only jailed for downtime on consumer chains that they opted-in to validate on, or in the case of Top N chains, where they are automatically opted in by being in the Top N% of the validator set on the provider.  ","version":"v5.2.0","tagName":"h2"},{"title":"Equivocation Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v5.2.0/features/slashing#equivocation-infractions","content":" Equivocation infractions are reported by external agents (e.g., relayers) that can submit to the provider evidence of light client or double signing attacks observed on a consumer chain. The evidence is submitted by sending MsgSubmitConsumerMisbehaviour or MsgSubmitConsumerDoubleVoting transactions to the provider. When valid evidence is received, the malicious validators are slashed, jailed, and tombstoned on the provider. This is enabled through the cryptographic verification of equivocation feature. For more details, see ADR-005 and ADR-013.  ","version":"v5.2.0","tagName":"h2"},{"title":"Report equivocation infractions through CLI​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v5.2.0/features/slashing#report-equivocation-infractions-through-cli","content":" The ICS provider module offers two commands for submitting evidence of misbehavior originating from a consumer chain. Below are two examples illustrating the process on Cosmos Hub.  Use the following command to submit evidence of double signing attacks:  gaiad tx provider submit-consumer-double-voting [path/to/evidence.json] [path/to/infraction_header.json] --from node0 --home ../node0 --chain-id $CID   Example of evidence.json { &quot;vote_a&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;tBBWTqjECl31S/clZGoxLdDqs93kTvy3qhpPqET/laY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;ai2qCLgVZAFph4FJ4Cqw5QW1GZKR4zjOv0bI/Um5AIc=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.565207Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;signature&quot;: &quot;y9yILm9hmv45BZwAaaq9mS1FpH7QeAIJ5Jkcc3U2/k5uks9cuqr4NTIwaIrqMSMKwxVyqiR56xmCT59a6AngAA==&quot; }, &quot;vote_b&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;3P06pszgPatuIdLTP5fDWiase4SYHIq9YXGSbRk9/50=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;S+SbOMxFRzfeNNpX9/jyFMz94VwBKk7Dpx6ZyvSYyNU=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.599273Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;validator_index&quot;: 0, &quot;signature&quot;: &quot;DGFcn4Um1t2kXW60+JhMk5cj7ZFdE5goKVOGiZkLwnNv43+6aGmOWjoq0SHYVzM4MwSwOwbhgZNbkWX+EHGUBw==&quot; }, &quot;total_voting_power&quot;: 300, &quot;validator_power&quot;: 100, &quot;timestamp&quot;: &quot;2023-11-20T12:57:51.267308Z&quot; }   Example of infraction_header.json { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: 11, &quot;app&quot;: 2 }, &quot;chain_id&quot;: &quot;consumer&quot;, &quot;height&quot;: 22, &quot;time&quot;: &quot;2023-11-20T12:57:40.479686Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;L63hyLJ+y9+fpb7WYKdmmBhPHwbfEGQEuKmvGzyBPiY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 18, &quot;hash&quot;: &quot;euzRQjN7MjGtM6skXM4B8wOgAldWGfZSJRA9JRlO42s=&quot; } }, &quot;last_commit_hash&quot;: &quot;qdDJwVziW3pPqmf8QDGZG+5HVd3OF7fCVh2Z8KQqNVU=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;next_validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;last_results_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: 22, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;PKrS32IEZoFY2q2S3iQ68HQL751ieBhf5Eu/Y5Z/QPg=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;8UuA7Oqw5AH/KOacpmHVSMOIDe4l2eC8VmdH2mzcpiM=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076538Z&quot;, &quot;signature&quot;: &quot;bSOH4+Vg2I37zeJphOguGOD0GK3JzM1ghSgJd0UlW/DHn1u9Hvv4EekHuCu6qwRLZcuS/ZxNlmr9qYNfxX3bDA==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:07:00Z&quot;, &quot;signature&quot;: &quot;7bXSDtlOwGK/gLEsFpTWOzm2TFoaARrWQUpbgWEwKtLlUs7iE06TOvJ3yPPfTfqqN/qYnvxxgjl0M0EhUWu5Bg==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076519Z&quot;, &quot;signature&quot;: &quot;Pb6G4bCg4wafmV89WNnzXxbSCknZUHnSQfSCE5QMFxPtSUIN4A7SK5m7yltqMJF5zkyenlFiEI4J3OZ4KCjCAw==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.057451Z&quot;, &quot;signature&quot;: &quot;j3EasIHNYA6MxW/PiWyruzHsjVsBV9t11W6Qx800WMm/+P+CkfR+UZAp7MPTvKZEZFuh3GUsBtyfb/vA+jJWCw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 }, { &quot;address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;UgN2JsjPy2WLh7dzJRBkUQtdgNoT4/uGj7kbIVqqHT8=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;5svW8261x+cZosp2xIhqzgt2tyuawrSDyHlpbgS3BC4=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } }, &quot;trusted_height&quot;: { &quot;revision_height&quot;: 18 }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 }, { &quot;address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;FCmIw7hSuiAoWk/2f4LuGQ+3zx5101xiqU8DoC5wGkg=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;2DrZF0roNnnvEy4NS2aY811ncKg=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;MI9c6sphsWlx0RAHCYOjMRXMFkTUaEYwOiOKG/0tsMs=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;73aN0uOc5b/Zfq2Xcjl0kH2r+tw=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;gWNcDup4mdnsuqET4QeFRzVb+FnSP4Vz3iNMj5wvWXk=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } } }   Use the following command to submit evidence of light client attacks:  gaiad tx provider submit-consumer-misbehaviour [path/to/misbehaviour.json] --from node0 --home ../node0 --chain-id $CID   Example of misbehaviour.json { &quot;client_id&quot;: &quot;07-tendermint-0&quot;, &quot;header_1&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;W2xVqzPw03ZQ1kAMpcpht9WohwMzsGnyKKNjPYKDF6U=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;PGTquCtnTNFFY5HfEFz9f9pA7PYqjtQfBwHq6cxF/Ux8OI6nVqyadD9a84Xm7fSm6mqdW+T6YVfqIKmIoRjJDQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;0e39yoBorwORAH/K9qJ7D1N1Yr7CutMiQJ+oiIK39eMhuoK3UWzQyMGRLzDOIDupf8yD99mvGVVAlNIODlV3Dg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;lhc2tkwydag9D1iLQhdDCE8GgrHP94M1LbHFYMoL9tExaEq6RiFW/k71TQH5x96XQ9XYOznMIHKC2BDh4GlnAQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;8xeSBf0nSFs/X/rQ9CZLzwkJJhQBLA2jKdPGP3MlULxm992XxrOsIYq47u1daxvSsn6ql5OVYjzBNU0qbPpvCA==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } }, &quot;header_2&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;IZM8NKS+8FHB7CBmgB8Nz7BRVVXiiyqMQDvHFUvgzxo=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;pLIEZ4WSAtnMsgryujheHSq4+YG3RqTfMn2ZxgEymr0wyi+BNlQAKRtRfesm0vfYxvjzc/jhGqtUqHtSIaCwCQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;XG7iTe/spWyTUkT7XDzfLMpYqrdyqizE4/X4wl/W+1eaQp0WsCHYnvPU3x9NAnYfZzaKdonZiDWs7wacbZTcDg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;TqegK7ORuICSy++wVdPHt8fL2WfPlYsMPv1XW79wUdcjnQkezOM50OSqYaP4ua5frIZsn+sWteDrlqFTdkl3BA==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;dhvp3XlIaCxx5MFDs0TCkAPHSm0PS2EtJzYAx2c/7MWdLwUJFZrAUTeimQE2c9i9ro91cjZn/vI0/oFRXab6Aw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } } }   ","version":"v5.2.0","tagName":"h3"},{"title":"Report equivocation infractions with Hermes​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v5.2.0/features/slashing#report-equivocation-infractions-with-hermes","content":" Ensure you have a well-configured Hermes v1.7.3+ relayer effectively relaying packets between a consumer chain and a provider chain. The following command demonstrates how to run a Hermes instance in evidence mode to detect misbehaviors on a consumer chain and automatically submit the evidence to the provider chain.  hermes evidence --chain &lt;CONSUMER-CHAIN-ID&gt;   tip hermes evidence takes a --check-past-blocks option giving the possibility to look for older evidence (default is 100). ","version":"v5.2.0","tagName":"h3"},{"title":"Joining Stride","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/validators/joining-stride","content":"","keywords":"","version":"v5.2.0"},{"title":"Note​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v5.2.0/validators/joining-stride#note","content":" Stride re-uses an existing transfer channel to send consumer rewards to the provider chain, in order to preserve existing transfer IBC denom between stride-1 and cosmoshub-4.  ","version":"v5.2.0","tagName":"h2"},{"title":"Resources​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v5.2.0/validators/joining-stride#resources","content":" Stride docsChangeover procedure timelineChangeover upgrade docs ","version":"v5.2.0","tagName":"h2"},{"title":"Joining Interchain Security testnet","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/validators/joining-testnet","content":"","keywords":"","version":"v5.2.0"},{"title":"Introduction​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v5.2.0/validators/joining-testnet#introduction","content":" This short guide will teach you how to join the Interchain Security testnet.  The experience gained in the testnet will prepare you for validating interchain secured chains.  tip Provider and consumer chain represent distinct networks and infrastructures operated by the same validator set. For general information about running cosmos-sdk based chains check out the validator basics and Running a Node section of Cosmos SDK docs  ","version":"v5.2.0","tagName":"h2"},{"title":"Joining the provider chain​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v5.2.0/validators/joining-testnet#joining-the-provider-chain","content":" info At present, all validators of the provider chain must also validate all governance approved consumer chains. The consumer chains cannot have a validator set different than the provider, which means they cannot introduce validators that are not also validating the provider chain.  A comprehensive guide is available here.  ","version":"v5.2.0","tagName":"h2"},{"title":"Initialization​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v5.2.0/validators/joining-testnet#initialization","content":" First, initialize your $NODE_HOME using the provider chain binary.  NODE_MONIKER=&lt;your_node&gt; CHAIN_ID=provider NODE_HOME=&lt;path_to_your_home&gt; gaiad init $NODE_MONIKER --chain-id $CHAIN_ID --home $NODE_HOME   Add your key to the keyring - more details available here.  In this example we will use the test keyring-backend. This option is not safe to use in production.  gaiad keys add &lt;key_moniker&gt; --keyring-backend test # save the address as variable for later use MY_VALIDATOR_ADDRESS=$(gaiad keys show my_validator -a --keyring-backend test)   Before issuing any transactions, use the provider testnet faucet to add funds to your address.  curl https://faucet.rs-testnet.polypore.xyz/request?address=$MY_VALIDATOR_ADDRESS&amp;chain=provider # example output: { &quot;address&quot;: &quot;cosmos17p3erf5gv2436fd4vyjwmudakts563a497syuz&quot;, &quot;amount&quot;: &quot;10000000uatom&quot;, &quot;chain&quot;: &quot;provider&quot;, &quot;hash&quot;: &quot;10BFEC53C80C9B649B66549FD88A0B6BCF09E8FCE468A73B4C4243422E724985&quot;, &quot;status&quot;: &quot;success&quot; }   Then, use the account associated with the keyring to issue a create-validator transaction which will register your validator on chain.  gaiad tx staking create-validator \\ --amount=1000000uatom \\ --pubkey=$(gaiad tendermint show-validator) \\ --moniker=&quot;choose a moniker&quot; \\ --chain-id=$CHAIN_ID&quot; \\ --commission-rate=&quot;0.10&quot; \\ --commission-max-rate=&quot;0.20&quot; \\ --commission-max-change-rate=&quot;0.01&quot; \\ --min-self-delegation=&quot;1000000&quot; \\ --gas=&quot;auto&quot; \\ --gas-prices=&quot;0.0025uatom&quot; \\ --from=&lt;key_moniker&gt;   tip Check this guide to edit your validator.  After this step, your validator is created and you can start your node and catch up to the rest of the network. It is recommended that you use statesync to catch up to the rest of the network.  You can use this script to modify your config.toml with the required statesync parameters.  # create the statesync script $: cd $NODE_HOME $: touch statesync.sh $ chmod 700 statesync.sh # make executable   Paste the following instructions into the statesync.sh:  #!/bin/bash SNAP_RPC=&quot;https://rpc.provider-state-sync-01.rs-testnet.polypore.xyz:443&quot; LATEST_HEIGHT=$(curl -s $SNAP_RPC/block | jq -r .result.block.header.height); \\ BLOCK_HEIGHT=$((LATEST_HEIGHT - 2000)); \\ TRUST_HASH=$(curl -s &quot;$SNAP_RPC/block?height=$BLOCK_HEIGHT&quot; | jq -r .result.block_id.hash) sed -i.bak -E &quot;s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1true| ; \\ s|^(rpc_servers[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$SNAP_RPC,$SNAP_RPC\\&quot;| ; \\ s|^(trust_height[[:space:]]+=[[:space:]]+).*$|\\1$BLOCK_HEIGHT| ; \\ s|^(trust_hash[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$TRUST_HASH\\&quot;|&quot; $NODE_HOME/config/config.toml   Then, you can execute the script:  $: ./statesync.sh # setup config.toml for statesync   Finally, copy the provider genesis and start your node:  $: GENESIS_URL=https://github.com/cosmos/testnets/raw/master/interchain-security/provider/provider-genesis.json $: wget $GENESIS_URL -O genesis.json $: genesis.json $NODE_HOME/config/genesis.json # start the service $: gaiad start --x-crisis-skip-assert-invariants --home $NODE_HOME --p2p.seeds=&quot;08ec17e86dac67b9da70deb20177655495a55407@provider-seed-01.rs-testnet.polypore.xyz:26656,4ea6e56300a2f37b90e58de5ee27d1c9065cf871@provider-seed-02.rs-testnet.polypore.xyz:26656&quot;   Additional scripts to setup your nodes are available here and here. The scripts will configure your node and create the required services - the scripts only work in linux environments.  ","version":"v5.2.0","tagName":"h2"},{"title":"Joining consumer chains​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v5.2.0/validators/joining-testnet#joining-consumer-chains","content":" tip Once you reach the active set on the provider chain, you will be required to validate all available consumer chains. We strongly recommend that you assign a separate key for each consumer chain. Check out this guide to learn more about key assignment in interchain security.  To join consumer chains, simply replicate the steps above for each consumer using the correct consumer chain binaries.  info When running the provider chain and consumers on the same machine please update the PORT numbers for each of them and make sure they do not overlap (otherwise the binaries will not start). Important ports to re-configure: --rpc.laddr--p2p.laddr--api.address--grpc.address--grpc-web.address  ","version":"v5.2.0","tagName":"h2"},{"title":"Re-using consensus key​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v5.2.0/validators/joining-testnet#re-using-consensus-key","content":" To reuse the key on the provider and consumer chains, simply initialize your consumer chain and place the priv_validator_key.json into the home directory of your consumer chain (&lt;consumer_home&gt;/config/priv_validator_key.json).  When you start the chain, the consensus key will be the same on the provider and the consumer chain.  ","version":"v5.2.0","tagName":"h2"},{"title":"Assigning consensus keys​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v5.2.0/validators/joining-testnet#assigning-consensus-keys","content":" Whenever you initialize a new node, it will be configured with a consensus key you can use.  # machine running consumer chain consumerd init &lt;node_moniker&gt; --home &lt;home_path&gt; --chain-id consumer-1 # use the output of this command to get the consumer chain consensus key consumerd tendermint show-validator # output: {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, let the provider know which key you will be using for the consumer chain:  # machine running the provider chain gaiad tx provider assign-consensus-key consumer-1 '&lt;consumer_pubkey&gt;' --from &lt;key_moniker&gt; --home $NODE_HOME --gas 900000 -b sync -y -o json   After this step, you are ready to copy the consumer genesis into your nodes's /config folder, start your consumer chain node and catch up to the network. ","version":"v5.2.0","tagName":"h2"},{"title":"Upgrading to ICS v5.x from v4.x","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5","content":"","keywords":"","version":"v5.2.0"},{"title":"Note​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#note","content":" v5.0.0 should not be used on the provider.  The provider should be updated to v5.1.1.  ","version":"v5.2.0","tagName":"h2"},{"title":"Provider​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#provider","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Keeper initialization​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#keeper-initialization","content":" // app.go app.ProviderKeeper = ibcproviderkeeper.NewKeeper( appCodec, keys[providertypes.StoreKey], app.GetSubspace(providertypes.ModuleName), scopedIBCProviderKeeper, app.IBCKeeper.ChannelKeeper, - app.IBCKeeper.PortKeeper + app.IBCKeeper.PortKeeper, app.IBCKeeper.ConnectionKeeper, app.IBCKeeper.ClientKeeper, app.StakingKeeper, app.SlashingKeeper, app.AccountKeeper, app.DistrKeeper, app.BankKeeper, *app.GovKeeper, + authtypes.NewModuleAddress(govtypes.ModuleName).String(), + authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()), + authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()), authtypes.FeeCollectorName, )   authority was added - requirement for executing MsgUpdateParams uses x/gov module address by default validatorAddressCodec &amp; consensusAddressCodec were added - they must match the bech32 address codec used by x/auth, x/bank, x/staking  ","version":"v5.2.0","tagName":"h3"},{"title":"Protocol changes​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#protocol-changes","content":" Revert AfterUnbondingInitiated​  AfterUnbondingInitiated behavior was reverted to ICS@v1.2.0-multiden  The revert re-introduces an additional state check.  See this issue for more context and the actions taken.  ","version":"v5.2.0","tagName":"h3"},{"title":"Migration (v4 -> v5)​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#migration-v4---v5","content":" ConensusVersion was bumped to 5.  The migration allows storing the provider module params in the x/ccv/provider module store instead of relying on legacy x/param store.  There are no special requirements for executing this migration.  ","version":"v5.2.0","tagName":"h3"},{"title":"Additions​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#additions","content":" ","version":"v5.2.0","tagName":"h3"},{"title":"MsgUpdateParams transaction​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#msgupdateparams-transaction","content":" x/gov module account is selected as the default authority.  It is available when using gov CLI commands:  Drafting a proposal:  interchain-security-pd tx gov draft-proposal # select &quot;other&quot; # find and select &quot;/interchain_security.ccv.provider.v1.MsgUpdateParams&quot;   Submitting a proposal:  interchain-security-pd tx gov submit-proposal &lt;proposal-message.json&gt;   Example proposal-message.json:  { &quot;messages&quot;: [ { &quot;@type&quot;: &quot;/interchain_security.ccv.provider.v1.MsgUpdateParams&quot;, &quot;authority&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot;, &quot;params&quot;: { &quot;trusting_period_fraction&quot;: &quot;0.66&quot;, &quot;ccv_timeout_period&quot;: &quot;2419200s&quot;, &quot;init_timeout_period&quot;: &quot;604800s&quot;, &quot;vsc_timeout_period&quot;: &quot;3024000s&quot;, &quot;slash_meter_replenish_period&quot;: &quot;3s&quot;, &quot;slash_meter_replenish_fraction&quot;: &quot;1.0&quot;, &quot;consumer_reward_denom_registration_fee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocks_per_epoch&quot;: &quot;600&quot; } } ], &quot;metadata&quot;: &quot;ipfs://CID&quot;, &quot;deposit&quot;: &quot;10000stake&quot;, &quot;title&quot;: &quot;Update Provider params&quot;, &quot;summary&quot;: &quot;Update Provider params&quot;, &quot;expedited&quot;: false }   ","version":"v5.2.0","tagName":"h3"},{"title":"","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5##","content":" When updating parameters all parameters fields must be specified. Make sure you are only changing parameters that you are interested in.  To avoid accidentally changing parameters you can first check the current on-chain provider params using:  interchain-security-pd q provider params -o json { &quot;template_client&quot;: {...}, &quot;trusting_period_fraction&quot;: &quot;0.66&quot;, &quot;ccv_timeout_period&quot;: &quot;2419200s&quot;, &quot;init_timeout_period&quot;: &quot;604800s&quot;, &quot;vsc_timeout_period&quot;: &quot;3024000s&quot;, &quot;slash_meter_replenish_period&quot;: &quot;3s&quot;, &quot;slash_meter_replenish_fraction&quot;: &quot;1.0&quot;, &quot;consumer_reward_denom_registration_fee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocks_per_epoch&quot;: &quot;600&quot; }   ","version":"v5.2.0","tagName":"h3"},{"title":"Governance proposals​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#governance-proposals","content":" Submitting the following legacy proposals is still supported:  Consumer addition proposal  interchain-security-pd tx gov submit-legacy-proposal consumer-addition &lt;proposal_file.json&gt;   Consumer removal proposal  interchain-security-pd tx gov submit-legacy-proposal consumer-removal &lt;proposal_file.json&gt;   Consumer addition proposal  interchain-security-pd tx gov submit-legacy-proposal change-reward-denoms &lt;proposal_file.json&gt;   You may also submit proposal messages above using submit-proposal.  ","version":"v5.2.0","tagName":"h3"},{"title":"Consumer​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#consumer","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"Keeper initialization​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#keeper-initialization-1","content":" // pre-initialize ConsumerKeeper to satsfy ibckeeper.NewKeeper app.ConsumerKeeper = ibcconsumerkeeper.NewNonZeroKeeper( appCodec, keys[ibcconsumertypes.StoreKey], app.GetSubspace(ibcconsumertypes.ModuleName), ) app.IBCKeeper = ibckeeper.NewKeeper( appCodec, keys[ibchost.StoreKey], app.GetSubspace(ibchost.ModuleName), app.ConsumerKeeper, app.UpgradeKeeper, scopedIBCKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // initialize the actual consumer keeper app.ConsumerKeeper = ibcconsumerkeeper.NewKeeper( appCodec, keys[ibcconsumertypes.StoreKey], app.GetSubspace(ibcconsumertypes.ModuleName), scopedIBCConsumerKeeper, app.IBCKeeper.ChannelKeeper, - &amp;app.IBCKeeper.PortKeeper, + app.IBCKeeper.PortKeeper, app.IBCKeeper.ConnectionKeeper, app.IBCKeeper.ClientKeeper, app.SlashingKeeper, app.BankKeeper, app.AccountKeeper, &amp;app.TransferKeeper, app.IBCKeeper, authtypes.FeeCollectorName, // make sure the authority address makes sense for your chain // the exact module account may differ depending on your setup (x/gov, x/admin or custom module) // for x/ccv/democracy using the x/gov module address is correct // if you don't have a way of updating consumer params you may still use the line below as it will have no affect + authtypes.NewModuleAddress(govtypes.ModuleName).String(), // add address codecs + authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()), + authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()), )   authority was added - requirement for executing MsgUpdateParams make sure the authority address makes sense for your chainthe exact module account may differ depending on your setup (x/gov, x/admin or custom module)for x/ccv/democracy using the x/gov module address is correctif you don't have a way of updating consumer params you may use authtypes.NewModuleAddress(govtypes.ModuleName).String() (has no effect on functionality) validatorAddressCodec &amp; consensusAddressCodec were added - they must match the bech32 address codec used by x/auth, x/bank, x/staking  ","version":"v5.2.0","tagName":"h3"},{"title":"Additions​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#additions-1","content":" MsgUpdateParams transaction​  This functionality is not supported on x/ccv/consumer without additional configuration.  if you are using x/ccv/democracy the feature is supported out of the boxif you are using custom logic for changing consumer params, please update your code by providing the appropriate authority module account during ConsumerKeeper initialization in app.go.  You must add &quot;/interchain_security.ccv.consumer.v1.MsgUpdateParams&quot; to your parameters whitelist to be able to change ccvconsumer parameters via governance.  It is available when using gov CLI commands:  Drafting a proposal:  interchain-security-cd tx gov draft-proposal # select &quot;other&quot; # find and select &quot;/interchain_security.ccv.consumer.v1.MsgUpdateParams&quot;   Submitting a proposal:  this proposal cannot be executed on chains without access to x/gov or other modules for managing governance   interchain-security-cdd tx gov submit-proposal &lt;proposal-message.json&gt;   Example proposal-message.json.  { &quot;messages&quot;: [ { &quot;@type&quot;: &quot;/interchain_security.ccv.consumer.v1.MsgUpdateParams&quot;, &quot;authority&quot;: &quot;consumer10d07y265gmmuvt4z0w9aw880jnsr700jlh7295&quot;, &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocks_per_distribution_transmission&quot;: &quot;20&quot;, &quot;distribution_transmission_channel&quot;: &quot;channel-1&quot;, &quot;provider_fee_pool_addr_str&quot;: &quot;&quot;, &quot;ccv_timeout_period&quot;: &quot;2419200s&quot;, &quot;transfer_timeout_period&quot;: &quot;3000s&quot;, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;historical_entries&quot;: &quot;10000&quot;, &quot;unbonding_period&quot;: &quot;1209600s&quot;, &quot;soft_opt_out_threshold&quot;: &quot;0.05&quot;, &quot;reward_denoms&quot;: [], &quot;provider_reward_denoms&quot;: [], &quot;retry_delay_period&quot;: &quot;3000s&quot; } } ], &quot;metadata&quot;: &quot;ipfs://CID&quot;, &quot;deposit&quot;: &quot;1000uatom&quot;, &quot;title&quot;: &quot;Update Consumer Params -- change transfer_timeout_period to 3000s&quot;, &quot;summary&quot;: &quot;Test Update Consumer Params&quot;, &quot;expedited&quot;: false }   When updating parameters all parameters fields must be specified. Make sure you are only changing parameters that you are interested in.  To avoid accidentally changing parameters you can first check the current on-chain consumer params using:  interchain-security-pd q ccvconsumer params -o json   Params Query​  Consumer params query was added:  interchain-security-cd q ccvconsumer params -o json { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocks_per_distribution_transmission&quot;: &quot;1000&quot;, &quot;distribution_transmission_channel&quot;: &quot;&quot;, &quot;provider_fee_pool_addr_str&quot;: &quot;&quot;, &quot;ccv_timeout_period&quot;: &quot;2419200s&quot;, &quot;transfer_timeout_period&quot;: &quot;3600s&quot;, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;historical_entries&quot;: &quot;10000&quot;, &quot;unbonding_period&quot;: &quot;1209600s&quot;, &quot;soft_opt_out_threshold&quot;: &quot;0.05&quot;, &quot;reward_denoms&quot;: [], &quot;provider_reward_denoms&quot;: [], &quot;retry_delay_period&quot;: &quot;3600s&quot; } }   ","version":"v5.2.0","tagName":"h3"},{"title":"Migration (v2 -> v3)​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#migration-v2---v3","content":" ConensusVersion was bumped to 3.  The migration allows storing the consumer module params in the x/ccv/consumer module store instead of relying on legacy x/param store.  There are no special requirements for executing this migration.  ","version":"v5.2.0","tagName":"h3"},{"title":"Interface method changes​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#interface-method-changes","content":" Consumer methods were changed to match the cosmos-sdk StakingKeeper interface. You will not need to change your code, unless you are using the ConsumerKeeper inside custom tests or you have developed custom app functionality that relies on ConsumerKeeper.  Please check the list below if you are using any of the consumer methods:  type StakingKeeper interface { UnbondingTime(ctx context.Context) (time.Duration, error) GetValidatorByConsAddr(ctx context.Context, consAddr sdk.ConsAddress) (stakingtypes.Validator, error) GetLastValidatorPower(ctx context.Context, operator sdk.ValAddress) (int64, error) Jail(context.Context, sdk.ConsAddress) error // jail a validator Slash(ctx context.Context, consAddr sdk.ConsAddress, infractionHeight, power int64, slashFactor math.LegacyDec) (math.Int, error) SlashWithInfractionReason(ctx context.Context, consAddr sdk.ConsAddress, infractionHeight, power int64, slashFactor math.LegacyDec, infraction stakingtypes.Infraction) (math.Int, error) Unjail(ctx context.Context, addr sdk.ConsAddress) error GetValidator(ctx context.Context, addr sdk.ValAddress) (stakingtypes.Validator, error) IterateLastValidatorPowers(ctx context.Context, cb func(addr sdk.ValAddress, power int64) (stop bool)) error IterateValidators(ctx context.Context, f func(index int64, validator stakingtypes.ValidatorI) (stop bool)) error Validator(ctx context.Context, addr sdk.ValAddress) (stakingtypes.ValidatorI, error) IsValidatorJailed(ctx context.Context, addr sdk.ConsAddress) (bool, error) ValidatorByConsAddr(ctx context.Context, consAddr sdk.ConsAddress) (stakingtypes.ValidatorI, error) Delegation(ctx context.Context, addr sdk.AccAddress, valAddr sdk.ValAddress) (stakingtypes.DelegationI, error) MaxValidators(ctx context.Context) (uint32, error) }   The consumer implements the StakingKeeper interface shown above.  ","version":"v5.2.0","tagName":"h3"},{"title":"Democracy​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#democracy","content":" Changes in Consumer also apply to Democracy.  Democracy x/staking, x/distribution and x/gov were updated to reflect changes in cosmos-sdk v0.50.x.  There were no notable changes arising to the module functionality aside from conforming to cosmos-sdk v0.50.x.  ","version":"v5.2.0","tagName":"h2"},{"title":"Note:​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v5.2.0/upgrading/migrate_v4_v5#note-1","content":" You must add &quot;/interchain_security.ccv.consumer.v1.MsgUpdateParams&quot; to your parameters whitelist to be able to change consumer parameters via governance. ","version":"v5.2.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/validators/overview","content":"","keywords":"","version":"v5.2.0"},{"title":"Startup sequence overview​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#startup-sequence-overview","content":" Consumer chains cannot start and be secured by the validator set of the provider unless a ConsumerAdditionProposal is passed. Each proposal contains defines a spawn_time - the timestamp when the consumer chain genesis is finalized and the consumer chain clients get initialized on the provider.  tip Validators are required to run consumer chain binaries only after spawn_time has passed.  Please note that any additional instructions pertaining to specific consumer chain launches will be available before spawn time. The chain start will be stewarded by the Cosmos Hub team and the teams developing their respective consumer chains.  The image below illustrates the startup sequence  ","version":"v5.2.0","tagName":"h2"},{"title":"1. Consumer Chain init + 2. Genesis generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#1-consumer-chain-init--2-genesis-generation","content":" Consumer chain team initializes the chain genesis.json and prepares binaries which will be listed in the ConsumerAdditionProposal  ","version":"v5.2.0","tagName":"h3"},{"title":"3. Submit Proposal​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#3-submit-proposal","content":" Consumer chain team (or their advocates) submits a ConsumerAdditionProposal. The most important parameters for validators are:  spawn_time - the time after which the consumer chain must be startedgenesis_hash - hash of the pre-ccv genesis.json; the file does not contain any validator info -&gt; the information is available only after the proposal is passed and spawn_time is reachedbinary_hash - hash of the consumer chain binary used to validate the software builds  ","version":"v5.2.0","tagName":"h3"},{"title":"4. CCV Genesis state generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#4-ccv-genesis-state-generation","content":" After reaching spawn_time the provider chain will automatically create the CCV validator states that will be used to populate the corresponding fields in the consumer chain genesis.json. The CCV validator set consists of the validator set on the provider at spawn_time.  The state can be queried on the provider chain (in this case the Cosmos Hub):   gaiad query provider consumer-genesis &lt;consumer chain ID&gt; -o json &gt; ccvconsumer_genesis.json   This is used by the launch coordinator to create the final genesis.json that will be distributed to validators in step 5.  ","version":"v5.2.0","tagName":"h3"},{"title":"5. Updating the genesis file​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#5-updating-the-genesis-file","content":" Upon reaching the spawn_time the initial validator set state will become available on the provider chain. The initial validator set is included in the final genesis.json of the consumer chain.  ","version":"v5.2.0","tagName":"h3"},{"title":"6. Chain start​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#6-chain-start","content":" info The consumer chain will start producing blocks as soon as 66.67% of the provider chain's voting power comes online (on the consumer chain). The relayer should be started after block production commences.  The new genesis.json containing the initial validator set will be distributed to validators by the consumer chain team (launch coordinator). Each validator should use the provided genesis.json to start their consumer chain node.  tip Please pay attention to any onboarding repositories provided by the consumer chain teams. Recommendations are available in Consumer Onboarding Checklist. Another comprehensive guide is available in the Interchain Security testnet repo.  ","version":"v5.2.0","tagName":"h3"},{"title":"7. Creating IBC connections​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#7-creating-ibc-connections","content":" Finally, to fully establish interchain security an IBC relayer is used to establish connections and create the required channels.  warning The relayer can establish the connection only after the consumer chain starts producing blocks.  hermes create connection --a-chain &lt;consumer chain ID&gt; --a-client 07-tendermint-0 --b-client &lt;client assigned by provider chain&gt; hermes create channel --a-chain &lt;consumer chain ID&gt; --a-port consumer --b-port provider --order ordered --a-connection connection-0 --channel-version 1 hermes start   ","version":"v5.2.0","tagName":"h3"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#downtime-infractions","content":" At present, the consumer chain can report evidence about downtime infractions to the provider chain. The min_signed_per_window and signed_blocks_window can be different on each consumer chain and are subject to changes via consumer chain governance.  info Causing a downtime infraction on any consumer chain will not incur a slash penalty. Instead, the offending validator will be jailed on the provider chain and consequently on all consumer chains. To unjail, the validator must wait for the jailing period to elapse on the provider chain and submit an unjail transaction on the provider chain. After unjailing on the provider, the validator will be unjailed on all consumer chains. More information is available in Downtime Slashing documentation  ","version":"v5.2.0","tagName":"h2"},{"title":"Double-signing Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#double-signing-infractions","content":" To learn more about equivocation handling in interchain security check out the Slashing documentation section.  ","version":"v5.2.0","tagName":"h2"},{"title":"Key assignment​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#key-assignment","content":" Validators can use different consensus keys on the provider and each of the consumer chains. The consumer chain consensus key must be registered on the provider before use.  For more information check out the Key assignment overview and guide  ","version":"v5.2.0","tagName":"h2"},{"title":"References:​","type":1,"pageTitle":"Overview","url":"/interchain-security/v5.2.0/validators/overview#references","content":" Cosmos Hub Validators FAQCosmos Hub Running a validatorStartup SequenceSubmit Unjailing Transaction ","version":"v5.2.0","tagName":"h2"},{"title":"Consumer chain validator rewards","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/validators/withdraw_rewards","content":"","keywords":"","version":"v5.2.0"},{"title":"Withdrawing rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v5.2.0/validators/withdraw_rewards#withdrawing-rewards","content":" Here are example steps for withdrawing rewards from consumer chains in the provider chain  info The examples used are from rs-testnet, the Interchain Security persistent testnet. Validator operator address: cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6Self-delegation address: cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf  Prior to withdrawing rewards, query balances for self-delegation address:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;1000000000000&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;   ","version":"v5.2.0","tagName":"h2"},{"title":"Querying validator rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v5.2.0/validators/withdraw_rewards#querying-validator-rewards","content":" Query rewards for the validator address:  gaiad q distribution rewards cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 rewards: - amount: &quot;158.069895000000000000&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;841842390516.072526500000000000&quot; denom: uatom   The ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD denom represents rewards from a consumer chain.  ","version":"v5.2.0","tagName":"h2"},{"title":"Withdrawing rewards and commission​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v5.2.0/validators/withdraw_rewards#withdrawing-rewards-and-commission","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"1. Withdraw rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v5.2.0/validators/withdraw_rewards#1-withdraw-rewards","content":" gaiad tx distribution withdraw-rewards cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 --from cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf --commission --chain-id provider --gas auto --fees 500uatom -b block -y txhash: A7E384FB1958211B43B7C06527FC7D4471FB6B491EE56FDEA9C5634D76FF1B9A   ","version":"v5.2.0","tagName":"h3"},{"title":"2. Confirm withdrawal​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v5.2.0/validators/withdraw_rewards#2-confirm-withdrawal","content":" After withdrawing rewards self-delegation address balance to confirm rewards were withdrawn:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;216&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;2233766225342&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;  ","version":"v5.2.0","tagName":"h3"},{"title":"Cosmos Hub - Interchain Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0","content":"Cosmos Hub - Interchain Security Welcome to the official documentation for the Cosmos Hub's Interchain Security - a platform for launching Cosmos-SDK chains. The Cosmos Hub is the best place to launch a chain. With the recent launch of Partial Set Security (PSS), it's easier than ever to leverage the Cosmos Hub validators, stake, and community for your chain. PSS provides powerful new capabilities for permissionlessly launching your chain and shaping your validator set. Here you can find information about Interchain Security, consumer chain development and instructions for validator onboarding. Basic Concepts Get started with the basic concepts and ideas. FAQ Frequently asked questions about the protocol and its implications Start Building Click here to start building with Interchain Security Onboarding Checklist Checklist to help you integrate Interchain Security, get support and onboard validators Become an ICS Validator Start validating on consumer chains Assign Consumer Keys Learn how to assign separate key on the consumer chains","keywords":"","version":"v6.1.0"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators","content":"","keywords":"","version":"v5.2.0"},{"title":"Messages​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#messages","content":" ","version":"v5.2.0","tagName":"h2"},{"title":"How to opt in to a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#how-to-opt-in-to-a-consumer-chain","content":" warning A validator is automatically opted in to a Top N chain if the validator belongs to the top N% of the validators on the provider chain.  In a Top N chain, a validator that does not belong to the top N% of the validators on the provider can still choose to opt in to a consumer chain. In other words, validators can opt in, in both Opt-In and Top N chains.  A validator can opt in to a consumer chain by issuing the following message:  interchain-security-pd tx provider opt-in &lt;consumer-chain-id&gt; &lt;optional consumer-pub-key&gt;   where  consumer-chain-id is the string identifier of the consumer chain the validator wants to opt in to;consumer-pub-key corresponds to the public key the validator wants to use on the consumer chain, and it has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}.  A validator can opt in to an existing consumer chain that is already running, or to a proposedconsumer chain that is still being voted on. A validator can use the following command to retrieve the currently existing consumer chains:  interchain-security-pd query provider list-consumer-chains   and this command to see the currently proposed consumer chains:  interchain-security-pd query provider list-proposed-consumer-chains   tip By setting the consumer-pub-key, a validator can both opt in to a chain and assign a public key on a consumer chain. Note that a validator can always assigna new consumer key at a later stage. The key-assignment rulesstill apply when setting consumer-pub-key when opting in.  info A validator is only eligible for consumer rewards from a consumer chain if the validator is opted into that chain.  ","version":"v5.2.0","tagName":"h3"},{"title":"How to opt out from a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#how-to-opt-out-from-a-consumer-chain","content":" A validator can opt out from a consumer by issuing the following message:  interchain-security-pd tx provider opt-out &lt;consumer-chain-id&gt;   where  consumer-chain-id is the string identifier of the consumer chain.  warning A validator cannot opt out from a Top N chain if it belongs to the top N% validators of the provider.  warning If a validator moves from the Top N to outside of the top N% of the validators on the provider, it will notbe automatically opted-out. The validator has to manually opt out.  warning A validator can stop its node on a consumer chain only after opting out and confirming through the has-to-validatequery (see below) that it does not have to validate the consumer chain any longer.  warning If all validators opt out from an Opt-In chain, the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"v5.2.0","tagName":"h3"},{"title":"How to set specific per consumer chain commission rate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#how-to-set-specific-per-consumer-chain-commission-rate","content":" A validator can choose to set a different commission rate on each of the consumer chains. This can be done with the following command:  interchain-security-pd tx provider set-consumer-commission-rate &lt;consumer-chain-id&gt; &lt;commission-rate&gt;   where  consumer-chain-id is the string identifier of the consumer chain;comission-rate decimal in [minRate, 1] where minRate corresponds to the minimum commission rate set on the provider chain (see min_commission_rate in interchain-security-pd query staking params).  If a validator does not set a commission rate on a consumer chain, the commission rate defaults to their commission rate on the provider chain.  tip Validators can set their commission rate even for consumer chains that they are not currently opted in on, and the commission rate will be applied when they opt in. This is particularly useful for Top N chains, where validators might be opted in automatically, so validators can set the commission rate in advance.  tip If a validator opts out and then back in, this will not reset their commission rate back to the default. Instead, their set commission rate still applies.  ","version":"v5.2.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#queries","content":" Partial Set Security introduces a number of queries to assist validators determine which consumer chains they have to validate, their commission rate per chain, etc.  ","version":"v5.2.0","tagName":"h2"},{"title":"Which chains does a validator have to validate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#which-chains-does-a-validator-have-to-validate","content":" Naturally, a validator is aware of the Opt-In chains it has to validate because in order to validate an Opt-In chain, a validator has to manually opt in to the chain. This is not the case for Top N chains where a validator might be required to validate such a chain without explicitly opting in if it belongs to the top N% of the validators on the provider.  We introduce the following query:  interchain-security-pd query provider has-to-validate &lt;provider-validator-address&gt;   that can be used by validator with provider-validator-address address to retrieve the list of chains that it has to validate.  tip As a validator, the list of chains returned by has-to-validate is the list of chains you should be validating to avoid getting jailed for downtime.  ","version":"v5.2.0","tagName":"h3"},{"title":"How do you know how much voting power you need to have to be in the top N for a chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#how-do-you-know-how-much-voting-power-you-need-to-have-to-be-in-the-top-n-for-a-chain","content":" This can be seen as part of the list-consumer-chains query:  interchain-security-pd query provider list-consumer-chains   where the min_power_in_top_N field shows the minimum voting power required to be automatically opted in to the chain.  tip list-consumer-chains shows the minimal voting power right now, but the automatic opt-in happens only when epochs end on the provider. In consequence, a validators power might be large enough to be automatically opted in during an epoch, but if their power is sufficiently decreased before the epoch ends, they will not be opted in automatically.  ","version":"v5.2.0","tagName":"h3"},{"title":"How to retrieve all the opted-in validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-opted-in-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-opted-in-validators &lt;consumer-chain-id&gt;   we can see all the opted-in validators on consumer-chain-id that were manually or automatically opted in.  ","version":"v5.2.0","tagName":"h3"},{"title":"How to retrieve all the consumer validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-consumer-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-validators &lt;consumer-chain-id&gt;   we can see all the consumer validators (i.e., validator set) of consumer-chain-id. The consumer validators are the ones that are currently (or in the future, see warning) validating the consumer chain. A consumer validator is an opted-in validator but not vice versa. For example, an opted-in validator V might not be a consumer validator because V is denylisted or because V is removed due to a validator-set cap.  warning The returned consumer validators from this query do not necessarily correspond to the validator set that is validating the consumer chain at this exact moment. This is because the VSCPacket sent to a consumer chain might be delayed and hence this query might return the validator set that the consumer chain would have at some future point in time.  ","version":"v5.2.0","tagName":"h3"},{"title":"How can we see the commission rate a validator has set on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v5.2.0/validators/partial-set-security-for-validators#how-can-we-see-the-commission-rate-a-validator-has-set-on-a-consumer-chain","content":" Using the following query:  interchain-security-pd query provider validator-consumer-commission-rate &lt;consumer-chain-id&gt; &lt;provider-validator-address&gt;   we retrieve the commission rate set by validator with provider-validator-address address on consumer-chain-id. ","version":"v5.2.0","tagName":"h3"},{"title":"ADR 003: Equivocation governance proposal","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal#changelog","content":" 2023-02-06: Initial draft2023-11-30: Change status to deprecated  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal#status","content":" Deprecated  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal#context","content":" Note: ADR deprecated as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  We want to limit the possibilities of a consumer chain to execute actions on the provider chain to maintain and ensure optimum security of the provider chain.  For instance, a malicious consumer consumer chain can send slash packet to the provider chain, which will slash a validator without the need of providing an evidence.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal#decision","content":" To protect against a malicious consumer chain, slash packets unrelated to downtime are ignored by the provider chain. Thus, an other mechanism is required to punish validators that have committed a double-sign on a consumer chain.  A new kind of governance proposal is added to the provider module, allowing to slash and tombstone a validator for double-signing in case of any harmful action on the consumer chain.  If such proposal passes, the proposal handler delegates to the evidence module to process the equivocation. This module ensures the evidence isn’t too old, or else ignores it (see code). Too old is determined by 2 consensus params :  evidence.max_age_duration number of nanoseconds before an evidence is considered too oldevidence.max_age_numblocks number of blocks before an evidence is considered too old.  On the hub, those parameters are equals to  // From https://cosmos-rpc.polkachu.com/consensus_params?height=13909682 (...) &quot;evidence&quot;: { &quot;max_age_num_blocks&quot;: &quot;1000000&quot;, &quot;max_age_duration&quot;: &quot;172800000000000&quot;, (...) }, (...)   A governance proposal takes 14 days, so those parameters must be big enough so the evidence provided in the proposal is not ignored by the evidence module when the proposal passes and is handled by the hub.  For max_age_num_blocks=1M, the parameter is big enough if we consider the hub produces 12k blocks per day (blocks_per_year/365 = 436,0000/365). The evidence can be up to 83 days old (1,000,000/12,000) and not be ignored.  For max_age_duration=172,800,000,000,000, the parameter is too low, because the value is in nanoseconds so it’s 2 days. Fortunately the condition that checks those 2 parameters uses a AND, so if max_age_num_blocks condition passes, the evidence won’t be ignored.  ","version":"v6.1.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal#positive","content":" Remove the possibility from a malicious consumer chain to “attack” the provider chain by slashing/jailing validators.Provide a more acceptable implementation for the validator community.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal#negative","content":" Punishment action of double-signing isn’t “automated”, a governance proposal is required which takes more time.You need to pay 250ATOM to submit an equivocation evidence.  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal#neutral","content":" ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.1.0/adrs/adr-003-equivocation-gov-proposal#references","content":" PR that ignores non downtime slash packet : https://github.com/cosmos/interchain-security/pull/692PR that adds the governance slash proposal: https://github.com/cosmos/interchain-security/pull/703 ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 001: Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#changelog","content":" 2022-12-01: Initial Draft2024-03-01: Updated to take into account they key-assigment-replacement deprecation.  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#context","content":" KeyAssignment is the name of the feature that allows validator operators to use different consensus keys for each consumer chain validator node that they operate.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#decision","content":" It is possible to change the keys at any time by submitting a transaction (i.e., MsgAssignConsumerKey).  ","version":"v6.1.0","tagName":"h2"},{"title":"State required​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#state-required","content":" ValidatorConsumerPubKey - Stores the validator assigned keys for every consumer chain.  ConsumerValidatorsBytePrefix | len(chainID) | chainID | providerConsAddress -&gt; consumerKey   ValidatorByConsumerAddr - Stores the mapping from validator addresses on consumer chains to validator addresses on the provider chain. Needed for the consumer initiated slashing sub-protocol.  ValidatorsByConsumerAddrBytePrefix | len(chainID) | chainID | consumerConsAddress -&gt; providerConsAddress   ConsumerAddrsToPrune - Stores the mapping from VSC ids to consumer validators addresses. Needed for pruning ValidatorByConsumerAddr.  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; []consumerConsAddresses   ","version":"v6.1.0","tagName":"h3"},{"title":"Protocol overview​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#protocol-overview","content":" On receiving a MsgAssignConsumerKey(chainID, providerAddr, consumerKey) message:  // get validator from staking module validator, found := stakingKeeper.GetValidator(providerAddr) if !found { return ErrNoValidatorFound } providerConsAddr := validator.GetConsAddr() // make sure consumer key is not in use consumerAddr := utils.TMCryptoPublicKeyToConsAddr(consumerKey) if _, found := GetValidatorByConsumerAddr(ChainID, consumerAddr); found { return ErrInvalidConsumerConsensusPubKey } // check whether the consumer chain is already registered // i.e., a client to the consumer was already created if _, consumerRegistered := GetConsumerClientId(chainID); consumerRegistered { // get the previous key assigned for this validator on this consumer chain oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr) if found { // mark this old consumer key as prunable once the VSCMaturedPacket // for the current VSC ID is received oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) vscID := GetValidatorSetUpdateId() AppendConsumerAddrsToPrune(chainID, vscID, oldConsumerAddr) } } else { // if the consumer chain is not registered, then remove the previous reverse mapping if oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr); found { oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) DeleteValidatorByConsumerAddr(chainID, oldConsumerAddr) } } // set the mapping from this validator's provider address to the new consumer key SetValidatorConsumerPubKey(chainID, providerConsAddr, consumerKey) // set the reverse mapping: from this validator's new consensus address // on the consumer to its consensus address on the provider SetValidatorByConsumerAddr(chainID, consumerAddr, providerConsAddr)   When a new consumer chain is registered, i.e., a client to the consumer chain is created, the provider constructs the consumer CCV module part of the genesis state (see MakeConsumerGenesis).  func (k Keeper) MakeConsumerGenesis(chainID string) (gen consumertypes.GenesisState, nextValidatorsHash []byte, err error) { // ... // get initial valset from the staking module var updates []abci.ValidatorUpdate{} stakingKeeper.IterateLastValidatorPowers(func(providerAddr sdk.ValAddress, power int64) (stop bool) { validator := stakingKeeper.GetValidator(providerAddr) providerKey := validator.TmConsPublicKey() updates = append(updates, abci.ValidatorUpdate{PubKey: providerKey, Power: power}) return false }) // applies the key assignment to the initial validator for i, update := range updates { providerAddr := utils.TMCryptoPublicKeyToConsAddr(update.PubKey) if consumerKey, found := GetValidatorConsumerPubKey(chainID, providerAddr); found { updates[i].PubKey = consumerKey } } gen.InitialValSet = updates // get a hash of the consumer validator set from the update updatesAsValSet := tendermint.PB2TM.ValidatorUpdates(updates) hash := tendermint.NewValidatorSet(updatesAsValSet).Hash() return gen, hash, nil }   Note that key assignment works hand-in-hand with epochs. For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. Specifically, for each validator in the set we store among others, the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacketwith all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   where DiffValidators internally checks if the consumer public key for a validator has changed since the last epoch and if so generates a validator update. This way, a validator can change its consumer public key for a consumer chain an arbitrary amount of times and only the last set consumer public key would be taken into account.  On receiving a SlashPacket from a consumer chain with id chainID for a infraction of a validator data.Validator:  func HandleSlashPacket(chainID string, data ccv.SlashPacketData) (success bool, err error) { // ... // the slash packet validator address may be known only on the consumer chain; // in this case, it must be mapped back to the consensus address on the provider chain consumerAddr := sdk.ConsAddress(data.Validator.Address) providerAddr, found := GetValidatorByConsumerAddr(chainID, consumerAddr) if !found { // the validator has the same key on the consumer as on the provider providerAddr = consumerAddr } // ... }   On receiving a VSCMatured:  func OnRecvVSCMaturedPacket(packet channeltypes.Packet, data ccv.VSCMaturedPacketData) exported.Acknowledgement { // ... // prune previous consumer validator address that are no longer needed consumerAddrs := GetConsumerAddrsToPrune(chainID, data.ValsetUpdateId) for _, addr := range consumerAddrs { DeleteValidatorByConsumerAddr(chainID, addr) } DeleteConsumerAddrsToPrune(chainID, data.ValsetUpdateId) // ... }   On stopping a consumer chain:  func (k Keeper) StopConsumerChain(ctx sdk.Context, chainID string, closeChan bool) (err error) { // ... // deletes all the state needed for key assignments on this consumer chain // ... }   ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#positive","content":" Validators can use different consensus keys on the consumer chains.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#negative","content":" None  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#neutral","content":" The consensus state necessary to create a client to the consumer chain must use the hash returned by the MakeConsumerGenesis method as the nextValsHash.The consumer chain can no longer check the initial validator set against the consensus state on InitGenesis.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.1.0/adrs/adr-001-key-assignment#references","content":" Key assignment issue ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 004: Denom DOS fixes","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes#changelog","content":" 5/9/2023: ADR created  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes#context","content":" The provider and consumer modules are vulnerable to similar issues involving an attacker sending millions of denoms to certain addresses and causing the chain to halt. This ADR outlines both fixes since they are similar. Both fixes involve processing only denoms that are on a whitelist to avoid iterating over millions of junk denoms but have different requirements and are implemented in different ways.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes#decision","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Provider​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes#provider","content":" Put the distribution module's FeePoolAddress back on the blocklist so that it cannot receive funds from users.Create a new address called ConsumerRewardPool and unblock it, allowing funds to be sent to it.Create a set of strings in the store for allowed ConsumerRewardDenoms.Create an endpoint called RegisterConsumerRewardDenom which deducts a fee from the sender's account, sends it to the community pool and adds a string to the ConsumerRewardDenoms set.Create a parameter called ConsumerRewardDenomRegistrationFee which determines the fee which is charged to register a consumer reward denom in the step above.Create a function called TransferRewardsToFeeCollector which gets the entire ConsumerRewardDenoms set from the store, iterates over it, and for each entry: Gets the balance of this denom for the ConsumerRewardPool accountSends the entire balance out to the FeePoolAddress using SendCoinsFromModuleToModule which is not affected by the blocklist. Run TransferRewardsToFeeCollector in the endblock  Now, nobody can send millions of junk denoms to the FeePoolAddress because it is on the block list. If they send millions of junk denoms to the ConsumerRewardPool, this does not matter because all balances are not iterated over, only those which are in the ConsumerRewardDenoms set.  We also add a new tx: register-consumer-reward-denom, and a new query: registered-consumer-reward-denoms  ","version":"v6.1.0","tagName":"h3"},{"title":"Consumer​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes#consumer","content":" Create a new param RewardDenoms with a list of stringsCreate a new param ProviderRewardDenoms with a list of stringsCreate a function AllowedRewardDenoms which iterates over ProviderRewardDenoms and converts each denom to its ibc-prefixed denom using the provider chain's ibc channel information, then concatenates the RewardDenoms list and returns the combined list of allowed denoms.In SendRewardsToProvider, instead of iterating over the balances of all denoms in the ToSendToProvider address, iterate over AllowedRewardDenoms  Now, if somebody sends millions of junk denoms to ToSendToProvider, they will not be iterated over. Only the RewardDenoms and ProviderRewardDenoms will be iterated over. Since we do not require this feature to be permissionless on the consumer, the registration fee process is not needed.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes#positive","content":" Denom DOS is no longer possible on either provider or consumer.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.1.0/adrs/adr-004-denom-dos-fixes#negative","content":" Consumer chain teams must pay a fee to register a denom for distribution on the provider, and add some extra parameters in their genesis file. ","version":"v6.1.0","tagName":"h3"},{"title":"ADR 007: Pause validator unbonding during equivocation proposal","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#changelog","content":" 2023-05-16: Initial Draft2023-11-30: Change the status to rejected  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#status","content":" Rejected  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#context","content":" Note: ADR rejected as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  Currently, if an equivocation slashing proposal is created after more than one week has passed since the equivocation, it is possible that the validator in question could unbond and get away without being slashed, since the unbonding period is 3 weeks, and the voting period is 2 weeks. For this reason, it might be good to pause unbondings for validators named in an equivocation slashing proposal until the proposal's voting period is over.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#decision","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"How​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#how","content":" Pausing the unbonding period is already possible thanks to the changes in thestaking module of the cosmos-sdk:  stakingKeeper.PutUnbondingOnHold pauses an unbonding periodstakingKeeper.UnbondingCanComplete unpauses an unbonding period  These methods use a reference counter under the hood, that gets incremented every time PutUnbondingOnHold is called, and decreased whenUnbondingCanComplete is called instead. A specific unbonding is considered fully unpaused when its underlying reference counter reaches 0. Therefore, as long as we safeguard consistency - i.e. we make sure we eventually decrement the reference counter for each time we have incremented it - we can safely use this existing mechanism without conflicts with the Completion of Unbonding Operations system.  ","version":"v6.1.0","tagName":"h3"},{"title":"When pause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-pause","content":" The unbonding period (if there is any unbonding) should be paused once an equivocation proposal enters the voting period. For that, the gov module's hook AfterProposalDeposit can be used.  If the hook is triggered with a an equivocation proposal in voting period, then for each equivocation of the proposal, the unbonding operations of the related validator that were initiated after the equivocation block time must be paused  i.e. the underlying reference counter has to be increased.  Note that even after the voting period has started, a proposal can receive additional deposits. The hook is triggered however at arrival of a deposit, so a check to verify that the proposal is not already in voting period is required.  ","version":"v6.1.0","tagName":"h3"},{"title":"When unpause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-unpause","content":" We can use a gov module's hook also here and it isAfterProposalVotingPeriodEnded.  If the hook is triggered with an equivocation proposal, then for each associated equivocation, the unbonding operations of the related validator that were initiated between the equivocation block time and the start of the proposal voting period must be unpaused - i.e. decrease the underlying reference counter - regardless of the proposal outcome.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#positive","content":" Validators subject to an equivocation proposal cannot finish unbonding their tokens before the end of the voting period.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#negative","content":" A malicious consumer chain could forge slash packets enabling submission of an equivocation proposal on the provider chain, resulting in the freezing of validator's unbondings for an undeterminated amount of time.Misbehavior on a consumer chain can potentially go unpunished, if no one submits an equivocation proposal in time, or if the proposal doesn't pass.  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#neutral","content":" This feature can't be used for social slashing, because an equivocation proposal is only accepted if there's a slash log for the related validator(s), meaning the consumer chain has reported the equivocation to the provider chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.1.0/adrs/adr-007-pause-unbonding-on-eqv-prop#references","content":" https://github.com/cosmos/interchain-security/issues/747https://github.com/cosmos/interchain-security/pull/791 ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 005: Cryptographic verification of equivocation evidence","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#changelog","content":" 5/1/2023: First draft7/23/2023: Add light client attacks handling9/6/2023: Add double signing attacks handling11/3/2023: Update limitations to clarify amnesia attacks are ignored  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#context","content":" Currently, we use a governance proposal to slash validators for equivocation (double signing and light client attacks). Every proposal needs to go through a (two weeks) voting period before it can be approved. Given a three-week unbonding period, this means that an equivocation proposal needs to be submitted within one week since the infraction occurred.  This ADR proposes a system to slash validators automatically for equivocation, immediately upon the provider chain's receipt of the evidence. Another thing to note is that we intend to introduce this system in stages, since even the partial ability to slash and/or tombstone is a strict improvement in security. The feature is implemented in two parts, each with its dedicated endpoint. One endpoint handles light client attacks, while the other handles double signing attacks.  ","version":"v6.1.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack","content":" In a nutshell, the light client is a process that solely verifies a specific state machine's consensus without executing the transactions. The light clients get new headers by querying multiple nodes, called primary and witness nodes.  Light clients download new headers committed on chain from a primary. Headers can be verified in two ways: sequentially, where the block height of headers is serial, or using skipping. This second verification method allows light clients to download headers with nonconsecutive block height, where some intermediate headers are skipped (see Tendermint Light Client, Figure 1 and Figure 3). Additionally, light clients are cross-checking new headers obtained from a primary with witnesses to ensure all nodes share the same state.  A light client attack occurs when a Byzantine validator sends invalid headers to a light client. As the light client doesn't execute transactions, it can be deceived into trusting corrupted application state transitions. For instance, if a light client receives header A from the primary and header B from a witness for the same block height H, and both headers are successfully verified, it indicates a light client attack. Note that in this case, either the primary or the witness or both are malicious.  The types of light client attacks are defined by analyzing the differences between the conflicting headers. There are three types of light client attacks: lunatic attack, equivocation attack, and amnesia attack. For details, see the CometBFT specification.  When a light client agent detects two conflicting headers, it will initially verify their traces (see cometBFT detector) using its primary and witness nodes. If these headers pass successful verification, the Byzantine validators will be identified based on the header's commit signatures and the type of light client attack. The agent will then transmit this information to its nodes using a LightClientAttackEvidence evidence to be eventually voted on and added to a block. Note that from a light client agent perspective, it is not possible to establish whether a primary or a witness node, or both, are malicious. Therefore, it will create and send two evidences: one against the primary (sent to the witness), and one against the witness (sent to the primary). Both nodes will then verify it before broadcasting it and adding it to the evidence pool. If an evidence is finally committed to a block, the chain's evidence module will execute it, resulting in the jailing and the slashing of the validators responsible for the light client attack.  Light clients are a core component of IBC. In the event of a light client attack, IBC relayers notify the affected chains by submitting an IBC misbehavior message. A misbehavior message includes the conflicting headers that constitute a light client attack evidence. Upon receiving such a message, a chain will first verify whether these headers would have convinced its light client. This verification is achieved by checking the header states against the light client consensus states (see IBC misbehaviour handler). If the misbehaviour is successfully verified, the chain will then &quot;freeze&quot; the light client, halting any further trust in or updating of its states.  ","version":"v6.1.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack","content":" A double signing attack, also known as equivocation, occurs when a validator votes for two different blocks in the same round of the CometBFT consensus. This consensus mechanism operates with multiple voting rounds at each block height, and it strictly prohibits sending two votes of the same type during a round (see CometBFT State Machine Overview).  When a node observes two votes from the same peer, it will use these two votes to create a DuplicateVoteEvidenceevidence and gossip it to the other nodes in the network (see CometBFT equivocation detection). Each node will then verify the evidence according to the CometBFT rules that define a valid double signing infraction, and based on this verification, they will decide whether to add the evidence to a block. During the evidence verification process, the signatures of the conflicting votes must be verified successfully. Note that this is achieved using the public key of the misbehaving validator, along with the chain ID of the chain where the infraction occurred (see CometBFT equivocation verification).  Once a double signing evidence is committed to a block, the consensus layer will report the equivocation to the evidence module of the Cosmos SDK application layer. The application will, in turn, punish the malicious validator through jailing, tombstoning and slashing (see handleEquivocationEvidence).  ","version":"v6.1.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#decision","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack-1","content":" In the first part of the feature, we introduce a new endpoint: HandleConsumerMisbehaviour(ctx sdk.Context, misbehaviour ibctmtypes.Misbehaviour). The main idea is to leverage the current IBC misbehaviour handling and update it to solely jail and slash the validators that performed a light client attack. Note that in this context, we assume that chains connected via a light client share a subset of the validator set of the provider.  This endpoint reuses the IBC client libraries to verify that the misbehaviour headers would have fooled the light client. Additionally, it’s crucial that the endpoint logic results in the slashing and jailing of validators under the same conditions as a light client agent detector. Therefore, the endpoint ensures that the two conditions are met: the headers in the misbehaviour message have the same block height, and the light client isn’t expired.  After having successfully verified a misbehaviour, the endpoint executes the jailing and slashing of the malicious validators similarly as in the evidence module.  ","version":"v6.1.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack-1","content":" In the second part of the feature, we introduce a new endpoint HandleConsumerDoubleVoting( ctx sdk.Context, evidence *tmtypes.DuplicateVoteEvidence, chainID string, pubkey cryptotypes.PubKey). Simply put, the handling logic verifies a double signing evidence against a provided public key and chain ID and, if successful, executes the jailing of the malicious validator who double voted.  We define a newMsgSubmitConsumerDoubleVoting message to report a double voting evidence observed on a consumer chain to the endpoint of the provider chain. This message contains two fields: a double signing evidenceduplicate_vote_evidence and a light client header for the infraction block height, referred to as infraction_block_header. The latter provides the malicious validator's public key and the chain ID required to verify the signature of the votes contained in the evidence.  Note that double signing evidence is not verified using the same conditions as in the implementation CometBFT (seeverify(evidence types.Evidence) method). Specifically, we do not check that the evidence hasn't expired. More details can be found in the &quot;Current limitations&quot; section below.  Upon a successful equivocation verification, the misbehaving validator is jailed for the maximum time (see DoubleSignJailEndTimein the SDK evidence module).  ","version":"v6.1.0","tagName":"h3"},{"title":"Current limitations:​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#current-limitations","content":" We cannot derive an infraction height from the evidence, so it is only possible to jail validators, not actually slash them. To explain the technical reasons behind this limitation, let's recap the initial consumer initiated slashing logic. In a nutshell, consumer heights are mapped to provider heights through VSCPackets, namely through the so called vscIDs. When an infraction occurs on the consumer, a SlashPacket containing the vscID obtained from mapping the consumer infraction height is sent to the provider. Upon receiving the packet, the provider maps the consumer infraction height to a local infraction height, which is used to slash the misbehaving validator. In the context of untrusted consumer chains, all their states, including vscIDs, could be corrupted and therefore cannot be used for slashing purposes. For the same reasons explained above, the age of a consumer double signing evidence can't be verified, either using its infraction height or its unsigned timestamp. Note that changes the jailing behaviour, potentially leading to a validator's jailing based on some &quot;old&quot; evidence from a consumer, which wouldn't occur if the consumer were a standalone chain. In the first stage of this feature, validators are jailed indefinitely without being tombstoned. The underlying reason is that a malicious validator could take advantage of getting tombstoned to avoid being slashed on the provider (see comment). Currently, the endpoint can only handle equivocation light client attacks. This is because the lunatic attacks require the endpoint to possess the ability to dissociate which header is conflicted or trusted upon receiving a misbehavior message. Without this information, it's not possible to extract the Byzantine validators from the conflicting headers (see comment). In addition, &quot;amnesia&quot; attacks are ignored, similar to CometBFT (see ADR-056).  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#positive","content":" It is now possible for the provider chain to jail validators who committed light client or double signing attacks on a consumer chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#negative","content":" N/A  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.1.0/adrs/adr-005-cryptographic-equivocation-verification#references","content":" ICS misbehaviour handling PRConsumer double voting handler PRArchitectural diagramsADR on equivocation slashing ","version":"v6.1.0","tagName":"h2"},{"title":"Soft Opt-Out","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out","content":"","keywords":"","version":"v6.1.0"},{"title":"ADR 009: Soft Opt-Out​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#adr-009-soft-opt-out","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#changelog","content":" 6/13/23: Initial draft of ADR. Feature already implemented and in production.6/19/24: Change status to deprecated  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#status","content":" Deprecated Deprecated by Partial Set Security  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#context","content":" Some small validators may not have the resources needed to validate all consumer chains. Therefore a need exists to allow the bottom x% of validators to opt-out of validating a consumer chain. Meaning downtime infractions for these validators are dropped without ever reaching the provider.  This document specifies a modification to the ccv protocol which allows the bottom x% of the validator set by power to opt out of validating consumer chains without being jailed or otherwise punished for it. The feature is implemented with entirely consumer-side code.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#decision","content":" A consumer param exists, known as SoftOptOutThreshold, which is a string decimal in the range of [0, 0.2], that determines the portion of validators which are allowed to opt out of validating that specific consumer.  In every consumer beginblocker, a function is ran which determines the so called smallest non opt-out voting power. Validators with voting power greater than or equal to this value must validate the consumer chain, while validators below this value may opt out of validating the consumer chain.  The smallest non opt-out voting power is recomputed every beginblocker in UpdateSmallestNonOptOutPower(). In a nutshell, the method obtains the total voting power of the consumer, iterates through the full valset (ordered power ascending) keeping track of a power sum, and when powerSum / totalPower &gt; SoftOptOutThreshold, the SmallestNonOptOutPower is found and persisted.  Then, whenever the Slash() interface is executed on the consumer, if the voting power of the relevant validator being slashed is less than SmallestNonOptOutPower for that block, the slash request is dropped and never sent to the provider.  ","version":"v6.1.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#positive","content":" Small validators can opt out of validating specific consumers without being punished for it.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#negative","content":" The bottom x% is still part of the total voting power of the consumer chain. This means that if the soft opt-out threshold is set to 10% for example, and every validator in the bottom 10% opts out from validating the consumer, then a 24% downtime of the remaining voting power would halt the chain. This may be especially problematic during consumer upgrades.In nominal scenarios, consumers with soft opt out enabled will be constructing slash packets for small vals, which may be dropped. This is wasted computation, but necessary to keep implementation simple. Note that the sdk's full downtime logic is always executed on the consumer, which can be computationally expensive and slow down certain blocks.In a consumer chain, when a validator that has opted out becomes the proposer, there will naturally be no proposal made and validators would need to move to the next consensus round for the same height to reach a decision. As a result, we would need more time to finalize blocks on a consumer chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#neutral","content":" Validators in the bottom of the valset who don't have to validate, may receive large delegation(s) which suddenly boost the validator to the subset that has to validate. This may catch the validator off guard.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.1.0/adrs/adr-009-soft-opt-out#references","content":" Original issue with some napkin math #784 ","version":"v6.1.0","tagName":"h2"},{"title":"Throttle with retries","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries","content":"","keywords":"","version":"v6.1.0"},{"title":"ADR 008: Throttle with retries​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#adr-008-throttle-with-retries","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#changelog","content":" 6/9/23: Initial draft6/22/23: added note on consumer pending packets storage optimization7/14/23: Added note on upgrade order  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#context","content":" For context on why the throttling mechanism exists, see ADR 002.  Note the terms slash throttling and jail throttling are synonymous, since in Interchain Security a SlashPacket simply jails a validator for downtime infractions.  Currently the throttling mechanism is designed so that provider logic (slash meter, etc.) dictates how many SlashPackets can be handled over time. Throttled SlashPackets are persisted on the provider, leading to multiple possible issues. Namely:  If SlashPackets or VSCMaturedPackets are actually throttled/queued on the provider, state can grow and potentially lead to a DoS attack. We have short term solutions around this, but overall they come with their own weaknesses. See #594.If a jailing attack described in ADR 002 were actually to be carried out with the current throttling design, we'd likely have to halt the provider, and perform an emergency upgrade and/or migration to clear the queues of SlashPackets that were deemed to be malicious. Alternatively, validators would just have to tough it out and wait for the queues to clear, during which all/most validators would be jailed. Right after being jailed, validators would have to unjail themselves promptly to ensure safety. The coordination required to maintain safety in such a scenario is not ideal.  As a solution, we can improve the throttling mechanism to instead queue/persist relevant data on each consumer, and have consumers retry slash requests as needed.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#decision","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Consumer changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#consumer-changes","content":" Note the consumer already queues up both SlashPackets and VSCMaturedPackets via AppendPendingPacket. Those packets are dequeued in every EndBlock in SendPackets and sent to the provider.  Instead, we will now introduce the following logic on EndBlock:  Slash packets will always be sent to the provider once they're at the head of the queue. However, once sent, the consumer will not send any subsequent VSCMaturedPackets from the queue until the provider responds with an acknowledgement that the sent SlashPacket has been handled, i.e., validator was jailed. That is, SlashPackets block the sending of subsequent VSCMaturedPackets in the consumer queue.If two SlashPackets are at the head of the queue, the consumer will send the first SlashPacket, and then wait for a success acknowledgement from the provider before sending the second SlashPacket. This seems like it'd simplify implementation.VSCMaturedPackets at the head of the queue (i.e., NOT following a SlashPacket) can be sent immediately, and do not block any other packets in the queue, since the provider always handles them immediately.  To prevent the provider from having to keep track of what SlashPackets have been rejected, the consumer will have to retry the sending of SlashPackets over some period of time. This can be achieved with an on-chain consumer param, i.e., RetryDelayPeriod. To reduce the amount of redundant re-sends, we recommend setting RetryDelayPeriod ~ SlashMeterReplenishmentPeriod, i.e., waiting for the provider slash meter to be replenished before resending the rejected SlashPacket.  Note to prevent weird edge case behavior, a retry would not be attempted until either a success or failure acknowledgement has been received from the provider.  With the behavior described, we maintain very similar behavior to the previous throttling mechanism regarding the timing that SlashPackets and VSCMaturedPackets are handled on the provider. Obviously the queueing and blocking logic is moved, and the two chains would have to send more messages between one another (only in the case the throttling mechanism is triggered).  In the normal case, when no or a few SlashPackets are being sent, the VSCMaturedPackets will not be delayed, and hence unbonding will not be delayed.  For the implementation of this design, see throttle_retry.go.  Consumer pending packets storage optimization​  In addition to the mentioned consumer changes, an optimization will need to be made to the consumer's pending packets storage to properly implement the feature from this ADR.  The consumer ccv module previously queued &quot;pending packets&quot; to be sent in each EndBlock in SendPackets. These packets are queued in state with a protobuf list of ConsumerPacketData. For a single append operation, the entire list is deserialized, then a packet is appended to that list, and the list is serialized again. See older version of AppendPendingPacket. That is, a single append operation has O(N) complexity, where N is the size of the list.  This poor append performance isn't a problem when the pending packets list is small. But with this ADR being implemented, the pending packets list could potentially grow to the order of thousands of entries when SlashPackets need to be resent.  We can improve the append time for this queue by converting it from a protobuf-esq list, to a queue implemented with sdk-esq code. The idea is to persist a uint64 index that will be incremented each time you queue up a packet. You can think of this as storing the tail of the queue. Then, packet data will be keyed by that index, making the data naturally ordered byte-wise for sdk's iterator. The index will also be stored in the packet data value bytes, so that the index can later be used to delete certain packets from the queue.  Two things are achieved with this approach:  More efficient packet append/enqueue timesThe ability to delete select packets from the queue (previously all packets were deleted at once)  ","version":"v6.1.0","tagName":"h3"},{"title":"Provider changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#provider-changes","content":" The main change needed for the provider is the removal of queuing logic for SlashPackets and VSCMaturedPackets upon being received.  Instead, the provider will consult the slash meter to determine if a SlashPacket can be handled immediately. If not, the provider will return an acknowledgement message to the consumer communicating that the SlashPacket could not be handled, and needs to be sent again in the future (retried).  VSCMaturedPackets will always be handled immediately upon being received by the provider.  Note spec. Specifically the section on VSC Maturity and Slashing Order. Previously the onus was on the provider to maintain this property via queuing packets and handling them FIFO.  Now this property will be maintained by the consumer sending packets in the correct order, and blocking the sending of VSCMaturedPackets as needed. Then, the ordered IBC channel will ensure that SlashPackets and VSCMaturedPackets are received in the correct order on the provider.  The provider's main responsibility regarding throttling will now be to determine if a received SlashPacket can be handled via slash meter etc., and appropriately acknowledge to the sending consumer.  Handling VSCMaturedPackets immediately​  Why the provider can handle VSCMatured packets immediately​  A VSCMaturedPacket communicates to the provider that sufficient time passed on the consumer since the corresponding VSCPacket has been applied (on the consumer) such that infractions committed on the consumer could have been submitted.  If the consumer is following the queuing/blocking protocol described, then no bad behavior occurs and the VSC Maturity and Slashing Order property is maintained.  If a consumer sends VSCMaturedPackets too leniently -- the consumer is malicious and sends duplicate VSCMaturedPackets, or sends the packets sooner than the CCV protocol specifies -- then the provider needs to handle VSCMaturedPackets immediately to prevent DOS, state bloat, or other issues. The only possible negative outcome is that the malicious consumer may not be able to jail a validator who should have been jailed. The malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  If a consumer blocks the sending of VSCMaturedPackets, then unbonding operations on the provider will be delayed, but only until the VSC timeout period has elapsed. At that time, the consumer is removed. Again the malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  ","version":"v6.1.0","tagName":"h3"},{"title":"Splitting of PRs and Upgrade Order​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#splitting-of-prs-and-upgrade-order","content":" This feature will implement consumer changes in #1024.  ❗These changes should be deployed to production for all consumers before the provider changes are deployed to production.  In other words, the consumer changes in #1024 are compatible with the current (&quot;v1&quot;) provider implementation of throttling that's running on the Cosmos Hub as of July 2023.  Once all consumers have deployed the changes in #1024, the provider changes from #1321 can be deployed to production, fully enabling v2 throttling.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#consequences","content":" Consumers will now have to manage their own queues, and retry logic.Consumers still aren't trustless, but the provider is now less susceptible to mismanaged or malicious consumers.Recovering from the &quot;jailing attack&quot; is more elegant.Some issues like #1001 will now be handled implicitly by the improved throttling mechanism.SlashPackets and VSCMaturedPackets can be handled immediately once received by the provider if the slash meter allows.In general, we reduce the amount of computation that happens in the provider EndBlock.  ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#positive","content":" We no longer have to reason about a &quot;global queue&quot; and a &quot;chain specific queue&quot;, and keeping those all in-sync. Now SlashPackets and VSCMaturedPackets queuing is handled on each consumer individually.Due to the above, the throttling protocol becomes less complex overall.We no longer have to worry about throttle related DoS attack on the provider, since no queuing exists on the provider.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#negative","content":" Increased number of IBC packets being relayed anytime throttling logic is triggered.Consumer complexity increases, since consumers now have manage queuing themselves, and implement packet retry logic.  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#neutral","content":" Core throttling logic on the provider remains unchanged, i.e., slash meter, replenishment cycles, etc.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.1.0/adrs/adr-008-throttle-retries#references","content":" EPIC tracking the changes proposed by this ADRADR 002: Jail Throttling#594 ","version":"v6.1.0","tagName":"h2"},{"title":"Standalone to Consumer Changeover","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover","content":"","keywords":"","version":"v6.1.0"},{"title":"ADR 010: Standalone to Consumer Changeover​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#adr-010-standalone-to-consumer-changeover","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#changelog","content":" 6/30/23: Feature completed, first draft of ADR.  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#status","content":" Implemented  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#context","content":" Stride will be the first consumer to &quot;changeover&quot; from a standalone cosmos blockchain, to a consumer chain secured by the Cosmos Hub. This document outlines the changes made to support this changeover process.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#decision","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Process​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#process","content":" Prior to the changeover, the consumer chain will have an existing staking keeper and validator set, these may be referred to as the &quot;standalone staking keeper&quot; and &quot;standalone validator set&quot; respectively.  The first step in the changeover process is to submit a ConsumerAdditionProposal. If the proposal passes, the provider will create a new IBC client for the consumer at spawn time, with the provider's validator set. A consumer genesis will also be constructed by the provider for validators to query. Within this consumer genesis contains the initial validator set for the consumer to apply after the changeover.  Next, the standalone consumer chain runs an upgrade which adds the CCV module, and is properly setup to execute changeover logic.  The consumer upgrade height must be reached after the provider has created the new IBC client. Any Interchain Security validators who will run the consumer, but are not a part of the sovereign validator set, must sync up a full node before the consumer upgrade height is reached. The disk state of said full node will be used to run the consumer chain after the changeover has completed.  The meat of the changeover logic is that the consumer chain validator set is updated to that which was specified by the provider via the queried consumer genesis. Validators which were a part of the old set, but not the new set, are given zero voting power. Once these validator updates are given to Comet, the set is committed, and in effect 2 blocks later (see FirstConsumerHeight).  A relayer then establishes the new IBC connection between the provider and consumer. The CCV channel handshake is started on top of this connection. Once the CCV channel is established and VSC packets are being relayed, the consumer chain is secured by the provider.  ","version":"v6.1.0","tagName":"h3"},{"title":"Changes to CCV Protocol​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#changes-to-ccv-protocol","content":" Consumer Genesis state is updated to include a PreCCV boolean. When this boolean is set true in the consumer genesis JSON, special logic is executed on InitGenesis to trigger the changeover process on the consumer's first endblocker after the upgrade which adds the CCV module. Note that InitGenesis is not automatically called during chain upgrades, so the consumer must manually call the consumer's InitGenesis method in an upgrade handler.The ConsumerAdditionProposal type is updated to include a DistributionTransmissionChannel field. This field allows the consumer to use an existing IBC transfer channel to send rewards as a part of the CCV protocol. Consumers that're not changing over from a standalone chain will leave this field blank, indicating that a new transfer channel should be created on top of the same connection as the CCV channel.The CCV consumer keeper is updated to contain an optional reference to the standalone staking keeper. The standalone staking keeper is used to slash for infractions that happened before the changeover was completed. Ie. any infraction from a block height before the changeover, that is submitted after the changeover, will call the standalone staking keeper's slash method. Note that a changeover consumer's standalone staking keeper becomes a democracy module keeper, so it is possible for a governance token to be slashed.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#positive","content":" Existing cosmos chains are now able to onboard over to a consumer chain secured by a provider.The previous staking keepers for such chains can be transitioned to democracy staking module keepers.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#negative","content":" The delineation between different types of consumers in this repo becomes less clear. Ie. there is code in the democracy consumer's app.go that only applies to a previously standalone chain, but that file also serves as the base for a normal democracy consumer launched with RS from genesis.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.1.0/adrs/adr-010-standalone-changeover#references","content":" EPIC: Standalone to Consumer Changeover #756Changeover diagram from Stride ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 002: Jail Throttling","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#changelog","content":" 2023-01-26: Initial Draft2023-02-07: Property refined, ADR ready to review/merge2023-11-22: Refactor for better understanding  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#context","content":" The CCV spec is based around the assumption that the provider binary and all consumers binaries are non-malicious, and follow the defined protocols. In practice, this assumption may not hold. A malicious consumer binary could potentially include code which is able to send many slash/jail packets at once to the provider.  Before the throttling feature was implemented, the following attack was possible. Attacker(s) would create provider validators just below the provider's active set. Using a malicious consumer binary, slash packets would be relayed to the provider, that would slash/jail a significant portion (or all) of honest validator at once. Control of the provider would then pass over to the attackers' validators. This enables the attacker(s) to halt the provider. Or even worse, commit arbitrary state on the provider, potentially stealing all tokens bridged to the provider over IBC.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#decision","content":" The throttling feature was designed to slow down the mentioned attack from above, allowing validators and the community to appropriately respond to the attack, i.e., this feature limits (enforced by on-chain params) the rate that the provider validator set can be jailed over time.  ","version":"v6.1.0","tagName":"h2"},{"title":"Required State​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#required-state","content":" Slash meter: There exists one slash meter on the provider which stores an amount of voting power (integer), corresponding to an allowance of validators that can be jailed over time. This meter is initialized to a certain value on genesis, decremented by the amount of voting power jailed whenever a slash packet is handled, and periodically replenished as decided by on-chain params.  Global entry queue: There exists a single queue which stores &quot;global slash entries&quot;. These entries allow the provider to appropriately handle slash packets sent from any consumer in FIFO ordering. This queue is responsible for coordinating the order that slash packets (from multiple chains) are handled over time.  Per-chain data queue: For each established consumer, there exists a queue which stores &quot;throttled packet data&quot;, i.e.,pending slash packet data is queued together with pending VSC matured packet data in FIFO ordering. Order is enforced by IBC sequence number. These &quot;per-chain&quot; queues are responsible for coordinating the order that slash packets are handled in relation to VSC matured packets from the same chain.  Note: The reason for a multiple-queue design is the VSC Maturity and Slashing Order property (see spec). There are other ways to ensure such a property (like a queue of linked lists, etc.), but the proposed approach seemed to be the most understandable and easiest to implement with a KV store.  ","version":"v6.1.0","tagName":"h3"},{"title":"Params​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#params","content":" SlashMeterReplenishPeriod -- the period after which the slash meter is replenished.  SlashMeterReplenishFraction -- the portion (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs. This param also serves as a maximum fraction of total voting power that the slash meter can hold.  MaxThrottledPackets -- the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value. This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness.  ","version":"v6.1.0","tagName":"h3"},{"title":"Protocol Overview​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#protocol-overview","content":" OnRecvSlashPacket​  Upon the provider receiving a slash packet from any of the established consumers during block execution, two things occur:  A global slash entry is queued.The data of such a packet is added to the per-chain queue.  OnRecvVSCMaturedPacket​  Upon the provider receiving a VSCMatured packet from any of the established consumers during block execution, the VSCMatured packet data is added to the per-chain queue.  Endblocker​  In the EndBlock of the provider CCV module, there are three actions performed:  replenish the slash meter;handle the leading VSCMaturedPackets;and handle the throttle queues.  Slash Meter Replenishment​  Once the slash meter becomes not full, it'll be replenished after SlashMeterReplenishPeriod by incrementing the meter with its allowance for the replenishment block, where allowance = SlashMeterReplenishFraction * currentTotalVotingPower. The slash meter will never exceed its current allowance (function of the total voting power for the block) in value.  Note a few things:  The slash meter can go negative in value, and will do so when handling a single slash packet that jails a validator with significant voting power. In such a scenario, the slash meter may take multiple replenishment periods to once again reach a positive value (or 0), meaning no other slash packets may be handled for multiple replenishment periods.Total voting power of a chain changes over time, especially as validators are jailed. As validators are jailed, total voting power decreases, and so does the jailing allowance. See below for more detailed throttling property discussion.The voting power allowance added to the slash meter during replenishment will always be greater than or equal to 1. If the SlashMeterReplenishFraction is set too low, integer rounding will put this minimum value into effect. That is, if SlashMeterReplenishFraction * currentTotalVotingPower &lt; 1, then the effective allowance would be 1. This min value of allowance ensures that there's some packets handled over time, even if that is a very long time. It's a crude solution to an edge case caused by too small of a replenishment fraction.  The behavior described above is achieved by executing CheckForSlashMeterReplenishment() every EndBlock, BEFORE HandleThrottleQueues() is executed.  Handle Leading VSCMaturedPackets​  In every block, it is possible that VSCMaturedPacket data was queued before any slash packet data. Since this &quot;leading&quot; VSCMatured packet data does not have to be throttled (see VSC Maturity and Slashing Order), we can handle all VSCMatured packet data at the head of the queue, before the any throttling or packet data handling logic executes.  Handle Throttle Queues​  In every EndBlock, the following logic is executed to handle data from the throttle queues.  meter := getSlashMeter() // Keep iterating as long as the meter has a positive (or 0) value, and global slash entries exist while meter.IsPositiveOrZero() &amp;&amp; entriesExist() { // Get next entry in queue entry := getNextGlobalSlashEntry() // Decrement slash meter by the voting power that will be removed from the valset from handling this slash packet valPower := entry.getValPower() meter = meter - valPower // Using the per-chain queue, handle the single slash packet using its queued data, // then handle all trailing VSCMatured packets for this consumer handleSlashPacketAndTrailingVSCMaturedPackets(entry) // Delete entry in global queue, delete handled data entry.Delete() deleteThrottledSlashPacketData() deleteTrailingVSCMaturedPacketData() }   ","version":"v6.1.0","tagName":"h3"},{"title":"System Properties​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#system-properties","content":" All CCV system properties should be maintained by implementing this feature, see CCV spec - Consumer Initiated Slashing.  One implementation-specific property introduced is that if any of the chain-specific packet data queues become larger than MaxThrottledPackets, then the provider binary will panic, and the provider chain will halt. Therefore this param should be set carefully. See SetThrottledPacketDataSize. This behavior ensures that if the provider binaries are queuing up more packet data than machines can handle, the provider chain halts deterministically between validators.  ","version":"v6.1.0","tagName":"h3"},{"title":"Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#main-throttling-property","content":" Using on-chain params and the sub protocol defined, slash packet throttling is implemented such that the following property holds under some conditions.  First, we introduce the following definitions:  A consumer initiated slash attack &quot;starts&quot; when the first slash packet from such an attack is received by the provider.The &quot;initial validator set&quot; for the attack is the validator set that existed on the provider when the attack started.There is a list of honest validators such that if they are jailed, X% of the initial validator set will be jailed.  For the Throttling Property to hold, the following assumptions must be true:  We assume the total voting power of the chain (as a function of delegations) does not increase over the course of the attack.No validator has more than SlashMeterReplenishFraction of total voting power on the provider.SlashMeterReplenishFraction is large enough that SlashMeterReplenishFraction * currentTotalVotingPower &gt; 1, i.e., the replenish fraction is set high enough that we can ignore the effects of rounding.SlashMeterReplenishPeriod is sufficiently longer than the time it takes to produce a block.  Note if these assumptions do not hold, throttling will still slow down the described attack in most cases, just not in a way that can be succinctly described. It's possible that more complex properties can be defined.  Throttling Property: The time it takes to jail/tombstone X% of the initial validator set will be greater than or equal toSlashMeterReplenishPeriod⋅XSlashMeterReplenishFraction−2⋅SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod} \\cdot \\frac{X}{\\mathit{SlashMeterReplenishFraction}} - 2 \\cdot \\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriod⋅SlashMeterReplenishFractionX​−2⋅SlashMeterReplenishPeriod.  Intuition Let's use the following notation: CCC: Number of replenishment cyclesPPP: SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriodFFF: SlashMeterReplenishFraction\\mathit{SlashMeterReplenishFraction}SlashMeterReplenishFractionVmaxV_{\\mathit{max}}Vmax​: Max power of a validator as a fraction of total voting power In CCC number of replenishment cycles, the fraction of total voting power that can be removed, aaa, is a≤F⋅C+Vmaxa \\leq F \\cdot C + V_{\\mathit{max}}a≤F⋅C+Vmax​ (where VmaxV_{\\mathit{max}}Vmax​ is there to account for the power fraction of the last validator removed, one which pushes the meter to the negative value). So, we need at least C≥a−VmaxFC \\geq \\frac{a - V_{\\mathit{max}}}{F}C≥Fa−Vmax​​ cycles to remove aaa fraction of the total voting power. Since we defined the start of the attack to be the moment when the first slash request arrives, then FFF fraction of the initial validator set can be jailed immediately. For the remaining X−FX - FX−F fraction of the initial validator set to be jailed, it takes at least C≥(X−F)−VmaxFC \\geq \\frac{(X - F) - V_{\\mathit{max}}}{F}C≥F(X−F)−Vmax​​ cycles. Using the assumption that Vmax≤FV_{\\mathit{max}} \\leq FVmax​≤F (assumption 2), we get C≥X−2FFC \\geq \\frac{X - 2F}{F}C≥FX−2F​ cycles. In order to execute CCC cycles, we need C⋅PC \\cdot PC⋅P time. Thus, jailing the remaining X−FX - FX−F fraction of the initial validator set corresponds to P⋅(X−2F)F\\frac{P \\cdot (X - 2F)}{F}FP⋅(X−2F)​ time. In other words, the attack must take at least P⋅XF−2P\\frac{P \\cdot X}{F} - 2PFP⋅X​−2P time (in the units of replenish period PPP).  This property is useful because it allows us to reason about the time it takes to jail a certain percentage of the initial provider validator set from consumer initiated slash requests. For example, if SlashMeterReplenishFraction is set to 0.06, then it takes no less than 4 replenishment periods to jail 33% of the initial provider validator set on the Cosmos Hub. Note that as of writing this on 11/29/22, the Cosmos Hub does not have a validator with more than 6% of total voting power.  Note also that 4 replenishment period is a worst case scenario that depends on well crafted attack timings.  ","version":"v6.1.0","tagName":"h3"},{"title":"How Unjailing Affects the Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#how-unjailing-affects-the-main-throttling-property","content":" Note that the jailing allowance is directly proportional to the current total voting power of the provider chain. Therefore, if honest validators don't unjail themselves during the attack, the total voting power of the provider chain will decrease over the course of the attack, and the attack will be slowed down, main throttling property is maintained.  If honest validators do unjail themselves, the total voting power of the provider chain will still not become higher than when the attack started (unless new token delegations happen), therefore the main property is still maintained. Moreover, honest validators unjailing themselves helps prevent the attacking validators from gaining control of the provider.  In summary, the throttling mechanism as designed has desirable properties whether or not honest validators unjail themselves over the course of the attack.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#positive","content":" The described attack is slowed down in seemingly all cases.If certain assumptions hold, the described attack is slowed down in a way that can be precisely time-bounded.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#negative","content":" Throttling introduces a vector for a malicious consumer chain to halt the provider, see issue below. However, this is sacrificing liveness in a edge case scenario for the sake of security. As an improvement, using retries would fully prevent this attack vector.  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#neutral","content":" Additional state is introduced to the provider chain.VSCMatured and slash packet data is not always handled in the same block that it is received.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.1.0/adrs/adr-002-throttle#references","content":" Original issue inspiring throttling featureIssue on DOS vectorConsideration of another attack vector ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 011: Improving testing and increasing confidence","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#changelog","content":" 2023-08-11: Proposed, first draft of ADR.  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#status","content":" Proposed  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#context","content":" Testing, QA, and maintenance of interchain-security libraries is an ever-evolving area of software engineering we have to keep incrementally improving. The purpose of the QA process is to catch bugs as early as possible. In an ideal development workflow a bug should never reach production. A bug found in the specification stage is a lot cheaper to resolve than a bug discovered in production (or even in testnet). Ideally, all bugs should be found during the CI execution, and we hope that no bugs will ever even reach the testnet (although nothing can replace actual system stress test under load interacting with users).  During development and testnet operation the following types of bugs were the most commonly found:  improper iterator usageunbounded array access/iterationimproper input handling and validationimproper cached context usagenon-determinism check (improper use of maps in go, relying on random values)KV store management and/or how keys are defineddeserialization issues arising from consumer/provider versioning mismatch  Such bugs can be discovered earlier with better tooling. Some of these bugs can induce increases in block times, chain halts, state corruption, or introduce an attack surface which is difficult to remove if other systems have started depending on that behavior.  Current state of testing​  Our testing suites consist of multiple parts, each with their own trade-offs and benefits with regards to code coverage, complexity and confidence they provide.  ","version":"v6.1.0","tagName":"h2"},{"title":"Unit testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#unit-testing","content":" Unit testing is employed mostly for testing single-module functionality. It is the first step in testing and often the most practical. While highly important, unit tests often test a single piece of code and don't test relationships between different moving parts, this makes them less valuable when dealing with multi-module interactions.  Unit tests often employ mocks to abstract parts of the system that are not under test. Mocks are not equivalent to actual models and should not be treated as such.  Out of all the approaches used, unit testing has the most tools available and the coverage can simply be displayed as % of code lines tested. Although this is a very nice and very easy to understand metric, it does not speak about the quality of the test coverage.  Since distributed systems testing is a lot more involved, unit tests are oftentimes not sufficient to cover complex interactions. Unit tests are still necessary and helpful, but in cases where unit tests are not helpful e2e or integration tests should be favored.  ","version":"v6.1.0","tagName":"h3"},{"title":"Integration testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#integration-testing","content":" With integration testing we test the multi-module interactions while isolating them from the remainder of the system. Integration tests can uncover bugs that are often missed by unit tests.  It is very difficult to gauge the actual test coverage imparted by integration tests and the available tooling is limited. In interchain-security we employ the ibc-go/testing framework to test interactions in-memory.  At present, integration testing does not involve the consensus layer - it is only concerned with application level state and logic.  ","version":"v6.1.0","tagName":"h3"},{"title":"End-to-end testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#end-to-end-testing","content":" In our context end-to-end testing comprises of tests that use the actual application binaries in an isolated environment (e.g. docker container). During test execution the inputs are meant to simulate actual user interaction, either by submitting transactions/queries using the command line or using gRPC/REST APIs and checking for state changes after an action has been performed. With this testing strategy we also include the consensus layer in all of our runs. This is the closest we can get to testing user interactions without starting a full testnet.  End-to-end testing strategies vary between different teams and projects and we strive to unify our approach to the best of our ability (at least for ICS and gaia).  The available tooling does not give us significant (or relevant) line of code coverage information since most of the tools are geared towards analyzing unit tests and simple code branch evaluation.  We aim to adapt our best practices by learning from other similar systems and projects such as cosmos-sdk, ibc-go and CometBFT.  ","version":"v6.1.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#decision","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"1. Connect specifications to code and tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#1-connect-specifications-to-code-and-tooling","content":" Oftentimes, specifications are disconnected from the development and QA processes. This gives rise to problems where the specification does not reflect the actual state of the system and vice-versa. Usually specifications are just text files that are rarely used and go unmaintained after a while, resulting in consistency issues and misleading instructions/expectations about system behavior.  Decision context and hypothesis​  Specifications written in a dedicated and executable specification language are easier to maintain than the ones written entirely in text. Additionally, we can create models based on the specification OR make the model equivalent to a specification.  Models do not care about the intricacies of implementation and neither do specifications. Since both models and specifications care about concisely and accurately describing a system (such as a finite state machine), we see a benefit of adding model based tools (such as quint) to our testing and development workflows.  Main benefit​  MBT tooling can be used to generate test traces that can be executed by multiple different testing setups.  ","version":"v6.1.0","tagName":"h3"},{"title":"2. Improve e2e tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#2-improve-e2e-tooling","content":" Matrix tests​  Instead of only running tests against current main branch we should adopt an approach where we also:  run regression tests against different released software versions (ICS v1 vs v2 vs v3)run non-determinism tests to uncover issues quickly  Matrix tests can be implemented using CometMock and refactoring our current e2e CI setup.  Introducing e2e regression testing​  This e2e test suite would execute using a cronjob in our CI (nightly, multiple times a day etc.)  Briefly, the same set of traces is run against different maintained versions of the software and the main branch. This would allow us to discover potential issues during development instead of in a testnet scenarios.  The most valuable issues that can be discovered in this way are state breaking changes, regressions and version incompatibilities.  The setup is illustrated by the image below.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  USES: ICS v1 PROVIDER\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv1 consumer (sdk45,ibc4.3)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v2 consumer (sdk45, ibc4.4)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v3 consumer (sdk47, ibc7)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main consumer\t❌\t❌\t❌\t❌\t❌\t❌\t❌\t❌ neutron\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌ stride\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌  Introducing e2e CometMock tests​  CometMock is a mock implementation of the CometBFT consensus engine. It supports most operations performed by CometBFT while also being lightweight and relatively easy to use.  CometMock tests allow more nuanced control of test scenarios because CometMock can &quot;fool&quot; the blockchain app into thinking that a certain number of blocks had passed.This allows us to test very nuanced scenarios, difficult edge cases and long-running operations (such as unbonding operations).  Examples of tests made easier with CometMock are listed below:  regression testsnon-determinism testsupgrade testsstate-breaking changes  With CometMock, the matrix test approach can also be used. The image below illustrates a CometMock setup that can be used to discover non-deterministic behavior and state-breaking changes.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  SCENARIO\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv3 provi + v3 consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main provi + main consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ commit provi + commit consu\t✅\t❌\t✅\t❌\t✅\t✅\t❌\t❌  Briefly; multiple versions of the application are run against the same CometMock instance and any deviations in app behavior would result in app hash errors (the apps would be in different states after performing the same set of actions).  ","version":"v6.1.0","tagName":"h3"},{"title":"3. Introduce innovative testing approaches​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#3-introduce-innovative-testing-approaches","content":" When discussing e2e testing, some very important patterns emerge - especially if test traces are used instead of ad-hoc tests written by hand.  We see a unique opportunity to clearly identify concerns and modularize the testing architecture.  The e2e testing frameworks can be split into a pipeline consisting of 3 parts: model, driver and harness.  Model​  Model is the part of the system that can emulate the behavior of the system under test. Ideally, it is very close to the specification and is written in a specification language such as quint, TLA+ or similar. One of the purposes of the model is that it can be used to generate test traces.  Driver​  The purpose of the driver is to accept test traces (generated by the model or written by hand), process them and provide inputs to the next part of the pipeline.  Basically, the driver sits between the model and the actual infrastructure on which the test traces are being executed on.  Harness​  Harness is the infrastructure layer of the pipeline that accepts inputs from the driver.  There can be multiple harnesses as long as they can perform four things:  bootstrap a test execution environment (local, docker, k8s…)accept inputs from driversperform the action specified by the driverreport results after performing actions  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#consequences","content":" The procedure outlined in this ADR is not an all-or-nothing approach. Concepts introduced here do not rely on each other, so this ADR may only be applied partially without negative impact on test coverage and code confidence.  ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#positive","content":" introduction of maintainable MBT solutions  improvement over the current &quot;difftest&quot; setup that relies on an opinionated typescript model and go driver  increased code coverage and confidence  using CometMock allows us to run more tests in less timeadding matrix e2e tests allows us to quickly pinpoint differences between code versions  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#negative","content":" It might be easier to forgo the MBT tooling and instead focus on pure property based testing  PBT proof of conceptproperty based testing in go  The solutions are potentially expensive if we increase usage of the CI pipeline - this is fixed by running &quot;expensive&quot; tests using a cronjob, instead of running them on every commit.  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#neutral","content":" The process of changing development and testing process is not something that can be thought of and delivered quickly. Luckily, the changes can be rolled out incrementally without impacting existing workflows.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.1.0/adrs/adr-011-improving-test-confidence#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  https://github.com/cosmos/gaia/issues/2427https://github.com/cosmos/gaia/issues/2420ibc-go e2e tests ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 012: Separate Releasing","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#changelog","content":" 0.0202020202020202: Initial draft of idea in #8010.01652892561983471: Put idea in this ADR0.05: Reject this ADR  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#status","content":" Rejected  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#context","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Spike results​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#spike-results","content":" I explored the idea of #801 with this spike branch. Here's my conclusions:  Splitting this repo to have multiple go.mods is possible. However there are various intricacies involved in decoupling the package hierarchy to have x/ccv/types as the lowest level dep, with x/ccv/consumer and x/ccv/provider being one dep layer above, with high-level tests depending on all three of the mentioned packages. I'd estimate this decoupling would take 2-5 workdays to finish, and require significant review effort.  ","version":"v6.1.0","tagName":"h3"},{"title":"Why go.mod split is not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#why-gomod-split-is-not-the-way-to-go","content":" Let's take a step back and remember the issue we're trying to solve - We need a clean way to decouple semver/releasing for the consumer and provider modules. After more consideration, splitting up go.mods gives us little benefit in achieving this. Reasons:  The go.mod dependency system is tied to git tags for the entire repo (ex: require github.com/cometbft/cometbft v0.37.2 refers to a historical tag for the entire cometbft repo).It'd be an odd dev experience to allow modules to reference past releases of other modules in the same repo. When would we ever want the consumer module to reference a past release of the types module for example?If we allow for go.mod replace statements to build from local source code, why split up the package deps at all?Splitting go.mods adds a bunch of complexity with go.work files and all that shiz. VSCode does not play well with multiple module repos either.  ","version":"v6.1.0","tagName":"h3"},{"title":"Why separate repos is cool but also not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#why-separate-repos-is-cool-but-also-not-the-way-to-go","content":" All this considered, the cleanest solution to decoupling semver/releasing for the consumer and provider modules would be to have multiple repos, each with their own go.mod (3-4 repos total including high level tests). With this scheme we could separately tag each repo as changes are merged, they could share some code from types being an external dep, etc.  I don't think any of us want to split up the monorepo, that's a lot of work and seems like bikeshedding. There's another solution that's very simple..  ","version":"v6.1.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#decision","content":" Slightly adapting the current semver ruleset:  A library API breaking change to EITHER the provider or consumer module will result in an increase of the MAJOR version number for BOTH modules (X.y.z-provider AND X.y.z-consumer).A state breaking change (change requiring coordinated upgrade and/or state migration) will result in an increase of the MINOR version number for the AFFECTED module(s) (x.Y.z-provider AND/OR x.Y.z-consumer).Any other changes (including node API breaking changes) will result in an increase of the PATCH version number for the AFFECTED module(s) (x.y.Z-provider AND/OR x.y.Z-consumer).  ","version":"v6.1.0","tagName":"h2"},{"title":"Example release flow​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#example-release-flow","content":" We upgrade main to use a new version of SDK. This is a major version bump, triggering a new release for both the provider and consumer modules, v5.0.0-provider and v5.0.0-consumer.  A state breaking change is merged to main for the provider module. We release only a v5.1.0-provider off main.Another state breaking change is merged to main for the provider module. We release only a v5.2.0-provider off main.At this point, the latest consumer version is still v5.0.0-consumer. We now merge a state breaking change for the consumer module to main, and consequently release v5.1.0-consumer. Note that v5.1.0-consumer is tagged off a LATER commit from main than v5.2.0-provider. This is fine, as the consumer module should not be affected by the provider module's state breaking changes.Once either module sees a library API breaking change, we bump the major version for both modules. For example, we merge a library API breaking change to main for the provider module. We release v6.0.0-provider and v6.0.0-consumer off main. Note that most often, a library API breaking change will affect both modules simultaneously (example being bumping sdk version).  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#positive","content":" Consumer repos have clear communication of what tagged versions are relevant to them. Consumer devs should know to never reference an ICS version that starts with provider, even if it'd technically build.Consumer and provider modules do not deviate as long as we continually release off a shared main branch. Backporting remains relatively unchanged besides being explicit about what module(s) your changes should affect.No code changes, just changes in process. Very simple.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#negative","content":" ~~Slightly more complexity.~~Considerably more complex to manage the ICS library. This is because ICS needs to support multiple versions of SDK (e.g., 0.45, 0.47, 0.50). In addition, ICS needs to support a special fork of SDK (with LSM included) for the Cosmos Hub. This means that instead of focusing on main the development team needs to manage multiple release branches with different dependency trees.This solution does not allow having provider and consumer on separate versions of e.g. the Cosmos SDK.  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#neutral","content":" ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.1.0/adrs/adr-012-separate-releasing#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  #801#801 comment ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 013: Slashing on the provider for consumer equivocation","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#changelog","content":" 1st Sept. 2023: Initial draft  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#context","content":" This ADR presents some approaches on how to slash on the provider chain validators that performed equivocations on consumer chains. Currently, the provider chain can receive and verify evidence of equivocation, but it cannot slash the misbehaving validator.  In the remainder of this section, we explain how slashing is performed on a single chain and show why slashing on the provider for equivocation on the consumer is challenging.  Note that future versions of the Cosmos SDK, CometBFT, and ibc-go could modify the way we slash, etc. Therefore, a future reader of this ADR, should note that when we refer to Cosmos SDK, CometBFT, and ibc-go we specifically refer to their v0.47, v0.37 and v7.3.0 versions respectively.  ","version":"v6.1.0","tagName":"h2"},{"title":"Single-chain slashing​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#single-chain-slashing","content":" Slashing is implemented across the slashingand staking modules. The slashing module's keeper calls the staking module's Slash() method, passing among others, the infractionHeight (i.e., the height when the equivocation occurred), the validator's power at the infraction height, and the slashFactor (currently set to 5% in case of equivocation on the Cosmos Hub).  Slashing undelegations and redelegations​  To slash undelegations, Slash goes through all undelegations and checks whether they started before or after the infraction occurred. If an undelegation started before the infractionHeight, then it is not slashed, otherwise it is slashed by slashFactor.  The slashing of redelegations happens in a similar way, meaning that Slash goes through all redelegations and checks whether the redelegations started before or after the infractionHeight.  Slashing delegations​  Besides undelegations and redelegations, the validator's delegations need to also be slashed. This is performed by deducting the appropriate amount of tokens from the validator. Note that this deduction is computed based on the voting power the misbehaving validator had at the height of the equivocation. As a result of the tokens deduction, the tokens per sharereduce and hence later on, when delegators undelegate or redelegate, the delegators retrieve back less tokens, effectively having their tokens slashed. The rationale behind this slashing mechanism, as mentioned in the Cosmos SDK documentation  [...] is to simplify the accounting around slashing. Rather than iteratively slashing the tokens of every delegation entry, instead the Validators total bonded tokens can be slashed, effectively reducing the value of each issued delegator share.  This approach of slashing delegations does not utilize theinfractionHeight in any way and hence the following scenario could occur:  a validator V performs an equivocation at a height Hia new delegator D delegates to V after height Hievidence of the equivocation by validator V is receivedthe tokens of delegator D are slashed  In the above scenario, delegator D is slashed, even though D's voting power did not contribute to the infraction.  Old evidence​  In the single-chain case, old evidence (e.g., from 3 years ago) is ignored. This is achieved throughCometBFT that ignores old evidence based on the parameters MaxAgeNumBlocks and MaxAgeDuration (see here). Additionally, note that when the evidence is sent by CometBFT to the application, the evidence is rechecked in the evidence module of Cosmos SDK and if it is old, the evidence is ignored. In Cosmos Hub, the MaxAgeNumBlocks is set to 1000000 (i.e., ~70 days if we assume we need ~6 sec per block) and MaxAgeDuration is set to 172800000000000 ns (i.e., 2 days). Because of this check, we can easily exclude old evidence.  ","version":"v6.1.0","tagName":"h3"},{"title":"Slashing for equivocation on the consumer​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#slashing-for-equivocation-on-the-consumer","content":" In the single-chain case, slashing requires both the infractionHeight and the voting power. In order to slash on the provider for an equivocation on a consumer, we need to have both the provider's infractionHeight and voting power. Note that the infractionHeight on the consumer chain must be mapped to a height on the provider chain. Unless we have a way to find the corresponding infractionHeight and power on the provider chain, we cannot slash for equivocation on the consumer in the same way as we would slash in the single-chain case.  The challenge of figuring out the corresponding infractionHeight and power values on the provider chain is due to the following trust assumption:  We trust the consensus layer and validator set of the consumer chains, but we do not trust the application layer.  As a result, we cannot trust anything that stems from the application state of a consumer chain.  Note that when a relayer or a user sends evidence through a MsgSubmitConsumerDoubleVoting message, the provider gets access to DuplicateVoteEvidence:  type DuplicateVoteEvidence struct { VoteA *Vote `json:&quot;vote_a&quot;` VoteB *Vote `json:&quot;vote_b&quot;` // abci specific information TotalVotingPower int64 ValidatorPower int64 Timestamp time.Time }   The &quot;abci specific information&quot; fields cannot be trusted because they are not signed. Therefore, we can use neither ValidatorPower for slashing on the provider chain, nor the Timestamp to check the evidence age. We can get the infractionHeight from the votes, but this infractionHeight corresponds to the infraction height on the consumer and not on the provider chain. Similarly, when a relayer or a user sends evidence through a MsgSubmitConsumerMisbehaviour message, the provider gets access to Misbehaviour that we cannot use to extract the infraction height, power, or the time on the provider chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"Proposed solution​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#proposed-solution","content":" As a first iteration, we propose the following approach. At the moment the provider receives evidence of equivocation on a consumer:  slash all the undelegations and redelegations using slashFactor;slash all delegations using as voting power the sum of the voting power of the misbehaving validator and the power of all the ongoing undelegations and redelegations.  Evidence expiration: Additionally, because we cannot infer the actual time of the evidence (i.e., the timestamp of the evidence cannot be trusted), we do not consider evidence expiration and hence old evidence is never ignored (e.g., the provider would act on 3 year-old evidence of equivocation on a consumer). Additionally, we do not need to store equivocation evidence to avoid slashing a validator more than once, because we do not slash tombstoned validators and we tombstone a validator when slashed.  We do not act on evidence that was signed by a validator consensus key that is pruned when we receive the evidence. We prune a validator's consensus key if the validator has assigned a new consumer key (using MsgAssignConsumerKey) and an unbonding period on the consumer chain has elapsed (see key assignment ADR). Note that the provider chain is informed that the unbonding period has elapsed on the consumer when the provider receives a VSCMaturedPacket and because of this, if the consumer delays the sending of a VSCMaturedPacket, we would delay the pruning of the key as well.  ","version":"v6.1.0","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#implementation","content":" The following logic needs to be added to the HandleConsumerDoubleVoting and HandleConsumerMisbehaviour methods:  undelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetUnbondingDelegationsFromValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // undelegation no longer eligible for slashing, skip it continue } undelegationsInTokens = undelegationsInTokens.Add(entry.InitialBalance) } } redelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetRedelegationsFromSrcValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // redelegation no longer eligible for slashing, skip it continue } redelegationsInTokens = redelegationsInTokens.Add(entry.InitialBalance) } } infractionHeight := 0 undelegationsAndRedelegationsInPower = sdk.TokensToConsensusPower(undelegationsInTokens.Add(redelegationsInTokens)) totalPower := validator's voting power + undelegationsAndRedelegationsInPower slashFraction := k.slashingKeeper.SlashFractionDoubleSign(ctx) k.stakingKeeper.Slash(ctx, validatorConsAddress, infractionHeight, totalPower, slashFraction, DoubleSign)   Infraction height: We provide a zero infractionHeight to the Slash method in order to slash all ongoing undelegations and redelegations (see checks in Slash, SlashUnbondingDelegation, and SlashRedelegation).  Power: We pass the sum of the voting power of the misbehaving validator when the evidence was received (i.e., at evidence height) and the power of all the ongoing undelegations and redelegations. If we assume that the slashFactor is 5%, then the voting power we pass is power + totalPower(undelegations) + totalPower(redelegations). Hence, when the Slash method slashes all the undelegations and redelegations it would end up with 0.05 * power + 0.05 * totalPower(undelegations) + 0.05 * totalPower(redelegations) - 0.05 * totalPower(undelegations) - 0.05 * totalPower(redelegations) = 0.05 * power and hence it would slash 5% of the validator's power when the evidence is received.  ","version":"v6.1.0","tagName":"h3"},{"title":"Positive​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#positive","content":" With the proposed approach we can quickly implement slashing functionality on the provider chain for consumer chain equivocations. This approach does not need to change the staking module and therefore does not change in any way how slashing is performed today for a single chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#negative","content":" We definitely slash more when it comes to undelegations and redelegations because we slash for all of them without considering an infractionHeight.We potentially slash more than what we would have slashed if we knew the voting power at the corresponding infractionHeight in the provider chain.We slash on old evidence of equivocation on a consumer.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing#references","content":" ADR 005: Cryptographic verification of equivocation evidenceEPIC tracking cryptographic equivocation featureCosmos Hub Forum discussion on cryptographic equivocation slashing ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 014: Epochs","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs#changelog","content":" 2024-01-05: Proposed, first draft of ADR.2024-02-29: Updated so that it describes the implementation where we store the whole consumer validator set.  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs#context","content":" In every block that the provider valset changes, a VSCPacket must be sent to every consumer and a corresponding VSCMaturedPacket sent back. Given that the validator powers may change very often on the provider chain (e.g., the Cosmos Hub), this approach results in a large workload for the relayers. Although the validator powers may change very often, these changes are usually small and have an insignificant impact on the chain's security. In other words, the valset on the consumers can be slightly outdated without affecting security. As a matter of fact, this already happens due to relaying delays.  As a solution, this ADR introduces the concept of epochs. An epoch consists of multiple blocks. The provider sends VSCPackets once per epoch. A VSCPacket contains all the validator updates that are needed by a consumer chain.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs#decision","content":" The implementation of epochs requires the following changes:  For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. For each validator in the set we store i) its voting power, and ii) the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. The initial consumer validator set for a chain is set during the creation of the consumer genesis.We introduce the BlocksPerEpoch param that sets the number of blocks in an epoch. By default, BlocksPerEpoch is set to be 600 which corresponds to 1 hour, assuming 6 seconds per block. This param can be changed through a governance proposal. In the provider EndBlock we check BlockHeight() % BlocksPerEpoch() == 0to decide when an epoch has ended.At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacket with all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   Note that a validator can change its consumer public key for a specific consumer chain an arbitrary amount of times during a block and during an epoch. Then, when we generate the validator updates in DiffValidators, we have to check whether the current consumer public key (retrieved by calling GetValidatorConsumerPubKey) is different from the consumer public key the validator was using in the current epoch.  ","version":"v6.1.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs#positive","content":" Reduce the cost of relaying.Reduce the amount of IBC packets needed for ICS.Simplifies key-assignment code because we only need to check if the consumer_public_key has been modified since the last epoch to generate an update.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs#negative","content":" Increase the delay in the propagation of validator set changes (but for reasonable epoch lengths on the order of ~hours or less, this is unlikely to be significant).  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs#neutral","content":" N/A  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.1.0/adrs/adr-014-epochs#references","content":" EPIC ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 015: Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#changelog","content":" 2024-01-22: Proposed, first draft of ADR.  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#context","content":" Currently, in Replicated Security, the entire validator set of the provider chain is used to secure consumer chains. There are at least three concerns with this approach. First, a large number of validators might be forced to validate consumer chains they are not interested in securing. Second, it is costly for small validators to secure additional chains. This concern is only partially addressed through soft opt-out that allows small validators to opt out from validating consumer chains. Third and for the above reasons, it is challenging for a new consumer chain to join Replicated Security.  As a solution, we present Partial Set Security (PSS). As the name suggests, PSS allows for every consumer chain to be secured by only a subset of the provider validator set. In what follows we propose the exact steps we need to take to implement PSS. This is a first iteration of PSS, and therefore we present the most minimal solution that make PSS possible.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#decision","content":" In Replicated Security, all the provider validators have to secure every consumer chain (with the exception of those validators allowed to opt out through the soft opt-out feature).  In PSS, we allow validators to opt in and out of validating any given consumer chain. This has one exception: we introduce a parameter N for each consumer chain and require that the validators in top N% of the provider's voting power have to secure the consumer chain. Validators outside of the top N% can dynamically opt in if they want to validate on the consumer chain.  For example, if a consumer chain has N = 95%, then it ultimately receives the same security it receives today with Replicated Security (with a default SoftOptOutThreshold of 5%). On the other hand, if a consumer chain has N = 0%, then no validator is forced to validate the chain, but validators can opt in to do so instead.  For the remainder of this ADR, we call a consumer chain Top N if it has joined as a Top N chain with N &gt; 0 and Opt In chain otherwise. An Opt In consumer chain is secured only by the validators that have opted in to secure that chain.  We intend to implement PSS using a feature branch off v4.0.0 interchain security.  ","version":"v6.1.0","tagName":"h2"},{"title":"How do consumer chains join?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#how-do-consumer-chains-join","content":" As a simplification and to avoid chain id squatting, a consumer chain can only join PSS through a governance proposal and not in a permissionless way.  However, this proposal type will be modified so that it requires a lower quorum percentage than normal proposal, and every validator who voted &quot;YES&quot; on the proposal will form the consumer chain's initial validator set.  Consumer chains join PSS the same way chains now join Replicated Security, namely through a ConsumerAdditionProposal proposal. We extend ConsumerAdditionProposal with one optional field:  uint32 top_N: Corresponds to the percentage of validators that join under the Top N case. For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators have to validate the proposed consumer chain.top_N can be 0 or include any value in [50, 100]. A chain can join with top_N == 0 as an Opt In, or with top_N ∈ [50, 100] as a Top N chain.  In case of a Top N chain, we restrict the possible values of top_N from (0, 100] to [50, 100]. By having top_N &gt;= 50 we can guarantee that we cannot have a successful attack, assuming that at most 1/3 of provider validators can be malicious. This is because, a Top N chain with N &gt;= 50% would have at least 1/3 honest validators, which is sufficient to stop attacks. Additionally, by having N &gt;= 50% (and hence N &gt; (VetoThreshold = 33.4%)) we enable the top N validators to Veto any ConsumerAdditionProposal for consumer chains they do not want to validate.  If a proposal has the top_N argument wrongly set, it should get rejected in [ValidateBasic] (https://github.com/cosmos/interchain-security/blob/v4.0.0/x/ccv/provider/types/proposal.go#L86).  In the code, we distinguish whether a chain is Top N or Opt In by checking whether top_N is zero or not.  In a future version of PSS, we intend to introduce a ConsumerModificationProposal so that we can modify the parameters of a consumer chain, e.g, a chain that is Opt In to become Top N, etc.  State &amp; Query​  We augment the provider module’s state to keep track of the top_N value for each consumer chain. The key to store this information would be:  topNBytePrefix | len(chainID) | chainID   To create the above key, we can use ChainIdWithLenKey.  Then in the keeper we introduce methods as follows:  func (k Keeper) SetTopN(ctx sdk.Context, chainID string, topN uint32) func (k Keeper) IsTopN(ctx sdk.Context, chainID string) bool func (k Keeper) IsOptIn(ctx sdk.Context, chainID string) bool // returns the N if Top N chain, otherwise an error func (k Keeper) GetTopN(ctx sdk.Context, chainID string) (uint32, error)   We also extend the interchain-security-pd query provider list-consumer-chains query to return information on whether a consumer chain is an Opt In or a Top N chain and with what N. This way, block explorers can present informative messages such as &quot;This chain is secured by N% of the provider chain&quot; for consumer chains.  ","version":"v6.1.0","tagName":"h3"},{"title":"How do validators opt in?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#how-do-validators-opt-in","content":" A validator can opt in by sending a new type of message that we introduce in tx.proto.  message MsgOptIn { // the chain id of the consumer chain to opt in to string chainID = 1; // the provider address of the validator string providerAddr = 2; // (optional) the consensus public key to use on the consumer optional string consumerKey = 3; }   Note that in a Top N consumer chain, the top N% provider validators have to validate the consumer chain. Nevertheless, validators in the bottom (100 - N)% can opt in to validate as well. Provider validators that belong or enter the top N% validators are automatically opted in to validate a Top N consumer chain. This means that if a validator V belongs to the top N% validators but later falls (e.g., due to undelegations) to the bottom (100 - N)%, V is still considered opted in and has to validate unless V sends a MsgOptOut message (see below). By automatically opting in validators when they enter the top N% validators and by forcing top N% validators to explicitly opt out in case they fall to the (100 - N)% bottom validators we simplify the design of PSS.  Note that a validator can send a MsgOptIn message even if the consumer chain is not yet running. To do this we reuse the IsConsumerProposedOrRegistered. If the chainID does not exist, the MsgOptIn should fail, as well as if the provider address does not exist.  Optionally, a validator that opts in can provide a consumerKey so that it assigns a different consumer key (from the provider) to the consumer chain. Naturally, a validator can always change the consumer key on a consumer chain by sending a MsgAssignConsumerKey message at a later point in time, as is done in Replicated Security.  State &amp; Query​  For each validator, we store a pair (blockHeight, isOptedIn) that contains the block height the validator opted in and whether the validator is currently opted in or not, under the key:  optedInBytePrefix | len(chainID) | chainID | addr   By using a prefix iterator on optedInBytePrefix | len(chainID) | chainID we retrieve all the opted in validators.  We introduce the following Keeper methods.  // returns all the validators that have opted in on chain `chainID` func (k Keeper) GetOptedInValidators(ctx sdk.Context, chainID string) []Validators func (k Keeper) IsValidatorOptedIn(ctx sdk.Context, chainID string, val Validator) bool   We introduce the following two queries:  interchain-security-pd query provider optedInValidators $chainID interchain-security-pd query provider hasToValidate $providerAddr   One query to retrieve the validators that are opted in and hence the validators that need to validate the consumer chain and one query that given a validator's address returns all the chains this validator has to validate.  When do validators opt in?​  As described earlier, validators can manually opt in by sending a MsgOptIn message. Additionally, in a Top N chain, a validator is automatically opted in when it moves from the bottom (100 - N)% to the top N% validators.  Lastly, validators can also opt in if they vote Yes during the ConsumerAdditionProposal that introduces a consumer chain. This simplifies validators operations because they do not have to send an additional message to opt in.  Because the Tally method deletes the votes after reading them, we cannot check the votes of the validators after the votes have been tallied. To circumvent this, we introduce a hook for AfterProposalVote and keep track of all the votes cast by a validator. If a validator casts more than one vote, we only consider the latest vote. Finally, we only consider a validator has opted in if it casts a 100% Yes vote in case of a weighted vote.  ","version":"v6.1.0","tagName":"h3"},{"title":"How do validators opt out?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#how-do-validators-opt-out","content":" Validators that have opted in on a chain can opt out by sending the following message:  message MsgOptOut { // the chain id of the consumer chain to opt out from string chainID = 1; // the provider address of the validator string providerAddr = 2; }   Validators can only opt out after a consumer chain has started and hence the above message returns an error if the chain with chainID is not running. Additionally, a validator that belongs to the top N% validators cannot opt out from a Top N chain and hence a MsgOptOut would error in such a case.  State &amp; Query​  We also update the state of the opted-in validators when a validator has opted out by removing the opted-out validator.  Note that only opted-in validators can be punished for downtime on a consumer chain. For this, we use historical info of all the validators that have opted in; We can examine the blockHeight stored under the key optedInBytePrefix | len(chainID) | chainID | addr to see if a validator was opted in. This way we can jail validators for downtime knowing that indeed the validators have opted in at some point in the past. Otherwise, we can think of a scenario where a validator V is down for a period of time, but before V gets punished for downtime, validator V opts out, and then we do not know whether V should be punished or not.  ","version":"v6.1.0","tagName":"h3"},{"title":"When does a consumer chain start?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#when-does-a-consumer-chain-start","content":" A Top N consumer chain always starts at the specified date (spawn_time) if the ConsumerAdditionProposal has passed. An Opt In consumer chain only starts if at least one validator has opted in. We check this in BeginBlockInit:  func (k Keeper) BeginBlockInit(ctx sdk.Context) { propsToExecute := k.GetConsumerAdditionPropsToExecute(ctx) for _, prop := range propsToExecute { chainID := prop.ChainId if !k.IsTopN(ctx, chainID) &amp;&amp; len(k.GetOptedInValidators(ctx, chainID)) == 0 { // drop the proposal ctx.Logger().Info(&quot;could not start chain because no validator has opted in&quot;) continue } ...   ","version":"v6.1.0","tagName":"h3"},{"title":"How do we send the partial validator sets to the consumer chains?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#how-do-we-send-the-partial-validator-sets-to-the-consumer-chains","content":" A consumer chain should only be validated by opted in validators. We introduce logic to do this when we queue the VSCPackets. The logic behind this, is not as straightforward as it seems because CometBFT does not receive the validator set that has to validate a chain, but rather a delta of validator updates. For example, to remove an opted-out validator from a consumer chain, we have to send a validator update with a power of 0, similarly to what is done in the assignment of consumer keys. We intend to update this ADR at a later stage on how exactly we intend to implement this logic.  ","version":"v6.1.0","tagName":"h3"},{"title":"How do we distribute rewards?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#how-do-we-distribute-rewards","content":" Currently, rewards are distributed as follows: The consumer periodically sends rewards on the provider ConsumerRewardsPool address. The provider then transfers those rewards to the fee collector address and those transferred rewards are distributed to validators and delegators.  In PSS, we distribute rewards only to validators that actually validate the consumer chain. To do this, we have a pool associated with each consumer chain and consumers IBC transfer the rewards to this pool. We then extract the rewards from each consumer pool and distribute them to the opted in validators.  Note that we only distribute rewards to validators that have been opted in for some time (e.g., 10000 blocks) to avoid cases where validators opt in just to receive rewards and then opt out immediately afterward.  ","version":"v6.1.0","tagName":"h3"},{"title":"Misbehaviour​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#misbehaviour","content":" Fraud votes​  In an Opt In chain, a set of validators might attempt to perform an attack. To deter such potential attacks, PSS allows for the use of fraud votes. A fraud vote is a governance proposal that enables the slashing of validators that performed an attack. Due to their inherent complexity, we intend to introduce fraud votes in a different ADR and at a future iteration of PSS.  Double signing​  We do not change the way slashing for double signing and light client attacks functions. If a validator misbehaves on a consumer, then we slash that validator on the provider.  Downtime​  We do not change the way downtime jailing functions. If a validator is down on a consumer chain for an adequate amount of time, we jail this validator on the provider but only if the validator was opted in on this consumer chain in the recent past.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#positive","content":" Easier for new consumer chains to consume the provider's chain economic security because proposals are more likely to pass if not everyone is forced to validate. Smaller validators are not forced to validate chains anymore if they do not want to. We can deprecate the soft opt-out implementation.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#negative","content":" A consumer chain does not receive the same economic security as with Replicated Security (assuming the value of SoftOptOutThreshold is 5%), unless it is a Top N chain with N &gt;= 95%.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security#references","content":" PSS: Permissionless vs premissioned-lite opt-in consumer chainsCHIPs discussion phase: Partial Set Security (updated)PSS: Exclusive vs Inclusive Top-NInitial PSS ADR and notes #1518Replicated vs. Mesh Security ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 016: Security aggregation","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#changelog","content":" 2024-04-24: Initial draft of ADR  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#status","content":" Proposed  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#context","content":" Security Aggregation enables staking of tokens from external sources such as Ethereum or Bitcoin to Cosmos blockchains. By integrating Security Aggregation, a Cosmos blockchain can be secured by both native tokens and external tokens (e.g. ETH, BTC).  Security Aggregation consists of the following parts:  A mechanism for delegating external tokens to Cosmos validators, such as Babylon or EigenLayer AVS contract.An oracle that tracks how much external stake has been delegated to each Cosmos validator and provides price feeds for external tokens.Power mixing: a mechanism to combine external and native stake to derive the power of each validator.A reward distribution protocol that enables sending back rewards to the external source.  External staking information is received from an oracle together with price information of related stakes. The CosmosLayer derives validator powers based on external and native staking information and initiates rewarding of external depositors.  This ADR describes the Cosmos modules of the solution.  ","version":"v6.1.0","tagName":"h2"},{"title":"Alternative Approaches​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#alternative-approaches","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Rewards​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#rewards","content":" As an alternative to sending rewards back to the external chains, stakers could be rewarded on the Cosmos chain. This would require a mapping of external addresses to addresses on Cosmos chain for each staker on external source. In addition detailed external staking information such as staking addresses, amount of stakes per staker and validator, etc. have to be provided by the oracle.  ","version":"v6.1.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#decision","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#rewards-will-be-sent-back-to-external-chains-instead-of-paying-rewards-for-external-stakers-on-cosmos-chain","content":" Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain  due to amount of additional staking information to be sent and tracked by the oracledue to the additional complexity of managing external and Cosmos addresses  ","version":"v6.1.0","tagName":"h3"},{"title":"Detailed Design​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#detailed-design","content":" The Power Mixing feature and Reward Distribution protocol are an integral part of the Security Aggregation solution. The Power Mixing module provides the capability of deriving validator power based on stake originated from external sources such as Ethereum/Bitcoin and the native staking module. The Reward Distribution manages the process of sending rewards to external stakers.  ","version":"v6.1.0","tagName":"h2"},{"title":"Power Mixing​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#power-mixing","content":" Power Mixing provides the final validator powers based on staking information of the native chain and the external stakes. The information about external staking and related price feeds are received from an oracle. Once the final validator powers are determined the result is submitted to the underlying CometBFT consensus layer by updating the validator set.  Requirements:  validator updates are performed on each EndBlocka validator's power is determined based on its native on-chain stakes and external stakesprice information of staked tokens is used to determine a validator’s power, e.g. price ratio (price of native on-chain token / price of external stake)price information of native/external tokens are received from an oraclestaking information from external sources received from the oraclenative staking information are received from the Cosmos SDK Staking Moduleset of validator stakes from oracle always have the current price, full set of validators, and current stakes  The Power Mixing implementation  queries current validators and their powers from x/stakingand from oracle (see below).calculates power updates by mixing power values of external and internal sources Following pseudocode snippet shows a possible implementation of how power mixing feature works.  // PowerSource is an abstract entity providing validator powers which // are used by the mixer. This can be an oracle, staking module or an // IBC connected bridge. type PowerSource interface { GetValidatorUpdates() []abci.ValidatorUpdate } // MixPowers calculates power updates by mixing validator powers from different sources func (k *Keeper) MixPowers(source ...PowerSource) []abci.ValidatorUpdate { var valUpdate []abci.ValidatorUpdate for _, ps := range source { // mix powers from two sets of validator updates an return set of validator updates // with aggregated powers valUpdate = mixPower(valUpdate, ps.GetValidatorUpdates()) } return valUpdate } func (k *keeper) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { // GetPowerSources (including local staking module) registeredPowerSource := GetPowerSources() return k.MixPowers(registeredPowerSource...) }   Integration with ICS provider​  The provider module updates the validator set on CometBFT instead of the SDK staking module (x/staking). The provider implementation will intervene in this behavior and ensure that the validator updates are taken from the Power Mixing feature.  External power sources are managed by the provider module. Only registered power sources can provide input to the Power Mixing feature. Power sources will be assigned a unique identifier which will be used by the oracle, provider module and the power mixing and rewarding feature.  Updates with the next validator set are sent to consumer chains on each epoch (see EndBlockVSU()). When collecting the validator updates for each consumer chain (see QueueVSCPackets()), the validator powers of the bonded validators will be updated with the validator powers from the external sources using the Power Mixing module. These updates are sent as part of the VSC packets to all registered consumer chains.  Integration with ICS consumer​  Consumer chains receive validator updates as part of VSC packets from the provider. These packets contain validator powers which were already mixed with external staked powers.  ","version":"v6.1.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#queries","content":" // GetValidatorUpdates returns the power mixed validator results from the provided sources service Query { rpc GetValidatorUpdates(PowerMixedValUpdateRequest) PowerMixedValUpdateResponse {}; } // PowerMixedValUpdateRequest contains the list of power sources on which the // power mixing should be based on message PowerMixedValUpdateRequest { repeated PowerSource sources; } // PowerMixedValUpdateResponse returns the validator set with the updated powers // from the power mixing feature message PowerMixedValUpdateResponse { repeated abci.ValidatorUpdate val_set }   The following queries will be provided by the oracle  service Query { rpc GetExtValidators(GetExtValidatorRequest) returns (ExtValidatorsResponse) { option (google.api.http).get = &quot;oracle/v1/get_validators&quot;; }; } message GetExtValidatorRequest {} // ExtValidatorsResponse is the response from GetExtValidators queries message ExtValidatorsResponse { repeated ExtValPower powers; } // ExtValPower represents a validator with its staking and token information, // where: // `power_source_identifier` is the identifier of the registered power source // `validator_address` is the address of the validator // `stakes` is the total amount of stakes for a validator // `denom` is the source token of the stake e.g. ETH,BTC // `price_ratio` is the ratio of price of the external token to the price of the 'local' token message ExtValPower { string power_source_identifier; string validator_address; uint64 stakes; string denom; float price_ratio; } // GetPrice returns a price feed for a given token service Query { rpc GetPrice(GetPriceRequest) returns (GetPriceResponse) { option (google.api.http).get = &quot;/oracle/v1/get_price&quot;; }; }   For security reasons the amount of external stakes needs to be limited. Limitation of external staking could be driven by governance and is not subject of this version of the ADR.  ","version":"v6.1.0","tagName":"h3"},{"title":"Reward Handler​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#reward-handler","content":" For native staked tokens the Distribution Module of the Cosmos SDK is taking care of sending the rewards to stakers. For stakes originated from external chains (Ethereum/Bitcoin) the Reward Handler module sends rewards to EigenLayer/Babylon. The transfer of rewards is done using a bridge between the Cosmos chain and the external provider chain.  Note: currently there's no support paying rewards on EigenLayer (see here)  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#positive","content":" Allow external depositors to stake their tokens to secure a Cosmos chain  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#negative","content":" Dependency to external sources e.g (price feeds) for validator power calculationSecurity impact  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#neutral","content":" Additional complexity for staking  ","version":"v6.1.0","tagName":"h3"},{"title":"Questions:​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#questions","content":" Slashing: subject of this ADR? (Defined but not activated currently on EigenLayer).  ","version":"v6.1.0","tagName":"h2"},{"title":"References​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.1.0/adrs/adr-016-securityaggregation#references","content":" EigenLayerBabylon ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 017: ICS with Inactive Provider Validators","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#changelog","content":" 15th May 2024: Initial draft  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#context","content":" Currently, only validators in the active set on the provider can validate on consumer chains, which limits the number of validators that can participate in Interchain Security (ICS). Validators outside of the active set might be willing to validate on consumer chains, but we might not want to make the provider validator set larger, e.g. to not put more strain on the consensus engine. This runs the risk of leaving consumer chains with too few validators.  The purpose of this ADR is to allow validators that are not part of the consensus process on the provider chain (because they are inactive) to validate on consumer chains.  In the context of this ADR, &quot;consensus validator set&quot; is the set of validators participating in the consensus protocol, and &quot;staking validator set&quot; is the set of validators viewed as active by the staking module.  Currently, the staking module, provider module, and CometBFT interact in this way:    The staking module keeps a list of validators. The MaxValidators validators with the largest amount of stake are &quot;active&quot; validators. MaxValidators is a parameter of the staking module. The staking module sends these validators to CometBFT to inform which validators make up the next consensus validators, that is, the set of validators participating in the consensus process. Separately, the provider module reads the list of bonded validators and sends this to the consumer chain, after shaping it according to which validators are opted in and the parameters set by the consumer chain for allowlist, denylist, etc.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#decision","content":" The proposed solution to allow validators that are not participating in the consensus process on the provider (inactive validators) is to change 3 main things:  a) increase the MaxValidators parameter of the staking module  b) do not take the updates for CometBFT directly from the bonded validators in the staking module, by wrapping the staking modules EndBlocker with a dummy EndBlocker that doesn't return any validator updates. Instead, we adjust the provider module to return validator updates on its EndBlocker. These validator updates are obtained by filtering the bonded validators to send only the first MaxProviderConsensusValidators (sorted by largest amount of stake first) many validators to CometBFT  c) use the enlarged list of bonded validators from the staking module as basis for the validator set that the provider module sends to consumer chains (again after applying power shaping and filtering out validators that are not opted in).  In consequence, the provider chain can keep a reasonably-sized consensus validator set, while giving consumer chains a much larger pool of potential validators.    Some additional considerations:  Migration: In the migration, the last consensus validator set will be set to the last active validator set from the view of the staking module. Existing consumer chains are migrated to have a validator set size cap (otherwise, they could end up with a huge validator set including all the staking-but-not-consensus-active validators from the provider chain)Slashing: Validators that are not part of the active set on the provider chain can still be jailed for downtime on a consumer chain (via an Interchain Security SlashPacket sent to the provider, who will then jail the validator), but they are not slashed for downtime on the provider chain. This is achieved without any additional changes to the slashing module, because the slashing module checks for downtime by looking at the consensus participants reported by CometBFT, and thus with the proposed solution, validators that are not part of the consensus validators on the provider chain are not considered for downtime slashing (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/slashing/abci.go#L22).Rewards: Validators that are not part of the active set on the provider chain can still receive rewards on the consumer chain, but they do not receive rewards from the provider chain. This change is achieved without further changes to staking or reward distributions, because similar to downtime, rewards are based on the consensus validator set (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/distribution/abci.go#L28)  ","version":"v6.1.0","tagName":"h2"},{"title":"Changes to the state​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#changes-to-the-state","content":" The following changes to the state are required:  Introduce the MaxProviderConsensusValidators parameter to the provider module, which is the number of validators that the provider module will send to the consensus engine.Store the provider consensus validator set in the provider module state under the LastProviderConsensusValsPrefix key. This is the last set of validators that the provider sent to the consensus engine. This is needed to compute the ValUpdates to send to the consensus engine (by diffing the current set with this last sent set).Increase the MaxValidators parameter of the staking module to the desired size of the potential validator set of consumer chains.Introduce extra per-consumer-chain parameters: MinStake: is the minimum amount of stake a validator must have to be considered for validation on the consumer chain.AllowInactiveVals: is a boolean that determines whether validators that are not part of the active set on the provider chain can validate on the consumer chain. If this is set to true, validators outside the active set on the provider chain can validate on the consumer chain. If this is set to true, validators outside the active set on the provider chain cannot validate on the consumer chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"Risk Mitigations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#risk-mitigations","content":" To mitigate risks from validators with little stake, we introduce a minimum stake requirement for validators to be able to validate on consumer chains, which can be set by each consumer chain independently, with a default value set by the provider chain.  Additional risk mitigations are to increase the active set size slowly, and to monitor the effects on the network closely. For the first iteration, we propose to increase the active set size to 200 validators (while keeping the consensus validators to 180), thus letting the 20 validators with the most stake outside of the active set validate on consumer chains.  ","version":"v6.1.0","tagName":"h2"},{"title":"Testing Scenarios​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#testing-scenarios","content":" In the following,  bonded validators refers to all validators that have bonded stake,active validators refers to the validators that take part in consensus,inactive validators refers to bonded validators that are not active validators.  ","version":"v6.1.0","tagName":"h2"},{"title":"Scenario 1: Inactive validators should not be considered by governance​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#scenario-1-inactive-validators-should-not-be-considered-by-governance","content":" Inactive validators should not be considered for the purpose of governance. In particular, the quorum should depend only on active validators.  We test this by:  creating a provider chain (either with 3 active validators, or with only 1 active validator), a quorum of 50%, and 3 validators with alice=300, bob=299, charlie=299 stakewe create a governance proposalalice votes for the proposalwe check that the proposal has the right status: in the scenario where we have 3 active validators, the proposal should not have passed, because alice alone is not enough to fulfill the quorumin the scenario where we have 1 active validator, the proposal should have passed, because alice is the only active validator, and thus fulfills the quorum  Tested by the e2e tests inactive-provider-validators-governance (scenario with 1 active val) and inactive-provider-validators-governance-basecase (scenario with 3 active vals).  ","version":"v6.1.0","tagName":"h3"},{"title":"Scenario 2: Inactive validators should not get rewards from the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#scenario-2-inactive-validators-should-not-get-rewards-from-the-provider-chain","content":" Inactive validators should not get rewards from the provider chain.  This can be tested by starting a provider chain with inactive validators and checking the rewards of inactive validators.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.1.0","tagName":"h3"},{"title":"Scenario 3: Inactive validators should get rewards from consumer chains​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#scenario-3-inactive-validators-should-get-rewards-from-consumer-chains","content":" An inactive validator that is validating on a consumer chain should receive rewards in the consumer chain token.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.1.0","tagName":"h3"},{"title":"Scenario 4: Inactive validators should not get slashed/jailed for downtime on the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#scenario-4-inactive-validators-should-not-get-slashedjailed-for-downtime-on-the-provider-chain","content":" This can be tested by having an inactive validator go offline on the provider chain for long enough to accrue downtime. The validator should be neither slashed nor jailed for downtime.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.1.0","tagName":"h3"},{"title":"Scenario 5: Inactive validators should get jailed for consumer downtime on the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#scenario-5-inactive-validators-should-get-jailed-for-consumer-downtime-on-the-provider-chain","content":" This can be tested by having an inactive validator go offline on a consumer chain for long enough to accrue downtime. The consumer chain should send a SlashPacket to the provider chain, which should jail the validator.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.1.0","tagName":"h3"},{"title":"Scenario 6: Inactive validators should not be counted when computing the minimum power in the top N​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#scenario-6-inactive-validators-should-not-be-counted-when-computing-the-minimum-power-in-the-top-n","content":" This can be tested like this:  Start a provider chain with validator powers alice=300, bob=200, charlie=100 and 2 max provider consensus validators So alice and bob will validate on the provider Start a consumer chain with top N = 51%. Without inactive validators, this means both alice and bob have to validate. But since charlie is inactive, this means bob is not in the top N Verify that alice is in the top N, but bob is not  Checked as part of the e2e test inactive-vals-topN.  ","version":"v6.1.0","tagName":"h3"},{"title":"Scenario 7: Mint does not consider inactive validators​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#scenario-7-mint-does-not-consider-inactive-validators","content":" To compute the inflation rate, only the active validators should be considered.  We can check this by querying the inflation rate change over subsequent blocks.  We start a provider chain with these arguments  3 validators with powers alice=290, bob=280, charlie=270either 1 or 3 active validatorsa bonded goal of 300 tokens (this is given in percent, but we simplify here)  If we have 3 validators active, then the inflation rate should decrease between blocks, because the bonded goal is exceeded as all validators are bonded. If we have only 1 validator active, then the inflation rate should increase between blocks, because the bonded goal is not met.  Checked as part of the e2e tests inactive-vals-mint (scenario with 1 active val) and mint-basecase (scenario with 3 active vals).  ","version":"v6.1.0","tagName":"h3"},{"title":"Scenarios 8: Inactive validators can validate on consumer chains​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#scenarios-8-inactive-validators-can-validate-on-consumer-chains","content":" An inactive validator can opt in and validate on consumer chains (if min stake allows it)  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.1.0","tagName":"h3"},{"title":"Scenario 9: MinStake parameters is respected​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#scenario-9-minstake-parameters-is-respected","content":" Validators that don't meet the criteria for a consumer chain cannot validate on it.  Checked in the e2e tests min-stake.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#positive","content":" Validators outside of the active set can validate on consumer chains without having an impact on the consensus engine of the provider chainConsumer chains can have a much larger validator set than the provider chain if they prefer this e.g. for decentralization reasonsConsumer chain teams can, with much less cost than today, start up their own consumer chain node to keep the chain running (in a centralized manner) even if no hub validators have opted in to validate on the chain. This is useful to stop the chain from ending up with an empty validator set and becoming recoverable only with a hardfork  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#negative","content":" Allowing validators from the inactive set brings with it some additional risks. In general, consumer chains will now face some of the problems also faced by standalone chains. It’s reasonable to assume that the validator set on the hub has a minimum amount of operational quality due to being battle tested and decentralized, and consumer chains with validators from outside the hub active set cannot rely on this as much anymore.  Sybil attacks​  With the restricted size of the active set today, it’s clear that the set is at least minimally competitive and it is not trivial to spin up multiple nodes as a validator.  When we make the “potential validator set” much larger, we should assume that it becomes much less competitive to be part of that set, and thus trivial for single entities to control many of those validators.  Reputational damage is not a deterrent​  For validators in the active set, we typically assume that if they would misbehave, they pay a large reputational cost. This represents delegators deciding to switch validators (potentially even on chains other than the one the misbehaviour happened on), and loss of credibility in the ecosystem. With the much larger active set, it seems prudent to assume that reputational damage is not a deterrent for many validators. They might only have minimal amounts of delegated stake and control most of it themselves, so they might not be deterred from performing actions that would usually bring reputational damage.  Additional negative consequences​  The provider keeper will need to implement the staking keeper interface, and modules need to be wired up to either the staking or provider keeper, depending on whether they need the consensus or staking validator setThis will impact how future modules are integrated, since we will need to consider whether those modules should consider the consensus validators or the bonded validators (which other modules might assume to be the same)  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#neutral","content":" There might be validators that are bonded, but not validating on any chain at all. This is not a problem, but it might be a bit confusing.  ","version":"v6.1.0","tagName":"h3"},{"title":"Alternative considerations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#alternative-considerations","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Modifying the staking module​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#modifying-the-staking-module","content":" We could instead adapt the staking module with a similar change. This might be better if it turns out that the staking module active set is used in many other places.  ","version":"v6.1.0","tagName":"h3"},{"title":"Allowing unbonding validators to validate​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#allowing-unbonding-validators-to-validate","content":" Instead of increasing the active set size, we could allow validators that are unbonded (but still exist on the provider) to validate consumer chains. For this, we would need to:  Modify the VSC updates to consider the set of all validators, even unbonded ones, instead of just active onesAdjust our downtime jailing/equivocation slashing logic to work correctly with unbonded validators. This is very hard, because redelegations are not usually tracked for unbonded validators.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.1.0/adrs/adr-017-allowing-inactive-validators#references","content":" Security Aggregation has similar concerns where the staking validator set will differ from the consensus validator set ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 018: Remove VSCMatured Packets","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#changelog","content":" 19/06/2024: Create initial draft  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#context","content":" The idea of removing VSCMatured packets was first suggested by Jae Kwon over a conversation in 2022. As a result of that conversation, an ADR was proposed to halt consumer chain if VSC packets are no longer received. The ADR was not accepted due to other considerations regarding the safety of consumer chains. See this blog post for more details.  The consumer module on the consumer chains is a representation of the Hub’s staking module, i.e., it provides an asynchronous view of the voting powers and indirectly of the locked collateral. The key word here is asynchronous, which means that (in theory) there is no bound on the lag between the Hub’s view of stake and the consumer’s view of stake. The reasons for this asynchrony are relaying delays and chain liveness (e.g., a consumer could be down for a long period of time without affecting the liveness of the staking module on the Hub).  The current version of ICS uses VSCMaturedPackets to create on the consumers a partially synchronous view of the Hub’s staking module. Partially synchronous means that the lag between the Hub’s view of stake and the consumer’s view of stake is bounded, because consumers that exceed this lag are forcibly removed from the protocol. Basically, unlocking collateral from the Hub is being delayed until the consumers’ UnbondingPeriod elapses. The reason the view is only partially synchronous is that eventually the collateral is unlocked, i.e., if VSCMaturedPackets are not received from a consumer for VscTimeoutPeriod (default: 5 weeks), then the consumer is removed from ICS and the collateral is unlocked. Note that keeping the stake locked “forever” would affect the Hub’s liveness, so it’s not a viable option.  The issue is that whatever attack is possible with an asynchronous view of the staking module, it is eventually possible with the partially synchronous view as well. For example, an attacker could wait for VscTimeoutPeriod for the collateral to be unlocked and then send invalid headers to third-party chains that are not aware the consumer's collateral is no longer locked on the Hub (i.e., the consumer is no longer part of ICS).  Moreover, with the introduction of PSS, a consumer’s validator set could “lie” about its UnbondingPeriod elapsing by sending VSCMaturedPackets earlier. This would result in a discrepancy between a light client’s view of the UnbondingPeriod and the actual Hub’s UnbondingPeriod.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#decision","content":" This ADR proposes the removal of VSCMaturedPackets. The reason is twofold. First, VSCMaturedPackets provide a &quot;false&quot; sense of correctness as the attack described above is still possible. Second, VSCMaturedPackets add considerable complexity to the ICS protocol -- an extra message plus the pausing of unbonding operations that can affect the UX.  To simplify the upgrading process, removing VSCMaturedPackets can be done in two releases:  (R1) Update the provider to drop VSCMaturedPackets.(R2) Update the consumer to stop sending VSCMaturedPackets.  As a result, once the provider chain runs R1, the consumers can start upgrading to R2.  ","version":"v6.1.0","tagName":"h2"},{"title":"Provider Changes (R1)​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#provider-changes-r1","content":" Parameters​  Deprecate the InitTimeoutPeriod and VscTimeoutPeriod parameters.  State​  Add the following key prefix to the state:  ConsumerAddrsToPruneV2BytePrefix -- the byte prefix for storing consumer validators addresses that need to be pruned. These are stored as ConsumerAddrsToPruneV2BytePrefix | len(chainID) | chainID | ts -&gt; (consumer_address1, consumer_address2, ...) where ts is the timestamp at which the consumer validators addresses can be pruned.  Migrate the consumer validator addresses stored under the ConsumerAddrsToPruneBytePrefix to the new prefix ConsumerAddrsToPruneV2BytePrefix. Note that these consumer validators addresses are stored as  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; (consumer_address1, consumer_address2, ...)   where vscID is the ID of the first VSCPacket sent after these consumer validator addresses were changed. These means that we can use the VscSendTimestamps to compute the timestamps when these consumer validator addresses can be pruned, i.e.,  func MigrateConsumerAddrsToPrune() iterator := sdk.KVStorePrefixIterator(store, []byte{providertypes.ConsumerAddrsToPruneBytePrefix}) for ; iterator.Valid(); iterator.Next() { chainID, vscID, _ := providertypes.ParseChainIdAndUintIdKey(providertypes.ConsumerAddrsToPruneBytePrefix, iterator.Key()) // use the VscSendTimestamp index to compute the timestamp at which this consumer addresses can be pruned vscSendTimestampKey := providertypes.ChainIdAndUintIdKey(providertypes.VscSendTimestampBytePrefix, chainID, vscID) timeBz := store.Get(vscSendTimestampKey) sentTime, _ := sdk.ParseTimeBytes(timeBz) pruneTs := sentTime.Add(sk.UnbondingTime(ctx)) var addrs providertypes.AddressList addrs.Unmarshal(iterator.Value()) for _, addr := range addrs.Addresses { consumerAddr := providertypes.NewConsumerConsAddress(addr) pk.AppendConsumerAddrsToPrune(ctx, chainID, pruneTs, consumerAddr) } } }   Remove the following key prefixes from the state. Note that these removals require state migration.  MaturedUnbondingOpsByteKey -- the byte key that stores the list of all unbonding operations ids that have matured from a consumer chain perspective.UnbondingOpBytePrefix -- the byte prefix that stores a record of all the ids of consumer chains that need to unbond before a given unbonding operation can unbond on this chain.UnbondingOpIndexBytePrefix -- the byte prefix of the index for looking up which unbonding operations are waiting for a given consumer chain to unbond.InitTimeoutTimestampBytePrefix -- the byte prefix for storing the init timeout timestamp for a given consumer chainID.VscSendTimestampBytePrefix -- the byte prefix for storing the list of VSC sending timestamps for a given consumer chainID.ConsumerAddrsToPruneBytePrefix -- the byte prefix for storing the mapping from VSC IDs to consumer validators addresses that need to be pruned.  State Transitions​  Removing VSCMaturedPackets affects three ICS sub-protocols (see HandleVSCMaturedPacket): unbonding operations pausing, VSCPackets timeout, and key assignment pruning. The first two are no longer needed, while the third (key assignment pruning) needs to be redesigned to not depend on VSCMaturedPackets.  Removing unbonding operations pausing:  Make the AfterUnbondingInitiated hook a no-op. As a result, unbonding operations are no longer paused.Stop calling the UnbondingCanComplete method from the staking keeper. This entails, it is no longer necessary to append MaturedUnbondingOps and the completeMaturedUnbondingOps method can be removed.Note, that during the upgrade, all unbonding operations stored under the UnbondingOpBytePrefix prefix need to be completed (via the UnbondingCanComplete method from the staking keeper).Remove the init timeout timestamp logic from the following methods: CreateConsumerClient, SetConsumerChain, and EndBlockCCR.  Removing VSCPackets timeout:  Stop setting VSC send timestamps when sending VSCPackets.Stop removing the VSC send timestamps when receiving VSCMaturedPackets.Remove the logic from EndBlockCCR that checks if the first VSC send timestamp in iterator plus VscTimeoutPeriod exceeds the current block time.  Redesign key assignment pruning. The reason for keeping &quot;old&quot; consumer addresses is to enable slashing / jailing validators that misbehave on consumer chains, i.e., the slashing logic uses the GetProviderAddrFromConsumerAddr method that accesses the mapping from validator addresses on consumer chains to validator addresses on the provider chain (ValidatorsByConsumerAddrBytePrefix). Thus, &quot;old&quot; consumer addresses are no longer needed after the provider's UnbondingPeriod elapses. This means that once a validator changes its key on a consumer, we can prune the address corresponding to the &quot;old&quot; key after UnbondingPeriod. This requires the following changes:  Adapt the AppendConsumerAddrsToPrune() method to use the timestamp at which it is safe to prune the consumer validator address (instead of the current vscID).Add a new method ConsumeConsumerAddrsToPrune(ts) that returns the list of consumer addresses that can be pruned at timestamp ts.Adapt the PruneKeyAssignments() method to call ConsumeConsumerAddrsToPrune(ctx.BlockTime()).Call the PruneKeyAssignments() method from every EndBlock() instead of calling it from HandleVSCMaturedPacket().  Queries​  Remove the oldest_unconfirmed_vsc query.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consumer Changes (R2)​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#consumer-changes-r2","content":" Parameters​  Given that currently relayers use the consumer UnbondingPeriod (see ConsumerParams), this param cannot be deprecated. Note that Hermes queries the UnbondingPeriod for sanity checks and to set the default trusting period when it is not specified. As a result, the UnbondingTime method from the staking interface will continue to be used to retrieve the consumer's UnbondingPeriod.  State​  Remove the following key prefixes from the state:  PacketMaturityTimeBytePrefix -- the byte prefix that will store maturity time for each received VSC packet  Note that these removals require state migration.  State Transitions​  To stop the consumer chains from sending VSCMaturedPackets, it is sufficient to not store the maturity time of VSCPackets when receiving them, i.e., do not call SetPacketMaturityTime from the OnRecvVSCPacket() method. Note that eventually, no additional VSCMaturedPackets will be added to the sending queue as QueueVSCMaturedPackets iterates over elapsed maturity times. In addition, to clean up the code, the QueueVSCMaturedPackets must be removed.  Messages​  VSCMaturedPacketData is deprecated. Note that this is a wire-breaking change -- older consumer versions will send VSCMaturedPackets and older provider versions will expect to receive VSCMaturedPackets.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#positive","content":" Remove feature that provides a &quot;false&quot; sense of correctness.Remove unnecessary complexity, from both ICS and Cosmos SDK.Remove one IBC packet and, thus, reduce relaying cost.Remove unbonding pausing logic that could affect the UX.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#negative","content":" Large refactor that might introduce unexpected bugs.Consumer chains are no longer removed if the duration between creating a client and creating the CCV channel exceeds InitTimeoutPeriod. This means that if the CCV channel is not created on time, the client expires and the consumer chain can no longer start without a ClientUpdate proposal or re-submitting a ConsumerAdditionProposal.  ","version":"v6.1.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#neutral","content":" Consumer chains are no longer removed after a VscTimeoutPeriod of inactivity. Note that consumers are still removed if their CCV channel expires, which usually happens after two weeks instead of five weeks (the default value for VscTimeoutPeriod).  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured#references","content":" PR #712 -- Proposal to set an expiration date on the consumer chain updated on each VSCPacket received to ensure the chain is up-to-date.Learning to Live with “Unbonding Pausing” blog post. ","version":"v6.1.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/intro","content":"","keywords":"","version":"v6.1.0"},{"title":"Table of Contents​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/adrs/intro#table-of-contents","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Accepted​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/adrs/intro#accepted","content":" ADR 001: Key AssignmentADR 002: Jail ThrottlingADR 004: Denom DOS fixesADR 005: Cryptographic verification of equivocation evidenceADR 008: Throttle with retriesADR 010: Standalone to Consumer ChangeoverADR 013: Slashing on the provider for consumer equivocationADR 014: EpochsADR 015: Partial Set SecurityADR 017: ICS with Inactive Provider ValidatorsADR 018: Remove VSCMatured PacketsADR 18: Permissionless Interchain Security  ","version":"v6.1.0","tagName":"h3"},{"title":"Proposed​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/adrs/intro#proposed","content":" ADR 011: Improving testing and increasing confidenceADR 016: Security aggregation  ","version":"v6.1.0","tagName":"h3"},{"title":"Rejected​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/adrs/intro#rejected","content":" ADR 007: Pause validator unbonding during equivocation proposalADR 012: Separate Releasing  ","version":"v6.1.0","tagName":"h3"},{"title":"Deprecated​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/adrs/intro#deprecated","content":" ADR 003: Equivocation governance proposalADR 009: Soft Opt-Out ","version":"v6.1.0","tagName":"h3"},{"title":"Developing an ICS consumer chain","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/consumer-development/app-integration","content":"","keywords":"","version":"v6.1.0"},{"title":"Basic consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v6.1.0/consumer-development/app-integration#basic-consumer-chain","content":" The source code for the example app can be found here.  Please note that consumer chains do not implement the staking module - part of the validator set of the provider is replicated over to the consumer, meaning that the consumer uses a subset of provider validator set and the stake of the validators on the provider determines their stake on the consumer. Note that after the introduction of Partial Set Security, not all the provider validators have to validate a consumer chain (e.g., if top_N != 100).  Your chain should import the consumer module from x/consumer and register it in the correct places in your app.go. The x/consumer module will allow your chain to communicate with the provider using the ICS protocol. The module handles all IBC communication with the provider, and it is a simple drop-in. You should not need to manage or override any code from the x/consumer module.  ","version":"v6.1.0","tagName":"h2"},{"title":"Democracy consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v6.1.0/consumer-development/app-integration#democracy-consumer-chain","content":" The source code for the example app can be found here.  This type of consumer chain wraps the basic CosmosSDK x/distribution, x/staking and x/governance modules allowing the consumer chain to perform democratic actions such as participating and voting within the chain's governance system.  This allows the consumer chain to leverage those modules while also using the x/consumer module.  With these modules enabled, the consumer chain can mint its own governance tokens, which can then be delegated to prominent community members which are referred to as &quot;representatives&quot; (as opposed to &quot;validators&quot; in standalone chains). The token may have different use cases besides just voting on governance proposals.  ","version":"v6.1.0","tagName":"h2"},{"title":"Standalone chain to consumer chain changeover​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v6.1.0/consumer-development/app-integration#standalone-chain-to-consumer-chain-changeover","content":" See the standalone chain to consumer chain changeover guide for more information on how to transition your standalone chain to a consumer chain. ","version":"v6.1.0","tagName":"h2"},{"title":"Consumer Chain Governance","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/consumer-development/consumer-chain-governance","content":"","keywords":"","version":"v6.1.0"},{"title":"Democracy module​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v6.1.0/consumer-development/consumer-chain-governance#democracy-module","content":" The democracy module provides a governance experience identical to what exists on a standalone Cosmos chain, with one small but important difference. On a standalone Cosmos chain validators can act as representatives for their delegators by voting with their stake, but only if the delegator themselves does not vote. This is a lightweight form of liquid democracy.  Using the democracy module on a consumer chain is the exact same experience, except for the fact that it is not the actual validator set of the chain (since it is a consumer chain, these are the Cosmos Hub validators) acting as representatives. Instead, there is a separate representative role who token holders can delegate to and who can perform the functions that validators do in Cosmos governance, without participating in proof of stake consensus.  For an example, see the Democracy Consumer  ","version":"v6.1.0","tagName":"h2"},{"title":"CosmWasm​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v6.1.0/consumer-development/consumer-chain-governance#cosmwasm","content":" There are several great DAO and governance frameworks written as CosmWasm contracts. These can be used as the main governance system for a consumer chain. Actions triggered by the CosmWasm governance contracts are able to affect parameters and trigger actions on the consumer chain.  For an example, see Neutron.  ","version":"v6.1.0","tagName":"h2"},{"title":"The Whitelist​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v6.1.0/consumer-development/consumer-chain-governance#the-whitelist","content":" Not everything on a consumer chain can be changed by the consumer's governance. Some settings having to do with consensus etc. can only be changed by the provider chain. Consumer chains include a whitelist of parameters that are allowed to be changed by the consumer chain governance. For an example, see Neutron's whitelist. ","version":"v6.1.0","tagName":"h2"},{"title":"ADR 019: Permissionless Interchain Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics","content":"","keywords":"","version":"v6.1.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#changelog","content":" 27th of June, 2024: Initial draft12th of September, 2024: Updated to take into account message changes, etc.  ","version":"v6.1.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#status","content":" Accepted  ","version":"v6.1.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#context","content":" Currently, a consumer chain can join Interchain Security (ICS) only through a governance proposal. A governance proposal was needed before the introduction of Partial Set Security (PSS) because validators were required to validate a consumer chain. However, after the introduction of PSS, a consumer chain can be either Top N or Opt In. If a chain is an Opt In chain, then no validator is required to validate this chain unless they choose to. Because of this, we can launch an Opt In consumer chain without going through a governance proposal.  This ADR presents Permissionless ICS, a way in which an Opt In consumer chain can join ICS without needing a governance proposal but by simply issuing a transaction.  ","version":"v6.1.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#decision","content":" In Permissionless ICS, launching an Opt In chain can be done by issuing a transaction. Naturally, Permissionless ICS does not eliminate governance proposals, as proposals are still necessary for Top N chains. Nevertheless, a Top N chain can transform to an Opt In chain through a gov proposal and vice versa.  ","version":"v6.1.0","tagName":"h2"},{"title":"The Phases of a Consumer Chain​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#the-phases-of-a-consumer-chain","content":" We first present the notion of an owner of a consumer chain before showing the specific phases of a consumer chain.  Owner. A consumer chain has an owner, which is simply an address. Only the owner can interact (i.e., launch, update, or stop) with the chain. The owner of an Opt In chain is the one who signed the initial transaction to register a consumer chain (more on this later). Naturally, an Opt In chain can change its owner at any point. The owner of a Top N chain is the account of the governance module. Therefore, any changes on a Top N chain have to go through governance proposals.  A consumer chain can reside in five phases: i) registered, ii) initialized, iii) launched, iv) stopped, and v) deleted phase as seen in the diagram below:  Registered phase. In the registered phase, a consumer chain has an assigned a unique identifier, that of consumerId (more on this later) that identifies a consumer chain that is used to interact with the chain (e.g., when a validator opts in on a chain, etc.). A chain is created and resides at the registered phase through the use of a MsgCreateConsumer which response contains the consumerId.MsgCreateConsumer is the first step in creating either a Top N or an Opt In consumer chain.  If all the optional initialization parameters are provided in MsgCreateConsumer, then an Opt In chain can immediately move to the initialized phase (see below) and get scheduled to launch. Note, however that a Top N chain needs at least two more MsgUpdateConsumer messages and one gov proposal to be able to launch.  In the registered phase, it is not yet known if the consumer chain would end up being a Top N or an Opt In chain and hence the owner of the consumer chain at this phase is the one that signed the MsgCreateConsumer.  Initialized phase. The initialized phase means that the chain has set all the needed initialization parameters to launch but has not yet launched. If a chain in the registered phase has not yet set the initialization parameters, it can issue a MsgUpdateConsumermessage to set those parameters. Additionally, MsgUpdateConsumer can be used to set up other parameters, such as the power-shaping parameters. If a chain is in the initialized phase and MsgUpdateConsumer is issued with spawn time being zero, the chain moves back to the registered phase.  In order to move a Top N chain to the initialized phase, we need to issue at least two MsgUpdateConsumer messages:  one to change the owner of the chain to be the account of the governance module;another as part of a governance proposal to set the Top N.  Launched phase. In the launched phase the consumer chain is running and is consuming a subset of the validator set of the provider. When the spawnTimepasses and at least one validator has opted inthe chain can launch and moves to the launched phase. Note that a Top N chain can launch if and only if the spawnTime has passed and the proposal with the MsgUpdateConsumer has successfully passed. While in launched phase, a consumer chain can choose to modify its parameters through MsgUpdateConsumer. Naturally, only the owner of the chain can issue MsgUpdateConsumer, thus for Top N chains, the chain can be updated only through a governance proposal that contains a MsgUpdateConsumer. Additionally, note that after the chain moves to the launched phase, the initialization parameters cannot be updated anymore, but general metadata and power-shaping parameters of the chain can still be updated.  Stopped phase. In the stopped phase the consumer chain stops receiving VSCPackets. A chain moves to the stopped phase, when the owner of the chain sends the MsgRemoveConsumer message.  Deleted phase. In the deleted phase the majority of the state in relation to this consumer chain is deleted from the provider. A chain moves to the deleted phase after the chain has been stopped for an unbonding period. We keep track of the state of the consumer chain for an unbonding period, so that we are able to punish validators for misbehaviors that occurred before the consumer chain stopped. Additionally, we do not fully delete the whole state of this chain, so that we can still query parameters a deleted chain used to have. This is useful for front-ends, etc.  Note that everything described so far and everything that follows applies to consumer chains that transition from standalone chains as well.  ","version":"v6.1.0","tagName":"h3"},{"title":"From chainId to consumerId​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#from-chainid-to-consumerid","content":" A hindrance in moving to Permissionless ICS is chain-id squatting. In a permissionless setting, anyone could issue a transaction to launch a consumer chain with a chainId that might already be used by some other consumer chain. This is a problem because in the current design the majority of stored state for a consumer chain is indexed using the chainId as the key (e.g., see key used to store client ids). To tackle this problem, in Permissionless ICS, we introduce the consumerId that defines a consumer chain and is simply an increasing counter (i.e., counter), thus we can support multiple consumer chains with the same chainId. Another way to understand this is with an analogy between consumer chains and IBC clients: Imagine having multiple IBC clients that each point to different consumer chains, but all share the exact same chainId. It is then up to the user to select the appropriate client (i.e., clientId) based on the actual chain they want to communicate with. Similarly, there can be multiple consumer chains with the exact same chainId, and it is the responsibility of the validators to choose the one they wish to interact with by providing the right consumerId.  Note that with Permissionless ICS, all interactions on a consumer chain have to use the consumerId instead of the chainId. For example, if a validator opts in on a chain using MsgOptIn, the validator has to provide the consumerId. Specifically, for the equivocation evidence, we update the MsgSubmitConsumerMisbehaviour and MsgSubmitConsumerDoubleVotingmessages to include the consumerId, and modify Hermesto include consumerId in those constructed messages as well. Hermes can find out the consumerId by querying the provider's clientId for some consumer chain (i.e., query ccvconsumer provider-info) and then asking the provider chain for the consumerId that corresponds to this clientId. To do this, we store the clientId to consumerId association on the provider and introduce a query to retrieve the clientId given the consumerId.  State​  As a result of using consumerId, we have to migrate a substantial chunk of state to re-index it using consumerId as the key. Currently, in ICS we have state that is indexed by a multitude of keys. In the table below, we see the ones that are associated with a chainId and how often state under those keys gets updated. Additionally, for each key, the table shows whose action can lead to the setting or deletion of the state associated with that key. An action can stem either from: i) a consumer chain (e.g., through a MsgUpdateConsumer message, an IBC packet sent over to the provider, etc.), ii) a provider chain (e.g., at the end of a block some action is taken), or by iii) a validator (e.g., through a MsgAssignConsumerKey message) or a combination of them.  Key\tDescription\tWho can set this?\tWho can delete this?\tHow often are chainId-associated keys updated?ChainToChannelBytePrefix\tStores the CCV channelID for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) ChannelToChainBytePrefix\tStores chainId for a specific channel\tconsumer chain\tconsumer chain\tOnly once (during set up) ChainToClientBytePrefix\tStores the clientID for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) PendingCAPBytePrefix\tStores pending consumer addition proposals\tconsumer chain\tprovider chain\tOnly once (for successful proposal) PendingCRPBytePrefix\tStores pending consumer removal proposals\tconsumer chain\tprovider chain\tOnly once (for successful proposal) ConsumerGenesisBytePrefix\tStores the consumer genesis for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) SlashAcksBytePrefix\tStores slash acks for a specific consumer chain\tconsumer chain\tprovider chain\tEvery time we receive a Slash packet PendingVSCsBytePrefix\tStores VSCPackets for a specific consumer chain\tprovider chain\tprovider chain\tEvery epoch ConsumerValidatorsBytePrefix\tStores consumer key per validator per consumer chain\tvalidator\tconsumer chain\tEvery MsgAssignConsumerKey or MsgOptIn ValidatorsByConsumerAddrBytePrefix\tStores consumer to provider validator address\tvalidator\tconsumer or provider chain\tEvery MsgAssignConsumerKey or MsgOptIn EquivocationEvidenceMinHeightBytePrefix\tStores min height for a consumer chain\tconsumer chain\tconsumer chain\tOnly once (during set up) ProposedConsumerChainByteKey\tStores proposalIDs for consumer chains with proposals in the voting period\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tCreated when the proposal is submitted and deleted when the proposal's voting period ends ConsumerValidatorBytePrefix\tStores consumer validators for a specific chain\tvalidator\tvalidator or consumer chain\tPotentially at every epoch OptedInBytePrefix\tStores opted-in validators for a specific chain\tvalidator\tvalidator or consumer chain\tPotentially at every block TopNBytePrefix\tStores whether a consumer chain is Top N or not\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tEvery parameter update ValidatorsPowerCapPrefix\tStores the power cap of a chain\tconsumer chain\tconsumer chain\tEvery parameter update ValidatorSetCapPrefix\tStores the set cap of a chain\tconsumer chain\tconsumer chain\tEvery parameter update AllowlistPrefix\tStores the allowlist of a chain\tconsumer chain\tconsumer chain\tEvery parameter update DenylistPrefix\tStores the denylist of a chain\tconsumer chain\tconsumer chain\tEvery parameter update ConsumerRewardsAllocationBytePrefix\tStores the ICS rewards per chain\tconsumer or provider chain\tprovider chain\tEvery IBC transfer packet that sends rewards to the provider ConsumerCommissionRatePrefix\tCommission rate per chain per validator\tvalidator\tconsumer chain\tEvery MsgSetConsumerCommissionRate message MinimumPowerInTopNBytePrefix\tStores the minimum power needed to opt in for a chain\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tEvery epoch ConsumerAddrsToPruneV2BytePrefix\tStores consumer addresses to be pruned (as part of VSCMaturedPackets deprecation)\tvalidator or provider chain\tprovider chain\tEvery MsgAssignConsumerKey or MsgOptIn and later during actual pruning  Everything stored under one of the above keys is associated with a chainId and has to be migrated to new state under a consumerId.  ","version":"v6.1.0","tagName":"h3"},{"title":"New Messages​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#new-messages","content":" In this section, we describe the new messages (i.e., MsgCreateConsumer, MsgUpdateConsumer, and MsgRemoveConsumer) that Permissionless ICS introduces.  Create a Consumer Chain​  We first have to create a chain before launching it, irrespectively of whether it is Top N or Opt In. This is done through the following message:  message MsgCreateConsumer { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; // Submitter address. If the message is successfully handled, the ownership of // the consumer chain will given to this address. string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the chain id of the new consumer chain string chain_id = 2; ConsumerMetadata metadata = 3 [ (gogoproto.nullable) = false ]; ConsumerInitializationParameters initialization_parameters = 4; PowerShapingParameters power_shaping_parameters = 5; }   Note that metadata is a required field, while the initialization_parameterrs and power_shaping_parameters are optional and can later be set using MsgUpdateConsumer.  metadata is of the following type:  message ConsumerMetadata { // the name of the chain string name = 1; // the description of the chain string description = 2; // the metadata (e.g., GitHub repository URL) of the chain string metadata = 3; }   initialization_parameters is of the following type and if all are provided the chain is scheduled to launch:  // ConsumerInitializationParameters are the parameters needed to launch a chain message ConsumerInitializationParameters { // ---------- ---------- ---------- // Following fields are used when the consumer chain launches and are not needed by the provider afterwards. // ---------- ---------- ---------- // the proposed initial height of new consumer chain. // For a completely new chain, this will be {0,1}. However, it may be // different if this is a chain that is converting to a consumer chain. ibc.core.client.v1.Height initial_height = 1 [ (gogoproto.nullable) = false ]; // The hash of the consumer chain genesis state without the consumer CCV // module genesis params. It is used for off-chain confirmation of // genesis.json validity by validators and other parties. bytes genesis_hash = 2; // The hash of the consumer chain binary that should be run by validators on // chain initialization. It is used for off-chain confirmation of binary // validity by validators and other parties. bytes binary_hash = 3; // spawn time is the time on the provider chain at which the consumer chain // genesis is finalized and all validators will be responsible for starting // their consumer chain validator node. google.protobuf.Timestamp spawn_time = 4 [ (gogoproto.nullable) = false, (gogoproto.stdtime) = true ]; // Unbonding period for the consumer, // which should be smaller than that of the provider in general. google.protobuf.Duration unbonding_period = 5 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // ---------- ---------- ---------- // Following fields are used to construct the consumer genesis of the to-be-launched consumer chain // and are set up as params on the consumer chain. Those params can then be directly modified by the consumer chain. // ---------- ---------- ---------- // Sent CCV related IBC packets will timeout after this duration google.protobuf.Duration ccv_timeout_period = 6 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // Sent transfer related IBC packets will timeout after this duration google.protobuf.Duration transfer_timeout_period = 7 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // The fraction of tokens allocated to the consumer redistribution address // during distribution events. The fraction is a string representing a // decimal number. For example &quot;0.75&quot; would represent 75%. string consumer_redistribution_fraction = 8; // BlocksPerDistributionTransmission is the number of blocks between // ibc-token-transfers from the consumer chain to the provider chain. On // sending transmission event, `consumer_redistribution_fraction` of the // accumulated tokens are sent to the consumer redistribution address. int64 blocks_per_distribution_transmission = 9; // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. int64 historical_entries = 10; // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer // chain. it is most relevant for chains performing a sovereign to consumer // changeover in order to maintain the existing ibc transfer channel string distribution_transmission_channel = 11; }   power_shaping_parameters is of the following type:  // PowerShapingParameters contains parameters that shape the validator set that we send to the consumer chain message PowerShapingParameters { // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. uint32 top_N = 1; // `validators_power_cap` corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. // For instance, if `validators_power_cap` is set to 32, no validator can have more than 32% of the total voting power of the // consumer chain. The power cap is intended as a safeguard against a validator having too much power on the consumer // chain and hence &quot;taking over&quot; the consumer chain. uint32 validators_power_cap = 2; // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. uint32 validator_set_cap = 3; // corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate the consumer chain repeated string allowlist = 4; // corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain repeated string denylist = 5; // Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain. uint64 min_stake = 6; // Corresponds to whether inactive validators are allowed to validate the consumer chain. bool allow_inactive_vals = 7; }   This MsgCreateConsumerResponse response contains a single string that is the consumerId for this registered consumer chain  Update a Consumer Chain​  We can issue a MsgUpdateConsumer at any point during the registered, initialized, or launched phase of a chain to update parameters of the consumer chain.  The MsgUpdateConsumer message is as follows:  message MsgUpdateConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the address of the owner of the consumer chain to be updated string owner = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to be updated string consumer_id = 2; // the new owner of the consumer when updated string new_owner_address = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the metadata of the consumer when updated ConsumerMetadata metadata = 4; // initialization parameters can only be updated before a chain has launched ConsumerInitializationParameters initialization_parameters = 5; // the power-shaping parameters of the consumer when updated PowerShapingParameters power_shaping_parameters = 6; }   Note that we need to extensively check the fields of the provided ConsumerInitializationParameters to guarantee that no consumer chain launches with problematic parameters.  For all consumer chains, irrespectively of their phase (even in the deleted phase), we keep a mapping between consumerIdand the underlying ConsumerMetadata, ConsumerInitializationParameters and PowerShapingParameters. This way, we can respond to queries that ask for all the consumer chain's parameters. For example, retrieving the spawn_time of consumer chain with a given consumerId.  MsgUpdateConsumer can be executed multiple times for the same Opt In consumer chain during its initialized phase to potentially change its to-be-launched parameters (e.g., spawnTime).  Remove (Stop) a Consumer Chain​  We introduce the MsgRemoveConsumer message so that we can stop any Opt In chain at any point in time. Note that all relevant state for this consumer chain remains on the provider's state before getting removed after the time of an unbonding period (of the provider) has passed. This is to enable potential slashing for any infraction that might have been incurred until now. Note however that we never recycle previously-used consumerIds. Naturally, this message can only be issued by the owner of the consumer chain.  message MsgRemoveConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the consumer id of the consumer chain to be stopped string consumer_id = 1; // the address of the owner of the consumer chain to be stopped string owner = 2 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   Examples of Launching a Consumer Chain​  The figures below depict some examples of some of the phases a consumer chain resides before launching.    ","version":"v6.1.0","tagName":"h3"},{"title":"Additional Modifications​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#additional-modifications","content":" We need to perform multiple migrations. All state needs to be reindex based on a consumerId instead of the chainId. Because we only have two consumer chains (i.e., Neutron and Stride) at the moment, this is not going to be an expensive migration even if we have some live consumer chains that are being voted upon. Similarly, all the messages, queries, etc. would need to be changed to operate on a consumerId instead of a chainId.  It is important to migrate any live proposals, such as ConsumerAdditionProposals and MsgConsumerAdditions, etc. when we upgrade before we actually deprecate ConsumerAdditionProposals, MsgConsumerAdditions, etc.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#consequences","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#positive","content":" Easier to launch an Opt In consumer chain because no governance is required.  ","version":"v6.1.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#negative","content":" Extensive migration and overhaul of existing code base (as part of API-breaking changes) that could lead to bugs.  ","version":"v6.1.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics#references","content":" CHIPs Discussion phase: Permissionless ICSChain-id squatting ","version":"v6.1.0","tagName":"h2"},{"title":"Consumer Offboarding","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/consumer-development/offboarding","content":"Consumer Offboarding To offboard a consumer chain simply submit a ConsumerRemovalProposal governance proposal listing a stop_time. After stop time passes, the provider chain will remove the chain from the ICS protocol (it will stop sending validator set updates). // ConsumerRemovalProposal is a governance proposal on the provider chain to remove (and stop) a consumer chain. // If it passes, all the consumer chain's state is removed from the provider chain. The outstanding unbonding // operation funds are released. { // the title of the proposal &quot;title&quot;: &quot;This was a great chain&quot;, &quot;description&quot;: &quot;Here is a .md formatted string specifying removal details&quot;, // the chain-id of the consumer chain to be stopped &quot;chain_id&quot;: &quot;consumerchain-1&quot;, // the time on the provider chain at which all validators are responsible to stop their consumer chain validator node &quot;stop_time&quot;: &quot;2023-03-07T12:40:00.000000Z&quot;, } More information will be listed in a future version of this document.","keywords":"","version":"v6.1.0"},{"title":"Consumer Genesis Transformation","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/consumer-development/consumer-genesis-transformation","content":"","keywords":"","version":"v6.1.0"},{"title":"1. Prerequisite​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v6.1.0/consumer-development/consumer-genesis-transformation#1-prerequisite","content":" used provider and consumer versions require transformation step as indicated in in the compatibility notesinterchain-security-cd application supports the versions used by the consumer and provider  ","version":"v6.1.0","tagName":"h2"},{"title":"2. Export the CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v6.1.0/consumer-development/consumer-genesis-transformation#2-export-the-ccv-data","content":" Export the CCV data from the provider chain as described in the Onboarding and Changeover your following. As a result the CCV data will be stored in a file in JSON format.  ","version":"v6.1.0","tagName":"h2"},{"title":"3. Transform CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v6.1.0/consumer-development/consumer-genesis-transformation#3-transform-ccv-data","content":" To transform the CCV data  to the format supported by the current version of the consumer run the following command: interchain-security-cd genesis transform [genesis-file] where 'genesis-file' is the path to the file containing the CCV data exported in step 2. As a result the CCV data in the new format will be written to standard output.a specific target version of a consumer run the following command: interchain-security-cd genesis transform --to &lt;target_version&gt; [genesis-file] where &lt;target_version is the ICS version the consumer chain is running. Use interchain-security-cd genesis transform --help to get more details about supported target versions and more.  Use the new CCV data as described in the procedure you're following. ","version":"v6.1.0","tagName":"h2"},{"title":"Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure","content":"","keywords":"","version":"v6.1.0"},{"title":"Overview​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#overview","content":" Standalone to consumer changeover procedure can roughly be separated into 4 parts:  ","version":"v6.1.0","tagName":"h2"},{"title":"1. ConsumerAddition proposal submitted to the provider chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#1-consumeraddition-proposal-submitted-to-the-provider-chain","content":" The proposal is equivalent to the &quot;normal&quot; ConsumerAddition proposal submitted by new consumer chains.  However, here are the most important notes and differences between a new consumer chain and a standalone chain performing a changeover:  chain_id must be equal to the standalone chain idinitial_height field has additional rules to abide by:  caution { ... &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. stride-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_height&quot;: 1, }, ... } RevisionNumber: 0, RevisionHeight: 111  genesis_hash can be safely ignored because the chain is already running. A hash of the standalone chain's initial genesis may be used binary_hash may not be available ahead of time. All chains performing the changeover go through rigorous testing - if bugs are caught and fixed the hash listed in the proposal may not be the most recent one. spawn_time listed in the proposal MUST be before the upgrade_height listed in the upgrade proposal on the standalone chain.  caution spawn_time must occur before the upgrade_height on the standalone chain is reached because the provider chain must generate the ConsumerGenesis that contains the validator set that will be used after the changeover.  unbonding_period must correspond to the value used on the standalone chain. Otherwise, the clients used for the ccv protocol may be incorrectly initialized. distribution_transmission_channel should be set.  note Populating distribution_transmission_channel will enable the standalone chain to reuse one of the existing channels to the provider for consumer chain rewards distribution. This will preserve the ibc denom that may already be in use. If the parameter is not set, a new channel will be created.  ccv_timeout_period has no important notes transfer_timeout_period has no important notes consumer_redistribution_fraction has no important notes blocks_per_distribution_transmission has no important notes historical_entries has no important notes  ","version":"v6.1.0","tagName":"h3"},{"title":"2. upgrade proposal on standalone chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#2-upgrade-proposal-on-standalone-chain","content":" The standalone chain creates an upgrade proposal to include the interchain-security/x/ccv/consumer module.  caution The upgrade height in the proposal should correspond to a height that is after the spawn_time in the consumer addition proposal submitted to the provider chain.  Otherwise, the upgrade is indistinguishable from a regular on-chain upgrade proposal.  ","version":"v6.1.0","tagName":"h3"},{"title":"3. spawn time is reached​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#3-spawn-time-is-reached","content":" When the spawn_time is reached on the provider it will generate a ConsumerGenesis that contains the validator set that will supersede the standalone validator set.  This ConsumerGenesis must be available on the standalone chain during the on-chain upgrade.  ","version":"v6.1.0","tagName":"h3"},{"title":"4. standalone chain upgrade​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#4-standalone-chain-upgrade","content":" Performing the on-chain upgrade on the standalone chain will add the ccv/consumer module and allow the chain to become a consumer of Interchain Security.  caution The ConsumerGenesis must be exported to a file and placed in the correct folder on the standalone chain before the upgrade. The file must be placed at the exact specified location, otherwise the upgrade will not be executed correctly. Usually the file is placed in $NODE_HOME/config, but the file name and the exact directory is dictated by the upgrade code on the standalone chain. please check exact instructions provided by the standalone chain team  After the genesis.json file has been made available, the process is equivalent to a normal on-chain upgrade. The standalone validator set will sign the next couple of blocks before transferring control to provider validator set.  The standalone validator set can still be slashed for any infractions if evidence is submitted within the unboding_period.  Notes​  The changeover procedure may be updated in the future to create a seamless way of providing the validator set information to the standalone chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"Onboarding Checklist​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#onboarding-checklist","content":" This onboarding checklist is slightly different from the one under Onboarding  Additionally, you can check the testnet repo for a comprehensive guide on preparing and launching consumer chains.  ","version":"v6.1.0","tagName":"h2"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.4.1) test the changeover procedure reach out to the ICS team if you are facing issues  ","version":"v6.1.0","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json with CCV data (after spawn time passes). Check if CCV data needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) copy of your governance proposal (as JSON) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"v6.1.0","tagName":"h2"},{"title":"3. Submit a ConsumerChainAddition Governance Proposal to the provider​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#3-submit-a-consumerchainaddition-governance-proposal-to-the-provider","content":" Before you submit a ConsumerChainAddition proposal, please provide a spawn_time that is before the upgrade_height of the upgrade that will introduce the ccv module to your chain.  danger If the spawn_time happens after your upgrade_height the provider will not be able to communicate the new validator set to be used after the changeover.  Additionally, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters to be put in the proposal take note to include a link to your onboarding repository  Example of a consumer chain addition proposal (compare with the ConsumerAdditionProposal in the ICS Provider Proposals section for chains that launch as consumers):  // ConsumerAdditionProposal is a governance proposal on the provider chain to spawn a new consumer chain or add a standalone chain. // If it passes, then a subset (i.e., depends on `top_N` and on the power shaping parameters) of validators on the provider chain are expected // to validate the consumer chain at spawn time. It is recommended that spawn time occurs after the proposal end time and that it is // scheduled to happen before the standalone chain upgrade that sill introduce the ccv module. { // Title of the proposal &quot;title&quot;: &quot;Changeover Standalone chain&quot;, // Description of the proposal // format the text as a .md file and include the file in your onboarding repository &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, // Proposed chain-id of the new consumer chain. // Must be unique from all other consumer chain ids of the executing provider chain. &quot;chain_id&quot;: &quot;standalone-1&quot;, // Initial height of new consumer chain. &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. standalone-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_number&quot;: 1, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // =&gt; not relevant for changeover procedure &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on standalone chain upgrade // =&gt; not relevant for changeover procedure as it may become stale &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and all validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should should be smaller than that of the provider. &quot;unbonding_period&quot;: 86400000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 259200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot; // NOTE: use existing transfer channel if available // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. &quot;top_N&quot;: 95, // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis. &quot;validators_power_cap&quot;: 0, // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. &quot;validator_set_cap&quot;: 0, // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate // the consumer chain. &quot;allowlist&quot;: [], // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. &quot;denylist&quot;: [] }   info As seen in the ConsumerAdditionProposal example above, the changeover procedure can be used together with Partial Set Security. This means, that a standalone chain can choose to only be validated by some of the validators of the provider chain by setting top_N appropriately, or by additionally setting a validators-power cap, validator-set cap, etc. by using the power-shaping parameters.  ","version":"v6.1.0","tagName":"h2"},{"title":"3. Submit an Upgrade Proposal & Prepare for Changeover​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#3-submit-an-upgrade-proposal--prepare-for-changeover","content":" This proposal should add the ccv consumer module to your chain.   proposal upgrade_height must happen after spawn_time in the ConsumerAdditionProposal advise validators about the exact procedure for your chain and point them to your onboarding repository  ","version":"v6.1.0","tagName":"h2"},{"title":"4. Upgrade time 🚀​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.1.0/consumer-development/changeover-procedure#4-upgrade-time-","content":"  after spawn_time, request ConsumerGenesis from the provider and place it in &lt;CURRENT_USER_HOME_DIR&gt;/.sovereign/config/genesis.json upgrade the binary to the one listed in your UpgradeProposal  The chain starts after at least 66.67% of standalone voting power comes online. The consumer chain is considered interchain secured once the &quot;old&quot; validator set signs a couple of blocks and transfers control to the provider validator set.   provide a repo with onboarding instructions for validators (it should already be listed in the proposal) genesis.json after spawn_time obtained from provider (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) ","version":"v6.1.0","tagName":"h2"},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/faq","content":"","keywords":"","version":"v6.1.0"},{"title":"General​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#general","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"What is Interchain Security (ICS)?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#what-is-interchain-security-ics","content":" ICS is an IBC protocol that enables a provider chain (e.g., the Cosmos Hub) to provide security to multiple consumer chains. This means that consumer chains will leverage the stake locked on the provider chain for block production (i.e., a cross-chain proof-of-stake system). ICS allows anyone to launch a consumer chain using a subset, or even the entire, validator set from the provider chain. Note that validators need to run separate infrastructure for the provider and consumer chains, resulting in different networks that only share (a subset of) the validator set.  ","version":"v6.1.0","tagName":"h3"},{"title":"What is the difference between ICS and Partial Set Security (PSS)?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#what-is-the-difference-between-ics-and-partial-set-security-pss","content":" ICS is a protocol. PSS is a feature of ICS that allows a provider chain to share only a subset of its validator set with a consumer chain. PSS differentiates between TopN and Opt-In consumer chains. For TopN chains, the validator subset is determined by the top N% provider validators by voting power. For Opt-In chains, the validator subset is determined by validators opting in to validate the consumer chains. PSS allows for flexible tradeoffs between security, decentralization, and the budget a consumer chain spends on rewards to validators.  For more details, see the PSS feature.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consumer Chains​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#consumer-chains","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"What are consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#what-are-consumer-chains","content":" Consumer chains are blockchains operated by (a subset of) the validators of the provider chain. The ICS protocol ensures that consumer chains get information about which validators should validate on them. This information consists of the opted in validators and their power on the consumer chains. Note that the validators' power on the consumer chains is a function of their stake locked on the provider chain.  Consumer chains are run on infrastructure (virtual or physical machines) distinct from the provider chain, have their own configurations and operating requirements.  Consumer chains are free to choose how they wish to operate and which modules to include. For example, they can choose to use CosmWasm either in a permissioned or a permissionless way. Also, consumer chains are free to perform software upgrades at any time without impacting the provider chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"How to become a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#how-to-become-a-consumer-chain","content":" To become a consumer chain use this checklist and check the App integration section.  ","version":"v6.1.0","tagName":"h3"},{"title":"What happens to consumers if the provider is down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#what-happens-to-consumers-if-the-provider-is-down","content":" In case the provider chain halts or experiences difficulties, the consumer chains will keep operating - the provider chain and consumer chains represent different networks that only share (a subset of) the validator set. As the validators run separate infrastructure on these networks, the provider chain liveness does not impact the liveness of consumer chains.  Every consumer chain communicates with the provider chain via a CCV channel -- an IBC ordered channel. If any of the packets sent over the CCV channel timeout (see the CCVTimeoutPeriod param), then the channel is closed and, consequently, the consumer chain transitions to a Proof of Authority (PoA) chain. This means that the validator set on the consumer will no longer be updated with information from the provider.  ","version":"v6.1.0","tagName":"h3"},{"title":"What happens to provider if any of the consumers are down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#what-happens-to-provider-if-any-of-the-consumers-are-down","content":" Consumer chains do not impact the livness of the provider chain.The ICS protocol is concerned only with validator set management, and the only communication that the provider requires from the consumer is information about validator activity (essentially keeping the provider informed about slash events).  ","version":"v6.1.0","tagName":"h3"},{"title":"Can consumer chains have their own token?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#can-consumer-chains-have-their-own-token","content":" As any other Cosmos SDK chains, consumer chains can issue their own token and manage inflation parameters. Note that the ICS protocol does not impact the transaction fee system on the consumer chains. This means consumer chains can use any token (including their own token) to pay gas fees. For more details, see the democracy modules.  ","version":"v6.1.0","tagName":"h3"},{"title":"Can consumer chains have their own governance?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#can-consumer-chains-have-their-own-governance","content":" Yes. ICS allows consumer chains to separate governance from block production. Validator operators (with their stake locked on the provider) are responsible for block production, while representatives (aka governators, governors) are responsible for on-chain governance. For more details, see the democracy modules.  ","version":"v6.1.0","tagName":"h3"},{"title":"Can a consumer chain modify its power shaping parameters?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#can-a-consumer-chain-modify-its-power-shaping-parameters","content":" Yes, by issuing a ConsumerModificationProposal.  ","version":"v6.1.0","tagName":"h3"},{"title":"Can a Top N consumer chain become Opt-In or vice versa?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#can-a-top-n-consumer-chain-become-opt-in-or-vice-versa","content":" Yes, by issuing a ConsumerModificationProposal.  ","version":"v6.1.0","tagName":"h3"},{"title":"Validators​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#validators","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"How can validators opt in to validate a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#how-can-validators-opt-in-to-validate-a-consumer-chain","content":" Check the validator guide to Partial Set Security.  An important note is that validator the top N% of the provider chain validator set are automatically opted in on Top N consumer chains.  ","version":"v6.1.0","tagName":"h3"},{"title":"Can validators opt in to an Opt-in chain after the spawn time if nobody else opted in?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#can-validators-opt-in-to-an-opt-in-chain-after-the-spawn-time-if-nobody-else-opted-in","content":" No, the consumer chain will be removed if nobody opted in by the spawn time. At least one validator, regardless of its voting power, must opt in before the spawn time in order for the chain can start.  ","version":"v6.1.0","tagName":"h3"},{"title":"How does a validator know which consumers chains it has to validate?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#how-does-a-validator-know-which-consumers-chains-it-has-to-validate","content":" In order for a validator to keep track of all the chains it has to validate, the validator can use thehas-to-validate query.  ","version":"v6.1.0","tagName":"h3"},{"title":"How many chains can a validator opt in to?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#how-many-chains-can-a-validator-opt-in-to","content":" There is no limit in the number of consumers chains a validator can choose to opt in to.  ","version":"v6.1.0","tagName":"h3"},{"title":"How can validators assign consumer keys?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#how-can-validators-assign-consumer-keys","content":" Check the Key Assignment guide for specific instructions.  Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  Also note that validators can assign consensus keys before a consumer chain is launched (e.g., during the voting period for Top N consumer chains).  ","version":"v6.1.0","tagName":"h3"},{"title":"What are the benefits for validators running consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#what-are-the-benefits-for-validators-running-consumer-chains","content":" The consumer chains sends a portion of its block rewards (e.g., transaction fees and inflation) to the provider chain as defined by the ConsumerRedistributionFraction param. These rewards are sent periodically to the provider (via IBC transfers), where they are distributed ONLY to the opted in validators and their delegators. For more details, see the Reward Distribution feature.  ","version":"v6.1.0","tagName":"h3"},{"title":"Can validators set per consumer chain commission rates?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#can-validators-set-per-consumer-chain-commission-rates","content":" Yes. See the validator guide to Partial Set Security.  ","version":"v6.1.0","tagName":"h3"},{"title":"What are the risks for validators running consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#what-are-the-risks-for-validators-running-consumer-chains","content":" Validators that perform an equivocation or a light-client attack on a consumer chain are slashed on the provider chain. This is done by submitting a proof of the equivocation or the light-client attack to the provider chain.  In addition, consumer chains send IBC packets via the CCV channels informing the provider when opted in validators should be jailed for downtime. It is important to notice that validators are not slashed for downtime on consumer chains. The downtime logic is custom to the consumer chain. For example, Cosmos SDK chains can use the slashing module to configure the downtime window.  For more details, see the slashing feature.  ","version":"v6.1.0","tagName":"h3"},{"title":"Can validators run the provider and consumer chains on the same machine?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#can-validators-run-the-provider-and-consumer-chains-on-the-same-machine","content":" In theory yes. In practice, we recommend validators to run the provider and consumer chains in separate environments for fault containment, i.e., failures of one machine do not impact the entire system.  ","version":"v6.1.0","tagName":"h3"},{"title":"Can validators opt out of validating a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#can-validators-opt-out-of-validating-a-consumer-chain","content":" Validators can always opt out from an Opt-In consumer chain. Validators can only opt out from a TopN chain if they do not belong to the top N% validators.  ","version":"v6.1.0","tagName":"h3"},{"title":"Can all validators opt out of an Opt-in chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#can-all-validators-opt-out-of-an-opt-in-chain","content":" Note that if all validators opt out of an Opt-In consumer chain, then the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"v6.1.0","tagName":"h3"},{"title":"How to connect to the testnets?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#how-to-connect-to-the-testnets","content":" Check out the Joining Interchain Security testnet section.  ","version":"v6.1.0","tagName":"h3"},{"title":"Integrators​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#integrators","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Which relayers are supported?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#which-relayers-are-supported","content":" Currently supported versions:  Hermes v1.8.0+  ","version":"v6.1.0","tagName":"h3"},{"title":"How to check when the next validator update will be sent to the consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.1.0/faq#how-to-check-when-the-next-validator-update-will-be-sent-to-the-consumer-chains","content":" Validator updates are sent to consumer chains every BlocksPerEpoch blocks. Depending on the status of relayers between the Hub and the consumer chains, it might take a while for the validator updates to be processed and applied on the consumer chains.  To query how many blocks are left until the next epoch starts, run the following command:  interchain-security-pd query provider blocks-until-next-epoch  ","version":"v6.1.0","tagName":"h3"},{"title":"Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/features/key-assignment","content":"","keywords":"","version":"v6.1.0"},{"title":"Rules​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.1.0/features/key-assignment#rules","content":" A key can be assigned as soon as the consumer addition proposal is submitted to the provider.Validator A cannot assign consumer key K to consumer chain X if there is already a validator B (B!=A) using K on the provider.Validator A cannot assign consumer key K to consumer chain X if there is already a validator B using K on X.A new validator on the provider cannot use a consensus key K if K is already used by any validator on any consumer chain.  ","version":"v6.1.0","tagName":"h2"},{"title":"Adding a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.1.0/features/key-assignment#adding-a-key","content":" warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  First, create a new node on the consumer chain using the equivalent:  consumerd init &lt;moniker&gt;   Then query your node for the consensus key.  consumerd tendermint show-validator # {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, make an assign-consensus-key transaction on the provider chain in order to inform the provider chain about the consensus key you will be using for a specific consumer chain.  gaiad tx provider assign-consensus-key &lt;consumer-chain-id&gt; '&lt;pubkey&gt;' --from &lt;tx-signer&gt; --home &lt;home_dir&gt; --gas 900000 -b sync -y -o json   consumer-chain-id is the string identifier of the consumer chain, as assigned on the provider chainconsumer-pub-key has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}  Check that the key was assigned correctly by querying the provider:  gaiad query provider validator-consumer-key &lt;consumer-chain-id&gt; cosmosvalcons1e....3xsj3ayzf4uv6   You must use a valcons address. You can obtain it by querying your node on the provider gaiad tendermint show-address  OR  gaiad query provider validator-provider-key &lt;consumer-chain-id&gt; consumervalcons1e....123asdnoaisdao   You must use a valcons address. You can obtain it by querying your node on the consumer consumerd tendermint show-address  OR  gaiad query provider all-pairs-valconsensus-address &lt;consumer-chain-id&gt;   You just need to use the chainId of consumer to query all pairs valconsensus address with consumer-pub-key for each of pair  ","version":"v6.1.0","tagName":"h2"},{"title":"Changing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.1.0/features/key-assignment#changing-a-key","content":" To change your key, simply repeat all of the steps listed above. Take note that your old key will be remembered for at least the unbonding period of the consumer chain so any slashes can be correctly applied  ","version":"v6.1.0","tagName":"h2"},{"title":"Removing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.1.0/features/key-assignment#removing-a-key","content":" To remove a key, simply switch it back to the consensus key you have assigned on the provider chain by following steps in the Adding a key section and using your provider consensus key.  ","version":"v6.1.0","tagName":"h2"},{"title":"Querying proposed consumer chains​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.1.0/features/key-assignment#querying-proposed-consumer-chains","content":" To query the consumer addition proposals that are in the voting period, you can use the following command on the provider:  gaiad query provider list-proposed-consumer-chains   This query is valuable for staying informed about when keys can be assigned to newly proposed consumer chains. ","version":"v6.1.0","tagName":"h2"},{"title":"Consumer Onboarding Checklist","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/consumer-development/onboarding","content":"","keywords":"","version":"v6.1.0"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.1.0/consumer-development/onboarding#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.4.1) reach out to the ICS team if you are facing issues  ","version":"v6.1.0","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.1.0/consumer-development/onboarding#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json without CCV data (before the proposal passes) genesis.json with CCV data (after spawn time passes). Check if CCV data needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) copy of your governance proposal (as JSON) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"v6.1.0","tagName":"h2"},{"title":"3. Submit a Governance Proposal​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.1.0/consumer-development/onboarding#3-submit-a-governance-proposal","content":" Before you submit a ConsumerChainAddition proposal, please consider allowing at least a day between your proposal passing and the chain spawn time. This will allow the validators, other node operators and the community to prepare for the chain launch. If possible, please set your spawn time so people from different parts of the globe can be available in case of emergencies. Ideally, you should set your spawn time to be between 12:00 UTC and 20:00 UTC so most validator operators are available and ready to respond to any issues.  Additionally, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters to be put in the proposal take note to include a link to your onboarding repository describe the purpose and benefits of running your chain determine whether your chain should be an Opt-In chain or a Top N chain (see Partial Set Security) if desired, decide on power-shaping parameters (see Power Shaping)  Example of a consumer chain addition proposal.  // ConsumerAdditionProposal is a governance proposal on the provider chain to spawn a new consumer chain. // If it passes, if the top_N parameter is not equal to 0, the top N% of validators by voting power on the provider chain are expected to validate the consumer chain at spawn time. // Otherwise, only validators that opted in during the proposal period are expected to validate the consumer chain at spawn time. // It is recommended that spawn time occurs after the proposal end time. { // Title of the proposal &quot;title&quot;: &quot;Add consumer chain&quot;, // Description of the proposal // format the text as a .md file and include the file in your onboarding repository &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, // Proposed chain-id of the new consumer chain. // Must be unique from all other consumer chain ids of the executing provider chain. &quot;chain_id&quot;: &quot;newchain-1&quot;, // Initial height of new consumer chain. // For a completely new chain, this will be {0,1}. &quot;initial_height&quot; : { &quot;revision_height&quot;: 0, &quot;revision_number&quot;: 1, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // It is used for off-chain confirmation of genesis.json validity by validators and other parties. &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on chain initialization. // It is used for off-chain confirmation of binary validity by validators and other parties. &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should be smaller than that of the provider. &quot;unbonding_period&quot;: 86400000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 259200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot;, // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. &quot;top_N&quot;: 95, // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis. &quot;validators_power_cap&quot;: 0, // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. &quot;validator_set_cap&quot;: 0, // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate // the consumer chain. &quot;allowlist&quot;: [], // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. &quot;denylist&quot;: [], // Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain. &quot;min_stake&quot;: 0, // Corresponds to whether inactive validators are allowed to validate the consumer chain. &quot;allow_inactive_vals&quot;: false }   ","version":"v6.1.0","tagName":"h2"},{"title":"4. Launch​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.1.0/consumer-development/onboarding#4-launch","content":" The consumer chain starts after at least 66.67% of its voting power comes online. Note that this means 66.67% of the voting power in the consumer validator set, which will be comprised of all validators that either opted in to the chain or are part of the top N% of the provider chain (and are thus automatically opted in). The consumer chain is considered interchain secured once the appropriate CCV channels are established and the first validator set update is propagated from the provider to the consumer   provide a repo with onboarding instructions for validators (it should already be listed in the proposal) genesis.json with ccv data populated (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) have a block explorer in place to track chain activity &amp; health ","version":"v6.1.0","tagName":"h2"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/features/partial-set-security","content":"Partial Set Security Partial Set Security (PSS) is a complete revamp of the Hub's security offering. It allows consumer chains to leverage only a subset of validators from the provider chain, which offers more flexibility than the previous Replicated Security model. By introducing the top_N parameter, each consumer chain can choose the extent of security needed: Top N: Requires the top N% validators from the provider chain to secure the consumer chain. This guarantees that the validators with the most power on the provider will validate the consumer chain, while others can voluntarily opt in. Opt-In: If the top_N parameter is set to zero, no validator is mandated to secure the consumer chain. Instead, any validator from the provider chain can opt in using a dedicated transaction. An advantage of Top N chains is that they are guaranteed to receive at least a certain fraction of the market cap of the provider chain in security. In turn, Top N chains need to be approved by governance, since some validators will be forced to validate on them. Thus, Top N chains should typically expect to need to provide a strong case for why they should be added to the provider chain, and they should make sure they offer enough rewards to incentivize validators and delegators to vote for their proposal. Opt-In chains, on the other hand, are more flexible. Validators are never forced to validate these chains and simply opt in if they want to. Because of this, Opt-In chains can be launch completely permissionlessly by sending a transaction to the provider chain. As a trade-off though, Opt-In chains do not get a fixed amount of security as a relation of the market cap of the provider as top N chains do, so Opt-In chains might want to keep an eye on how many validators have opted in to validate their chain and adjust their reward emissions accordingly to incentivize validators. Note that Top N consumer chains can become Opt-In chains or vice versa via a ConsumerModificationProposal. Partial Set Security is handled only by the provider chain - the consumer chains are simply sent validator sets, and they are not aware that this represents only a subset of the provider chain's validator set.","keywords":"","version":"v6.1.0"},{"title":"Power Shaping","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/features/power-shaping","content":"","keywords":"","version":"v6.1.0"},{"title":"Power Shaping Configuration​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.1.0/features/power-shaping#power-shaping-configuration","content":" Currently, ICS supports the following power shaping parameters.  ","version":"v6.1.0","tagName":"h2"},{"title":"Capping the validator set size​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.1.0/features/power-shaping#capping-the-validator-set-size","content":" The consumer chain can specify a maximum number of validators it wants to have in its validator set. This can be used to limit the number of validators in the set, which can be useful for chains that want to have a smaller validator set for faster blocks or lower overhead. If more validators than the maximum size have opted in on a consumer chain, only the validators with the highest power, up to the specified maximum, will validate the consumer chain.  Note that this parameter only applies to Opt In consumer chains (i.e., with Top N = 0).  ","version":"v6.1.0","tagName":"h3"},{"title":"Capping the validator powers​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.1.0/features/power-shaping#capping-the-validator-powers","content":" The consumer chain can specify a maximum fraction of the total voting power any of its validators should have. This is a security measure that makes it harder for a single large validator to take over a consumer chain: It mitigates the risk of an Opt In chain with only a few validators being dominated by a validator with a large amount of stake. For example, setting this fraction to 33% would mean that no single validator can have more than 33% of the total voting power on the consumer, and thus no single validator would be able to stop the consumer by going offline.  warning This parameter is a soft cap, and the actual power of a validator can exceed this fraction if the validator set is small (e.g. there are only 3 validators and the cap is 20%).  Note that rewards are distributed proportionally to validators with respect to their capped voting power on the consumer, not their total voting power on the provider.  ","version":"v6.1.0","tagName":"h3"},{"title":"Allowlist and denylist​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.1.0/features/power-shaping#allowlist-and-denylist","content":" The consumer chain can specify a list of validators that are allowed or disallowed from participating in the validator set. If an allowlist is set, all validators not on the allowlist cannot validate the consumer chain. If a validator is on both lists, the denylist takes precedence, that is, they cannot validate the consumer chain. By default, both lists are empty -- there are no restrictions on which validators are eligible to opt in.  warning Note that if denylisting is used in a Top N consumer chain, then the chain might not be secured by N% of the total provider's power. For example, consider that the top validator V on the provider chain has 10% of the voting power, and we have a Top 50% consumer chain, then if V is denylisted, the consumer chain would only be secured by at least 40% of the provider's power.  ","version":"v6.1.0","tagName":"h3"},{"title":"Minimum validator stake​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.1.0/features/power-shaping#minimum-validator-stake","content":" The consumer chains can specify a minimum amount of stake that any validator must have on the provider chain to be eligible to opt in. For example, setting this to 1000 would mean only validators with at least 1000 tokens staked on the provider chain can validate the consumer chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"Allow inactive validators​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.1.0/features/power-shaping#allow-inactive-validators","content":" The consumer chains can specify whether validators outside of the provider's active set are eligible to opt in. This can be useful for chains that want to have a larger validator set than the provider chain, or for chains that want to have a more decentralized validator set. Consumer chains that enable this feature should strongly consider setting a minimum validator stake to ensure that only validators with some reputation/stake can validate the chain. By default, this parameter is set to false, i.e., validators outside of the provider's active set are not eligible to opt in.  ","version":"v6.1.0","tagName":"h3"},{"title":"Setting Power Shaping Parameters​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.1.0/features/power-shaping#setting-power-shaping-parameters","content":" All the power shaping parameters can be set by the consumer chain in the ConsumerAdditionProposal (see Onboarding). They operate solely on the provider chain, meaning the consumer chain simply receives the validator set after these rules have been applied and does not have any knowledge about whether they are applied.  When setting power shaping parameters, please consider the following guidelines:  Do not cap the validator set size too low.Notice that this number is the *maximum number of validators that will ever validate the consumer chain. If this number is too low, the chain will be very limited in the amount of stake that secures it. The validator set size cap should only be used if there are strong reasons to prefer fewer validators.Be aware of the interaction between capping the validator powers capping the validator set size.For example, if there are only 3 validators, and the cap is 20%, this will not be possible (since even splitting the power fairly would mean that each validator has 33% of the power, so is above the cap). Also note that the smaller this value is, the more the original voting power gets distorted, which could discourage large validators from deciding to opt in to the chain.Do not have allowlist contain too few validators.If the allowlist is non empty, then only validators on the allowlist can validate the chain. Thus, an allowlist containing too few validators is a security risk, e.g., the validators on the allowlist get jailed on the provider.Do not have denylist contain too many validators.If the denylist is non empty, then the validators on the denylist cannot validate the chain. Thus, a denylist containing too many validators is a security risk, e.g., the validators on the denylist represents a large fraction of the provider's power.  In general, when setting these parameters, consider that the voting power distribution in the future might be very different from the one right now, and that the chain should be secure even if the power distribution changes significantly.  The power shaping parameters of a running consumer chain can be changed through a ConsumerModificationProposal.  The power shaping parameters can be seen by querying the list of consumer chains:  interchain-security-pd query provider list-consumer-chains  ","version":"v6.1.0","tagName":"h2"},{"title":"Reward Distribution","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/features/reward-distribution","content":"","keywords":"","version":"v6.1.0"},{"title":"Whitelisting Reward Denoms​","type":1,"pageTitle":"Reward Distribution","url":"/interchain-security/v6.1.0/features/reward-distribution#whitelisting-reward-denoms","content":" The ICS distribution system works by allowing consumer chains to send rewards to a module address on the provider called the ConsumerRewardsPool. Only whitelisted denoms are transferred from the ConsumerRewardsPool to the FeePoolAddress, to be distributed to validators and their delegators. The whitelisted denoms can be adjusted through governance by sending a ChangeRewardDenomProposal.  To query the list of whitelisted reward denoms on the Cosmos Hub, use the following command:  &gt; gaiad q provider registered-consumer-reward-denoms denoms: - ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 - ibc/6B8A3F5C2AD51CD6171FA41A7E8C35AD594AB69226438DB94450436EA57B3A89 - uatom   tip Use the following command to get a human readable denom from the ibc/* denom trace format: &gt; gaiad query ibc-transfer denom-trace ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 denom_trace: base_denom: untrn path: transfer/channel-569  ","version":"v6.1.0","tagName":"h2"},{"title":"Democracy modules","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/features/democracy-modules","content":"","keywords":"","version":"v6.1.0"},{"title":"Staking​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v6.1.0/features/democracy-modules#staking","content":" The democracy staking module allows the cosmos-sdk x/staking module to be used alongside the interchain security consumer module.  The module uses overrides that allow the full x/staking functionality with one notable difference - the staking module will no longer be used to provide the validator set to the consensus engine.  ","version":"v6.1.0","tagName":"h2"},{"title":"Implications for consumer chains​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v6.1.0/features/democracy-modules#implications-for-consumer-chains","content":" The x/ccv/democracy/staking allows consumer chains to separate governance from block production. The validator set coming from the provider chain does not need to participate in governance - they only provide infrastructure (create blocks and maintain consensus).  Governators (aka. Governors)​  Validators registered with the x/staking module become Governators. Unlike validators, governators are not required to run any chain infrastructure since they are not signing any blocks. However, governators retain a subset of the validator properties:  new governators can be created (via MsgCreateValidator)governators can accept delegationsgovernators can vote on governance proposals (with their self stake and delegations)governators earn block rewards -- the block rewards kept on the consumer (see the ConsumerRedistributionFraction param) are distributed to all governators and their delegators.  With these changes, governators can become community advocates that can specialize in chain governance and they get rewarded for their participation the same way the validators do. Additionally, governators can choose to provide additional infrastructure such as RPC/API access points, archive nodes, indexers and similar software.  Tokenomics​  The consumer chain's token will remain a governance token. The token's parameters (inflation, max supply, burn rate) are completely under the control of the consumer chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v6.1.0/features/democracy-modules#integration","content":" The x/ccv/democracy/staking module provides these x/staking overrides:   // InitGenesis delegates the InitGenesis call to the underlying x/staking module, // however, it returns no validator updates as validators are tracked via the // consumer chain's x/cvv/consumer module and so this module is not responsible for returning the initial validator set. func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run staking InitGenesis return []abci.ValidatorUpdate{} // do not return validator updates } // EndBlock delegates the EndBlock call to the underlying x/staking module. // However, no validator updates are returned as validators are tracked via the // consumer chain's x/cvv/consumer module. func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates return []abci.ValidatorUpdate{} // do not return validator updates }   To integrate the democracy/staking follow this guide:  1. confirm that no modules are returning validator updates​  warning Only the x/ccv/consumer module should be returning validator updates.  If some of your modules are returning validator updates please disable them while maintaining your business logic:  func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) -\treturn am.keeper.InitGenesis(ctx, &amp;genesisState) + _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run InitGenesis but drop the result +\treturn []abci.ValidatorUpdate{} // return empty validator updates } func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { -\treturn am.keeper.BlockValidatorUpdates(ctx) + _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates +\treturn []abci.ValidatorUpdate{} // return empty validator updates }   2. wire the module in app.go​  You do not need to remove the cosmos-sdk StakingKeeper from your wiring.  import ( ... + ccvstaking &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/staking&quot; ) var ( // replace the staking.AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, - sdkstaking.AppModuleBasic{}, + ccvstaking.AppModuleBasic{}, // replace sdkstaking ... ) ) func NewApp(...) { ... // use sdk StakingKeepeer app.StakingKeeper = stakingkeeper.NewKeeper( appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.MintKeeper = mintkeeper.NewKeeper( appCodec, keys[minttypes.StoreKey], app.StakingKeeper, app.AccountKeeper, app.BankKeeper, authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // no changes required for the distribution keeper app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // keep StakingKeeper! authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) + // pre-initialize ConsumerKeeper to satsfy ibckeeper.NewKeeper +\tapp.ConsumerKeeper = consumerkeeper.NewNonZeroKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), +\t) + +\tapp.IBCKeeper = ibckeeper.NewKeeper( + appCodec, + keys[ibchost.StoreKey], + app.GetSubspace(ibchost.ModuleName), + &amp;app.ConsumerKeeper, + app.UpgradeKeeper, + scopedIBCKeeper, +\t) + +\t// Create CCV consumer and modules +\tapp.ConsumerKeeper = consumerkeeper.NewKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), + scopedIBCConsumerKeeper, + app.IBCKeeper.ChannelKeeper, + &amp;app.IBCKeeper.PortKeeper, + app.IBCKeeper.ConnectionKeeper, + app.IBCKeeper.ClientKeeper, + app.SlashingKeeper, + app.BankKeeper, + app.AccountKeeper, + &amp;app.TransferKeeper, + app.IBCKeeper, + authtypes.FeeCollectorName, +\t) + +\t// Setting the standalone staking keeper is only needed for standalone to consumer changeover chains + // New chains using the democracy/staking do not need to set this +\tapp.ConsumerKeeper.SetStandaloneStakingKeeper(app.StakingKeeper) // change the slashing keeper dependency app.SlashingKeeper = slashingkeeper.NewKeeper( appCodec, legacyAmino, keys[slashingtypes.StoreKey], - app.StakingKeeper, + &amp;app.ConsumerKeeper, // ConsumerKeeper implements StakingKeeper interface authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register slashing module StakingHooks to the consumer keeper +\tapp.ConsumerKeeper = *app.ConsumerKeeper.SetHooks(app.SlashingKeeper.Hooks()) +\tconsumerModule := consumer.NewAppModule(app.ConsumerKeeper, app.GetSubspace(consumertypes.ModuleName)) // register the module with module manager // replace the x/staking module app.MM = module.NewManager( ... - sdkstaking.NewAppModule(appCodec, &amp;app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), + ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }   ","version":"v6.1.0","tagName":"h3"},{"title":"Governance​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v6.1.0/features/democracy-modules#governance","content":" The x/ccv/democracy/governance module extends the x/governance module with the functionality to filter proposals. The module uses AnteHandler to limit the types of proposals that can be executed. As a result, consumer chains can limit the types of governance proposals that can be executed on chain to avoid inadvertent changes to the ICS protocol that could affect security properties.  ","version":"v6.1.0","tagName":"h2"},{"title":"Integration​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v6.1.0/features/democracy-modules#integration-1","content":" Add new AnteHandler to your app.   // app/ante/forbidden_proposals.go package ante import ( &quot;fmt&quot; sdk &quot;github.com/cosmos/cosmos-sdk/types&quot; govv1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1&quot; govv1beta1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; ibctransfertypes &quot;github.com/cosmos/ibc-go/v7/modules/apps/transfer/types&quot; &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; &quot;github.com/cosmos/cosmos-sdk/x/params/types/proposal&quot; ) type ForbiddenProposalsDecorator struct { isLegacyProposalWhitelisted func(govv1beta1.Content) bool isModuleWhiteList func(string) bool } func NewForbiddenProposalsDecorator( whiteListFn func(govv1beta1.Content) bool, isModuleWhiteList func(string) bool, ) ForbiddenProposalsDecorator { return ForbiddenProposalsDecorator{ isLegacyProposalWhitelisted: whiteListFn, isModuleWhiteList: isModuleWhiteList, } } func (decorator ForbiddenProposalsDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (newCtx sdk.Context, err error) { currHeight := ctx.BlockHeight() for _, msg := range tx.GetMsgs() { // if the message is MsgSubmitProposal, check if proposal is whitelisted submitProposalMgs, ok := msg.(*govv1.MsgSubmitProposal) if !ok { continue } messages := submitProposalMgs.GetMessages() for _, message := range messages { if sdkMsg, isLegacyProposal := message.GetCachedValue().(*govv1.MsgExecLegacyContent); isLegacyProposal { // legacy gov proposal content content, err := govv1.LegacyContentFromMessage(sdkMsg) if err != nil { return ctx, fmt.Errorf(&quot;tx contains invalid LegacyContent&quot;) } if !decorator.isLegacyProposalWhitelisted(content) { return ctx, fmt.Errorf(&quot;tx contains unsupported proposal message types at height %d&quot;, currHeight) } continue } // not legacy gov proposal content and not whitelisted if !decorator.isModuleWhiteList(message.TypeUrl) { return ctx, fmt.Errorf(&quot;tx contains unsupported proposal message types at height %d&quot;, currHeight) } } } return next(ctx, tx, simulate) } func IsProposalWhitelisted(content v1beta1.Content) bool { switch c := content.(type) { case *proposal.ParameterChangeProposal: return isLegacyParamChangeWhitelisted(c.Changes) default: return false } } func isLegacyParamChangeWhitelisted(paramChanges []proposal.ParamChange) bool { for _, paramChange := range paramChanges { _, found := LegacyWhitelistedParams[legacyParamChangeKey{Subspace: paramChange.Subspace, Key: paramChange.Key}] if !found { return false } } return true } type legacyParamChangeKey struct { Subspace, Key string } // Legacy params can be whitelisted var LegacyWhitelistedParams = map[legacyParamChangeKey]struct{}{ {Subspace: ibctransfertypes.ModuleName, Key: &quot;SendEnabled&quot;}: {}, {Subspace: ibctransfertypes.ModuleName, Key: &quot;ReceiveEnabled&quot;}: {}, } // New proposal types can be whitelisted var WhiteListModule = map[string]struct{}{ &quot;/cosmos.gov.v1.MsgUpdateParams&quot;: {}, &quot;/cosmos.bank.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.staking.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.distribution.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.mint.v1beta1.MsgUpdateParams&quot;: {}, } func IsModuleWhiteList(typeUrl string) bool { _, found := WhiteListModule[typeUrl] return found }   Add the AnteHandler to the list of supported antehandlers:  // app/ante_handler.go package app import ( ... +\tdemocracyante &quot;github.com/cosmos/interchain-security/v4/app/consumer-democracy/ante&quot; +\tconsumerante &quot;github.com/cosmos/interchain-security/v4/app/consumer/ante&quot; +\ticsconsumerkeeper &quot;github.com/cosmos/interchain-security/v4/x/ccv/consumer/keeper&quot; ) type HandlerOptions struct { ante.HandlerOptions IBCKeeper *ibckeeper.Keeper +\tConsumerKeeper ibcconsumerkeeper.Keeper } func NewAnteHandler(options HandlerOptions) (sdk.AnteHandler, error) { .... anteDecorators := []sdk.AnteDecorator{ ... + consumerante.NewMsgFilterDecorator(options.ConsumerKeeper), + consumerante.NewDisabledModulesDecorator(&quot;/cosmos.evidence&quot;, &quot;/cosmos.slashing&quot;), + democracyante.NewForbiddenProposalsDecorator(IsProposalWhitelisted, IsModuleWhiteList), ... } return sdk.ChainAnteDecorators(anteDecorators...), nil }   Wire the module in app.go.  // app/app.go package app import ( ... sdkgov &quot;github.com/cosmos/cosmos-sdk/x/gov&quot; govkeeper &quot;github.com/cosmos/cosmos-sdk/x/gov/keeper&quot; govtypes &quot;github.com/cosmos/cosmos-sdk/x/gov/types&quot; govv1beta1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; +\tccvgov &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/governance&quot; ) var ( // use sdk governance module ModuleBasics = module.NewBasicManager( ... sdkgov.NewAppModuleBasic( []govclient.ProposalHandler{ paramsclient.ProposalHandler, upgradeclient.LegacyProposalHandler, upgradeclient.LegacyCancelProposalHandler, }, ), ) ) func NewApp(...) { // retain sdk gov router and keeper registrations sdkgovRouter := govv1beta1.NewRouter() sdkgovRouter. AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler). AddRoute(paramproposal.RouterKey, params.NewParamChangeProposalHandler(app.ParamsKeeper)). AddRoute(upgradetypes.RouterKey, upgrade.NewSoftwareUpgradeProposalHandler(&amp;app.UpgradeKeeper)) govConfig := govtypes.DefaultConfig() app.GovKeeper = *govkeeper.NewKeeper( appCodec, keys[govtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, app.MsgServiceRouter(), govConfig, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.GovKeeper.SetLegacyRouter(sdkgovRouter) // register the module with module manager // replace the x/gov module app.MM = module.NewManager( - sdkgov.NewAppModule(appCodec, app.GovKeeper, app.AccountKeeper, app.BankKeeper, IsProposalWhitelisted, app.GetSubspace(govtypes.ModuleName), IsModuleWhiteList), + ccvgov.NewAppModule(appCodec, app.GovKeeper, app.AccountKeeper, app.BankKeeper, IsProposalWhitelisted, app.GetSubspace(govtypes.ModuleName), IsModuleWhiteList), ... ) }   ","version":"v6.1.0","tagName":"h3"},{"title":"Distribution​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v6.1.0/features/democracy-modules#distribution","content":" The democracy/distribution module allows the consumer chain to send rewards to the provider chain while retaining the logic of the x/distribution module for internal reward distribution to governators and their delegators.  ","version":"v6.1.0","tagName":"h2"},{"title":"How it works​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v6.1.0/features/democracy-modules#how-it-works","content":" First, a percentage of the block rewards is sent to the provider chain, where is distributed only to opted-in validators and their delegators. Second, the remaining rewards get distributed to the consumer chain's governators and their delegators. The percentage that is sent to the provider chain corresponds to 1 - ConsumerRedistributionFraction. For example, ConsumerRedistributionFraction = &quot;0.75&quot; means that the consumer chain retains 75% of the rewards, while 25% gets sent to the provider chain  ","version":"v6.1.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"Democracy modules","url":"/interchain-security/v6.1.0/features/democracy-modules#integration-2","content":" Change the wiring in app.go  import ( ... distrkeeper &quot;github.com/cosmos/cosmos-sdk/x/distribution/keeper&quot; distrtypes &quot;github.com/cosmos/cosmos-sdk/x/distribution/types&quot; sdkdistr &quot;github.com/cosmos/cosmos-sdk/x/distribution&quot; + ccvdistr &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/distribution&quot; ) var ( // replace sdk distribution AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, ccvstaking.AppModuleBasic{}, // make sure you first swap the staking keeper mint.AppModuleBasic{}, - sdkdistr.AppModuleBasic{}, + ccvdistr.AppModuleBasic{}, ) ) func NewApp(...) { .... app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // connect to sdk StakingKeeper consumertypes.ConsumerRedistributeName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register with the module manager app.MM = module.NewManager( ... - sdkdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), + ccvdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }  ","version":"v6.1.0","tagName":"h3"},{"title":"ICS Provider Proposals","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/features/proposals","content":"","keywords":"","version":"v6.1.0"},{"title":"ConsumerAdditionProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v6.1.0/features/proposals#consumeradditionproposal","content":" tip If you are preparing a ConsumerAdditionProposal you can find more information in the consumer onboarding checklist.  ConsumerAdditionProposal is used to add new consumer chains. When proposals of this type pass governance and the spawn_time specified in the proposal is reached, all opted in provider validators are expected to run infrastructure (validator nodes) for the proposed consumer chain. Note that for TopN consumer chains, the validators in the top N% of the voting power are automatically opted in at spawn time.  Minimal example:  { // Time on the provider chain at which the consumer chain genesis is finalized and all validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, &quot;title&quot;: &quot;Add consumer chain&quot;, &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, &quot;chain_id&quot;: &quot;newchain-1&quot;, &quot;initial_height&quot; : { &quot;revision_height&quot;: 0, &quot;revision_number&quot;: 1, }, // Unbonding period for the consumer chain. // It should be smaller than that of the provider. &quot;unbonding_period&quot;: 86400000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 259200000000000, &quot;transfer_timeout_period&quot;: 1800000000000, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;blocks_per_distribution_transmission&quot;: 1000, &quot;historical_entries&quot;: 10000, &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot;, &quot;top_N&quot;: 95, &quot;validators_power_cap&quot;: 0, &quot;validator_set_cap&quot;: 0, &quot;allowlist&quot;: [], &quot;denylist&quot;: [], &quot;min_stake&quot;: 0, &quot;allow_inactive_vals&quot;: false }   More examples can be found in the Interchain Security testnet repository here and here.  ","version":"v6.1.0","tagName":"h2"},{"title":"ConsumerRemovalProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v6.1.0/features/proposals#consumerremovalproposal","content":" ConsumerRemovalProposal is used to remove an existing consumer chain. When proposals of this type pass governance, the consumer chain in question will be gracefully removed from Interchain Security and validators will no longer be required to run infrastructure for the specified chain.  Minimal example:  { // the time on the provider chain at which all validators are responsible to stop their consumer chain validator node &quot;stop_time&quot;: &quot;2023-03-07T12:40:00.000000Z&quot;, // the chain-id of the consumer chain to be stopped &quot;chain_id&quot;: &quot;consumerchain-1&quot;, &quot;title&quot;: &quot;This was a great chain&quot;, &quot;description&quot;: &quot;Here is a .md formatted string specifying removal details&quot; }   After the consumer chain removal, the consumer chain is no longer secured by the provider chain. The consumer chain might continue to produce blocks using the last validator set received from the provider. However, its validator set can no longer be slashed for any infractions committed on the consumer. Additional steps are required to completely offboard a consumer chain, such as re-introducing the staking module and removing the provider's validators from the active set.  ","version":"v6.1.0","tagName":"h2"},{"title":"ConsumerModificationProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v6.1.0/features/proposals#consumermodificationproposal","content":" ConsumerModificationProposal is used to change the power shaping parameters of a running consumer chain, as well as to change a Top N running consumer chain to an Opt-In chain and vice versa. When proposals of this type pass governance, the consumer chain in question would change all its parameters to the ones passed in the ConsumerModificationProposal.  For example, given chain-1 is a TopN consumer chain with, if the following ConsumerModificationProposal passes, then chain-1 would become an Opt-In chain with a 40% validators power cap, a maximum number of 30 validators, and one denylisted validator.  { &quot;title&quot;: &quot;Modify consumer chain&quot;, &quot;description&quot;: &quot;.md description of your chain and all other relevant information&quot;, &quot;chain_id&quot;: &quot;chain-1&quot;, &quot;top_N&quot;: 0, &quot;validators_power_cap&quot;: 40, &quot;validator_set_cap&quot;: 30, &quot;allowlist&quot;: [], &quot;denylist&quot;: [&quot;cosmosvalcons1qmq08eruchr5sf5s3rwz7djpr5a25f7xw4mceq&quot;] }   warning If top_N, validators_power_cap, or some other argument is not included in the proposal, then it is considered that the default value is set for this argument. For example, if a Top 50% chain wants to only modify validators_power_capfrom 35 to 40, then the ConsumerModificationProposal would still need to include that top_N is 50. Otherwisetop_N would be set to its default value of 0, and the chain would become an Opt-In chain. To be safe, always include top_N and all the power shaping parameters in your ConsumerModificationProposal.  ","version":"v6.1.0","tagName":"h2"},{"title":"ChangeRewardDenomProposal​","type":1,"pageTitle":"ICS Provider Proposals","url":"/interchain-security/v6.1.0/features/proposals#changerewarddenomproposal","content":" ChangeRewardDenomProposal is used to update the set of denoms accepted by the provider as rewards. Note that a ChangeRewardDenomProposal will only be accepted on the provider chain if at least one of the denomsToAdd or denomsToRemove fields is populated with at least one denom. Also, a denom cannot be repeated in both sets.  Minimal example:  { &quot;title&quot;: &quot;Add uatom as a reward denom&quot;, &quot;description&quot;: &quot;Here is more information about the proposal&quot;, &quot;denomsToAdd&quot;: [&quot;uatom&quot;], &quot;denomsToRemove&quot;: [] }   Besides native provider denoms (e.g., uatom for the Cosmos Hub), please use the ibc/* denom trace format. For example, for untrn transferred over the path transfer/channel-569, the denom trace can be queried using the following command:  &gt; gaiad query ibc-transfer denom-hash transfer/channel-569/untrn hash: 0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5   Then use the resulting hash in the ChangeRewardDenomProposal, e.g.,  { &quot;title&quot;: &quot;Add untrn as a reward denom&quot;, &quot;description&quot;: &quot;Here is more information about the proposal&quot;, &quot;denomsToAdd&quot;: [&quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;], &quot;denomsToRemove&quot;: [] }  ","version":"v6.1.0","tagName":"h2"},{"title":"Inactive Validators Integration Guide","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/integrators/integrating_inactive_validators","content":"Inactive Validators Integration Guide With the inactive validators feature of Interchain Security, validators outside of the active set on the provider chain can validate on consumer chains that allow this. Technically, this is achieved by increasing the MaxValidators parameter in the staking module, to let additional validators be part of the set of bonded validators. However, to keep the set of validators participating in consensus on the Cosmos Hub the same, we introduce the MaxProviderConsensusValidators parameter in the provider module, which will restrict the number of validators that actively validate on the provider chain. To clarify the terminology: bonded validators are all validators that are bonded on the Cosmos Hub, and active validators are all validators that actively participate in consensus on the Cosmos Hub. Before the introduction of the feature, these two terms were equivalent: every bonded validator was active, and every active validator was bonded. After the introduction of this feature, it still holds that every active validator is bonded, but not every bonded validator is active. Importantly, only active validators receive inflation rewards from ATOM; only active validators may vote on behalf of their delegators in governance, and only active validators can get slashed for downtime (because only those validators participate in consensus and produce blocks). Apart from these differences, bonded but inactive validators are just like active validators - they can receive delegations, and they can validate on consumer chains (and receive rewards for this) just like active validators. The following queries will change after this upgrade: /cosmos/staking/v1beta1/pool / query staking pool The bonded_tokens will include the stake of all bonded validators. As the number of bonded validators will be increased as part of the upgrade, the number of bonded_tokens is expected to have a sudden increase after the upgrade is applied. All queries in the staking module that return a Validator All bonded validators will show with Status=Bonded. To identify active validators, query the validator set from Tendermint (https://docs.cometbft.com/v0.37/rpc/#/Info/validators or query comet-validator-set [height]), which will return the set of all active validators.","keywords":"","version":"v6.1.0"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/introduction/overview","content":"","keywords":"","version":"v6.1.0"},{"title":"Why Interchain Security?​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/introduction/overview#why-interchain-security","content":" Tailored security.Consumer chains can choose the right level of security based on their needs: Chains can choose to inherit the whole validator set from the provider, or they can launch as an opt-in chain with a subset of the provider validators. Additionally, consumer chains have the power to shape the validator set to their specific requirements by setting allow &amp; deny lists, capping its size, etc. This allows for a wide range of security tradeoffs. For example, it enables emerging projects to deploy on consumer chains that don’t need high level of security.Separation of governance from block production.Consumer chains can separate their governance mechanism from block production. Block production is handled by provider validators, which means it is an extension of the proof-of-state (PoS) mechanism on the provider chain. Governance on the consumer chains can rely on the same PoS mechanism (using the same stake locked on the provider), but it doesn't have to. For example, consumer chains can have a governance system based on proof-of-authority (PoA) or on PoS using the consumer token (which would make the consumer token a governance token). This also allows the governance to be more decentralized without affecting consensus (i.e., increasing the number of validators usually leads to slower block production).Distribution of block rewards.Consumer chains can choose how to distribute the block rewards (i.e., inflation and fees), what percentage to send to the provider as payment for block production, and what percentage to keep on-chain. The rewards kept on-chain can then be distributed to the community DAO (the consumer's governance) or can be used in the protocol in other ways.No validator search.Consumer chains do not have their own validator sets, and so do not need to find validators one by one. Validators from the provider chain validate on the consumer chain with their stake on the provider chain, earning additional rewards. For the consumer chain, this comes with the benefit of exposing their chain to the wider audience of the provider chain.Instant sovereignty.Consumers can run arbitrary app logic similar to standalone chains. At any time in the future, a consumer chain can elect to become a completely standalone chain, with its own validator set.Block-space sharding.Consumer chains are Cosmos appchains, which means that transactions on these chains do not compete with any other applications. As a result, there will be no unexpected congestion, and performance will generally be much better than on a shared smart contract platform such as Ethereum.  ","version":"v6.1.0","tagName":"h2"},{"title":"Core protocol​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/introduction/overview#core-protocol","content":" Validator updates. Once an IBC connection and channel are established between a provider and consumer chain, the provider will continually send validator set updates to the consumer over IBC. Note the provider only sends updates for opted in validators. The consumer uses these validator set updates to update its own validator set in the consensus engine (e.g., CometBFT).  Slashing and jailing.If the opted-in validators misbehave on the consumer chains, then they will be punished on the provider chain. ICS currently differentiates between two types of infractions -- double signing and downtime. Double signing on consumer chains results in the misbehaving validators having their provider stake slashed and being permanently jailed on the provider, while downtime on consumer chains results in the misbehaving validators being temporarily jailed. Note that jailing entails removing the validator from the provider active validator set and, consequently, from any of the consumer validato sets. This entails the validator will miss out on both staking and ICS rewards.  Tokenomics and rewards.Consumer chains are free to create their own native token which can be used for fees, and can be created on the consumer chain in the form of inflationary rewards. These rewards can be used to incentivize user behavior, for example, LPing or staking. A percentage of these fees and rewards will be sent to provider chain to be distributed among the opted in validators and their delegators. The percentage is completely customizable by the developers and subject to governance. ","version":"v6.1.0","tagName":"h2"},{"title":"Terminology","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/introduction/terminology","content":"","keywords":"","version":"v6.1.0"},{"title":"Shared Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.1.0/introduction/terminology#shared-security","content":" Shared Security is a family of technologies that include optimistic rollups, zk-rollups, sharding and Interchain Security. Basically, any protocol or technology that can allow one blockchain to lend/share its proof-of-stake security with another blockchain or off-chain process.  ","version":"v6.1.0","tagName":"h2"},{"title":"Interchain Security (ICS)​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.1.0/introduction/terminology#interchain-security-ics","content":" Interchain Security is the Cosmos-specific category of Shared Security that uses IBC (Inter-Blockchain Communication).  ","version":"v6.1.0","tagName":"h2"},{"title":"Replicated Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.1.0/introduction/terminology#replicated-security","content":" A particular protocol/implementation of Interchain Security that fully replicates the security and decentralization of a validator set across multiple blockchains. Replicated security has also been referred to as &quot;Interchain Security V1&quot;, a legacy term for the same protocol. That is, a &quot;provider chain&quot; such as the Cosmos Hub can share its exact validator set with multiple consumer chains by communicating changes in its validator set over IBC. Note that since the introduction of Partial Set Security, a TopN consumer chain with N 100% fully replicates the security and decentralization of the provider chain.  ","version":"v6.1.0","tagName":"h2"},{"title":"Partial Set Security (PSS)​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.1.0/introduction/terminology#partial-set-security-pss","content":" A major feature of Interchain Security (also referred to as &quot;Interchain Security V2&quot;) that allows a provider chain to share only a subset of its validator set with a consumer chain. This subset can be determined by the top N% validators by voting power, or by validators opting in to validate the consumer chain. PSS allows for more flexible security tradeoffs than Replicated Security.  ","version":"v6.1.0","tagName":"h2"},{"title":"Mesh Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.1.0/introduction/terminology#mesh-security","content":" A protocol built on IBC that allows delegators on a Cosmos chain to re-delegate their stake to validators in another chain's own validator set, using the original chain's token (which remains bonded on the original chain). For a deeper exploration of Mesh Security, see Replicated vs. Mesh Security on the Informal Blog.  ","version":"v6.1.0","tagName":"h2"},{"title":"Consumer Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.1.0/introduction/terminology#consumer-chain","content":" Chain that is secured by the validator set of the provider, instead of its own. Interchain Security allows a subset of the provider chain's validator set to validate blocks on the consumer chain.  ","version":"v6.1.0","tagName":"h2"},{"title":"Standalone Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.1.0/introduction/terminology#standalone-chain","content":" Chain that is secured by its own validator set. This chain does not participate in Interchain Security.  ","version":"v6.1.0","tagName":"h2"},{"title":"Changeover Procedure​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.1.0/introduction/terminology#changeover-procedure","content":" Chains that were not initially launched as consumers of Interchain Security can still participate in the protocol and leverage the economic security of the provider chain. The process where a standalone chain transitions to being a replicated consumer chain is called the changeover procedure and is part of the ICS protocol. After the changeover, the new consumer chain will retain all existing state, including the IBC clients, connections and channels already established by the chain. ","version":"v6.1.0","tagName":"h2"},{"title":"Interchain Security Parameters","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/introduction/params","content":"","keywords":"","version":"v6.1.0"},{"title":"Time-Based Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#time-based-parameters","content":" ICS relies on the following time-based parameters.  ","version":"v6.1.0","tagName":"h2"},{"title":"ProviderUnbondingPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#providerunbondingperiod","content":" ProviderUnbondingPeriod is the unbonding period on the provider chain as configured during chain genesis. This parameter can later be changed via governance.  ","version":"v6.1.0","tagName":"h3"},{"title":"ConsumerUnbondingPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#consumerunbondingperiod","content":" ConsumerUnbondingPeriod is the unbonding period on the consumer chain.  info ConsumerUnbondingPeriod is set via the ConsumerAdditionProposal governance proposal to add a new consumer chain. It is recommended that every consumer chain set and unbonding period shorter than ProviderUnbondingPeriod Example: ConsumerUnbondingPeriod = ProviderUnbondingPeriod - one day   Unbonding operations (such as undelegations) are completed on the provider only after the unbonding period elapses on every consumer.  ","version":"v6.1.0","tagName":"h3"},{"title":"TrustingPeriodFraction​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#trustingperiodfraction","content":" TrustingPeriodFraction is used to calculate the TrustingPeriod of created IBC clients on both provider and consumer chains.  Setting TrustingPeriodFraction to 0.5 would result in the following:  TrustingPeriodFraction = 0.5 ProviderClientOnConsumerTrustingPeriod = ProviderUnbondingPeriod * 0.5 ConsumerClientOnProviderTrustingPeriod = ConsumerUnbondingPeriod * 0.5   Note that a light clients must be updated within the TrustingPeriod in order to avoid being frozen.  For more details, see the IBC specification of Tendermint clients.  ","version":"v6.1.0","tagName":"h3"},{"title":"CCVTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#ccvtimeoutperiod","content":" CCVTimeoutPeriod is the period used to compute the timeout timestamp when sending IBC packets.  For more details, see the IBC specification of Channel &amp; Packet Semantics.  warning If a sent packet is not relayed within this period, then the packet times out. The CCV channel used by the interchain security protocol is closed, and the corresponding consumer is removed.  CCVTimeoutPeriod may have different values on the provider and consumer chains.  CCVTimeoutPeriod on the provider must be larger than ConsumerUnbondingPeriodCCVTimeoutPeriod on the consumer is initial set via the ConsumerAdditionProposal  ","version":"v6.1.0","tagName":"h3"},{"title":"BlocksPerDistributionTransmission​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#blocksperdistributiontransmission","content":" BlocksPerDistributionTransmission is the number of blocks between rewards transfers from the consumer to the provider.  ","version":"v6.1.0","tagName":"h3"},{"title":"TransferPeriodTimeout​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#transferperiodtimeout","content":" TransferPeriodTimeout is the period used to compute the timeout timestamp when sending IBC transfer packets from a consumer to the provider.  If this timeout expires, then the transfer is attempted again after BlocksPerDistributionTransmission blocks.  TransferPeriodTimeout on the consumer is initial set via the ConsumerAdditionProposal gov proposal to add the consumerTransferPeriodTimeout should be smaller than BlocksPerDistributionTransmission x avg_block_time  ","version":"v6.1.0","tagName":"h3"},{"title":"Reward Distribution Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#reward-distribution-parameters","content":" tip The following chain parameters dictate consumer chain distribution amount and frequency. They are set at consumer genesis and BlocksPerDistributionTransmission, ConsumerRedistributionFractionTransferTimeoutPeriod must be provided in every ConsumerChainAddition proposal.  ","version":"v6.1.0","tagName":"h2"},{"title":"ConsumerRedistributionFraction​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#consumerredistributionfraction","content":" ConsumerRedistributionFraction is the fraction of tokens allocated to the consumer redistribution address during distribution events. The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%.  tip Example: With ConsumerRedistributionFraction set to &quot;0.75&quot; the consumer chain would send 75% of its block rewards and accumulated fees to the consumer redistribution address, and the remaining 25% to the provider chain every BlocksPerDistributionTransmission blocks.  ","version":"v6.1.0","tagName":"h3"},{"title":"BlocksPerDistributionTransmission​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#blocksperdistributiontransmission-1","content":" BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"TransferTimeoutPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#transfertimeoutperiod","content":" TransferTimeoutPeriod is the timeout period for consumer chain reward distribution IBC packets.  ","version":"v6.1.0","tagName":"h3"},{"title":"DistributionTransmissionChannel​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#distributiontransmissionchannel","content":" DistributionTransmissionChannel is the provider chain IBC channel used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  ","version":"v6.1.0","tagName":"h3"},{"title":"ProviderFeePoolAddrStr​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#providerfeepooladdrstr","content":" ProviderFeePoolAddrStr is the provider chain fee pool address used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  ","version":"v6.1.0","tagName":"h3"},{"title":"Slash Throttle Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#slash-throttle-parameters","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"SlashMeterReplenishPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#slashmeterreplenishperiod","content":" SlashMeterReplenishPeriod exists on the provider such that once the slash meter becomes not-full, the slash meter is replenished after this period has elapsed.  The meter is replenished to an amount equal to the slash meter allowance for that block, or SlashMeterReplenishFraction * CurrentTotalVotingPower.  ","version":"v6.1.0","tagName":"h3"},{"title":"SlashMeterReplenishFraction​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#slashmeterreplenishfraction","content":" SlashMeterReplenishFraction exists on the provider as the portion (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs.  This param also serves as a maximum fraction of total voting power that the slash meter can hold. The param is set/persisted as a string, and converted to a sdk.Dec when used.  ","version":"v6.1.0","tagName":"h3"},{"title":"MaxThrottledPackets​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#maxthrottledpackets","content":" MaxThrottledPackets exists on the provider as the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value.  This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness.  info MaxThrottledPackets was deprecated in ICS versions &gt;= v3.2.0 due to the implementation of ADR-008.  ","version":"v6.1.0","tagName":"h3"},{"title":"RetryDelayPeriod​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#retrydelayperiod","content":" RetryDelayPeriod exists on the consumer for ICS versions &gt;= v3.2.0 (introduced by the implementation of ADR-008) and is the period at which the consumer retries to send a SlashPacket that was rejected by the provider.  ","version":"v6.1.0","tagName":"h3"},{"title":"Epoch Parameters​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#epoch-parameters","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"BlocksPerEpoch​","type":1,"pageTitle":"Interchain Security Parameters","url":"/interchain-security/v6.1.0/introduction/params#blocksperepoch","content":" BlocksPerEpoch exists on the provider for ICS versions &gt;= 3.3.0 (introduced by the implementation of ADR-014) and corresponds to the number of blocks that constitute an epoch. This param is set to 600 by default. Assuming we need 6 seconds to commit a block, the duration of an epoch corresponds to 1 hour. This means that a VSCPacket would be sent to a consumer chain once at the end of every epoch, so once every 600 blocks. This parameter can be adjusted via a governance proposal, however careful consideration is needed so that BlocksPerEpoch is not too large. A large BlocksPerEpoch could lead to a delay of VSCPackets and hence potentially lead to unbonding pausing. For setting BlocksPerEpoch, we also need to consider potential slow chain upgrades that could delay the sending of aVSCPacket, as well as potential increases in the time it takes to commit a block (e.g., from 6 seconds to 30 seconds). ","version":"v6.1.0","tagName":"h3"},{"title":"Consumer Initiated Slashing","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/features/slashing","content":"","keywords":"","version":"v6.1.0"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.1.0/features/slashing#downtime-infractions","content":" Downtime infractions are reported by consumer chains and are acted upon on the provider as soon as they are received. Instead of slashing, the provider will only jail offending validator for the duration of time established by the provider chain parameters. Note that validators are only jailed for downtime on consumer chains that they opted in to validate on, or in the case of Top N chains, where they are automatically opted in by being in the Top N% of the validator set on the provider.  For preventing malicious consumer chains from harming the provider, slash throttling (also known as jail throttling) ensures that only a fraction of the provider validator set can be jailed at any given time.  ","version":"v6.1.0","tagName":"h2"},{"title":"Equivocation Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.1.0/features/slashing#equivocation-infractions","content":" Equivocation infractions are reported by external agents (e.g., relayers) that can submit to the provider evidence of light client or double signing attacks observed on a consumer chain. The evidence is submitted by sending MsgSubmitConsumerMisbehaviour or MsgSubmitConsumerDoubleVoting transactions to the provider. When valid evidence is received, the malicious validators are slashed, jailed, and tombstoned on the provider. This is enabled through the cryptographic verification of equivocation feature. For more details, see ADR-005 and ADR-013.  ","version":"v6.1.0","tagName":"h2"},{"title":"Report equivocation infractions through CLI​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.1.0/features/slashing#report-equivocation-infractions-through-cli","content":" The ICS provider module offers two commands for submitting evidence of misbehavior originating from a consumer chain. Below are two examples illustrating the process on Cosmos Hub.  Use the following command to submit evidence of double signing attacks:  gaiad tx provider submit-consumer-double-voting [path/to/evidence.json] [path/to/infraction_header.json] --from node0 --home ../node0 --chain-id $CID   Example of evidence.json { &quot;vote_a&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;tBBWTqjECl31S/clZGoxLdDqs93kTvy3qhpPqET/laY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;ai2qCLgVZAFph4FJ4Cqw5QW1GZKR4zjOv0bI/Um5AIc=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.565207Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;signature&quot;: &quot;y9yILm9hmv45BZwAaaq9mS1FpH7QeAIJ5Jkcc3U2/k5uks9cuqr4NTIwaIrqMSMKwxVyqiR56xmCT59a6AngAA==&quot; }, &quot;vote_b&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;3P06pszgPatuIdLTP5fDWiase4SYHIq9YXGSbRk9/50=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;S+SbOMxFRzfeNNpX9/jyFMz94VwBKk7Dpx6ZyvSYyNU=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.599273Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;validator_index&quot;: 0, &quot;signature&quot;: &quot;DGFcn4Um1t2kXW60+JhMk5cj7ZFdE5goKVOGiZkLwnNv43+6aGmOWjoq0SHYVzM4MwSwOwbhgZNbkWX+EHGUBw==&quot; }, &quot;total_voting_power&quot;: 300, &quot;validator_power&quot;: 100, &quot;timestamp&quot;: &quot;2023-11-20T12:57:51.267308Z&quot; }   Example of infraction_header.json { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: 11, &quot;app&quot;: 2 }, &quot;chain_id&quot;: &quot;consumer&quot;, &quot;height&quot;: 22, &quot;time&quot;: &quot;2023-11-20T12:57:40.479686Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;L63hyLJ+y9+fpb7WYKdmmBhPHwbfEGQEuKmvGzyBPiY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 18, &quot;hash&quot;: &quot;euzRQjN7MjGtM6skXM4B8wOgAldWGfZSJRA9JRlO42s=&quot; } }, &quot;last_commit_hash&quot;: &quot;qdDJwVziW3pPqmf8QDGZG+5HVd3OF7fCVh2Z8KQqNVU=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;next_validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;last_results_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: 22, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;PKrS32IEZoFY2q2S3iQ68HQL751ieBhf5Eu/Y5Z/QPg=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;8UuA7Oqw5AH/KOacpmHVSMOIDe4l2eC8VmdH2mzcpiM=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076538Z&quot;, &quot;signature&quot;: &quot;bSOH4+Vg2I37zeJphOguGOD0GK3JzM1ghSgJd0UlW/DHn1u9Hvv4EekHuCu6qwRLZcuS/ZxNlmr9qYNfxX3bDA==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:07:00Z&quot;, &quot;signature&quot;: &quot;7bXSDtlOwGK/gLEsFpTWOzm2TFoaARrWQUpbgWEwKtLlUs7iE06TOvJ3yPPfTfqqN/qYnvxxgjl0M0EhUWu5Bg==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076519Z&quot;, &quot;signature&quot;: &quot;Pb6G4bCg4wafmV89WNnzXxbSCknZUHnSQfSCE5QMFxPtSUIN4A7SK5m7yltqMJF5zkyenlFiEI4J3OZ4KCjCAw==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.057451Z&quot;, &quot;signature&quot;: &quot;j3EasIHNYA6MxW/PiWyruzHsjVsBV9t11W6Qx800WMm/+P+CkfR+UZAp7MPTvKZEZFuh3GUsBtyfb/vA+jJWCw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 }, { &quot;address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;UgN2JsjPy2WLh7dzJRBkUQtdgNoT4/uGj7kbIVqqHT8=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;5svW8261x+cZosp2xIhqzgt2tyuawrSDyHlpbgS3BC4=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } }, &quot;trusted_height&quot;: { &quot;revision_height&quot;: 18 }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 }, { &quot;address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;FCmIw7hSuiAoWk/2f4LuGQ+3zx5101xiqU8DoC5wGkg=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;2DrZF0roNnnvEy4NS2aY811ncKg=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;MI9c6sphsWlx0RAHCYOjMRXMFkTUaEYwOiOKG/0tsMs=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;73aN0uOc5b/Zfq2Xcjl0kH2r+tw=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;gWNcDup4mdnsuqET4QeFRzVb+FnSP4Vz3iNMj5wvWXk=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } } }   Use the following command to submit evidence of light client attacks:  gaiad tx provider submit-consumer-misbehaviour [path/to/misbehaviour.json] --from node0 --home ../node0 --chain-id $CID   Example of misbehaviour.json { &quot;client_id&quot;: &quot;07-tendermint-0&quot;, &quot;header_1&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;W2xVqzPw03ZQ1kAMpcpht9WohwMzsGnyKKNjPYKDF6U=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;PGTquCtnTNFFY5HfEFz9f9pA7PYqjtQfBwHq6cxF/Ux8OI6nVqyadD9a84Xm7fSm6mqdW+T6YVfqIKmIoRjJDQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;0e39yoBorwORAH/K9qJ7D1N1Yr7CutMiQJ+oiIK39eMhuoK3UWzQyMGRLzDOIDupf8yD99mvGVVAlNIODlV3Dg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;lhc2tkwydag9D1iLQhdDCE8GgrHP94M1LbHFYMoL9tExaEq6RiFW/k71TQH5x96XQ9XYOznMIHKC2BDh4GlnAQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;8xeSBf0nSFs/X/rQ9CZLzwkJJhQBLA2jKdPGP3MlULxm992XxrOsIYq47u1daxvSsn6ql5OVYjzBNU0qbPpvCA==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } }, &quot;header_2&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;IZM8NKS+8FHB7CBmgB8Nz7BRVVXiiyqMQDvHFUvgzxo=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;pLIEZ4WSAtnMsgryujheHSq4+YG3RqTfMn2ZxgEymr0wyi+BNlQAKRtRfesm0vfYxvjzc/jhGqtUqHtSIaCwCQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;XG7iTe/spWyTUkT7XDzfLMpYqrdyqizE4/X4wl/W+1eaQp0WsCHYnvPU3x9NAnYfZzaKdonZiDWs7wacbZTcDg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;TqegK7ORuICSy++wVdPHt8fL2WfPlYsMPv1XW79wUdcjnQkezOM50OSqYaP4ua5frIZsn+sWteDrlqFTdkl3BA==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;dhvp3XlIaCxx5MFDs0TCkAPHSm0PS2EtJzYAx2c/7MWdLwUJFZrAUTeimQE2c9i9ro91cjZn/vI0/oFRXab6Aw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } } }   ","version":"v6.1.0","tagName":"h3"},{"title":"Report equivocation infractions with Hermes​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.1.0/features/slashing#report-equivocation-infractions-with-hermes","content":" Ensure you have a well-configured Hermes v1.7.3+ relayer effectively relaying packets between a consumer chain and a provider chain. The following command demonstrates how to run a Hermes instance in evidence mode to detect misbehaviors on a consumer chain and automatically submit the evidence to the provider chain.  hermes evidence --chain &lt;CONSUMER-CHAIN-ID&gt;   Note that hermes evidence takes a --check-past-blocks option giving the possibility to look for older evidence (default is 100). ","version":"v6.1.0","tagName":"h3"},{"title":"Joining Neutron","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/validators/joining-neutron","content":"","keywords":"","version":"v6.1.0"},{"title":"Resources​","type":1,"pageTitle":"Joining Neutron","url":"/interchain-security/v6.1.0/validators/joining-neutron#resources","content":" Neutron docs ","version":"v6.1.0","tagName":"h2"},{"title":"Validator Instructions for Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/validators/changeover-procedure","content":"","keywords":"","version":"v6.1.0"},{"title":"Timeline​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#timeline","content":" Upgrading standalone chains can be best visualised using a timeline, such as the one available Excalidraw graphic by Stride.  There is some flexibility with regards to how the changeover procedure is executed, so please make sure to follow the guides provided by the team doing the changeover.    ","version":"v6.1.0","tagName":"h2"},{"title":"1. ConsumerAdditionProposal on provider chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#1-consumeradditionproposal-on-provider-chain","content":" This step will add the standalone chain to the list of consumer chains secured by the provider. This step dictates the spawn_time. After spawn_time the CCV state (initial validator set of the provider) will be available to the consumer.  To obtain it from the provider use:  gaiad q provider consumer-genesis stride-1 -o json &gt; ccv-state.json jq -s '.[0].app_state.ccvconsumer = .[1] | .[0]' genesis.json ccv-state.json &gt; ccv.json   Transformation of the exported consumer genesis state to the target version of the consumer might be needed in case the provider and consumer formats are incompatible. Refer to the compatibility notes here to check if data transformation is needed for your case. Instructions on how to transform the exported CCV genesis state (ccv-state.json in the example above) to the required target version can be found here  ","version":"v6.1.0","tagName":"h3"},{"title":"2. SoftwareUpgradeProposal on the standalone/consumer chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#2-softwareupgradeproposal-on-the-standaloneconsumer-chain","content":" This upgrade proposal will introduce ICS to the standalone chain, making it a consumer.  ","version":"v6.1.0","tagName":"h3"},{"title":"3. Assigning a consumer key​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#3-assigning-a-consumer-key","content":" After spawn_time, make sure to assign a consumer key if you intend to use one.  Instructions are available here  ","version":"v6.1.0","tagName":"h3"},{"title":"4. Perform the software upgrade on standalone chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#4-perform-the-software-upgrade-on-standalone-chain","content":" Please use instructions provided by the standalone chain team and make sure to reach out if you are facing issues. The upgrade preparation depends on your setup, so please make sure you prepare ahead of time.  danger The ccv.json from step 1. must be made available on the machine running the standalone/consumer chain at standalone chain upgrade_height. This file contains the initial validator set and parameters required for normal ICS operation. Usually, the file is placed in $NODE_HOME/config but this is not a strict requirement. The exact details are available in the upgrade code of the standalone/consumer chain.  Performing this upgrade will transition the standalone chain to be a consumer chain.  After 3 blocks, the standalone chain will stop using the &quot;old&quot; validator set and begin using the provider validator set.  ","version":"v6.1.0","tagName":"h3"},{"title":"FAQ​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#faq","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Can I reuse the same validator key for the consumer chain that I am already using on the standalone chain? Will I need to perform a AssignConsumerKey tx with this key before spawn time?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#can-i-reuse-the-same-validator-key-for-the-consumer-chain-that-i-am-already-using-on-the-standalone-chain-will-i-need-to-perform-a-assignconsumerkey-tx-with-this-key-before-spawn-time","content":" Validators must either assign a key or use the same key as on the provider.  If you are validating both the standalone and the provider, you can use your current standalone key with some caveats:  you must submit an AssignConsumerKey tx with your current standalone validator keyit is best to submit AssignConsumerKey tx before spawn_timeif you do not submit the Tx, it is assumed that you will be re-using your provider key to validate the standalone/consumer chain  ","version":"v6.1.0","tagName":"h3"},{"title":"Can I continue using the same node that was validating the standalone chain?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#can-i-continue-using-the-same-node-that-was-validating-the-standalone-chain","content":" Yes.  Please assign your consensus key as stated above.  ","version":"v6.1.0","tagName":"h3"},{"title":"Can I set up a new node to validate the standalone/consumer chain after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#can-i-set-up-a-new-node-to-validate-the-standaloneconsumer-chain-after-it-transitions-to-interchain-security","content":" Yes.  If you are planning to do this please make sure that the node is synced with standalone network and to submit AssignConsumerKey tx before spawn_time.  ","version":"v6.1.0","tagName":"h3"},{"title":"What happens to the standalone validator set after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#what-happens-to-the-standalone-validator-set-after-it-transitions-to-interchain-security","content":" The standalone chain validators will stop being validators after the first 3 blocks are created while using Interchain Security. The standalone validators will become governors and still can receive delegations if the consumer chain is using the consumer-democracy module.  Governors DO NOT VALIDATE BLOCKS.  Instead, they can participate in the governance process and take on other chain-specific roles.  ","version":"v6.1.0","tagName":"h3"},{"title":"Credits​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.1.0/validators/changeover-procedure#credits","content":" Thank you Stride team for providing detailed instructions about the changeover procedure. ","version":"v6.1.0","tagName":"h2"},{"title":"Upgrading to ICS v5.x from v4.x","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5","content":"","keywords":"","version":"v6.1.0"},{"title":"Note​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#note","content":" v5.0.0 should not be used on the provider.  The provider should be updated to v5.1.0.  ","version":"v6.1.0","tagName":"h2"},{"title":"Provider​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#provider","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Keeper initialization​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#keeper-initialization","content":" // app.go app.ProviderKeeper = ibcproviderkeeper.NewKeeper( appCodec, keys[providertypes.StoreKey], app.GetSubspace(providertypes.ModuleName), scopedIBCProviderKeeper, app.IBCKeeper.ChannelKeeper, - app.IBCKeeper.PortKeeper + app.IBCKeeper.PortKeeper, app.IBCKeeper.ConnectionKeeper, app.IBCKeeper.ClientKeeper, app.StakingKeeper, app.SlashingKeeper, app.AccountKeeper, app.DistrKeeper, app.BankKeeper, *app.GovKeeper, + authtypes.NewModuleAddress(govtypes.ModuleName).String(), + authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()), + authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()), authtypes.FeeCollectorName, )   authority was added - requirement for executing MsgUpdateParams uses x/gov module address by default validatorAddressCodec &amp; consensusAddressCodec were added - they must match the bech32 address codec used by x/auth, x/bank, x/staking  ","version":"v6.1.0","tagName":"h3"},{"title":"Protocol changes​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#protocol-changes","content":" Revert AfterUnbondingInitiated​  AfterUnbondingInitiated behavior was reverted to ICS@v1.2.0-multiden  The revert re-introduces an additional state check.  See this issue for more context and the actions taken.  ","version":"v6.1.0","tagName":"h3"},{"title":"Migration (v4 -> v5)​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#migration-v4---v5","content":" ConensusVersion was bumped to 5.  The migration allows storing the provider module params in the x/ccv/provider module store instead of relying on legacy x/param store.  There are no special requirements for executing this migration.  ","version":"v6.1.0","tagName":"h3"},{"title":"Additions​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#additions","content":" ","version":"v6.1.0","tagName":"h3"},{"title":"MsgUpdateParams transaction​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#msgupdateparams-transaction","content":" x/gov module account is selected as the default authority.  It is available when using gov CLI commands:  Drafting a proposal:  interchain-security-pd tx gov draft-proposal # select &quot;other&quot; # find and select &quot;/interchain_security.ccv.provider.v1.MsgUpdateParams&quot;   Submitting a proposal:  interchain-security-pd tx gov submit-proposal &lt;proposal-message.json&gt;   Example proposal-message.json:  { &quot;messages&quot;: [ { &quot;@type&quot;: &quot;/interchain_security.ccv.provider.v1.MsgUpdateParams&quot;, &quot;authority&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot;, &quot;params&quot;: { &quot;trusting_period_fraction&quot;: &quot;0.66&quot;, &quot;ccv_timeout_period&quot;: &quot;2419200s&quot;, &quot;init_timeout_period&quot;: &quot;604800s&quot;, &quot;vsc_timeout_period&quot;: &quot;3024000s&quot;, &quot;slash_meter_replenish_period&quot;: &quot;3s&quot;, &quot;slash_meter_replenish_fraction&quot;: &quot;1.0&quot;, &quot;consumer_reward_denom_registration_fee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocks_per_epoch&quot;: &quot;600&quot; } } ], &quot;metadata&quot;: &quot;ipfs://CID&quot;, &quot;deposit&quot;: &quot;10000stake&quot;, &quot;title&quot;: &quot;Update Provider params&quot;, &quot;summary&quot;: &quot;Update Provider params&quot;, &quot;expedited&quot;: false }   ","version":"v6.1.0","tagName":"h3"},{"title":"","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5##","content":" When updating parameters all parameters fields must be specified. Make sure you are only changing parameters that you are interested in.  To avoid accidentally changing parameters you can first check the current on-chain provider params using:  interchain-security-pd q provider params -o json { &quot;template_client&quot;: {...}, &quot;trusting_period_fraction&quot;: &quot;0.66&quot;, &quot;ccv_timeout_period&quot;: &quot;2419200s&quot;, &quot;init_timeout_period&quot;: &quot;604800s&quot;, &quot;vsc_timeout_period&quot;: &quot;3024000s&quot;, &quot;slash_meter_replenish_period&quot;: &quot;3s&quot;, &quot;slash_meter_replenish_fraction&quot;: &quot;1.0&quot;, &quot;consumer_reward_denom_registration_fee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocks_per_epoch&quot;: &quot;600&quot; }   ","version":"v6.1.0","tagName":"h3"},{"title":"Governance proposals​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#governance-proposals","content":" Submitting the following legacy proposals is still supported:  Consumer addition proposal  interchain-security-pd tx gov submit-legacy-proposal consumer-addition &lt;proposal_file.json&gt;   Consumer removal proposal  interchain-security-pd tx gov submit-legacy-proposal consumer-removal &lt;proposal_file.json&gt;   Consumer addition proposal  interchain-security-pd tx gov submit-legacy-proposal change-reward-denoms &lt;proposal_file.json&gt;   You may also submit proposal messages above using submit-proposal.  ","version":"v6.1.0","tagName":"h3"},{"title":"Consumer​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#consumer","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"Keeper initialization​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#keeper-initialization-1","content":" // pre-initialize ConsumerKeeper to satsfy ibckeeper.NewKeeper app.ConsumerKeeper = ibcconsumerkeeper.NewNonZeroKeeper( appCodec, keys[ibcconsumertypes.StoreKey], app.GetSubspace(ibcconsumertypes.ModuleName), ) app.IBCKeeper = ibckeeper.NewKeeper( appCodec, keys[ibchost.StoreKey], app.GetSubspace(ibchost.ModuleName), app.ConsumerKeeper, app.UpgradeKeeper, scopedIBCKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // initialize the actual consumer keeper app.ConsumerKeeper = ibcconsumerkeeper.NewKeeper( appCodec, keys[ibcconsumertypes.StoreKey], app.GetSubspace(ibcconsumertypes.ModuleName), scopedIBCConsumerKeeper, app.IBCKeeper.ChannelKeeper, - &amp;app.IBCKeeper.PortKeeper, + app.IBCKeeper.PortKeeper, app.IBCKeeper.ConnectionKeeper, app.IBCKeeper.ClientKeeper, app.SlashingKeeper, app.BankKeeper, app.AccountKeeper, &amp;app.TransferKeeper, app.IBCKeeper, authtypes.FeeCollectorName, // make sure the authority address makes sense for your chain // the exact module account may differ depending on your setup (x/gov, x/admin or custom module) // for x/ccv/democracy using the x/gov module address is correct // if you don't have a way of updating consumer params you may still use the line below as it will have no affect + authtypes.NewModuleAddress(govtypes.ModuleName).String(), // add address codecs + authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()), + authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()), )   authority was added - requirement for executing MsgUpdateParams make sure the authority address makes sense for your chainthe exact module account may differ depending on your setup (x/gov, x/admin or custom module)for x/ccv/democracy using the x/gov module address is correctif you don't have a way of updating consumer params you may use authtypes.NewModuleAddress(govtypes.ModuleName).String() (has no effect on functionality) validatorAddressCodec &amp; consensusAddressCodec were added - they must match the bech32 address codec used by x/auth, x/bank, x/staking  ","version":"v6.1.0","tagName":"h3"},{"title":"Additions​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#additions-1","content":" MsgUpdateParams transaction​  This functionality is not supported on x/ccv/consumer without additional configuration.  if you are using x/ccv/democracy the feature is supported out of the boxif you are using custom logic for changing consumer params, please update your code by providing the appropriate authority module account during ConsumerKeeper initialization in app.go.  You must add &quot;/interchain_security.ccv.consumer.v1.MsgUpdateParams&quot; to your parameters whitelist to be able to change ccvconsumer parameters via governance.  It is available when using gov CLI commands:  Drafting a proposal:  interchain-security-cd tx gov draft-proposal # select &quot;other&quot; # find and select &quot;/interchain_security.ccv.consumer.v1.MsgUpdateParams&quot;   Submitting a proposal:  this proposal cannot be executed on chains without access to x/gov or other modules for managing governance   interchain-security-cdd tx gov submit-proposal &lt;proposal-message.json&gt;   Example proposal-message.json.  { &quot;messages&quot;: [ { &quot;@type&quot;: &quot;/interchain_security.ccv.consumer.v1.MsgUpdateParams&quot;, &quot;authority&quot;: &quot;consumer10d07y265gmmuvt4z0w9aw880jnsr700jlh7295&quot;, &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocks_per_distribution_transmission&quot;: &quot;20&quot;, &quot;distribution_transmission_channel&quot;: &quot;channel-1&quot;, &quot;provider_fee_pool_addr_str&quot;: &quot;&quot;, &quot;ccv_timeout_period&quot;: &quot;2419200s&quot;, &quot;transfer_timeout_period&quot;: &quot;3000s&quot;, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;historical_entries&quot;: &quot;10000&quot;, &quot;unbonding_period&quot;: &quot;1209600s&quot;, &quot;soft_opt_out_threshold&quot;: &quot;0.05&quot;, &quot;reward_denoms&quot;: [], &quot;provider_reward_denoms&quot;: [], &quot;retry_delay_period&quot;: &quot;3000s&quot; } } ], &quot;metadata&quot;: &quot;ipfs://CID&quot;, &quot;deposit&quot;: &quot;1000uatom&quot;, &quot;title&quot;: &quot;Update Consumer Params -- change transfer_timeout_period to 3000s&quot;, &quot;summary&quot;: &quot;Test Update Consumer Params&quot;, &quot;expedited&quot;: false }   When updating parameters all parameters fields must be specified. Make sure you are only changing parameters that you are interested in.  To avoid accidentally changing parameters you can first check the current on-chain consumer params using:  interchain-security-pd q ccvconsumer params -o json   Params Query​  Consumer params query was added:  interchain-security-cd q ccvconsumer params -o json { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocks_per_distribution_transmission&quot;: &quot;1000&quot;, &quot;distribution_transmission_channel&quot;: &quot;&quot;, &quot;provider_fee_pool_addr_str&quot;: &quot;&quot;, &quot;ccv_timeout_period&quot;: &quot;2419200s&quot;, &quot;transfer_timeout_period&quot;: &quot;3600s&quot;, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;historical_entries&quot;: &quot;10000&quot;, &quot;unbonding_period&quot;: &quot;1209600s&quot;, &quot;soft_opt_out_threshold&quot;: &quot;0.05&quot;, &quot;reward_denoms&quot;: [], &quot;provider_reward_denoms&quot;: [], &quot;retry_delay_period&quot;: &quot;3600s&quot; } }   ","version":"v6.1.0","tagName":"h3"},{"title":"Migration (v2 -> v3)​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#migration-v2---v3","content":" ConensusVersion was bumped to 3.  The migration allows storing the consumer module params in the x/ccv/consumer module store instead of relying on legacy x/param store.  There are no special requirements for executing this migration.  ","version":"v6.1.0","tagName":"h3"},{"title":"Interface method changes​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#interface-method-changes","content":" Consumer methods were changed to match the cosmos-sdk StakingKeeper interface. You will not need to change your code, unless you are using the ConsumerKeeper inside custom tests or you have developed custom app functionality that relies on ConsumerKeeper.  Please check the list below if you are using any of the consumer methods:  type StakingKeeper interface { UnbondingTime(ctx context.Context) (time.Duration, error) GetValidatorByConsAddr(ctx context.Context, consAddr sdk.ConsAddress) (stakingtypes.Validator, error) GetLastValidatorPower(ctx context.Context, operator sdk.ValAddress) (int64, error) Jail(context.Context, sdk.ConsAddress) error // jail a validator Slash(ctx context.Context, consAddr sdk.ConsAddress, infractionHeight, power int64, slashFactor math.LegacyDec) (math.Int, error) SlashWithInfractionReason(ctx context.Context, consAddr sdk.ConsAddress, infractionHeight, power int64, slashFactor math.LegacyDec, infraction stakingtypes.Infraction) (math.Int, error) Unjail(ctx context.Context, addr sdk.ConsAddress) error GetValidator(ctx context.Context, addr sdk.ValAddress) (stakingtypes.Validator, error) IterateLastValidatorPowers(ctx context.Context, cb func(addr sdk.ValAddress, power int64) (stop bool)) error IterateValidators(ctx context.Context, f func(index int64, validator stakingtypes.ValidatorI) (stop bool)) error Validator(ctx context.Context, addr sdk.ValAddress) (stakingtypes.ValidatorI, error) IsValidatorJailed(ctx context.Context, addr sdk.ConsAddress) (bool, error) ValidatorByConsAddr(ctx context.Context, consAddr sdk.ConsAddress) (stakingtypes.ValidatorI, error) Delegation(ctx context.Context, addr sdk.AccAddress, valAddr sdk.ValAddress) (stakingtypes.DelegationI, error) MaxValidators(ctx context.Context) (uint32, error) }   The consumer implements the StakingKeeper interface shown above.  ","version":"v6.1.0","tagName":"h3"},{"title":"Democracy​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#democracy","content":" Changes in Consumer also apply to Democracy.  Democracy x/staking, x/distribution and x/gov were updated to reflect changes in cosmos-sdk v0.50.x.  There were no notable changes arising to the module functionality aside from conforming to cosmos-sdk v0.50.x.  ","version":"v6.1.0","tagName":"h2"},{"title":"Note:​","type":1,"pageTitle":"Upgrading to ICS v5.x from v4.x","url":"/interchain-security/v6.1.0/upgrading/migrate_v4_v5#note-1","content":" You must add &quot;/interchain_security.ccv.consumer.v1.MsgUpdateParams&quot; to your parameters whitelist to be able to change consumer parameters via governance. ","version":"v6.1.0","tagName":"h2"},{"title":"Joining Stride","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/validators/joining-stride","content":"","keywords":"","version":"v6.1.0"},{"title":"Note​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v6.1.0/validators/joining-stride#note","content":" Stride re-uses an existing transfer channel to send consumer rewards to the provider chain, in order to preserve existing transfer IBC denom between stride-1 and cosmoshub-4.  ","version":"v6.1.0","tagName":"h2"},{"title":"Resources​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v6.1.0/validators/joining-stride#resources","content":" Stride docsChangeover procedure timelineChangeover upgrade docs ","version":"v6.1.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/validators/overview","content":"","keywords":"","version":"v6.1.0"},{"title":"Startup sequence overview​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#startup-sequence-overview","content":" Consumer chains cannot start and be secured by the validator set of the provider unless a ConsumerAdditionProposal is passed. Each proposal contains defines a spawn_time - the timestamp when the consumer chain genesis is finalized and the consumer chain clients get initialized on the provider.  tip Validators are required to run consumer chain binaries only after spawn_time has passed.  Please note that any additional instructions pertaining to specific consumer chain launches will be available before spawn time. The chain start will be stewarded by the Cosmos Hub team and the teams developing their respective consumer chains.  The image below illustrates the startup sequence  ","version":"v6.1.0","tagName":"h2"},{"title":"1. Consumer Chain init + 2. Genesis generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#1-consumer-chain-init--2-genesis-generation","content":" Consumer chain team initializes the chain genesis.json and prepares binaries which will be listed in the ConsumerAdditionProposal  ","version":"v6.1.0","tagName":"h3"},{"title":"3. Submit Proposal​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#3-submit-proposal","content":" Consumer chain team (or their advocates) submits a ConsumerAdditionProposal. The most important parameters for validators are:  spawn_time - the time after which the consumer chain must be startedgenesis_hash - hash of the pre-ccv genesis.json; the file does not contain any validator info -&gt; the information is available only after the proposal is passed and spawn_time is reachedbinary_hash - hash of the consumer chain binary used to validate the software builds  ","version":"v6.1.0","tagName":"h3"},{"title":"4. CCV Genesis state generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#4-ccv-genesis-state-generation","content":" After reaching spawn_time the provider chain will automatically create the CCV validator states that will be used to populate the corresponding fields in the consumer chain genesis.json. The CCV validator set consists of the validator set on the provider at spawn_time.  The state can be queried on the provider chain (in this case the Cosmos Hub):   gaiad query provider consumer-genesis &lt;consumer chain ID&gt; -o json &gt; ccvconsumer_genesis.json   This is used by the launch coordinator to create the final genesis.json that will be distributed to validators in step 5.  ","version":"v6.1.0","tagName":"h3"},{"title":"5. Updating the genesis file​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#5-updating-the-genesis-file","content":" Upon reaching the spawn_time the initial validator set state will become available on the provider chain. The initial validator set is included in the final genesis.json of the consumer chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"6. Chain start​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#6-chain-start","content":" info The consumer chain will start producing blocks as soon as 66.67% of the provider chain's voting power comes online (on the consumer chain). The relayer should be started after block production commences.  The new genesis.json containing the initial validator set will be distributed to validators by the consumer chain team (launch coordinator). Each validator should use the provided genesis.json to start their consumer chain node.  tip Please pay attention to any onboarding repositories provided by the consumer chain teams. Recommendations are available in Consumer Onboarding Checklist. Another comprehensive guide is available in the Interchain Security testnet repo.  ","version":"v6.1.0","tagName":"h3"},{"title":"7. Creating IBC connections​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#7-creating-ibc-connections","content":" Finally, to fully establish interchain security an IBC relayer is used to establish connections and create the required channels.  warning The relayer can establish the connection only after the consumer chain starts producing blocks.  hermes create connection --a-chain &lt;consumer chain ID&gt; --a-client 07-tendermint-0 --b-client &lt;client assigned by provider chain&gt; hermes create channel --a-chain &lt;consumer chain ID&gt; --a-port consumer --b-port provider --order ordered --a-connection connection-0 --channel-version 1 hermes start   ","version":"v6.1.0","tagName":"h3"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#downtime-infractions","content":" At present, the consumer chain can report evidence about downtime infractions to the provider chain. The min_signed_per_window and signed_blocks_window can be different on each consumer chain and are subject to changes via consumer chain governance.  info Causing a downtime infraction on any consumer chain will not incur a slash penalty. Instead, the offending validator will be jailed on the provider chain and consequently on all consumer chains. To unjail, the validator must wait for the jailing period to elapse on the provider chain and submit an unjail transaction on the provider chain. After unjailing on the provider, the validator will be unjailed on all consumer chains. More information is available in Downtime Slashing documentation  ","version":"v6.1.0","tagName":"h2"},{"title":"Double-signing Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#double-signing-infractions","content":" To learn more about equivocation handling in interchain security check out the Slashing documentation section.  ","version":"v6.1.0","tagName":"h2"},{"title":"Key assignment​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#key-assignment","content":" Validators can use different consensus keys on the provider and each of the consumer chains. The consumer chain consensus key must be registered on the provider before use.  For more information check out the Key assignment overview and guide  ","version":"v6.1.0","tagName":"h2"},{"title":"References:​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.1.0/validators/overview#references","content":" Cosmos Hub Validators FAQCosmos Hub Running a validatorStartup SequenceSubmit Unjailing Transaction ","version":"v6.1.0","tagName":"h2"},{"title":"Joining Interchain Security testnet","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/validators/joining-testnet","content":"","keywords":"","version":"v6.1.0"},{"title":"Introduction​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.1.0/validators/joining-testnet#introduction","content":" This short guide will teach you how to join the Interchain Security testnet.  The experience gained in the testnet will prepare you for validating interchain secured chains.  tip Provider and consumer chain represent distinct networks and infrastructures operated by the same validator set. For general information about running cosmos-sdk based chains check out the validator basics and Running a Node section of Cosmos SDK docs  ","version":"v6.1.0","tagName":"h2"},{"title":"Joining the provider chain​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.1.0/validators/joining-testnet#joining-the-provider-chain","content":" info At present, all validators of the provider chain must also validate all governance approved consumer chains. The consumer chains cannot have a validator set different than the provider, which means they cannot introduce validators that are not also validating the provider chain.  A comprehensive guide is available here.  ","version":"v6.1.0","tagName":"h2"},{"title":"Initialization​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.1.0/validators/joining-testnet#initialization","content":" First, initialize your $NODE_HOME using the provider chain binary.  NODE_MONIKER=&lt;your_node&gt; CHAIN_ID=provider NODE_HOME=&lt;path_to_your_home&gt; gaiad init $NODE_MONIKER --chain-id $CHAIN_ID --home $NODE_HOME   Add your key to the keyring - more details available here.  In this example we will use the test keyring-backend. This option is not safe to use in production.  gaiad keys add &lt;key_moniker&gt; --keyring-backend test # save the address as variable for later use MY_VALIDATOR_ADDRESS=$(gaiad keys show my_validator -a --keyring-backend test)   Before issuing any transactions, use the provider testnet faucet to add funds to your address.  curl https://faucet.rs-testnet.polypore.xyz/request?address=$MY_VALIDATOR_ADDRESS&amp;chain=provider # example output: { &quot;address&quot;: &quot;cosmos17p3erf5gv2436fd4vyjwmudakts563a497syuz&quot;, &quot;amount&quot;: &quot;10000000uatom&quot;, &quot;chain&quot;: &quot;provider&quot;, &quot;hash&quot;: &quot;10BFEC53C80C9B649B66549FD88A0B6BCF09E8FCE468A73B4C4243422E724985&quot;, &quot;status&quot;: &quot;success&quot; }   Then, use the account associated with the keyring to issue a create-validator transaction which will register your validator on chain.  gaiad tx staking create-validator \\ --amount=1000000uatom \\ --pubkey=$(gaiad tendermint show-validator) \\ --moniker=&quot;choose a moniker&quot; \\ --chain-id=$CHAIN_ID&quot; \\ --commission-rate=&quot;0.10&quot; \\ --commission-max-rate=&quot;0.20&quot; \\ --commission-max-change-rate=&quot;0.01&quot; \\ --min-self-delegation=&quot;1000000&quot; \\ --gas=&quot;auto&quot; \\ --gas-prices=&quot;0.0025uatom&quot; \\ --from=&lt;key_moniker&gt;   tip Check this guide to edit your validator.  After this step, your validator is created and you can start your node and catch up to the rest of the network. It is recommended that you use statesync to catch up to the rest of the network.  You can use this script to modify your config.toml with the required statesync parameters.  # create the statesync script $: cd $NODE_HOME $: touch statesync.sh $ chmod 700 statesync.sh # make executable   Paste the following instructions into the statesync.sh:  #!/bin/bash SNAP_RPC=&quot;https://rpc.provider-state-sync-01.rs-testnet.polypore.xyz:443&quot; LATEST_HEIGHT=$(curl -s $SNAP_RPC/block | jq -r .result.block.header.height); \\ BLOCK_HEIGHT=$((LATEST_HEIGHT - 2000)); \\ TRUST_HASH=$(curl -s &quot;$SNAP_RPC/block?height=$BLOCK_HEIGHT&quot; | jq -r .result.block_id.hash) sed -i.bak -E &quot;s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1true| ; \\ s|^(rpc_servers[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$SNAP_RPC,$SNAP_RPC\\&quot;| ; \\ s|^(trust_height[[:space:]]+=[[:space:]]+).*$|\\1$BLOCK_HEIGHT| ; \\ s|^(trust_hash[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$TRUST_HASH\\&quot;|&quot; $NODE_HOME/config/config.toml   Then, you can execute the script:  $: ./statesync.sh # setup config.toml for statesync   Finally, copy the provider genesis and start your node:  $: GENESIS_URL=https://github.com/cosmos/testnets/raw/master/interchain-security/provider/provider-genesis.json $: wget $GENESIS_URL -O genesis.json $: genesis.json $NODE_HOME/config/genesis.json # start the service $: gaiad start --x-crisis-skip-assert-invariants --home $NODE_HOME --p2p.seeds=&quot;08ec17e86dac67b9da70deb20177655495a55407@provider-seed-01.rs-testnet.polypore.xyz:26656,4ea6e56300a2f37b90e58de5ee27d1c9065cf871@provider-seed-02.rs-testnet.polypore.xyz:26656&quot;   Additional scripts to setup your nodes are available here and here. The scripts will configure your node and create the required services - the scripts only work in linux environments.  ","version":"v6.1.0","tagName":"h2"},{"title":"Joining consumer chains​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.1.0/validators/joining-testnet#joining-consumer-chains","content":" tip Once you reach the active set on the provider chain, you will be required to validate all available consumer chains. We strongly recommend that you assign a separate key for each consumer chain. Check out this guide to learn more about key assignment in interchain security.  To join consumer chains, simply replicate the steps above for each consumer using the correct consumer chain binaries.  info When running the provider chain and consumers on the same machine please update the PORT numbers for each of them and make sure they do not overlap (otherwise the binaries will not start). Important ports to re-configure: --rpc.laddr--p2p.laddr--api.address--grpc.address--grpc-web.address  ","version":"v6.1.0","tagName":"h2"},{"title":"Re-using consensus key​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.1.0/validators/joining-testnet#re-using-consensus-key","content":" To reuse the key on the provider and consumer chains, simply initialize your consumer chain and place the priv_validator_key.json into the home directory of your consumer chain (&lt;consumer_home&gt;/config/priv_validator_key.json).  When you start the chain, the consensus key will be the same on the provider and the consumer chain.  ","version":"v6.1.0","tagName":"h2"},{"title":"Assigning consensus keys​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.1.0/validators/joining-testnet#assigning-consensus-keys","content":" Whenever you initialize a new node, it will be configured with a consensus key you can use.  # machine running consumer chain consumerd init &lt;node_moniker&gt; --home &lt;home_path&gt; --chain-id consumer-1 # use the output of this command to get the consumer chain consensus key consumerd tendermint show-validator # output: {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, let the provider know which key you will be using for the consumer chain:  # machine running the provider chain gaiad tx provider assign-consensus-key consumer-1 '&lt;consumer_pubkey&gt;' --from &lt;key_moniker&gt; --home $NODE_HOME --gas 900000 -b sync -y -o json   After this step, you are ready to copy the consumer genesis into your nodes's /config folder, start your consumer chain node and catch up to the network. ","version":"v6.1.0","tagName":"h2"},{"title":"Cosmos Hub - Interchain Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0","content":"Cosmos Hub - Interchain Security Welcome to the official documentation for the Cosmos Hub's Interchain Security (ICS) - a platform for launching Cosmos-SDK chains. The Cosmos Hub is the best place to launch a chain. With the recent launch of the Partial Set Security and Permissionless features, it's easier than ever to leverage the Cosmos Hub validators, stake, and community for your chain. ICS provides powerful capabilities for permissionlessly launching your chain and shaping your validator set. Here you can find information about Interchain Security, consumer chain development and instructions for validator onboarding. Basic Concepts Get started with the basic concepts and ideas. FAQ Frequently asked questions about the protocol and its implications Start Building Click here to start building with Interchain Security Onboarding Checklist Checklist to help you integrate Interchain Security, get support and onboard validators Become an ICS Validator Start validating on consumer chains Assign Consumer Keys Learn how to assign separate key on the consumer chains","keywords":"","version":"v6.3.0"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators","content":"","keywords":"","version":"v6.1.0"},{"title":"Messages​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#messages","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"How to opt in to a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#how-to-opt-in-to-a-consumer-chain","content":" warning A validator is automatically opted in to a Top N chain if the validator belongs to the top N% of the validators on the provider chain.  In a Top N chain, a validator that does not belong to the top N% of the validators on the provider can still choose to opt in to a consumer chain. In other words, validators can opt in, in both Opt-In and Top N chains.  A validator can opt in to a consumer chain by issuing the following message:  interchain-security-pd tx provider opt-in &lt;consumer-chain-id&gt; &lt;optional consumer-pub-key&gt;   where  consumer-chain-id is the string identifier of the consumer chain the validator wants to opt in to;consumer-pub-key corresponds to the public key the validator wants to use on the consumer chain, and it has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}.  A validator can opt in to an existing consumer chain that is already running, or to a proposedconsumer chain that is still being voted on. A validator can use the following command to retrieve the currently existing consumer chains:  interchain-security-pd query provider list-consumer-chains   and this command to see the currently proposed consumer chains:  interchain-security-pd query provider list-proposed-consumer-chains   By setting the consumer-pub-key, a validator can both opt in to a chain and assign a public key on a consumer chain. Note that a validator can always assigna new consumer key at a later stage. The key-assignment rulesstill apply when setting consumer-pub-key when opting in.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  Note that a validator is only eligible for consumer rewards from a consumer chain if the validator is opted into that chain.  ","version":"v6.1.0","tagName":"h3"},{"title":"How to opt out from a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#how-to-opt-out-from-a-consumer-chain","content":" A validator can opt out from a consumer by issuing the following message:  interchain-security-pd tx provider opt-out &lt;consumer-chain-id&gt;   where  consumer-chain-id is the string identifier of the consumer chain.  The opting out mechanism has the following rules:  A validator cannot opt out from a Top N chain if it belongs to the top N% validators of the provider.If a validator moves from the Top N to outside of the top N% of the validators on the provider, it will notbe automatically opted-out. The validator has to manually opt out.A validator should stop its node on a consumer chain only after opting out and confirming through the has-to-validatequery (see below) that it does not have to validate the consumer chain any longer. Otherwise, the validator risks getting jailed for downtime.  warning If all validators opt out from an Opt-In chain, the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"v6.1.0","tagName":"h3"},{"title":"How to set specific per consumer chain commission rate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#how-to-set-specific-per-consumer-chain-commission-rate","content":" A validator can choose to set a different commission rate on each of the consumer chains. This can be done with the following command:  interchain-security-pd tx provider set-consumer-commission-rate &lt;consumer-chain-id&gt; &lt;commission-rate&gt;   where  consumer-chain-id is the string identifier of the consumer chain;comission-rate decimal in [minRate, 1] where minRate corresponds to the minimum commission rate set on the provider chain (see min_commission_rate in interchain-security-pd query staking params).  If a validator does not set a commission rate on a consumer chain, the commission rate defaults to their commission rate on the provider chain.  Validators can set their commission rate even for consumer chains that they are not currently opted in on, and the commission rate will be applied when they opt in. This is particularly useful for Top N chains, where validators might be opted in automatically, so validators can set the commission rate in advance.  If a validator opts out and then back in, this will not reset their commission rate back to the default. Instead, their set commission rate still applies.  ","version":"v6.1.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#queries","content":" PSS introduces a number of queries to assist validators in determining which consumer chains they have to validate, their commission rate per chain, etc.  ","version":"v6.1.0","tagName":"h2"},{"title":"Which chains does a validator have to validate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#which-chains-does-a-validator-have-to-validate","content":" Naturally, a validator is aware of the Opt-In chains it has to validate because in order to validate an Opt-In chain, a validator has to manually opt in to the chain. This is not the case for Top N chains where a validator might be required to validate such a chain without explicitly opting in if it belongs to the top N% of the validators on the provider.  We introduce the following query:  interchain-security-pd query provider has-to-validate &lt;provider-validator-address&gt;   that can be used by validator with provider-validator-address address to retrieve the list of chains that it has to validate.  warning For a validator, the list of chains returned by has-to-validate is the list of chains the validator should be validating to avoid getting jailed for downtime.  ","version":"v6.1.0","tagName":"h3"},{"title":"How do you know how much voting power you need to have to be in the top N for a chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#how-do-you-know-how-much-voting-power-you-need-to-have-to-be-in-the-top-n-for-a-chain","content":" This can be seen as part of the list-consumer-chains query:  interchain-security-pd query provider list-consumer-chains   where the min_power_in_top_N field shows the minimum voting power required to be automatically opted in to the chain.  Note that list-consumer-chains shows the minimal voting power right now, but the automatic opt-in happens only when epochs end on the provider. In consequence, a validators power might be large enough to be automatically opted in during an epoch, but if their power is sufficiently decreased before the epoch ends, they will not be opted in automatically.  ","version":"v6.1.0","tagName":"h3"},{"title":"How to retrieve all the opted-in validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-opted-in-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-opted-in-validators &lt;consumer-chain-id&gt;   we can see all the opted-in validators on consumer-chain-id that were manually or automatically opted in.  ","version":"v6.1.0","tagName":"h3"},{"title":"How to retrieve all the consumer validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-consumer-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-validators &lt;consumer-chain-id&gt;   we can see all the consumer validators (i.e., validator set) of consumer-chain-id. The consumer validators are the ones that are currently (or in the future, see warning) validating the consumer chain. A consumer validator is an opted-in validator but not vice versa. For example, an opted-in validator V might not be a consumer validator because V is denylisted or because V is removed due to a validator-set cap.  Note that the returned consumer validators from this query do not necessarily correspond to the validator set that is validating the consumer chain at this exact moment. This is because the VSCPacket sent to a consumer chain might be delayed and hence this query might return the validator set that the consumer chain would have at some future point in time.  ","version":"v6.1.0","tagName":"h3"},{"title":"How can we see the commission rate a validator has set on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.1.0/validators/partial-set-security-for-validators#how-can-we-see-the-commission-rate-a-validator-has-set-on-a-consumer-chain","content":" Using the following query:  interchain-security-pd query provider validator-consumer-commission-rate &lt;consumer-chain-id&gt; &lt;provider-validator-address&gt;   we retrieve the commission rate set by validator with provider-validator-address address on consumer-chain-id. ","version":"v6.1.0","tagName":"h3"},{"title":"Consumer chain validator rewards","type":0,"sectionRef":"#","url":"/interchain-security/v6.1.0/validators/withdraw_rewards","content":"","keywords":"","version":"v6.1.0"},{"title":"Withdrawing rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.1.0/validators/withdraw_rewards#withdrawing-rewards","content":" Here are example steps for withdrawing rewards from consumer chains in the provider chain  info The examples used are from rs-testnet, the Interchain Security persistent testnet. Validator operator address: cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6Self-delegation address: cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf  Prior to withdrawing rewards, query balances for self-delegation address:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;1000000000000&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;   ","version":"v6.1.0","tagName":"h2"},{"title":"Querying validator rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.1.0/validators/withdraw_rewards#querying-validator-rewards","content":" Query rewards for the validator address:  gaiad q distribution rewards cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 rewards: - amount: &quot;158.069895000000000000&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;841842390516.072526500000000000&quot; denom: uatom   The ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD denom represents rewards from a consumer chain.  ","version":"v6.1.0","tagName":"h2"},{"title":"Withdrawing rewards and commission​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.1.0/validators/withdraw_rewards#withdrawing-rewards-and-commission","content":" ","version":"v6.1.0","tagName":"h2"},{"title":"1. Withdraw rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.1.0/validators/withdraw_rewards#1-withdraw-rewards","content":" gaiad tx distribution withdraw-rewards cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 --from cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf --commission --chain-id provider --gas auto --fees 500uatom -b block -y txhash: A7E384FB1958211B43B7C06527FC7D4471FB6B491EE56FDEA9C5634D76FF1B9A   ","version":"v6.1.0","tagName":"h3"},{"title":"2. Confirm withdrawal​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.1.0/validators/withdraw_rewards#2-confirm-withdrawal","content":" After withdrawing rewards self-delegation address balance to confirm rewards were withdrawn:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;216&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;2233766225342&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;  ","version":"v6.1.0","tagName":"h3"},{"title":"ADR 001: Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#changelog","content":" 2022-12-01: Initial Draft2024-03-01: Updated to take into account they key-assigment-replacement deprecation.  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#context","content":" KeyAssignment is the name of the feature that allows validator operators to use different consensus keys for each consumer chain validator node that they operate.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#decision","content":" It is possible to change the keys at any time by submitting a transaction (i.e., MsgAssignConsumerKey).  ","version":"v6.3.0","tagName":"h2"},{"title":"State required​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#state-required","content":" ValidatorConsumerPubKey - Stores the validator assigned keys for every consumer chain.  ConsumerValidatorsBytePrefix | len(chainID) | chainID | providerConsAddress -&gt; consumerKey   ValidatorByConsumerAddr - Stores the mapping from validator addresses on consumer chains to validator addresses on the provider chain. Needed for the consumer initiated slashing sub-protocol.  ValidatorsByConsumerAddrBytePrefix | len(chainID) | chainID | consumerConsAddress -&gt; providerConsAddress   ConsumerAddrsToPrune - Stores the mapping from VSC ids to consumer validators addresses. Needed for pruning ValidatorByConsumerAddr.  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; []consumerConsAddresses   ","version":"v6.3.0","tagName":"h3"},{"title":"Protocol overview​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#protocol-overview","content":" On receiving a MsgAssignConsumerKey(chainID, providerAddr, consumerKey) message:  // get validator from staking module validator, found := stakingKeeper.GetValidator(providerAddr) if !found { return ErrNoValidatorFound } providerConsAddr := validator.GetConsAddr() // make sure consumer key is not in use consumerAddr := utils.TMCryptoPublicKeyToConsAddr(consumerKey) if _, found := GetValidatorByConsumerAddr(ChainID, consumerAddr); found { return ErrInvalidConsumerConsensusPubKey } // check whether the consumer chain is already registered // i.e., a client to the consumer was already created if _, consumerRegistered := GetConsumerClientId(chainID); consumerRegistered { // get the previous key assigned for this validator on this consumer chain oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr) if found { // mark this old consumer key as prunable once the VSCMaturedPacket // for the current VSC ID is received oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) vscID := GetValidatorSetUpdateId() AppendConsumerAddrsToPrune(chainID, vscID, oldConsumerAddr) } } else { // if the consumer chain is not registered, then remove the previous reverse mapping if oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr); found { oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) DeleteValidatorByConsumerAddr(chainID, oldConsumerAddr) } } // set the mapping from this validator's provider address to the new consumer key SetValidatorConsumerPubKey(chainID, providerConsAddr, consumerKey) // set the reverse mapping: from this validator's new consensus address // on the consumer to its consensus address on the provider SetValidatorByConsumerAddr(chainID, consumerAddr, providerConsAddr)   When a new consumer chain is registered, i.e., a client to the consumer chain is created, the provider constructs the consumer CCV module part of the genesis state (see MakeConsumerGenesis).  func (k Keeper) MakeConsumerGenesis(chainID string) (gen consumertypes.GenesisState, nextValidatorsHash []byte, err error) { // ... // get initial valset from the staking module var updates []abci.ValidatorUpdate{} stakingKeeper.IterateLastValidatorPowers(func(providerAddr sdk.ValAddress, power int64) (stop bool) { validator := stakingKeeper.GetValidator(providerAddr) providerKey := validator.TmConsPublicKey() updates = append(updates, abci.ValidatorUpdate{PubKey: providerKey, Power: power}) return false }) // applies the key assignment to the initial validator for i, update := range updates { providerAddr := utils.TMCryptoPublicKeyToConsAddr(update.PubKey) if consumerKey, found := GetValidatorConsumerPubKey(chainID, providerAddr); found { updates[i].PubKey = consumerKey } } gen.InitialValSet = updates // get a hash of the consumer validator set from the update updatesAsValSet := tendermint.PB2TM.ValidatorUpdates(updates) hash := tendermint.NewValidatorSet(updatesAsValSet).Hash() return gen, hash, nil }   Note that key assignment works hand-in-hand with epochs. For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. Specifically, for each validator in the set we store among others, the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacketwith all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   where DiffValidators internally checks if the consumer public key for a validator has changed since the last epoch and if so generates a validator update. This way, a validator can change its consumer public key for a consumer chain an arbitrary amount of times and only the last set consumer public key would be taken into account.  On receiving a SlashPacket from a consumer chain with id chainID for a infraction of a validator data.Validator:  func HandleSlashPacket(chainID string, data ccv.SlashPacketData) (success bool, err error) { // ... // the slash packet validator address may be known only on the consumer chain; // in this case, it must be mapped back to the consensus address on the provider chain consumerAddr := sdk.ConsAddress(data.Validator.Address) providerAddr, found := GetValidatorByConsumerAddr(chainID, consumerAddr) if !found { // the validator has the same key on the consumer as on the provider providerAddr = consumerAddr } // ... }   On receiving a VSCMatured:  func OnRecvVSCMaturedPacket(packet channeltypes.Packet, data ccv.VSCMaturedPacketData) exported.Acknowledgement { // ... // prune previous consumer validator address that are no longer needed consumerAddrs := GetConsumerAddrsToPrune(chainID, data.ValsetUpdateId) for _, addr := range consumerAddrs { DeleteValidatorByConsumerAddr(chainID, addr) } DeleteConsumerAddrsToPrune(chainID, data.ValsetUpdateId) // ... }   On stopping a consumer chain:  func (k Keeper) StopConsumerChain(ctx sdk.Context, chainID string, closeChan bool) (err error) { // ... // deletes all the state needed for key assignments on this consumer chain // ... }   ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#positive","content":" Validators can use different consensus keys on the consumer chains.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#negative","content":" None  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#neutral","content":" The consensus state necessary to create a client to the consumer chain must use the hash returned by the MakeConsumerGenesis method as the nextValsHash.The consumer chain can no longer check the initial validator set against the consensus state on InitGenesis.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.3.0/adrs/adr-001-key-assignment#references","content":" Key assignment issue ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 003: Equivocation governance proposal","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal#changelog","content":" 2023-02-06: Initial draft2023-11-30: Change status to deprecated  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal#status","content":" Deprecated  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal#context","content":" Note: ADR deprecated as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  We want to limit the possibilities of a consumer chain to execute actions on the provider chain to maintain and ensure optimum security of the provider chain.  For instance, a malicious consumer consumer chain can send slash packet to the provider chain, which will slash a validator without the need of providing an evidence.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal#decision","content":" To protect against a malicious consumer chain, slash packets unrelated to downtime are ignored by the provider chain. Thus, an other mechanism is required to punish validators that have committed a double-sign on a consumer chain.  A new kind of governance proposal is added to the provider module, allowing to slash and tombstone a validator for double-signing in case of any harmful action on the consumer chain.  If such proposal passes, the proposal handler delegates to the evidence module to process the equivocation. This module ensures the evidence isn’t too old, or else ignores it (see code). Too old is determined by 2 consensus params :  evidence.max_age_duration number of nanoseconds before an evidence is considered too oldevidence.max_age_numblocks number of blocks before an evidence is considered too old.  On the hub, those parameters are equals to  // From https://cosmos-rpc.polkachu.com/consensus_params?height=13909682 (...) &quot;evidence&quot;: { &quot;max_age_num_blocks&quot;: &quot;1000000&quot;, &quot;max_age_duration&quot;: &quot;172800000000000&quot;, (...) }, (...)   A governance proposal takes 14 days, so those parameters must be big enough so the evidence provided in the proposal is not ignored by the evidence module when the proposal passes and is handled by the hub.  For max_age_num_blocks=1M, the parameter is big enough if we consider the hub produces 12k blocks per day (blocks_per_year/365 = 436,0000/365). The evidence can be up to 83 days old (1,000,000/12,000) and not be ignored.  For max_age_duration=172,800,000,000,000, the parameter is too low, because the value is in nanoseconds so it’s 2 days. Fortunately the condition that checks those 2 parameters uses a AND, so if max_age_num_blocks condition passes, the evidence won’t be ignored.  ","version":"v6.3.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal#positive","content":" Remove the possibility from a malicious consumer chain to “attack” the provider chain by slashing/jailing validators.Provide a more acceptable implementation for the validator community.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal#negative","content":" Punishment action of double-signing isn’t “automated”, a governance proposal is required which takes more time.You need to pay 250ATOM to submit an equivocation evidence.  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal#neutral","content":" ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.3.0/adrs/adr-003-equivocation-gov-proposal#references","content":" PR that ignores non downtime slash packet : https://github.com/cosmos/interchain-security/pull/692PR that adds the governance slash proposal: https://github.com/cosmos/interchain-security/pull/703 ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 004: Denom DOS fixes","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes#changelog","content":" 5/9/2023: ADR created  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes#context","content":" The provider and consumer modules are vulnerable to similar issues involving an attacker sending millions of denoms to certain addresses and causing the chain to halt. This ADR outlines both fixes since they are similar. Both fixes involve processing only denoms that are on a whitelist to avoid iterating over millions of junk denoms but have different requirements and are implemented in different ways.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes#decision","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Provider​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes#provider","content":" Put the distribution module's FeePoolAddress back on the blocklist so that it cannot receive funds from users.Create a new address called ConsumerRewardPool and unblock it, allowing funds to be sent to it.Create a set of strings in the store for allowed ConsumerRewardDenoms.Create an endpoint called RegisterConsumerRewardDenom which deducts a fee from the sender's account, sends it to the community pool and adds a string to the ConsumerRewardDenoms set.Create a parameter called ConsumerRewardDenomRegistrationFee which determines the fee which is charged to register a consumer reward denom in the step above.Create a function called TransferRewardsToFeeCollector which gets the entire ConsumerRewardDenoms set from the store, iterates over it, and for each entry: Gets the balance of this denom for the ConsumerRewardPool accountSends the entire balance out to the FeePoolAddress using SendCoinsFromModuleToModule which is not affected by the blocklist. Run TransferRewardsToFeeCollector in the endblock  Now, nobody can send millions of junk denoms to the FeePoolAddress because it is on the block list. If they send millions of junk denoms to the ConsumerRewardPool, this does not matter because all balances are not iterated over, only those which are in the ConsumerRewardDenoms set.  We also add a new tx: register-consumer-reward-denom, and a new query: registered-consumer-reward-denoms  ","version":"v6.3.0","tagName":"h3"},{"title":"Consumer​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes#consumer","content":" Create a new param RewardDenoms with a list of stringsCreate a new param ProviderRewardDenoms with a list of stringsCreate a function AllowedRewardDenoms which iterates over ProviderRewardDenoms and converts each denom to its ibc-prefixed denom using the provider chain's ibc channel information, then concatenates the RewardDenoms list and returns the combined list of allowed denoms.In SendRewardsToProvider, instead of iterating over the balances of all denoms in the ToSendToProvider address, iterate over AllowedRewardDenoms  Now, if somebody sends millions of junk denoms to ToSendToProvider, they will not be iterated over. Only the RewardDenoms and ProviderRewardDenoms will be iterated over. Since we do not require this feature to be permissionless on the consumer, the registration fee process is not needed.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes#positive","content":" Denom DOS is no longer possible on either provider or consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.3.0/adrs/adr-004-denom-dos-fixes#negative","content":" Consumer chain teams must pay a fee to register a denom for distribution on the provider, and add some extra parameters in their genesis file. ","version":"v6.3.0","tagName":"h3"},{"title":"ADR 005: Cryptographic verification of equivocation evidence","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#changelog","content":" 5/1/2023: First draft7/23/2023: Add light client attacks handling9/6/2023: Add double signing attacks handling11/3/2023: Update limitations to clarify amnesia attacks are ignored  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#context","content":" Currently, we use a governance proposal to slash validators for equivocation (double signing and light client attacks). Every proposal needs to go through a (two weeks) voting period before it can be approved. Given a three-week unbonding period, this means that an equivocation proposal needs to be submitted within one week since the infraction occurred.  This ADR proposes a system to slash validators automatically for equivocation, immediately upon the provider chain's receipt of the evidence. Another thing to note is that we intend to introduce this system in stages, since even the partial ability to slash and/or tombstone is a strict improvement in security. The feature is implemented in two parts, each with its dedicated endpoint. One endpoint handles light client attacks, while the other handles double signing attacks.  ","version":"v6.3.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack","content":" In a nutshell, the light client is a process that solely verifies a specific state machine's consensus without executing the transactions. The light clients get new headers by querying multiple nodes, called primary and witness nodes.  Light clients download new headers committed on chain from a primary. Headers can be verified in two ways: sequentially, where the block height of headers is serial, or using skipping. This second verification method allows light clients to download headers with nonconsecutive block height, where some intermediate headers are skipped (see Tendermint Light Client, Figure 1 and Figure 3). Additionally, light clients are cross-checking new headers obtained from a primary with witnesses to ensure all nodes share the same state.  A light client attack occurs when a Byzantine validator sends invalid headers to a light client. As the light client doesn't execute transactions, it can be deceived into trusting corrupted application state transitions. For instance, if a light client receives header A from the primary and header B from a witness for the same block height H, and both headers are successfully verified, it indicates a light client attack. Note that in this case, either the primary or the witness or both are malicious.  The types of light client attacks are defined by analyzing the differences between the conflicting headers. There are three types of light client attacks: lunatic attack, equivocation attack, and amnesia attack. For details, see the CometBFT specification.  When a light client agent detects two conflicting headers, it will initially verify their traces (see cometBFT detector) using its primary and witness nodes. If these headers pass successful verification, the Byzantine validators will be identified based on the header's commit signatures and the type of light client attack. The agent will then transmit this information to its nodes using a LightClientAttackEvidence evidence to be eventually voted on and added to a block. Note that from a light client agent perspective, it is not possible to establish whether a primary or a witness node, or both, are malicious. Therefore, it will create and send two evidences: one against the primary (sent to the witness), and one against the witness (sent to the primary). Both nodes will then verify it before broadcasting it and adding it to the evidence pool. If an evidence is finally committed to a block, the chain's evidence module will execute it, resulting in the jailing and the slashing of the validators responsible for the light client attack.  Light clients are a core component of IBC. In the event of a light client attack, IBC relayers notify the affected chains by submitting an IBC misbehavior message. A misbehavior message includes the conflicting headers that constitute a light client attack evidence. Upon receiving such a message, a chain will first verify whether these headers would have convinced its light client. This verification is achieved by checking the header states against the light client consensus states (see IBC misbehaviour handler). If the misbehaviour is successfully verified, the chain will then &quot;freeze&quot; the light client, halting any further trust in or updating of its states.  ","version":"v6.3.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack","content":" A double signing attack, also known as equivocation, occurs when a validator votes for two different blocks in the same round of the CometBFT consensus. This consensus mechanism operates with multiple voting rounds at each block height, and it strictly prohibits sending two votes of the same type during a round (see CometBFT State Machine Overview).  When a node observes two votes from the same peer, it will use these two votes to create a DuplicateVoteEvidenceevidence and gossip it to the other nodes in the network (see CometBFT equivocation detection). Each node will then verify the evidence according to the CometBFT rules that define a valid double signing infraction, and based on this verification, they will decide whether to add the evidence to a block. During the evidence verification process, the signatures of the conflicting votes must be verified successfully. Note that this is achieved using the public key of the misbehaving validator, along with the chain ID of the chain where the infraction occurred (see CometBFT equivocation verification).  Once a double signing evidence is committed to a block, the consensus layer will report the equivocation to the evidence module of the Cosmos SDK application layer. The application will, in turn, punish the malicious validator through jailing, tombstoning and slashing (see handleEquivocationEvidence).  ","version":"v6.3.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#decision","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack-1","content":" In the first part of the feature, we introduce a new endpoint: HandleConsumerMisbehaviour(ctx sdk.Context, misbehaviour ibctmtypes.Misbehaviour). The main idea is to leverage the current IBC misbehaviour handling and update it to solely jail and slash the validators that performed a light client attack. Note that in this context, we assume that chains connected via a light client share a subset of the validator set of the provider.  This endpoint reuses the IBC client libraries to verify that the misbehaviour headers would have fooled the light client. Additionally, it’s crucial that the endpoint logic results in the slashing and jailing of validators under the same conditions as a light client agent detector. Therefore, the endpoint ensures that the two conditions are met: the headers in the misbehaviour message have the same block height, and the light client isn’t expired.  After having successfully verified a misbehaviour, the endpoint executes the jailing and slashing of the malicious validators similarly as in the evidence module.  ","version":"v6.3.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack-1","content":" In the second part of the feature, we introduce a new endpoint HandleConsumerDoubleVoting( ctx sdk.Context, evidence *tmtypes.DuplicateVoteEvidence, chainID string, pubkey cryptotypes.PubKey). Simply put, the handling logic verifies a double signing evidence against a provided public key and chain ID and, if successful, executes the jailing of the malicious validator who double voted.  We define a newMsgSubmitConsumerDoubleVoting message to report a double voting evidence observed on a consumer chain to the endpoint of the provider chain. This message contains two fields: a double signing evidenceduplicate_vote_evidence and a light client header for the infraction block height, referred to as infraction_block_header. The latter provides the malicious validator's public key and the chain ID required to verify the signature of the votes contained in the evidence.  Note that double signing evidence is not verified using the same conditions as in the implementation CometBFT (seeverify(evidence types.Evidence) method). Specifically, we do not check that the evidence hasn't expired. More details can be found in the &quot;Current limitations&quot; section below.  Upon a successful equivocation verification, the misbehaving validator is jailed for the maximum time (see DoubleSignJailEndTimein the SDK evidence module).  ","version":"v6.3.0","tagName":"h3"},{"title":"Current limitations:​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#current-limitations","content":" We cannot derive an infraction height from the evidence, so it is only possible to jail validators, not actually slash them. To explain the technical reasons behind this limitation, let's recap the initial consumer initiated slashing logic. In a nutshell, consumer heights are mapped to provider heights through VSCPackets, namely through the so called vscIDs. When an infraction occurs on the consumer, a SlashPacket containing the vscID obtained from mapping the consumer infraction height is sent to the provider. Upon receiving the packet, the provider maps the consumer infraction height to a local infraction height, which is used to slash the misbehaving validator. In the context of untrusted consumer chains, all their states, including vscIDs, could be corrupted and therefore cannot be used for slashing purposes. For the same reasons explained above, the age of a consumer double signing evidence can't be verified, either using its infraction height or its unsigned timestamp. Note that changes the jailing behaviour, potentially leading to a validator's jailing based on some &quot;old&quot; evidence from a consumer, which wouldn't occur if the consumer were a standalone chain. In the first stage of this feature, validators are jailed indefinitely without being tombstoned. The underlying reason is that a malicious validator could take advantage of getting tombstoned to avoid being slashed on the provider (see comment). Currently, the endpoint can only handle equivocation light client attacks. This is because the lunatic attacks require the endpoint to possess the ability to dissociate which header is conflicted or trusted upon receiving a misbehavior message. Without this information, it's not possible to extract the Byzantine validators from the conflicting headers (see comment). In addition, &quot;amnesia&quot; attacks are ignored, similar to CometBFT (see ADR-056).  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#positive","content":" It is now possible for the provider chain to jail validators who committed light client or double signing attacks on a consumer chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#negative","content":" N/A  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.3.0/adrs/adr-005-cryptographic-equivocation-verification#references","content":" ICS misbehaviour handling PRConsumer double voting handler PRArchitectural diagramsADR on equivocation slashing ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 007: Pause validator unbonding during equivocation proposal","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#changelog","content":" 2023-05-16: Initial Draft2023-11-30: Change the status to rejected  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#status","content":" Rejected  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#context","content":" Note: ADR rejected as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  Currently, if an equivocation slashing proposal is created after more than one week has passed since the equivocation, it is possible that the validator in question could unbond and get away without being slashed, since the unbonding period is 3 weeks, and the voting period is 2 weeks. For this reason, it might be good to pause unbondings for validators named in an equivocation slashing proposal until the proposal's voting period is over.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#decision","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"How​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#how","content":" Pausing the unbonding period is already possible thanks to the changes in thestaking module of the cosmos-sdk:  stakingKeeper.PutUnbondingOnHold pauses an unbonding periodstakingKeeper.UnbondingCanComplete unpauses an unbonding period  These methods use a reference counter under the hood, that gets incremented every time PutUnbondingOnHold is called, and decreased whenUnbondingCanComplete is called instead. A specific unbonding is considered fully unpaused when its underlying reference counter reaches 0. Therefore, as long as we safeguard consistency - i.e. we make sure we eventually decrement the reference counter for each time we have incremented it - we can safely use this existing mechanism without conflicts with the Completion of Unbonding Operations system.  ","version":"v6.3.0","tagName":"h3"},{"title":"When pause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-pause","content":" The unbonding period (if there is any unbonding) should be paused once an equivocation proposal enters the voting period. For that, the gov module's hook AfterProposalDeposit can be used.  If the hook is triggered with a an equivocation proposal in voting period, then for each equivocation of the proposal, the unbonding operations of the related validator that were initiated after the equivocation block time must be paused  i.e. the underlying reference counter has to be increased.  Note that even after the voting period has started, a proposal can receive additional deposits. The hook is triggered however at arrival of a deposit, so a check to verify that the proposal is not already in voting period is required.  ","version":"v6.3.0","tagName":"h3"},{"title":"When unpause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-unpause","content":" We can use a gov module's hook also here and it isAfterProposalVotingPeriodEnded.  If the hook is triggered with an equivocation proposal, then for each associated equivocation, the unbonding operations of the related validator that were initiated between the equivocation block time and the start of the proposal voting period must be unpaused - i.e. decrease the underlying reference counter - regardless of the proposal outcome.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#positive","content":" Validators subject to an equivocation proposal cannot finish unbonding their tokens before the end of the voting period.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#negative","content":" A malicious consumer chain could forge slash packets enabling submission of an equivocation proposal on the provider chain, resulting in the freezing of validator's unbondings for an undeterminated amount of time.Misbehavior on a consumer chain can potentially go unpunished, if no one submits an equivocation proposal in time, or if the proposal doesn't pass.  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#neutral","content":" This feature can't be used for social slashing, because an equivocation proposal is only accepted if there's a slash log for the related validator(s), meaning the consumer chain has reported the equivocation to the provider chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.3.0/adrs/adr-007-pause-unbonding-on-eqv-prop#references","content":" https://github.com/cosmos/interchain-security/issues/747https://github.com/cosmos/interchain-security/pull/791 ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 002: Jail Throttling","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#changelog","content":" 2023-01-26: Initial Draft2023-02-07: Property refined, ADR ready to review/merge2023-11-22: Refactor for better understanding  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#context","content":" The CCV spec is based around the assumption that the provider binary and all consumers binaries are non-malicious, and follow the defined protocols. In practice, this assumption may not hold. A malicious consumer binary could potentially include code which is able to send many slash/jail packets at once to the provider.  Before the throttling feature was implemented, the following attack was possible. Attacker(s) would create provider validators just below the provider's active set. Using a malicious consumer binary, slash packets would be relayed to the provider, that would slash/jail a significant portion (or all) of honest validator at once. Control of the provider would then pass over to the attackers' validators. This enables the attacker(s) to halt the provider. Or even worse, commit arbitrary state on the provider, potentially stealing all tokens bridged to the provider over IBC.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#decision","content":" The throttling feature was designed to slow down the mentioned attack from above, allowing validators and the community to appropriately respond to the attack, i.e., this feature limits (enforced by on-chain params) the rate that the provider validator set can be jailed over time.  ","version":"v6.3.0","tagName":"h2"},{"title":"Required State​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#required-state","content":" Slash meter: There exists one slash meter on the provider which stores an amount of voting power (integer), corresponding to an allowance of validators that can be jailed over time. This meter is initialized to a certain value on genesis, decremented by the amount of voting power jailed whenever a slash packet is handled, and periodically replenished as decided by on-chain params.  Global entry queue: There exists a single queue which stores &quot;global slash entries&quot;. These entries allow the provider to appropriately handle slash packets sent from any consumer in FIFO ordering. This queue is responsible for coordinating the order that slash packets (from multiple chains) are handled over time.  Per-chain data queue: For each established consumer, there exists a queue which stores &quot;throttled packet data&quot;, i.e.,pending slash packet data is queued together with pending VSC matured packet data in FIFO ordering. Order is enforced by IBC sequence number. These &quot;per-chain&quot; queues are responsible for coordinating the order that slash packets are handled in relation to VSC matured packets from the same chain.  Note: The reason for a multiple-queue design is the VSC Maturity and Slashing Order property (see spec). There are other ways to ensure such a property (like a queue of linked lists, etc.), but the proposed approach seemed to be the most understandable and easiest to implement with a KV store.  ","version":"v6.3.0","tagName":"h3"},{"title":"Params​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#params","content":" SlashMeterReplenishPeriod -- the period after which the slash meter is replenished.  SlashMeterReplenishFraction -- the portion (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs. This param also serves as a maximum fraction of total voting power that the slash meter can hold.  MaxThrottledPackets -- the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value. This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness.  ","version":"v6.3.0","tagName":"h3"},{"title":"Protocol Overview​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#protocol-overview","content":" OnRecvSlashPacket​  Upon the provider receiving a slash packet from any of the established consumers during block execution, two things occur:  A global slash entry is queued.The data of such a packet is added to the per-chain queue.  OnRecvVSCMaturedPacket​  Upon the provider receiving a VSCMatured packet from any of the established consumers during block execution, the VSCMatured packet data is added to the per-chain queue.  Endblocker​  In the EndBlock of the provider CCV module, there are three actions performed:  replenish the slash meter;handle the leading VSCMaturedPackets;and handle the throttle queues.  Slash Meter Replenishment​  Once the slash meter becomes not full, it'll be replenished after SlashMeterReplenishPeriod by incrementing the meter with its allowance for the replenishment block, where allowance = SlashMeterReplenishFraction * currentTotalVotingPower. The slash meter will never exceed its current allowance (function of the total voting power for the block) in value.  Note a few things:  The slash meter can go negative in value, and will do so when handling a single slash packet that jails a validator with significant voting power. In such a scenario, the slash meter may take multiple replenishment periods to once again reach a positive value (or 0), meaning no other slash packets may be handled for multiple replenishment periods.Total voting power of a chain changes over time, especially as validators are jailed. As validators are jailed, total voting power decreases, and so does the jailing allowance. See below for more detailed throttling property discussion.The voting power allowance added to the slash meter during replenishment will always be greater than or equal to 1. If the SlashMeterReplenishFraction is set too low, integer rounding will put this minimum value into effect. That is, if SlashMeterReplenishFraction * currentTotalVotingPower &lt; 1, then the effective allowance would be 1. This min value of allowance ensures that there's some packets handled over time, even if that is a very long time. It's a crude solution to an edge case caused by too small of a replenishment fraction.  The behavior described above is achieved by executing CheckForSlashMeterReplenishment() every EndBlock, BEFORE HandleThrottleQueues() is executed.  Handle Leading VSCMaturedPackets​  In every block, it is possible that VSCMaturedPacket data was queued before any slash packet data. Since this &quot;leading&quot; VSCMatured packet data does not have to be throttled (see VSC Maturity and Slashing Order), we can handle all VSCMatured packet data at the head of the queue, before the any throttling or packet data handling logic executes.  Handle Throttle Queues​  In every EndBlock, the following logic is executed to handle data from the throttle queues.  meter := getSlashMeter() // Keep iterating as long as the meter has a positive (or 0) value, and global slash entries exist while meter.IsPositiveOrZero() &amp;&amp; entriesExist() { // Get next entry in queue entry := getNextGlobalSlashEntry() // Decrement slash meter by the voting power that will be removed from the valset from handling this slash packet valPower := entry.getValPower() meter = meter - valPower // Using the per-chain queue, handle the single slash packet using its queued data, // then handle all trailing VSCMatured packets for this consumer handleSlashPacketAndTrailingVSCMaturedPackets(entry) // Delete entry in global queue, delete handled data entry.Delete() deleteThrottledSlashPacketData() deleteTrailingVSCMaturedPacketData() }   ","version":"v6.3.0","tagName":"h3"},{"title":"System Properties​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#system-properties","content":" All CCV system properties should be maintained by implementing this feature, see CCV spec - Consumer Initiated Slashing.  One implementation-specific property introduced is that if any of the chain-specific packet data queues become larger than MaxThrottledPackets, then the provider binary will panic, and the provider chain will halt. Therefore this param should be set carefully. See SetThrottledPacketDataSize. This behavior ensures that if the provider binaries are queuing up more packet data than machines can handle, the provider chain halts deterministically between validators.  ","version":"v6.3.0","tagName":"h3"},{"title":"Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#main-throttling-property","content":" Using on-chain params and the sub protocol defined, slash packet throttling is implemented such that the following property holds under some conditions.  First, we introduce the following definitions:  A consumer initiated slash attack &quot;starts&quot; when the first slash packet from such an attack is received by the provider.The &quot;initial validator set&quot; for the attack is the validator set that existed on the provider when the attack started.There is a list of honest validators such that if they are jailed, X% of the initial validator set will be jailed.  For the Throttling Property to hold, the following assumptions must be true:  We assume the total voting power of the chain (as a function of delegations) does not increase over the course of the attack.No validator has more than SlashMeterReplenishFraction of total voting power on the provider.SlashMeterReplenishFraction is large enough that SlashMeterReplenishFraction * currentTotalVotingPower &gt; 1, i.e., the replenish fraction is set high enough that we can ignore the effects of rounding.SlashMeterReplenishPeriod is sufficiently longer than the time it takes to produce a block.  Note if these assumptions do not hold, throttling will still slow down the described attack in most cases, just not in a way that can be succinctly described. It's possible that more complex properties can be defined.  Throttling Property: The time it takes to jail/tombstone X% of the initial validator set will be greater than or equal toSlashMeterReplenishPeriod⋅XSlashMeterReplenishFraction−2⋅SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod} \\cdot \\frac{X}{\\mathit{SlashMeterReplenishFraction}} - 2 \\cdot \\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriod⋅SlashMeterReplenishFractionX​−2⋅SlashMeterReplenishPeriod.  Intuition Let's use the following notation: CCC: Number of replenishment cyclesPPP: SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriodFFF: SlashMeterReplenishFraction\\mathit{SlashMeterReplenishFraction}SlashMeterReplenishFractionVmaxV_{\\mathit{max}}Vmax​: Max power of a validator as a fraction of total voting power In CCC number of replenishment cycles, the fraction of total voting power that can be removed, aaa, is a≤F⋅C+Vmaxa \\leq F \\cdot C + V_{\\mathit{max}}a≤F⋅C+Vmax​ (where VmaxV_{\\mathit{max}}Vmax​ is there to account for the power fraction of the last validator removed, one which pushes the meter to the negative value). So, we need at least C≥a−VmaxFC \\geq \\frac{a - V_{\\mathit{max}}}{F}C≥Fa−Vmax​​ cycles to remove aaa fraction of the total voting power. Since we defined the start of the attack to be the moment when the first slash request arrives, then FFF fraction of the initial validator set can be jailed immediately. For the remaining X−FX - FX−F fraction of the initial validator set to be jailed, it takes at least C≥(X−F)−VmaxFC \\geq \\frac{(X - F) - V_{\\mathit{max}}}{F}C≥F(X−F)−Vmax​​ cycles. Using the assumption that Vmax≤FV_{\\mathit{max}} \\leq FVmax​≤F (assumption 2), we get C≥X−2FFC \\geq \\frac{X - 2F}{F}C≥FX−2F​ cycles. In order to execute CCC cycles, we need C⋅PC \\cdot PC⋅P time. Thus, jailing the remaining X−FX - FX−F fraction of the initial validator set corresponds to P⋅(X−2F)F\\frac{P \\cdot (X - 2F)}{F}FP⋅(X−2F)​ time. In other words, the attack must take at least P⋅XF−2P\\frac{P \\cdot X}{F} - 2PFP⋅X​−2P time (in the units of replenish period PPP).  This property is useful because it allows us to reason about the time it takes to jail a certain percentage of the initial provider validator set from consumer initiated slash requests. For example, if SlashMeterReplenishFraction is set to 0.06, then it takes no less than 4 replenishment periods to jail 33% of the initial provider validator set on the Cosmos Hub. Note that as of writing this on 11/29/22, the Cosmos Hub does not have a validator with more than 6% of total voting power.  Note also that 4 replenishment period is a worst case scenario that depends on well crafted attack timings.  ","version":"v6.3.0","tagName":"h3"},{"title":"How Unjailing Affects the Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#how-unjailing-affects-the-main-throttling-property","content":" Note that the jailing allowance is directly proportional to the current total voting power of the provider chain. Therefore, if honest validators don't unjail themselves during the attack, the total voting power of the provider chain will decrease over the course of the attack, and the attack will be slowed down, main throttling property is maintained.  If honest validators do unjail themselves, the total voting power of the provider chain will still not become higher than when the attack started (unless new token delegations happen), therefore the main property is still maintained. Moreover, honest validators unjailing themselves helps prevent the attacking validators from gaining control of the provider.  In summary, the throttling mechanism as designed has desirable properties whether or not honest validators unjail themselves over the course of the attack.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#positive","content":" The described attack is slowed down in seemingly all cases.If certain assumptions hold, the described attack is slowed down in a way that can be precisely time-bounded.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#negative","content":" Throttling introduces a vector for a malicious consumer chain to halt the provider, see issue below. However, this is sacrificing liveness in a edge case scenario for the sake of security. As an improvement, using retries would fully prevent this attack vector.  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#neutral","content":" Additional state is introduced to the provider chain.VSCMatured and slash packet data is not always handled in the same block that it is received.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.3.0/adrs/adr-002-throttle#references","content":" Original issue inspiring throttling featureIssue on DOS vectorConsideration of another attack vector ","version":"v6.3.0","tagName":"h2"},{"title":"Standalone to Consumer Changeover","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover","content":"","keywords":"","version":"v6.3.0"},{"title":"ADR 010: Standalone to Consumer Changeover​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#adr-010-standalone-to-consumer-changeover","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#changelog","content":" 6/30/23: Feature completed, first draft of ADR.  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#status","content":" Implemented  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#context","content":" Stride will be the first consumer to &quot;changeover&quot; from a standalone cosmos blockchain, to a consumer chain secured by the Cosmos Hub. This document outlines the changes made to support this changeover process.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#decision","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Process​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#process","content":" Prior to the changeover, the consumer chain will have an existing staking keeper and validator set, these may be referred to as the &quot;standalone staking keeper&quot; and &quot;standalone validator set&quot; respectively.  The first step in the changeover process is to submit a ConsumerAdditionProposal. If the proposal passes, the provider will create a new IBC client for the consumer at spawn time, with the provider's validator set. A consumer genesis will also be constructed by the provider for validators to query. Within this consumer genesis contains the initial validator set for the consumer to apply after the changeover.  Next, the standalone consumer chain runs an upgrade which adds the CCV module, and is properly setup to execute changeover logic.  The consumer upgrade height must be reached after the provider has created the new IBC client. Any Interchain Security validators who will run the consumer, but are not a part of the sovereign validator set, must sync up a full node before the consumer upgrade height is reached. The disk state of said full node will be used to run the consumer chain after the changeover has completed.  The meat of the changeover logic is that the consumer chain validator set is updated to that which was specified by the provider via the queried consumer genesis. Validators which were a part of the old set, but not the new set, are given zero voting power. Once these validator updates are given to Comet, the set is committed, and in effect 2 blocks later (see FirstConsumerHeight).  A relayer then establishes the new IBC connection between the provider and consumer. The CCV channel handshake is started on top of this connection. Once the CCV channel is established and VSC packets are being relayed, the consumer chain is secured by the provider.  ","version":"v6.3.0","tagName":"h3"},{"title":"Changes to CCV Protocol​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#changes-to-ccv-protocol","content":" Consumer Genesis state is updated to include a PreCCV boolean. When this boolean is set true in the consumer genesis JSON, special logic is executed on InitGenesis to trigger the changeover process on the consumer's first endblocker after the upgrade which adds the CCV module. Note that InitGenesis is not automatically called during chain upgrades, so the consumer must manually call the consumer's InitGenesis method in an upgrade handler.The ConsumerAdditionProposal type is updated to include a DistributionTransmissionChannel field. This field allows the consumer to use an existing IBC transfer channel to send rewards as a part of the CCV protocol. Consumers that're not changing over from a standalone chain will leave this field blank, indicating that a new transfer channel should be created on top of the same connection as the CCV channel.The CCV consumer keeper is updated to contain an optional reference to the standalone staking keeper. The standalone staking keeper is used to slash for infractions that happened before the changeover was completed. Ie. any infraction from a block height before the changeover, that is submitted after the changeover, will call the standalone staking keeper's slash method. Note that a changeover consumer's standalone staking keeper becomes a democracy module keeper, so it is possible for a governance token to be slashed.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#positive","content":" Existing cosmos chains are now able to onboard over to a consumer chain secured by a provider.The previous staking keepers for such chains can be transitioned to democracy staking module keepers.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#negative","content":" The delineation between different types of consumers in this repo becomes less clear. Ie. there is code in the democracy consumer's app.go that only applies to a previously standalone chain, but that file also serves as the base for a normal democracy consumer launched with RS from genesis.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.3.0/adrs/adr-010-standalone-changeover#references","content":" EPIC: Standalone to Consumer Changeover #756Changeover diagram from Stride ","version":"v6.3.0","tagName":"h2"},{"title":"Throttle with retries","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries","content":"","keywords":"","version":"v6.3.0"},{"title":"ADR 008: Throttle with retries​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#adr-008-throttle-with-retries","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#changelog","content":" 6/9/23: Initial draft6/22/23: added note on consumer pending packets storage optimization7/14/23: Added note on upgrade order  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#context","content":" For context on why the throttling mechanism exists, see ADR 002.  Note the terms slash throttling and jail throttling are synonymous, since in Interchain Security a SlashPacket simply jails a validator for downtime infractions.  Currently the throttling mechanism is designed so that provider logic (slash meter, etc.) dictates how many SlashPackets can be handled over time. Throttled SlashPackets are persisted on the provider, leading to multiple possible issues. Namely:  If SlashPackets or VSCMaturedPackets are actually throttled/queued on the provider, state can grow and potentially lead to a DoS attack. We have short term solutions around this, but overall they come with their own weaknesses. See #594.If a jailing attack described in ADR 002 were actually to be carried out with the current throttling design, we'd likely have to halt the provider, and perform an emergency upgrade and/or migration to clear the queues of SlashPackets that were deemed to be malicious. Alternatively, validators would just have to tough it out and wait for the queues to clear, during which all/most validators would be jailed. Right after being jailed, validators would have to unjail themselves promptly to ensure safety. The coordination required to maintain safety in such a scenario is not ideal.  As a solution, we can improve the throttling mechanism to instead queue/persist relevant data on each consumer, and have consumers retry slash requests as needed.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#decision","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Consumer changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#consumer-changes","content":" Note the consumer already queues up both SlashPackets and VSCMaturedPackets via AppendPendingPacket. Those packets are dequeued in every EndBlock in SendPackets and sent to the provider.  Instead, we will now introduce the following logic on EndBlock:  Slash packets will always be sent to the provider once they're at the head of the queue. However, once sent, the consumer will not send any subsequent VSCMaturedPackets from the queue until the provider responds with an acknowledgement that the sent SlashPacket has been handled, i.e., validator was jailed. That is, SlashPackets block the sending of subsequent VSCMaturedPackets in the consumer queue.If two SlashPackets are at the head of the queue, the consumer will send the first SlashPacket, and then wait for a success acknowledgement from the provider before sending the second SlashPacket. This seems like it'd simplify implementation.VSCMaturedPackets at the head of the queue (i.e., NOT following a SlashPacket) can be sent immediately, and do not block any other packets in the queue, since the provider always handles them immediately.  To prevent the provider from having to keep track of what SlashPackets have been rejected, the consumer will have to retry the sending of SlashPackets over some period of time. This can be achieved with an on-chain consumer param, i.e., RetryDelayPeriod. To reduce the amount of redundant re-sends, we recommend setting RetryDelayPeriod ~ SlashMeterReplenishmentPeriod, i.e., waiting for the provider slash meter to be replenished before resending the rejected SlashPacket.  Note to prevent weird edge case behavior, a retry would not be attempted until either a success or failure acknowledgement has been received from the provider.  With the behavior described, we maintain very similar behavior to the previous throttling mechanism regarding the timing that SlashPackets and VSCMaturedPackets are handled on the provider. Obviously the queueing and blocking logic is moved, and the two chains would have to send more messages between one another (only in the case the throttling mechanism is triggered).  In the normal case, when no or a few SlashPackets are being sent, the VSCMaturedPackets will not be delayed, and hence unbonding will not be delayed.  For the implementation of this design, see throttle_retry.go.  Consumer pending packets storage optimization​  In addition to the mentioned consumer changes, an optimization will need to be made to the consumer's pending packets storage to properly implement the feature from this ADR.  The consumer ccv module previously queued &quot;pending packets&quot; to be sent in each EndBlock in SendPackets. These packets are queued in state with a protobuf list of ConsumerPacketData. For a single append operation, the entire list is deserialized, then a packet is appended to that list, and the list is serialized again. See older version of AppendPendingPacket. That is, a single append operation has O(N) complexity, where N is the size of the list.  This poor append performance isn't a problem when the pending packets list is small. But with this ADR being implemented, the pending packets list could potentially grow to the order of thousands of entries when SlashPackets need to be resent.  We can improve the append time for this queue by converting it from a protobuf-esq list, to a queue implemented with sdk-esq code. The idea is to persist a uint64 index that will be incremented each time you queue up a packet. You can think of this as storing the tail of the queue. Then, packet data will be keyed by that index, making the data naturally ordered byte-wise for sdk's iterator. The index will also be stored in the packet data value bytes, so that the index can later be used to delete certain packets from the queue.  Two things are achieved with this approach:  More efficient packet append/enqueue timesThe ability to delete select packets from the queue (previously all packets were deleted at once)  ","version":"v6.3.0","tagName":"h3"},{"title":"Provider changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#provider-changes","content":" The main change needed for the provider is the removal of queuing logic for SlashPackets and VSCMaturedPackets upon being received.  Instead, the provider will consult the slash meter to determine if a SlashPacket can be handled immediately. If not, the provider will return an acknowledgement message to the consumer communicating that the SlashPacket could not be handled, and needs to be sent again in the future (retried).  VSCMaturedPackets will always be handled immediately upon being received by the provider.  Note spec. Specifically the section on VSC Maturity and Slashing Order. Previously the onus was on the provider to maintain this property via queuing packets and handling them FIFO.  Now this property will be maintained by the consumer sending packets in the correct order, and blocking the sending of VSCMaturedPackets as needed. Then, the ordered IBC channel will ensure that SlashPackets and VSCMaturedPackets are received in the correct order on the provider.  The provider's main responsibility regarding throttling will now be to determine if a received SlashPacket can be handled via slash meter etc., and appropriately acknowledge to the sending consumer.  Handling VSCMaturedPackets immediately​  Why the provider can handle VSCMatured packets immediately​  A VSCMaturedPacket communicates to the provider that sufficient time passed on the consumer since the corresponding VSCPacket has been applied (on the consumer) such that infractions committed on the consumer could have been submitted.  If the consumer is following the queuing/blocking protocol described, then no bad behavior occurs and the VSC Maturity and Slashing Order property is maintained.  If a consumer sends VSCMaturedPackets too leniently -- the consumer is malicious and sends duplicate VSCMaturedPackets, or sends the packets sooner than the CCV protocol specifies -- then the provider needs to handle VSCMaturedPackets immediately to prevent DOS, state bloat, or other issues. The only possible negative outcome is that the malicious consumer may not be able to jail a validator who should have been jailed. The malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  If a consumer blocks the sending of VSCMaturedPackets, then unbonding operations on the provider will be delayed, but only until the VSC timeout period has elapsed. At that time, the consumer is removed. Again the malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  ","version":"v6.3.0","tagName":"h3"},{"title":"Splitting of PRs and Upgrade Order​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#splitting-of-prs-and-upgrade-order","content":" This feature will implement consumer changes in #1024.  ❗These changes should be deployed to production for all consumers before the provider changes are deployed to production.  In other words, the consumer changes in #1024 are compatible with the current (&quot;v1&quot;) provider implementation of throttling that's running on the Cosmos Hub as of July 2023.  Once all consumers have deployed the changes in #1024, the provider changes from #1321 can be deployed to production, fully enabling v2 throttling.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#consequences","content":" Consumers will now have to manage their own queues, and retry logic.Consumers still aren't trustless, but the provider is now less susceptible to mismanaged or malicious consumers.Recovering from the &quot;jailing attack&quot; is more elegant.Some issues like #1001 will now be handled implicitly by the improved throttling mechanism.SlashPackets and VSCMaturedPackets can be handled immediately once received by the provider if the slash meter allows.In general, we reduce the amount of computation that happens in the provider EndBlock.  ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#positive","content":" We no longer have to reason about a &quot;global queue&quot; and a &quot;chain specific queue&quot;, and keeping those all in-sync. Now SlashPackets and VSCMaturedPackets queuing is handled on each consumer individually.Due to the above, the throttling protocol becomes less complex overall.We no longer have to worry about throttle related DoS attack on the provider, since no queuing exists on the provider.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#negative","content":" Increased number of IBC packets being relayed anytime throttling logic is triggered.Consumer complexity increases, since consumers now have manage queuing themselves, and implement packet retry logic.  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#neutral","content":" Core throttling logic on the provider remains unchanged, i.e., slash meter, replenishment cycles, etc.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.3.0/adrs/adr-008-throttle-retries#references","content":" EPIC tracking the changes proposed by this ADRADR 002: Jail Throttling#594 ","version":"v6.3.0","tagName":"h2"},{"title":"Soft Opt-Out","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out","content":"","keywords":"","version":"v6.3.0"},{"title":"ADR 009: Soft Opt-Out​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#adr-009-soft-opt-out","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#changelog","content":" 6/13/23: Initial draft of ADR. Feature already implemented and in production.6/19/24: Change status to deprecated  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#status","content":" Deprecated Deprecated by Partial Set Security  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#context","content":" Some small validators may not have the resources needed to validate all consumer chains. Therefore a need exists to allow the bottom x% of validators to opt-out of validating a consumer chain. Meaning downtime infractions for these validators are dropped without ever reaching the provider.  This document specifies a modification to the ccv protocol which allows the bottom x% of the validator set by power to opt out of validating consumer chains without being jailed or otherwise punished for it. The feature is implemented with entirely consumer-side code.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#decision","content":" A consumer param exists, known as SoftOptOutThreshold, which is a string decimal in the range of [0, 0.2], that determines the portion of validators which are allowed to opt out of validating that specific consumer.  In every consumer beginblocker, a function is ran which determines the so called smallest non opt-out voting power. Validators with voting power greater than or equal to this value must validate the consumer chain, while validators below this value may opt out of validating the consumer chain.  The smallest non opt-out voting power is recomputed every beginblocker in UpdateSmallestNonOptOutPower(). In a nutshell, the method obtains the total voting power of the consumer, iterates through the full valset (ordered power ascending) keeping track of a power sum, and when powerSum / totalPower &gt; SoftOptOutThreshold, the SmallestNonOptOutPower is found and persisted.  Then, whenever the Slash() interface is executed on the consumer, if the voting power of the relevant validator being slashed is less than SmallestNonOptOutPower for that block, the slash request is dropped and never sent to the provider.  ","version":"v6.3.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#positive","content":" Small validators can opt out of validating specific consumers without being punished for it.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#negative","content":" The bottom x% is still part of the total voting power of the consumer chain. This means that if the soft opt-out threshold is set to 10% for example, and every validator in the bottom 10% opts out from validating the consumer, then a 24% downtime of the remaining voting power would halt the chain. This may be especially problematic during consumer upgrades.In nominal scenarios, consumers with soft opt out enabled will be constructing slash packets for small vals, which may be dropped. This is wasted computation, but necessary to keep implementation simple. Note that the sdk's full downtime logic is always executed on the consumer, which can be computationally expensive and slow down certain blocks.In a consumer chain, when a validator that has opted out becomes the proposer, there will naturally be no proposal made and validators would need to move to the next consensus round for the same height to reach a decision. As a result, we would need more time to finalize blocks on a consumer chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#neutral","content":" Validators in the bottom of the valset who don't have to validate, may receive large delegation(s) which suddenly boost the validator to the subset that has to validate. This may catch the validator off guard.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.3.0/adrs/adr-009-soft-opt-out#references","content":" Original issue with some napkin math #784 ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 012: Separate Releasing","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#changelog","content":" 0.0202020202020202: Initial draft of idea in #8010.01652892561983471: Put idea in this ADR0.05: Reject this ADR  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#status","content":" Rejected  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#context","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Spike results​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#spike-results","content":" I explored the idea of #801 with this spike branch. Here's my conclusions:  Splitting this repo to have multiple go.mods is possible. However there are various intricacies involved in decoupling the package hierarchy to have x/ccv/types as the lowest level dep, with x/ccv/consumer and x/ccv/provider being one dep layer above, with high-level tests depending on all three of the mentioned packages. I'd estimate this decoupling would take 2-5 workdays to finish, and require significant review effort.  ","version":"v6.3.0","tagName":"h3"},{"title":"Why go.mod split is not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#why-gomod-split-is-not-the-way-to-go","content":" Let's take a step back and remember the issue we're trying to solve - We need a clean way to decouple semver/releasing for the consumer and provider modules. After more consideration, splitting up go.mods gives us little benefit in achieving this. Reasons:  The go.mod dependency system is tied to git tags for the entire repo (ex: require github.com/cometbft/cometbft v0.37.2 refers to a historical tag for the entire cometbft repo).It'd be an odd dev experience to allow modules to reference past releases of other modules in the same repo. When would we ever want the consumer module to reference a past release of the types module for example?If we allow for go.mod replace statements to build from local source code, why split up the package deps at all?Splitting go.mods adds a bunch of complexity with go.work files and all that shiz. VSCode does not play well with multiple module repos either.  ","version":"v6.3.0","tagName":"h3"},{"title":"Why separate repos is cool but also not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#why-separate-repos-is-cool-but-also-not-the-way-to-go","content":" All this considered, the cleanest solution to decoupling semver/releasing for the consumer and provider modules would be to have multiple repos, each with their own go.mod (3-4 repos total including high level tests). With this scheme we could separately tag each repo as changes are merged, they could share some code from types being an external dep, etc.  I don't think any of us want to split up the monorepo, that's a lot of work and seems like bikeshedding. There's another solution that's very simple..  ","version":"v6.3.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#decision","content":" Slightly adapting the current semver ruleset:  A library API breaking change to EITHER the provider or consumer module will result in an increase of the MAJOR version number for BOTH modules (X.y.z-provider AND X.y.z-consumer).A state breaking change (change requiring coordinated upgrade and/or state migration) will result in an increase of the MINOR version number for the AFFECTED module(s) (x.Y.z-provider AND/OR x.Y.z-consumer).Any other changes (including node API breaking changes) will result in an increase of the PATCH version number for the AFFECTED module(s) (x.y.Z-provider AND/OR x.y.Z-consumer).  ","version":"v6.3.0","tagName":"h2"},{"title":"Example release flow​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#example-release-flow","content":" We upgrade main to use a new version of SDK. This is a major version bump, triggering a new release for both the provider and consumer modules, v5.0.0-provider and v5.0.0-consumer.  A state breaking change is merged to main for the provider module. We release only a v5.1.0-provider off main.Another state breaking change is merged to main for the provider module. We release only a v5.2.0-provider off main.At this point, the latest consumer version is still v5.0.0-consumer. We now merge a state breaking change for the consumer module to main, and consequently release v5.1.0-consumer. Note that v5.1.0-consumer is tagged off a LATER commit from main than v5.2.0-provider. This is fine, as the consumer module should not be affected by the provider module's state breaking changes.Once either module sees a library API breaking change, we bump the major version for both modules. For example, we merge a library API breaking change to main for the provider module. We release v6.0.0-provider and v6.0.0-consumer off main. Note that most often, a library API breaking change will affect both modules simultaneously (example being bumping sdk version).  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#positive","content":" Consumer repos have clear communication of what tagged versions are relevant to them. Consumer devs should know to never reference an ICS version that starts with provider, even if it'd technically build.Consumer and provider modules do not deviate as long as we continually release off a shared main branch. Backporting remains relatively unchanged besides being explicit about what module(s) your changes should affect.No code changes, just changes in process. Very simple.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#negative","content":" ~~Slightly more complexity.~~Considerably more complex to manage the ICS library. This is because ICS needs to support multiple versions of SDK (e.g., 0.45, 0.47, 0.50). In addition, ICS needs to support a special fork of SDK (with LSM included) for the Cosmos Hub. This means that instead of focusing on main the development team needs to manage multiple release branches with different dependency trees.This solution does not allow having provider and consumer on separate versions of e.g. the Cosmos SDK.  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#neutral","content":" ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.3.0/adrs/adr-012-separate-releasing#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  #801#801 comment ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 013: Slashing on the provider for consumer equivocation","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#changelog","content":" 1st Sept. 2023: Initial draft  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#context","content":" This ADR presents some approaches on how to slash on the provider chain validators that performed equivocations on consumer chains. Currently, the provider chain can receive and verify evidence of equivocation, but it cannot slash the misbehaving validator.  In the remainder of this section, we explain how slashing is performed on a single chain and show why slashing on the provider for equivocation on the consumer is challenging.  Note that future versions of the Cosmos SDK, CometBFT, and ibc-go could modify the way we slash, etc. Therefore, a future reader of this ADR, should note that when we refer to Cosmos SDK, CometBFT, and ibc-go we specifically refer to their v0.47, v0.37 and v7.3.0 versions respectively.  ","version":"v6.3.0","tagName":"h2"},{"title":"Single-chain slashing​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#single-chain-slashing","content":" Slashing is implemented across the slashingand staking modules. The slashing module's keeper calls the staking module's Slash() method, passing among others, the infractionHeight (i.e., the height when the equivocation occurred), the validator's power at the infraction height, and the slashFactor (currently set to 5% in case of equivocation on the Cosmos Hub).  Slashing undelegations and redelegations​  To slash undelegations, Slash goes through all undelegations and checks whether they started before or after the infraction occurred. If an undelegation started before the infractionHeight, then it is not slashed, otherwise it is slashed by slashFactor.  The slashing of redelegations happens in a similar way, meaning that Slash goes through all redelegations and checks whether the redelegations started before or after the infractionHeight.  Slashing delegations​  Besides undelegations and redelegations, the validator's delegations need to also be slashed. This is performed by deducting the appropriate amount of tokens from the validator. Note that this deduction is computed based on the voting power the misbehaving validator had at the height of the equivocation. As a result of the tokens deduction, the tokens per sharereduce and hence later on, when delegators undelegate or redelegate, the delegators retrieve back less tokens, effectively having their tokens slashed. The rationale behind this slashing mechanism, as mentioned in the Cosmos SDK documentation  [...] is to simplify the accounting around slashing. Rather than iteratively slashing the tokens of every delegation entry, instead the Validators total bonded tokens can be slashed, effectively reducing the value of each issued delegator share.  This approach of slashing delegations does not utilize theinfractionHeight in any way and hence the following scenario could occur:  a validator V performs an equivocation at a height Hia new delegator D delegates to V after height Hievidence of the equivocation by validator V is receivedthe tokens of delegator D are slashed  In the above scenario, delegator D is slashed, even though D's voting power did not contribute to the infraction.  Old evidence​  In the single-chain case, old evidence (e.g., from 3 years ago) is ignored. This is achieved throughCometBFT that ignores old evidence based on the parameters MaxAgeNumBlocks and MaxAgeDuration (see here). Additionally, note that when the evidence is sent by CometBFT to the application, the evidence is rechecked in the evidence module of Cosmos SDK and if it is old, the evidence is ignored. In Cosmos Hub, the MaxAgeNumBlocks is set to 1000000 (i.e., ~70 days if we assume we need ~6 sec per block) and MaxAgeDuration is set to 172800000000000 ns (i.e., 2 days). Because of this check, we can easily exclude old evidence.  ","version":"v6.3.0","tagName":"h3"},{"title":"Slashing for equivocation on the consumer​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#slashing-for-equivocation-on-the-consumer","content":" In the single-chain case, slashing requires both the infractionHeight and the voting power. In order to slash on the provider for an equivocation on a consumer, we need to have both the provider's infractionHeight and voting power. Note that the infractionHeight on the consumer chain must be mapped to a height on the provider chain. Unless we have a way to find the corresponding infractionHeight and power on the provider chain, we cannot slash for equivocation on the consumer in the same way as we would slash in the single-chain case.  The challenge of figuring out the corresponding infractionHeight and power values on the provider chain is due to the following trust assumption:  We trust the consensus layer and validator set of the consumer chains, but we do not trust the application layer.  As a result, we cannot trust anything that stems from the application state of a consumer chain.  Note that when a relayer or a user sends evidence through a MsgSubmitConsumerDoubleVoting message, the provider gets access to DuplicateVoteEvidence:  type DuplicateVoteEvidence struct { VoteA *Vote `json:&quot;vote_a&quot;` VoteB *Vote `json:&quot;vote_b&quot;` // abci specific information TotalVotingPower int64 ValidatorPower int64 Timestamp time.Time }   The &quot;abci specific information&quot; fields cannot be trusted because they are not signed. Therefore, we can use neither ValidatorPower for slashing on the provider chain, nor the Timestamp to check the evidence age. We can get the infractionHeight from the votes, but this infractionHeight corresponds to the infraction height on the consumer and not on the provider chain. Similarly, when a relayer or a user sends evidence through a MsgSubmitConsumerMisbehaviour message, the provider gets access to Misbehaviour that we cannot use to extract the infraction height, power, or the time on the provider chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"Proposed solution​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#proposed-solution","content":" As a first iteration, we propose the following approach. At the moment the provider receives evidence of equivocation on a consumer:  slash all the undelegations and redelegations using slashFactor;slash all delegations using as voting power the sum of the voting power of the misbehaving validator and the power of all the ongoing undelegations and redelegations.  Evidence expiration: Additionally, because we cannot infer the actual time of the evidence (i.e., the timestamp of the evidence cannot be trusted), we do not consider evidence expiration and hence old evidence is never ignored (e.g., the provider would act on 3 year-old evidence of equivocation on a consumer). Additionally, we do not need to store equivocation evidence to avoid slashing a validator more than once, because we do not slash tombstoned validators and we tombstone a validator when slashed.  We do not act on evidence that was signed by a validator consensus key that is pruned when we receive the evidence. We prune a validator's consensus key if the validator has assigned a new consumer key (using MsgAssignConsumerKey) and an unbonding period on the consumer chain has elapsed (see key assignment ADR). Note that the provider chain is informed that the unbonding period has elapsed on the consumer when the provider receives a VSCMaturedPacket and because of this, if the consumer delays the sending of a VSCMaturedPacket, we would delay the pruning of the key as well.  ","version":"v6.3.0","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#implementation","content":" The following logic needs to be added to the HandleConsumerDoubleVoting and HandleConsumerMisbehaviour methods:  undelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetUnbondingDelegationsFromValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // undelegation no longer eligible for slashing, skip it continue } undelegationsInTokens = undelegationsInTokens.Add(entry.InitialBalance) } } redelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetRedelegationsFromSrcValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // redelegation no longer eligible for slashing, skip it continue } redelegationsInTokens = redelegationsInTokens.Add(entry.InitialBalance) } } infractionHeight := 0 undelegationsAndRedelegationsInPower = sdk.TokensToConsensusPower(undelegationsInTokens.Add(redelegationsInTokens)) totalPower := validator's voting power + undelegationsAndRedelegationsInPower slashFraction := k.slashingKeeper.SlashFractionDoubleSign(ctx) k.stakingKeeper.Slash(ctx, validatorConsAddress, infractionHeight, totalPower, slashFraction, DoubleSign)   Infraction height: We provide a zero infractionHeight to the Slash method in order to slash all ongoing undelegations and redelegations (see checks in Slash, SlashUnbondingDelegation, and SlashRedelegation).  Power: We pass the sum of the voting power of the misbehaving validator when the evidence was received (i.e., at evidence height) and the power of all the ongoing undelegations and redelegations. If we assume that the slashFactor is 5%, then the voting power we pass is power + totalPower(undelegations) + totalPower(redelegations). Hence, when the Slash method slashes all the undelegations and redelegations it would end up with 0.05 * power + 0.05 * totalPower(undelegations) + 0.05 * totalPower(redelegations) - 0.05 * totalPower(undelegations) - 0.05 * totalPower(redelegations) = 0.05 * power and hence it would slash 5% of the validator's power when the evidence is received.  ","version":"v6.3.0","tagName":"h3"},{"title":"Positive​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#positive","content":" With the proposed approach we can quickly implement slashing functionality on the provider chain for consumer chain equivocations. This approach does not need to change the staking module and therefore does not change in any way how slashing is performed today for a single chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#negative","content":" We definitely slash more when it comes to undelegations and redelegations because we slash for all of them without considering an infractionHeight.We potentially slash more than what we would have slashed if we knew the voting power at the corresponding infractionHeight in the provider chain.We slash on old evidence of equivocation on a consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.3.0/adrs/adr-013-equivocation-slashing#references","content":" ADR 005: Cryptographic verification of equivocation evidenceEPIC tracking cryptographic equivocation featureCosmos Hub Forum discussion on cryptographic equivocation slashing ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 014: Epochs","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs#changelog","content":" 2024-01-05: Proposed, first draft of ADR.2024-02-29: Updated so that it describes the implementation where we store the whole consumer validator set.  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs#context","content":" In every block that the provider valset changes, a VSCPacket must be sent to every consumer and a corresponding VSCMaturedPacket sent back. Given that the validator powers may change very often on the provider chain (e.g., the Cosmos Hub), this approach results in a large workload for the relayers. Although the validator powers may change very often, these changes are usually small and have an insignificant impact on the chain's security. In other words, the valset on the consumers can be slightly outdated without affecting security. As a matter of fact, this already happens due to relaying delays.  As a solution, this ADR introduces the concept of epochs. An epoch consists of multiple blocks. The provider sends VSCPackets once per epoch. A VSCPacket contains all the validator updates that are needed by a consumer chain.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs#decision","content":" The implementation of epochs requires the following changes:  For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. For each validator in the set we store i) its voting power, and ii) the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. The initial consumer validator set for a chain is set during the creation of the consumer genesis.We introduce the BlocksPerEpoch param that sets the number of blocks in an epoch. By default, BlocksPerEpoch is set to be 600 which corresponds to 1 hour, assuming 6 seconds per block. This param can be changed through a governance proposal. In the provider EndBlock we check BlockHeight() % BlocksPerEpoch() == 0to decide when an epoch has ended.At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacket with all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   Note that a validator can change its consumer public key for a specific consumer chain an arbitrary amount of times during a block and during an epoch. Then, when we generate the validator updates in DiffValidators, we have to check whether the current consumer public key (retrieved by calling GetValidatorConsumerPubKey) is different from the consumer public key the validator was using in the current epoch.  ","version":"v6.3.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs#positive","content":" Reduce the cost of relaying.Reduce the amount of IBC packets needed for ICS.Simplifies key-assignment code because we only need to check if the consumer_public_key has been modified since the last epoch to generate an update.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs#negative","content":" Increase the delay in the propagation of validator set changes (but for reasonable epoch lengths on the order of ~hours or less, this is unlikely to be significant).  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs#neutral","content":" N/A  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.3.0/adrs/adr-014-epochs#references","content":" EPIC ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 011: Improving testing and increasing confidence","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#changelog","content":" 2023-08-11: Proposed, first draft of ADR.  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#status","content":" Proposed  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#context","content":" Testing, QA, and maintenance of interchain-security libraries is an ever-evolving area of software engineering we have to keep incrementally improving. The purpose of the QA process is to catch bugs as early as possible. In an ideal development workflow a bug should never reach production. A bug found in the specification stage is a lot cheaper to resolve than a bug discovered in production (or even in testnet). Ideally, all bugs should be found during the CI execution, and we hope that no bugs will ever even reach the testnet (although nothing can replace actual system stress test under load interacting with users).  During development and testnet operation the following types of bugs were the most commonly found:  improper iterator usageunbounded array access/iterationimproper input handling and validationimproper cached context usagenon-determinism check (improper use of maps in go, relying on random values)KV store management and/or how keys are defineddeserialization issues arising from consumer/provider versioning mismatch  Such bugs can be discovered earlier with better tooling. Some of these bugs can induce increases in block times, chain halts, state corruption, or introduce an attack surface which is difficult to remove if other systems have started depending on that behavior.  Current state of testing​  Our testing suites consist of multiple parts, each with their own trade-offs and benefits with regards to code coverage, complexity and confidence they provide.  ","version":"v6.3.0","tagName":"h2"},{"title":"Unit testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#unit-testing","content":" Unit testing is employed mostly for testing single-module functionality. It is the first step in testing and often the most practical. While highly important, unit tests often test a single piece of code and don't test relationships between different moving parts, this makes them less valuable when dealing with multi-module interactions.  Unit tests often employ mocks to abstract parts of the system that are not under test. Mocks are not equivalent to actual models and should not be treated as such.  Out of all the approaches used, unit testing has the most tools available and the coverage can simply be displayed as % of code lines tested. Although this is a very nice and very easy to understand metric, it does not speak about the quality of the test coverage.  Since distributed systems testing is a lot more involved, unit tests are oftentimes not sufficient to cover complex interactions. Unit tests are still necessary and helpful, but in cases where unit tests are not helpful e2e or integration tests should be favored.  ","version":"v6.3.0","tagName":"h3"},{"title":"Integration testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#integration-testing","content":" With integration testing we test the multi-module interactions while isolating them from the remainder of the system. Integration tests can uncover bugs that are often missed by unit tests.  It is very difficult to gauge the actual test coverage imparted by integration tests and the available tooling is limited. In interchain-security we employ the ibc-go/testing framework to test interactions in-memory.  At present, integration testing does not involve the consensus layer - it is only concerned with application level state and logic.  ","version":"v6.3.0","tagName":"h3"},{"title":"End-to-end testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#end-to-end-testing","content":" In our context end-to-end testing comprises of tests that use the actual application binaries in an isolated environment (e.g. docker container). During test execution the inputs are meant to simulate actual user interaction, either by submitting transactions/queries using the command line or using gRPC/REST APIs and checking for state changes after an action has been performed. With this testing strategy we also include the consensus layer in all of our runs. This is the closest we can get to testing user interactions without starting a full testnet.  End-to-end testing strategies vary between different teams and projects and we strive to unify our approach to the best of our ability (at least for ICS and gaia).  The available tooling does not give us significant (or relevant) line of code coverage information since most of the tools are geared towards analyzing unit tests and simple code branch evaluation.  We aim to adapt our best practices by learning from other similar systems and projects such as cosmos-sdk, ibc-go and CometBFT.  ","version":"v6.3.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#decision","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"1. Connect specifications to code and tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#1-connect-specifications-to-code-and-tooling","content":" Oftentimes, specifications are disconnected from the development and QA processes. This gives rise to problems where the specification does not reflect the actual state of the system and vice-versa. Usually specifications are just text files that are rarely used and go unmaintained after a while, resulting in consistency issues and misleading instructions/expectations about system behavior.  Decision context and hypothesis​  Specifications written in a dedicated and executable specification language are easier to maintain than the ones written entirely in text. Additionally, we can create models based on the specification OR make the model equivalent to a specification.  Models do not care about the intricacies of implementation and neither do specifications. Since both models and specifications care about concisely and accurately describing a system (such as a finite state machine), we see a benefit of adding model based tools (such as quint) to our testing and development workflows.  Main benefit​  MBT tooling can be used to generate test traces that can be executed by multiple different testing setups.  ","version":"v6.3.0","tagName":"h3"},{"title":"2. Improve e2e tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#2-improve-e2e-tooling","content":" Matrix tests​  Instead of only running tests against current main branch we should adopt an approach where we also:  run regression tests against different released software versions (ICS v1 vs v2 vs v3)run non-determinism tests to uncover issues quickly  Matrix tests can be implemented using CometMock and refactoring our current e2e CI setup.  Introducing e2e regression testing​  This e2e test suite would execute using a cronjob in our CI (nightly, multiple times a day etc.)  Briefly, the same set of traces is run against different maintained versions of the software and the main branch. This would allow us to discover potential issues during development instead of in a testnet scenarios.  The most valuable issues that can be discovered in this way are state breaking changes, regressions and version incompatibilities.  The setup is illustrated by the image below.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  USES: ICS v1 PROVIDER\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv1 consumer (sdk45,ibc4.3)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v2 consumer (sdk45, ibc4.4)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v3 consumer (sdk47, ibc7)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main consumer\t❌\t❌\t❌\t❌\t❌\t❌\t❌\t❌ neutron\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌ stride\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌  Introducing e2e CometMock tests​  CometMock is a mock implementation of the CometBFT consensus engine. It supports most operations performed by CometBFT while also being lightweight and relatively easy to use.  CometMock tests allow more nuanced control of test scenarios because CometMock can &quot;fool&quot; the blockchain app into thinking that a certain number of blocks had passed.This allows us to test very nuanced scenarios, difficult edge cases and long-running operations (such as unbonding operations).  Examples of tests made easier with CometMock are listed below:  regression testsnon-determinism testsupgrade testsstate-breaking changes  With CometMock, the matrix test approach can also be used. The image below illustrates a CometMock setup that can be used to discover non-deterministic behavior and state-breaking changes.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  SCENARIO\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv3 provi + v3 consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main provi + main consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ commit provi + commit consu\t✅\t❌\t✅\t❌\t✅\t✅\t❌\t❌  Briefly; multiple versions of the application are run against the same CometMock instance and any deviations in app behavior would result in app hash errors (the apps would be in different states after performing the same set of actions).  ","version":"v6.3.0","tagName":"h3"},{"title":"3. Introduce innovative testing approaches​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#3-introduce-innovative-testing-approaches","content":" When discussing e2e testing, some very important patterns emerge - especially if test traces are used instead of ad-hoc tests written by hand.  We see a unique opportunity to clearly identify concerns and modularize the testing architecture.  The e2e testing frameworks can be split into a pipeline consisting of 3 parts: model, driver and harness.  Model​  Model is the part of the system that can emulate the behavior of the system under test. Ideally, it is very close to the specification and is written in a specification language such as quint, TLA+ or similar. One of the purposes of the model is that it can be used to generate test traces.  Driver​  The purpose of the driver is to accept test traces (generated by the model or written by hand), process them and provide inputs to the next part of the pipeline.  Basically, the driver sits between the model and the actual infrastructure on which the test traces are being executed on.  Harness​  Harness is the infrastructure layer of the pipeline that accepts inputs from the driver.  There can be multiple harnesses as long as they can perform four things:  bootstrap a test execution environment (local, docker, k8s…)accept inputs from driversperform the action specified by the driverreport results after performing actions  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#consequences","content":" The procedure outlined in this ADR is not an all-or-nothing approach. Concepts introduced here do not rely on each other, so this ADR may only be applied partially without negative impact on test coverage and code confidence.  ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#positive","content":" introduction of maintainable MBT solutions  improvement over the current &quot;difftest&quot; setup that relies on an opinionated typescript model and go driver  increased code coverage and confidence  using CometMock allows us to run more tests in less timeadding matrix e2e tests allows us to quickly pinpoint differences between code versions  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#negative","content":" It might be easier to forgo the MBT tooling and instead focus on pure property based testing  PBT proof of conceptproperty based testing in go  The solutions are potentially expensive if we increase usage of the CI pipeline - this is fixed by running &quot;expensive&quot; tests using a cronjob, instead of running them on every commit.  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#neutral","content":" The process of changing development and testing process is not something that can be thought of and delivered quickly. Luckily, the changes can be rolled out incrementally without impacting existing workflows.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.3.0/adrs/adr-011-improving-test-confidence#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  https://github.com/cosmos/gaia/issues/2427https://github.com/cosmos/gaia/issues/2420ibc-go e2e tests ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 016: Security aggregation","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#changelog","content":" 2024-04-24: Initial draft of ADR  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#status","content":" Proposed  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#context","content":" Security Aggregation enables staking of tokens from external sources such as Ethereum or Bitcoin to Cosmos blockchains. By integrating Security Aggregation, a Cosmos blockchain can be secured by both native tokens and external tokens (e.g. ETH, BTC).  Security Aggregation consists of the following parts:  A mechanism for delegating external tokens to Cosmos validators, such as Babylon or EigenLayer AVS contract.An oracle that tracks how much external stake has been delegated to each Cosmos validator and provides price feeds for external tokens.Power mixing: a mechanism to combine external and native stake to derive the power of each validator.A reward distribution protocol that enables sending back rewards to the external source.  External staking information is received from an oracle together with price information of related stakes. The CosmosLayer derives validator powers based on external and native staking information and initiates rewarding of external depositors.  This ADR describes the Cosmos modules of the solution.  ","version":"v6.3.0","tagName":"h2"},{"title":"Alternative Approaches​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#alternative-approaches","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Rewards​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#rewards","content":" As an alternative to sending rewards back to the external chains, stakers could be rewarded on the Cosmos chain. This would require a mapping of external addresses to addresses on Cosmos chain for each staker on external source. In addition detailed external staking information such as staking addresses, amount of stakes per staker and validator, etc. have to be provided by the oracle.  ","version":"v6.3.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#decision","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#rewards-will-be-sent-back-to-external-chains-instead-of-paying-rewards-for-external-stakers-on-cosmos-chain","content":" Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain  due to amount of additional staking information to be sent and tracked by the oracledue to the additional complexity of managing external and Cosmos addresses  ","version":"v6.3.0","tagName":"h3"},{"title":"Detailed Design​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#detailed-design","content":" The Power Mixing feature and Reward Distribution protocol are an integral part of the Security Aggregation solution. The Power Mixing module provides the capability of deriving validator power based on stake originated from external sources such as Ethereum/Bitcoin and the native staking module. The Reward Distribution manages the process of sending rewards to external stakers.  ","version":"v6.3.0","tagName":"h2"},{"title":"Power Mixing​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#power-mixing","content":" Power Mixing provides the final validator powers based on staking information of the native chain and the external stakes. The information about external staking and related price feeds are received from an oracle. Once the final validator powers are determined the result is submitted to the underlying CometBFT consensus layer by updating the validator set.  Requirements:  validator updates are performed on each EndBlocka validator's power is determined based on its native on-chain stakes and external stakesprice information of staked tokens is used to determine a validator’s power, e.g. price ratio (price of native on-chain token / price of external stake)price information of native/external tokens are received from an oraclestaking information from external sources received from the oraclenative staking information are received from the Cosmos SDK Staking Moduleset of validator stakes from oracle always have the current price, full set of validators, and current stakes  The Power Mixing implementation  queries current validators and their powers from x/stakingand from oracle (see below).calculates power updates by mixing power values of external and internal sources Following pseudocode snippet shows a possible implementation of how power mixing feature works.  // PowerSource is an abstract entity providing validator powers which // are used by the mixer. This can be an oracle, staking module or an // IBC connected bridge. type PowerSource interface { GetValidatorUpdates() []abci.ValidatorUpdate } // MixPowers calculates power updates by mixing validator powers from different sources func (k *Keeper) MixPowers(source ...PowerSource) []abci.ValidatorUpdate { var valUpdate []abci.ValidatorUpdate for _, ps := range source { // mix powers from two sets of validator updates an return set of validator updates // with aggregated powers valUpdate = mixPower(valUpdate, ps.GetValidatorUpdates()) } return valUpdate } func (k *keeper) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { // GetPowerSources (including local staking module) registeredPowerSource := GetPowerSources() return k.MixPowers(registeredPowerSource...) }   Integration with ICS provider​  The provider module updates the validator set on CometBFT instead of the SDK staking module (x/staking). The provider implementation will intervene in this behavior and ensure that the validator updates are taken from the Power Mixing feature.  External power sources are managed by the provider module. Only registered power sources can provide input to the Power Mixing feature. Power sources will be assigned a unique identifier which will be used by the oracle, provider module and the power mixing and rewarding feature.  Updates with the next validator set are sent to consumer chains on each epoch (see EndBlockVSU()). When collecting the validator updates for each consumer chain (see QueueVSCPackets()), the validator powers of the bonded validators will be updated with the validator powers from the external sources using the Power Mixing module. These updates are sent as part of the VSC packets to all registered consumer chains.  Integration with ICS consumer​  Consumer chains receive validator updates as part of VSC packets from the provider. These packets contain validator powers which were already mixed with external staked powers.  ","version":"v6.3.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#queries","content":" // GetValidatorUpdates returns the power mixed validator results from the provided sources service Query { rpc GetValidatorUpdates(PowerMixedValUpdateRequest) PowerMixedValUpdateResponse {}; } // PowerMixedValUpdateRequest contains the list of power sources on which the // power mixing should be based on message PowerMixedValUpdateRequest { repeated PowerSource sources; } // PowerMixedValUpdateResponse returns the validator set with the updated powers // from the power mixing feature message PowerMixedValUpdateResponse { repeated abci.ValidatorUpdate val_set }   The following queries will be provided by the oracle  service Query { rpc GetExtValidators(GetExtValidatorRequest) returns (ExtValidatorsResponse) { option (google.api.http).get = &quot;oracle/v1/get_validators&quot;; }; } message GetExtValidatorRequest {} // ExtValidatorsResponse is the response from GetExtValidators queries message ExtValidatorsResponse { repeated ExtValPower powers; } // ExtValPower represents a validator with its staking and token information, // where: // `power_source_identifier` is the identifier of the registered power source // `validator_address` is the address of the validator // `stakes` is the total amount of stakes for a validator // `denom` is the source token of the stake e.g. ETH,BTC // `price_ratio` is the ratio of price of the external token to the price of the 'local' token message ExtValPower { string power_source_identifier; string validator_address; uint64 stakes; string denom; float price_ratio; } // GetPrice returns a price feed for a given token service Query { rpc GetPrice(GetPriceRequest) returns (GetPriceResponse) { option (google.api.http).get = &quot;/oracle/v1/get_price&quot;; }; }   For security reasons the amount of external stakes needs to be limited. Limitation of external staking could be driven by governance and is not subject of this version of the ADR.  ","version":"v6.3.0","tagName":"h3"},{"title":"Reward Handler​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#reward-handler","content":" For native staked tokens the Distribution Module of the Cosmos SDK is taking care of sending the rewards to stakers. For stakes originated from external chains (Ethereum/Bitcoin) the Reward Handler module sends rewards to EigenLayer/Babylon. The transfer of rewards is done using a bridge between the Cosmos chain and the external provider chain.  Note: currently there's no support paying rewards on EigenLayer (see here)  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#positive","content":" Allow external depositors to stake their tokens to secure a Cosmos chain  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#negative","content":" Dependency to external sources e.g (price feeds) for validator power calculationSecurity impact  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#neutral","content":" Additional complexity for staking  ","version":"v6.3.0","tagName":"h3"},{"title":"Questions:​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#questions","content":" Slashing: subject of this ADR? (Defined but not activated currently on EigenLayer).  ","version":"v6.3.0","tagName":"h2"},{"title":"References​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.3.0/adrs/adr-016-securityaggregation#references","content":" EigenLayerBabylon ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 017: ICS with Inactive Provider Validators","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#changelog","content":" 15th May 2024: Initial draft  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#context","content":" Currently, only validators in the active set on the provider can validate on consumer chains, which limits the number of validators that can participate in Interchain Security (ICS). Validators outside of the active set might be willing to validate on consumer chains, but we might not want to make the provider validator set larger, e.g. to not put more strain on the consensus engine. This runs the risk of leaving consumer chains with too few validators.  The purpose of this ADR is to allow validators that are not part of the consensus process on the provider chain (because they are inactive) to validate on consumer chains.  In the context of this ADR, &quot;consensus validator set&quot; is the set of validators participating in the consensus protocol, and &quot;staking validator set&quot; is the set of validators viewed as active by the staking module.  Currently, the staking module, provider module, and CometBFT interact in this way:    The staking module keeps a list of validators. The MaxValidators validators with the largest amount of stake are &quot;active&quot; validators. MaxValidators is a parameter of the staking module. The staking module sends these validators to CometBFT to inform which validators make up the next consensus validators, that is, the set of validators participating in the consensus process. Separately, the provider module reads the list of bonded validators and sends this to the consumer chain, after shaping it according to which validators are opted in and the parameters set by the consumer chain for allowlist, denylist, etc.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#decision","content":" The proposed solution to allow validators that are not participating in the consensus process on the provider (inactive validators) is to change 3 main things:  a) increase the MaxValidators parameter of the staking module  b) do not take the updates for CometBFT directly from the bonded validators in the staking module, by wrapping the staking modules EndBlocker with a dummy EndBlocker that doesn't return any validator updates. Instead, we adjust the provider module to return validator updates on its EndBlocker. These validator updates are obtained by filtering the bonded validators to send only the first MaxProviderConsensusValidators (sorted by largest amount of stake first) many validators to CometBFT  c) use the enlarged list of bonded validators from the staking module as basis for the validator set that the provider module sends to consumer chains (again after applying power shaping and filtering out validators that are not opted in).  In consequence, the provider chain can keep a reasonably-sized consensus validator set, while giving consumer chains a much larger pool of potential validators.    Some additional considerations:  Migration: In the migration, the last consensus validator set will be set to the last active validator set from the view of the staking module. Existing consumer chains are migrated to have a validator set size cap (otherwise, they could end up with a huge validator set including all the staking-but-not-consensus-active validators from the provider chain)Slashing: Validators that are not part of the active set on the provider chain can still be jailed for downtime on a consumer chain (via an Interchain Security SlashPacket sent to the provider, who will then jail the validator), but they are not slashed for downtime on the provider chain. This is achieved without any additional changes to the slashing module, because the slashing module checks for downtime by looking at the consensus participants reported by CometBFT, and thus with the proposed solution, validators that are not part of the consensus validators on the provider chain are not considered for downtime slashing (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/slashing/abci.go#L22).Rewards: Validators that are not part of the active set on the provider chain can still receive rewards on the consumer chain, but they do not receive rewards from the provider chain. This change is achieved without further changes to staking or reward distributions, because similar to downtime, rewards are based on the consensus validator set (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/distribution/abci.go#L28)  ","version":"v6.3.0","tagName":"h2"},{"title":"Changes to the state​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#changes-to-the-state","content":" The following changes to the state are required:  Introduce the MaxProviderConsensusValidators parameter to the provider module, which is the number of validators that the provider module will send to the consensus engine.Store the provider consensus validator set in the provider module state under the LastProviderConsensusValsPrefix key. This is the last set of validators that the provider sent to the consensus engine. This is needed to compute the ValUpdates to send to the consensus engine (by diffing the current set with this last sent set).Increase the MaxValidators parameter of the staking module to the desired size of the potential validator set of consumer chains.Introduce extra per-consumer-chain parameters: MinStake: is the minimum amount of stake a validator must have to be considered for validation on the consumer chain.AllowInactiveVals: is a boolean that determines whether validators that are not part of the active set on the provider chain can validate on the consumer chain. If this is set to true, validators outside the active set on the provider chain can validate on the consumer chain. If this is set to true, validators outside the active set on the provider chain cannot validate on the consumer chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"Risk Mitigations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#risk-mitigations","content":" To mitigate risks from validators with little stake, we introduce a minimum stake requirement for validators to be able to validate on consumer chains, which can be set by each consumer chain independently, with a default value set by the provider chain.  Additional risk mitigations are to increase the active set size slowly, and to monitor the effects on the network closely. For the first iteration, we propose to increase the active set size to 200 validators (while keeping the consensus validators to 180), thus letting the 20 validators with the most stake outside of the active set validate on consumer chains.  ","version":"v6.3.0","tagName":"h2"},{"title":"Testing Scenarios​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#testing-scenarios","content":" In the following,  bonded validators refers to all validators that have bonded stake,active validators refers to the validators that take part in consensus,inactive validators refers to bonded validators that are not active validators.  ","version":"v6.3.0","tagName":"h2"},{"title":"Scenario 1: Inactive validators should not be considered by governance​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#scenario-1-inactive-validators-should-not-be-considered-by-governance","content":" Inactive validators should not be considered for the purpose of governance. In particular, the quorum should depend only on active validators.  We test this by:  creating a provider chain (either with 3 active validators, or with only 1 active validator), a quorum of 50%, and 3 validators with alice=300, bob=299, charlie=299 stakewe create a governance proposalalice votes for the proposalwe check that the proposal has the right status: in the scenario where we have 3 active validators, the proposal should not have passed, because alice alone is not enough to fulfill the quorumin the scenario where we have 1 active validator, the proposal should have passed, because alice is the only active validator, and thus fulfills the quorum  Tested by the e2e tests inactive-provider-validators-governance (scenario with 1 active val) and inactive-provider-validators-governance-basecase (scenario with 3 active vals).  ","version":"v6.3.0","tagName":"h3"},{"title":"Scenario 2: Inactive validators should not get rewards from the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#scenario-2-inactive-validators-should-not-get-rewards-from-the-provider-chain","content":" Inactive validators should not get rewards from the provider chain.  This can be tested by starting a provider chain with inactive validators and checking the rewards of inactive validators.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"Scenario 3: Inactive validators should get rewards from consumer chains​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#scenario-3-inactive-validators-should-get-rewards-from-consumer-chains","content":" An inactive validator that is validating on a consumer chain should receive rewards in the consumer chain token.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"Scenario 4: Inactive validators should not get slashed/jailed for downtime on the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#scenario-4-inactive-validators-should-not-get-slashedjailed-for-downtime-on-the-provider-chain","content":" This can be tested by having an inactive validator go offline on the provider chain for long enough to accrue downtime. The validator should be neither slashed nor jailed for downtime.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"Scenario 5: Inactive validators should get jailed for consumer downtime on the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#scenario-5-inactive-validators-should-get-jailed-for-consumer-downtime-on-the-provider-chain","content":" This can be tested by having an inactive validator go offline on a consumer chain for long enough to accrue downtime. The consumer chain should send a SlashPacket to the provider chain, which should jail the validator.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"Scenario 6: Inactive validators should not be counted when computing the minimum power in the top N​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#scenario-6-inactive-validators-should-not-be-counted-when-computing-the-minimum-power-in-the-top-n","content":" This can be tested like this:  Start a provider chain with validator powers alice=300, bob=200, charlie=100 and 2 max provider consensus validators So alice and bob will validate on the provider Start a consumer chain with top N = 51%. Without inactive validators, this means both alice and bob have to validate. But since charlie is inactive, this means bob is not in the top N Verify that alice is in the top N, but bob is not  Checked as part of the e2e test inactive-vals-topN.  ","version":"v6.3.0","tagName":"h3"},{"title":"Scenario 7: Mint does not consider inactive validators​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#scenario-7-mint-does-not-consider-inactive-validators","content":" To compute the inflation rate, only the active validators should be considered.  We can check this by querying the inflation rate change over subsequent blocks.  We start a provider chain with these arguments  3 validators with powers alice=290, bob=280, charlie=270either 1 or 3 active validatorsa bonded goal of 300 tokens (this is given in percent, but we simplify here)  If we have 3 validators active, then the inflation rate should decrease between blocks, because the bonded goal is exceeded as all validators are bonded. If we have only 1 validator active, then the inflation rate should increase between blocks, because the bonded goal is not met.  Checked as part of the e2e tests inactive-vals-mint (scenario with 1 active val) and mint-basecase (scenario with 3 active vals).  ","version":"v6.3.0","tagName":"h3"},{"title":"Scenarios 8: Inactive validators can validate on consumer chains​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#scenarios-8-inactive-validators-can-validate-on-consumer-chains","content":" An inactive validator can opt in and validate on consumer chains (if min stake allows it)  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"Scenario 9: MinStake parameters is respected​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#scenario-9-minstake-parameters-is-respected","content":" Validators that don't meet the criteria for a consumer chain cannot validate on it.  Checked in the e2e tests min-stake.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#positive","content":" Validators outside of the active set can validate on consumer chains without having an impact on the consensus engine of the provider chainConsumer chains can have a much larger validator set than the provider chain if they prefer this e.g. for decentralization reasonsConsumer chain teams can, with much less cost than today, start up their own consumer chain node to keep the chain running (in a centralized manner) even if no hub validators have opted in to validate on the chain. This is useful to stop the chain from ending up with an empty validator set and becoming recoverable only with a hardfork  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#negative","content":" Allowing validators from the inactive set brings with it some additional risks. In general, consumer chains will now face some of the problems also faced by standalone chains. It’s reasonable to assume that the validator set on the hub has a minimum amount of operational quality due to being battle tested and decentralized, and consumer chains with validators from outside the hub active set cannot rely on this as much anymore.  Sybil attacks​  With the restricted size of the active set today, it’s clear that the set is at least minimally competitive and it is not trivial to spin up multiple nodes as a validator.  When we make the “potential validator set” much larger, we should assume that it becomes much less competitive to be part of that set, and thus trivial for single entities to control many of those validators.  Reputational damage is not a deterrent​  For validators in the active set, we typically assume that if they would misbehave, they pay a large reputational cost. This represents delegators deciding to switch validators (potentially even on chains other than the one the misbehaviour happened on), and loss of credibility in the ecosystem. With the much larger active set, it seems prudent to assume that reputational damage is not a deterrent for many validators. They might only have minimal amounts of delegated stake and control most of it themselves, so they might not be deterred from performing actions that would usually bring reputational damage.  Additional negative consequences​  The provider keeper will need to implement the staking keeper interface, and modules need to be wired up to either the staking or provider keeper, depending on whether they need the consensus or staking validator setThis will impact how future modules are integrated, since we will need to consider whether those modules should consider the consensus validators or the bonded validators (which other modules might assume to be the same)  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#neutral","content":" There might be validators that are bonded, but not validating on any chain at all. This is not a problem, but it might be a bit confusing.  ","version":"v6.3.0","tagName":"h3"},{"title":"Alternative considerations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#alternative-considerations","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Modifying the staking module​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#modifying-the-staking-module","content":" We could instead adapt the staking module with a similar change. This might be better if it turns out that the staking module active set is used in many other places.  ","version":"v6.3.0","tagName":"h3"},{"title":"Allowing unbonding validators to validate​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#allowing-unbonding-validators-to-validate","content":" Instead of increasing the active set size, we could allow validators that are unbonded (but still exist on the provider) to validate consumer chains. For this, we would need to:  Modify the VSC updates to consider the set of all validators, even unbonded ones, instead of just active onesAdjust our downtime jailing/equivocation slashing logic to work correctly with unbonded validators. This is very hard, because redelegations are not usually tracked for unbonded validators.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.3.0/adrs/adr-017-allowing-inactive-validators#references","content":" Security Aggregation has similar concerns where the staking validator set will differ from the consensus validator set ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 018: Remove VSCMatured Packets","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#changelog","content":" 19/06/2024: Create initial draft  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#context","content":" The idea of removing VSCMatured packets was first suggested by Jae Kwon over a conversation in 2022. As a result of that conversation, an ADR was proposed to halt consumer chain if VSC packets are no longer received. The ADR was not accepted due to other considerations regarding the safety of consumer chains. See this blog post for more details.  The consumer module on the consumer chains is a representation of the Hub’s staking module, i.e., it provides an asynchronous view of the voting powers and indirectly of the locked collateral. The key word here is asynchronous, which means that (in theory) there is no bound on the lag between the Hub’s view of stake and the consumer’s view of stake. The reasons for this asynchrony are relaying delays and chain liveness (e.g., a consumer could be down for a long period of time without affecting the liveness of the staking module on the Hub).  The current version of ICS uses VSCMaturedPackets to create on the consumers a partially synchronous view of the Hub’s staking module. Partially synchronous means that the lag between the Hub’s view of stake and the consumer’s view of stake is bounded, because consumers that exceed this lag are forcibly removed from the protocol. Basically, unlocking collateral from the Hub is being delayed until the consumers’ UnbondingPeriod elapses. The reason the view is only partially synchronous is that eventually the collateral is unlocked, i.e., if VSCMaturedPackets are not received from a consumer for VscTimeoutPeriod (default: 5 weeks), then the consumer is removed from ICS and the collateral is unlocked. Note that keeping the stake locked “forever” would affect the Hub’s liveness, so it’s not a viable option.  The issue is that whatever attack is possible with an asynchronous view of the staking module, it is eventually possible with the partially synchronous view as well. For example, an attacker could wait for VscTimeoutPeriod for the collateral to be unlocked and then send invalid headers to third-party chains that are not aware the consumer's collateral is no longer locked on the Hub (i.e., the consumer is no longer part of ICS).  Moreover, with the introduction of PSS, a consumer’s validator set could “lie” about its UnbondingPeriod elapsing by sending VSCMaturedPackets earlier. This would result in a discrepancy between a light client’s view of the UnbondingPeriod and the actual Hub’s UnbondingPeriod.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#decision","content":" This ADR proposes the removal of VSCMaturedPackets. The reason is twofold. First, VSCMaturedPackets provide a &quot;false&quot; sense of correctness as the attack described above is still possible. Second, VSCMaturedPackets add considerable complexity to the ICS protocol -- an extra message plus the pausing of unbonding operations that can affect the UX.  To simplify the upgrading process, removing VSCMaturedPackets can be done in two releases:  (R1) Update the provider to drop VSCMaturedPackets.(R2) Update the consumer to stop sending VSCMaturedPackets.  As a result, once the provider chain runs R1, the consumers can start upgrading to R2.  ","version":"v6.3.0","tagName":"h2"},{"title":"Provider Changes (R1)​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#provider-changes-r1","content":" Parameters​  Deprecate the InitTimeoutPeriod and VscTimeoutPeriod parameters.  State​  Add the following key prefix to the state:  ConsumerAddrsToPruneV2BytePrefix -- the byte prefix for storing consumer validators addresses that need to be pruned. These are stored as ConsumerAddrsToPruneV2BytePrefix | len(chainID) | chainID | ts -&gt; (consumer_address1, consumer_address2, ...) where ts is the timestamp at which the consumer validators addresses can be pruned.  Migrate the consumer validator addresses stored under the ConsumerAddrsToPruneBytePrefix to the new prefix ConsumerAddrsToPruneV2BytePrefix. Note that these consumer validators addresses are stored as  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; (consumer_address1, consumer_address2, ...)   where vscID is the ID of the first VSCPacket sent after these consumer validator addresses were changed. These means that we can use the VscSendTimestamps to compute the timestamps when these consumer validator addresses can be pruned, i.e.,  func MigrateConsumerAddrsToPrune() iterator := sdk.KVStorePrefixIterator(store, []byte{providertypes.ConsumerAddrsToPruneBytePrefix}) for ; iterator.Valid(); iterator.Next() { chainID, vscID, _ := providertypes.ParseChainIdAndUintIdKey(providertypes.ConsumerAddrsToPruneBytePrefix, iterator.Key()) // use the VscSendTimestamp index to compute the timestamp at which this consumer addresses can be pruned vscSendTimestampKey := providertypes.ChainIdAndUintIdKey(providertypes.VscSendTimestampBytePrefix, chainID, vscID) timeBz := store.Get(vscSendTimestampKey) sentTime, _ := sdk.ParseTimeBytes(timeBz) pruneTs := sentTime.Add(sk.UnbondingTime(ctx)) var addrs providertypes.AddressList addrs.Unmarshal(iterator.Value()) for _, addr := range addrs.Addresses { consumerAddr := providertypes.NewConsumerConsAddress(addr) pk.AppendConsumerAddrsToPrune(ctx, chainID, pruneTs, consumerAddr) } } }   Remove the following key prefixes from the state. Note that these removals require state migration.  MaturedUnbondingOpsByteKey -- the byte key that stores the list of all unbonding operations ids that have matured from a consumer chain perspective.UnbondingOpBytePrefix -- the byte prefix that stores a record of all the ids of consumer chains that need to unbond before a given unbonding operation can unbond on this chain.UnbondingOpIndexBytePrefix -- the byte prefix of the index for looking up which unbonding operations are waiting for a given consumer chain to unbond.InitTimeoutTimestampBytePrefix -- the byte prefix for storing the init timeout timestamp for a given consumer chainID.VscSendTimestampBytePrefix -- the byte prefix for storing the list of VSC sending timestamps for a given consumer chainID.ConsumerAddrsToPruneBytePrefix -- the byte prefix for storing the mapping from VSC IDs to consumer validators addresses that need to be pruned.  State Transitions​  Removing VSCMaturedPackets affects three ICS sub-protocols (see HandleVSCMaturedPacket): unbonding operations pausing, VSCPackets timeout, and key assignment pruning. The first two are no longer needed, while the third (key assignment pruning) needs to be redesigned to not depend on VSCMaturedPackets.  Removing unbonding operations pausing:  Make the AfterUnbondingInitiated hook a no-op. As a result, unbonding operations are no longer paused.Stop calling the UnbondingCanComplete method from the staking keeper. This entails, it is no longer necessary to append MaturedUnbondingOps and the completeMaturedUnbondingOps method can be removed.Note, that during the upgrade, all unbonding operations stored under the UnbondingOpBytePrefix prefix need to be completed (via the UnbondingCanComplete method from the staking keeper).Remove the init timeout timestamp logic from the following methods: CreateConsumerClient, SetConsumerChain, and EndBlockCCR.  Removing VSCPackets timeout:  Stop setting VSC send timestamps when sending VSCPackets.Stop removing the VSC send timestamps when receiving VSCMaturedPackets.Remove the logic from EndBlockCCR that checks if the first VSC send timestamp in iterator plus VscTimeoutPeriod exceeds the current block time.  Redesign key assignment pruning. The reason for keeping &quot;old&quot; consumer addresses is to enable slashing / jailing validators that misbehave on consumer chains, i.e., the slashing logic uses the GetProviderAddrFromConsumerAddr method that accesses the mapping from validator addresses on consumer chains to validator addresses on the provider chain (ValidatorsByConsumerAddrBytePrefix). Thus, &quot;old&quot; consumer addresses are no longer needed after the provider's UnbondingPeriod elapses. This means that once a validator changes its key on a consumer, we can prune the address corresponding to the &quot;old&quot; key after UnbondingPeriod. This requires the following changes:  Adapt the AppendConsumerAddrsToPrune() method to use the timestamp at which it is safe to prune the consumer validator address (instead of the current vscID).Add a new method ConsumeConsumerAddrsToPrune(ts) that returns the list of consumer addresses that can be pruned at timestamp ts.Adapt the PruneKeyAssignments() method to call ConsumeConsumerAddrsToPrune(ctx.BlockTime()).Call the PruneKeyAssignments() method from every EndBlock() instead of calling it from HandleVSCMaturedPacket().  Queries​  Remove the oldest_unconfirmed_vsc query.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consumer Changes (R2)​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#consumer-changes-r2","content":" Parameters​  Given that currently relayers use the consumer UnbondingPeriod (see ConsumerParams), this param cannot be deprecated. Note that Hermes queries the UnbondingPeriod for sanity checks and to set the default trusting period when it is not specified. As a result, the UnbondingTime method from the staking interface will continue to be used to retrieve the consumer's UnbondingPeriod.  State​  Remove the following key prefixes from the state:  PacketMaturityTimeBytePrefix -- the byte prefix that will store maturity time for each received VSC packet  Note that these removals require state migration.  State Transitions​  To stop the consumer chains from sending VSCMaturedPackets, it is sufficient to not store the maturity time of VSCPackets when receiving them, i.e., do not call SetPacketMaturityTime from the OnRecvVSCPacket() method. Note that eventually, no additional VSCMaturedPackets will be added to the sending queue as QueueVSCMaturedPackets iterates over elapsed maturity times. In addition, to clean up the code, the QueueVSCMaturedPackets must be removed.  Messages​  VSCMaturedPacketData is deprecated. Note that this is a wire-breaking change -- older consumer versions will send VSCMaturedPackets and older provider versions will expect to receive VSCMaturedPackets.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#positive","content":" Remove feature that provides a &quot;false&quot; sense of correctness.Remove unnecessary complexity, from both ICS and Cosmos SDK.Remove one IBC packet and, thus, reduce relaying cost.Remove unbonding pausing logic that could affect the UX.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#negative","content":" Large refactor that might introduce unexpected bugs.Consumer chains are no longer removed if the duration between creating a client and creating the CCV channel exceeds InitTimeoutPeriod. This means that if the CCV channel is not created on time, the client expires and the consumer chain can no longer start without a ClientUpdate proposal or re-submitting a ConsumerAdditionProposal.  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#neutral","content":" Consumer chains are no longer removed after a VscTimeoutPeriod of inactivity. Note that consumers are still removed if their CCV channel expires, which usually happens after two weeks instead of five weeks (the default value for VscTimeoutPeriod).  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.3.0/adrs/adr-018-remove-vscmatured#references","content":" PR #712 -- Proposal to set an expiration date on the consumer chain updated on each VSCPacket received to ensure the chain is up-to-date.Learning to Live with “Unbonding Pausing” blog post. ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 015: Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#changelog","content":" 2024-01-22: Proposed, first draft of ADR.  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#context","content":" Currently, in Replicated Security, the entire validator set of the provider chain is used to secure consumer chains. There are at least three concerns with this approach. First, a large number of validators might be forced to validate consumer chains they are not interested in securing. Second, it is costly for small validators to secure additional chains. This concern is only partially addressed through soft opt-out that allows small validators to opt out from validating consumer chains. Third and for the above reasons, it is challenging for a new consumer chain to join Replicated Security.  As a solution, we present Partial Set Security (PSS). As the name suggests, PSS allows for every consumer chain to be secured by only a subset of the provider validator set. In what follows we propose the exact steps we need to take to implement PSS. This is a first iteration of PSS, and therefore we present the most minimal solution that make PSS possible.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#decision","content":" In Replicated Security, all the provider validators have to secure every consumer chain (with the exception of those validators allowed to opt out through the soft opt-out feature).  In PSS, we allow validators to opt in and out of validating any given consumer chain. This has one exception: we introduce a parameter N for each consumer chain and require that the validators in top N% of the provider's voting power have to secure the consumer chain. Validators outside of the top N% can dynamically opt in if they want to validate on the consumer chain.  For example, if a consumer chain has N = 95%, then it ultimately receives the same security it receives today with Replicated Security (with a default SoftOptOutThreshold of 5%). On the other hand, if a consumer chain has N = 0%, then no validator is forced to validate the chain, but validators can opt in to do so instead.  For the remainder of this ADR, we call a consumer chain Top N if it has joined as a Top N chain with N &gt; 0 and Opt In chain otherwise. An Opt In consumer chain is secured only by the validators that have opted in to secure that chain.  We intend to implement PSS using a feature branch off v4.0.0 interchain security.  ","version":"v6.3.0","tagName":"h2"},{"title":"How do consumer chains join?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#how-do-consumer-chains-join","content":" As a simplification and to avoid chain id squatting, a consumer chain can only join PSS through a governance proposal and not in a permissionless way.  However, this proposal type will be modified so that it requires a lower quorum percentage than normal proposal, and every validator who voted &quot;YES&quot; on the proposal will form the consumer chain's initial validator set.  Consumer chains join PSS the same way chains now join Replicated Security, namely through a ConsumerAdditionProposal proposal. We extend ConsumerAdditionProposal with one optional field:  uint32 top_N: Corresponds to the percentage of validators that join under the Top N case. For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators have to validate the proposed consumer chain.top_N can be 0 or include any value in [50, 100]. A chain can join with top_N == 0 as an Opt In, or with top_N ∈ [50, 100] as a Top N chain.  In case of a Top N chain, we restrict the possible values of top_N from (0, 100] to [50, 100]. By having top_N &gt;= 50 we can guarantee that we cannot have a successful attack, assuming that at most 1/3 of provider validators can be malicious. This is because, a Top N chain with N &gt;= 50% would have at least 1/3 honest validators, which is sufficient to stop attacks. Additionally, by having N &gt;= 50% (and hence N &gt; (VetoThreshold = 33.4%)) we enable the top N validators to Veto any ConsumerAdditionProposal for consumer chains they do not want to validate.  If a proposal has the top_N argument wrongly set, it should get rejected in [ValidateBasic] (https://github.com/cosmos/interchain-security/blob/v4.0.0/x/ccv/provider/types/proposal.go#L86).  In the code, we distinguish whether a chain is Top N or Opt In by checking whether top_N is zero or not.  In a future version of PSS, we intend to introduce a ConsumerModificationProposal so that we can modify the parameters of a consumer chain, e.g, a chain that is Opt In to become Top N, etc.  State &amp; Query​  We augment the provider module’s state to keep track of the top_N value for each consumer chain. The key to store this information would be:  topNBytePrefix | len(chainID) | chainID   To create the above key, we can use ChainIdWithLenKey.  Then in the keeper we introduce methods as follows:  func (k Keeper) SetTopN(ctx sdk.Context, chainID string, topN uint32) func (k Keeper) IsTopN(ctx sdk.Context, chainID string) bool func (k Keeper) IsOptIn(ctx sdk.Context, chainID string) bool // returns the N if Top N chain, otherwise an error func (k Keeper) GetTopN(ctx sdk.Context, chainID string) (uint32, error)   We also extend the interchain-security-pd query provider list-consumer-chains query to return information on whether a consumer chain is an Opt In or a Top N chain and with what N. This way, block explorers can present informative messages such as &quot;This chain is secured by N% of the provider chain&quot; for consumer chains.  ","version":"v6.3.0","tagName":"h3"},{"title":"How do validators opt in?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#how-do-validators-opt-in","content":" A validator can opt in by sending a new type of message that we introduce in tx.proto.  message MsgOptIn { // the chain id of the consumer chain to opt in to string chainID = 1; // the provider address of the validator string providerAddr = 2; // (optional) the consensus public key to use on the consumer optional string consumerKey = 3; }   Note that in a Top N consumer chain, the top N% provider validators have to validate the consumer chain. Nevertheless, validators in the bottom (100 - N)% can opt in to validate as well. Provider validators that belong or enter the top N% validators are automatically opted in to validate a Top N consumer chain. This means that if a validator V belongs to the top N% validators but later falls (e.g., due to undelegations) to the bottom (100 - N)%, V is still considered opted in and has to validate unless V sends a MsgOptOut message (see below). By automatically opting in validators when they enter the top N% validators and by forcing top N% validators to explicitly opt out in case they fall to the (100 - N)% bottom validators we simplify the design of PSS.  Note that a validator can send a MsgOptIn message even if the consumer chain is not yet running. To do this we reuse the IsConsumerProposedOrRegistered. If the chainID does not exist, the MsgOptIn should fail, as well as if the provider address does not exist.  Optionally, a validator that opts in can provide a consumerKey so that it assigns a different consumer key (from the provider) to the consumer chain. Naturally, a validator can always change the consumer key on a consumer chain by sending a MsgAssignConsumerKey message at a later point in time, as is done in Replicated Security.  State &amp; Query​  For each validator, we store a pair (blockHeight, isOptedIn) that contains the block height the validator opted in and whether the validator is currently opted in or not, under the key:  optedInBytePrefix | len(chainID) | chainID | addr   By using a prefix iterator on optedInBytePrefix | len(chainID) | chainID we retrieve all the opted in validators.  We introduce the following Keeper methods.  // returns all the validators that have opted in on chain `chainID` func (k Keeper) GetOptedInValidators(ctx sdk.Context, chainID string) []Validators func (k Keeper) IsValidatorOptedIn(ctx sdk.Context, chainID string, val Validator) bool   We introduce the following two queries:  interchain-security-pd query provider optedInValidators $chainID interchain-security-pd query provider hasToValidate $providerAddr   One query to retrieve the validators that are opted in and hence the validators that need to validate the consumer chain and one query that given a validator's address returns all the chains this validator has to validate.  When do validators opt in?​  As described earlier, validators can manually opt in by sending a MsgOptIn message. Additionally, in a Top N chain, a validator is automatically opted in when it moves from the bottom (100 - N)% to the top N% validators.  Lastly, validators can also opt in if they vote Yes during the ConsumerAdditionProposal that introduces a consumer chain. This simplifies validators operations because they do not have to send an additional message to opt in.  Because the Tally method deletes the votes after reading them, we cannot check the votes of the validators after the votes have been tallied. To circumvent this, we introduce a hook for AfterProposalVote and keep track of all the votes cast by a validator. If a validator casts more than one vote, we only consider the latest vote. Finally, we only consider a validator has opted in if it casts a 100% Yes vote in case of a weighted vote.  ","version":"v6.3.0","tagName":"h3"},{"title":"How do validators opt out?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#how-do-validators-opt-out","content":" Validators that have opted in on a chain can opt out by sending the following message:  message MsgOptOut { // the chain id of the consumer chain to opt out from string chainID = 1; // the provider address of the validator string providerAddr = 2; }   Validators can only opt out after a consumer chain has started and hence the above message returns an error if the chain with chainID is not running. Additionally, a validator that belongs to the top N% validators cannot opt out from a Top N chain and hence a MsgOptOut would error in such a case.  State &amp; Query​  We also update the state of the opted-in validators when a validator has opted out by removing the opted-out validator.  Note that only opted-in validators can be punished for downtime on a consumer chain. For this, we use historical info of all the validators that have opted in; We can examine the blockHeight stored under the key optedInBytePrefix | len(chainID) | chainID | addr to see if a validator was opted in. This way we can jail validators for downtime knowing that indeed the validators have opted in at some point in the past. Otherwise, we can think of a scenario where a validator V is down for a period of time, but before V gets punished for downtime, validator V opts out, and then we do not know whether V should be punished or not.  ","version":"v6.3.0","tagName":"h3"},{"title":"When does a consumer chain start?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#when-does-a-consumer-chain-start","content":" A Top N consumer chain always starts at the specified date (spawn_time) if the ConsumerAdditionProposal has passed. An Opt In consumer chain only starts if at least one validator has opted in. We check this in BeginBlockInit:  func (k Keeper) BeginBlockInit(ctx sdk.Context) { propsToExecute := k.GetConsumerAdditionPropsToExecute(ctx) for _, prop := range propsToExecute { chainID := prop.ChainId if !k.IsTopN(ctx, chainID) &amp;&amp; len(k.GetOptedInValidators(ctx, chainID)) == 0 { // drop the proposal ctx.Logger().Info(&quot;could not start chain because no validator has opted in&quot;) continue } ...   ","version":"v6.3.0","tagName":"h3"},{"title":"How do we send the partial validator sets to the consumer chains?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#how-do-we-send-the-partial-validator-sets-to-the-consumer-chains","content":" A consumer chain should only be validated by opted in validators. We introduce logic to do this when we queue the VSCPackets. The logic behind this, is not as straightforward as it seems because CometBFT does not receive the validator set that has to validate a chain, but rather a delta of validator updates. For example, to remove an opted-out validator from a consumer chain, we have to send a validator update with a power of 0, similarly to what is done in the assignment of consumer keys. We intend to update this ADR at a later stage on how exactly we intend to implement this logic.  ","version":"v6.3.0","tagName":"h3"},{"title":"How do we distribute rewards?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#how-do-we-distribute-rewards","content":" Currently, rewards are distributed as follows: The consumer periodically sends rewards on the provider ConsumerRewardsPool address. The provider then transfers those rewards to the fee collector address and those transferred rewards are distributed to validators and delegators.  In PSS, we distribute rewards only to validators that actually validate the consumer chain. To do this, we have a pool associated with each consumer chain and consumers IBC transfer the rewards to this pool. We then extract the rewards from each consumer pool and distribute them to the opted in validators.  Note that we only distribute rewards to validators that have been opted in for some time (e.g., 10000 blocks) to avoid cases where validators opt in just to receive rewards and then opt out immediately afterward.  ","version":"v6.3.0","tagName":"h3"},{"title":"Misbehaviour​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#misbehaviour","content":" Fraud votes​  In an Opt In chain, a set of validators might attempt to perform an attack. To deter such potential attacks, PSS allows for the use of fraud votes. A fraud vote is a governance proposal that enables the slashing of validators that performed an attack. Due to their inherent complexity, we intend to introduce fraud votes in a different ADR and at a future iteration of PSS.  Double signing​  We do not change the way slashing for double signing and light client attacks functions. If a validator misbehaves on a consumer, then we slash that validator on the provider.  Downtime​  We do not change the way downtime jailing functions. If a validator is down on a consumer chain for an adequate amount of time, we jail this validator on the provider but only if the validator was opted in on this consumer chain in the recent past.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#positive","content":" Easier for new consumer chains to consume the provider's chain economic security because proposals are more likely to pass if not everyone is forced to validate. Smaller validators are not forced to validate chains anymore if they do not want to. We can deprecate the soft opt-out implementation.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#negative","content":" A consumer chain does not receive the same economic security as with Replicated Security (assuming the value of SoftOptOutThreshold is 5%), unless it is a Top N chain with N &gt;= 95%.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.3.0/adrs/adr-015-partial-set-security#references","content":" PSS: Permissionless vs premissioned-lite opt-in consumer chainsCHIPs discussion phase: Partial Set Security (updated)PSS: Exclusive vs Inclusive Top-NInitial PSS ADR and notes #1518Replicated vs. Mesh Security ","version":"v6.3.0","tagName":"h2"},{"title":"ADR 020: Customizable Slashing and Jailing","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#changelog","content":" 2024-07-19: Initial draft of ADR2024-08-23: Generalize ADR to make slashing and jailing customizable  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#status","content":" Proposed  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#context","content":" Interchain Security (ICS) is a cross-chain staking protocol -- it uses the stake on the provider chain as collateral for the Proof of Stake (PoS) on the consumer chains. This means that the voting power of validators validating (aka producing blocks) on the consumer chains is a function of their stake on the provider. Moreover, if these validators misbehave on the consumer chains, they get punished on the provider chain. ICS is currently differentiating between two types of infractions -- equivocation and downtime. Depending on the infraction type, the misbehaving validators might be jailed (i.e., removed from the provider validator set) and / or slashed (i.e., a portion of their stake on the provider is being burned). For example, validators double signing on consumer chains get slashed and are permanently jailed, while validators not validating sufficient blocks are temporarily jailed.  This means that ICS consumer chains get their economical security from the provider. However, this might come at a high cost.  ","version":"v6.3.0","tagName":"h2"},{"title":"The Cost of PoS​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#the-cost-of-pos","content":" One of the cost of validating on the consumer chains is operational -- validators need to run and monitor full nodes of every consumer chain they opt in for. Although this cost varies from validator team to validator team (depending on how efficiently they can run their infrastructure), it doesn't depend on the total stake (or voting power) of the validators, so we can think of it as constant. The other cost of validating comes from the risk of getting slashed or jailed.  Most chains in Cosmos (including the Cosmos Hub) use delegated PoS -- users delegate their tokens to validators, which stake them in return for voting power. Therefore, validators act as representatives chosen by their delegators to represent their interests. However, delegators share the risk of their validators getting slashed or jailed:  When validators get slashed, a portion of their stake is being burned, including a portion of the tokens delegated by users. As validators don't need to have their own stake, it is possible that delegators take all the risk of validators misbehaving.When validators get jailed, they no longer receive block rewards (neither from the provider nor from the consumer chains). This also applies to their delegators. As a result, delegators might choose to restake their tokens with another validator. The longer the validators are jailed, the more likely is that delegators will restake. Thus, by getting jailed, validators risk damaging their reputation.  Misbehaviors don't need to be malicious, e.g., most cases of double signing infractions are due to misconfiguration. This means that, by opting in on multiple consumer chains, validators and their delegators incur a higher risk. As a result, validators and their delegators want to be compensated for this additional risk, which makes the current design of ICS expensive.  This ADR addresses the high cost of ICS by allowing consumer chains to customize the slashing and jailing conditions. Basically, every consumer chain can decide the punishment for every type of infraction. This enables consumer chains to tradeoff economical security against cost.  ","version":"v6.3.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#decision","content":" To reduce the cost of ICS, consumer chains will be able to customize the slashing and jailing for every type of infraction. As a result, consumer chains can decide on the amount of economic security they want and validators (and their delegators) can decide on the amount of additional risk they want to incur.  For every consumer chain, we introduce the following slashing and jailing parameters:  message InfractionParameters { SlashJailParameters double_sign = 1; SlashJailParameters downtime = 2; } message SlashJailParameters { bytes slash_fraction = 1 [ (cosmos_proto.scalar) = &quot;cosmos.Dec&quot;, (gogoproto.customtype) = &quot;cosmossdk.io/math.LegacyDec&quot;, (gogoproto.nullable) = false, (amino.dont_omitempty) = true ]; // use time.Unix(253402300799, 0) for permanent jailing google.protobuf.Duration jail_duration = 2; }   Currently, we consider only two infraction types -- double signing and downtime.  By default, every consumer chain will have the following slashing and jailing parameters:  double_sign.slash_fraction: 0.05 // same as on the provider double_sign.jail_duration: time.Unix(253402300799, 0) // permanent jailing, same as on the provider downtime.slash_fraction: 0 // no slashing for downtime on the consumer downtime.jail_duration: 600s // same as on the provider   These parameters can be updated by the consumer chain owner at any given time (via MsgCreateConsumer or MsgUpdateConsumer). However, the changes will come into effect after a period equal to the staking module's unbonding period elapses. This will allow validators that don't agree with the changes to opt out and not be affected by them. Also, to avoid malicious chains attacking the provider validator set, these params will be bounded by the values on the provider chain:  double_sign.slash_fraction &lt;= 0.05 // 5% downtime.slash_fraction &lt;= 0.0001 // 0.1% downtime.jail_duration &lt;= 600s // 10 minutes   Although consumer chains can set any values to these parameters (within the allowed bounds), we recommend the following settings, depending on the type of consumer chain.  Proof-of-Stake (PoS) Consumer Chains. These are chains that have the full economical security of the provider validators that opted in. This means that all slashing and jailing parameters are the same as on the provider. double_sign.slash_fraction: 0.05 double_sign.jail_duration: time.Unix(253402300799, 0) downtime.slash_fraction: 0.0001 downtime.jail_duration: 600s Proof-of-Reputation (PoR) Consumer Chains. double_sign.slash_fraction: 0 // no slashing double_sign.jail_duration: time.Unix(253402300799, 0) downtime.slash_fraction: 0 // no slashing downtime.jail_duration: 600s This means that when validators that opt in misbehave on PoR consumer chains, their stake on the provider is not being slashed, instead they are just jailed on the provider. As a result, delegators incur (almost) no risk if their validators opt in on multiple PoR consumer chains. If their validators are jailed, then the delegators can redelegate to other validators. Note though that delegators cannot redelegate multiple times, which means that if the new validators also get permanently jailed, the delegators need to wait for the unbonding period to elapse. Testnet Consumer Chains. double_sign.slash_fraction: 0 // no slashing double_sign.jail_duration: 0 // no jailing downtime.slash_fraction: 0 // no slashing downtime.jail_duration: 0 // no jailing This means that validators are not punished for infractions on consumer chains. This setting is ideal for testing consumer chains before going in production, as neither validators nor their delegators incur any risk from the validators opting in on these consumer chains.  This means that both PoR and testnet consumer chains need only to cover the operational costs of the validators that opt in. For example, if we take $600 as the cost of running a validator node, a budget of $3000 will be sufficient to cover the cost of four validators running such a consumer chain and have $150 profit per validator as incentive. In practice, this can be implemented via the per-consumer-chain commission rate that allows validators to have different commission rates on different consumer chains.  ","version":"v6.3.0","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#implementation","content":" The implementation of this feature involves the following steps:  Add the InfractionParameters to MsgCreateConsumer.On slashing events (for either downtime or double signing infractions), use the corresponding slash_fraction set by the consumer chain.On jailing events (for either downtime or double signing infractions), use the corresponding jail_duration set by the consumer chain.Cryptographic equivocation evidence received for PoR chains results in the misbehaving validators only being tombstoned and not slashed.(Optional) Add the InfractionParameters to MsgUpdateConsumer, i.e., allow consumer chains to update the slashing and jailing parameters, but the changes will come into effect after a period equal to the staking module's unbonding period elapses to allow for validators to opt out.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#positive","content":" Reduce the cost of ICS by removing the risk of slashing delegators.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#negative","content":" Reduce the economical security of consumer chains with weaker slashing conditions.  Economic Security Model without Slashing​  The economic security model of most Cosmos chains relies on the following properties:  validators are not anonymous, which means that they could be legally liable if they are malicious;the delegated PoS mechanism creates a reputation-based network of validators;most validators have most of their stake coming from delegations (i.e., nothing at stake, besides reputation);it is relatively difficult to enter the active validator set and even more so to climb the voting power ladder.  These properties enable us to make the following assumption:  Being permanently removed from the provider validator set is strong enough of a deterrent to misbehaving on consumer chains.  The additional economical security a consumer gets from slashing is limited: Since most of the stake is delegated, slashing punishes delegators more than validators.  One benefit of slashing is that it acts as a deterrent for someone buying a large amount of staking tokens in order to attack a consumer chain. For example, an attacker could get $15,000,000 worth of ATOM, which would give them around 1% voting power on the Cosmos Hub (at the time of this writing). On a consumer chain, this voting power could be amplified depending on the other validators that opt in. However, by having the right power shaping settings, the voting power of validators can be capped. This means that even if the attacker manages to double sign without getting slashed, as long as they don't have 1/3+ of the voting power, they cannot benefit from the attack. Moreover, the attacker might lose due to other factors, such as token toxicity.  ","version":"v6.3.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#neutral","content":" NA  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.3.0/adrs/adr-020-cutomizable_slashing_and_jailing#references","content":"","version":"v6.3.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/intro","content":"","keywords":"","version":"v6.3.0"},{"title":"Table of Contents​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/adrs/intro#table-of-contents","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Accepted​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/adrs/intro#accepted","content":" ADR 001: Key AssignmentADR 002: Jail ThrottlingADR 004: Denom DOS fixesADR 005: Cryptographic verification of equivocation evidenceADR 008: Throttle with retriesADR 010: Standalone to Consumer ChangeoverADR 013: Slashing on the provider for consumer equivocationADR 014: EpochsADR 015: Partial Set SecurityADR 017: ICS with Inactive Provider ValidatorsADR 018: Remove VSCMatured PacketsADR 18: Permissionless Interchain Security  ","version":"v6.3.0","tagName":"h3"},{"title":"Proposed​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/adrs/intro#proposed","content":" ADR 011: Improving testing and increasing confidenceADR 016: Security aggregation  ","version":"v6.3.0","tagName":"h3"},{"title":"Rejected​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/adrs/intro#rejected","content":" ADR 007: Pause validator unbonding during equivocation proposalADR 012: Separate Releasing  ","version":"v6.3.0","tagName":"h3"},{"title":"Deprecated​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/adrs/intro#deprecated","content":" ADR 003: Equivocation governance proposalADR 009: Soft Opt-Out ","version":"v6.3.0","tagName":"h3"},{"title":"ADR 019: Permissionless Interchain Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics","content":"","keywords":"","version":"v6.3.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#changelog","content":" 27th of June, 2024: Initial draft12th of September, 2024: Updated to take into account message changes, etc.  ","version":"v6.3.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#status","content":" Accepted  ","version":"v6.3.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#context","content":" Currently, a consumer chain can join Interchain Security (ICS) only through a governance proposal. A governance proposal was needed before the introduction of Partial Set Security (PSS) because validators were required to validate a consumer chain. However, after the introduction of PSS, a consumer chain can be either Top N or Opt In. If a chain is an Opt In chain, then no validator is required to validate this chain unless they choose to. Because of this, we can launch an Opt In consumer chain without going through a governance proposal.  This ADR presents Permissionless ICS, a way in which an Opt In consumer chain can join ICS without needing a governance proposal but by simply issuing a transaction.  ","version":"v6.3.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#decision","content":" In Permissionless ICS, launching an Opt In chain can be done by issuing a transaction. Naturally, Permissionless ICS does not eliminate governance proposals, as proposals are still necessary for Top N chains. Nevertheless, a Top N chain can transform to an Opt In chain through a gov proposal and vice versa.  ","version":"v6.3.0","tagName":"h2"},{"title":"The Phases of a Consumer Chain​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#the-phases-of-a-consumer-chain","content":" We first present the notion of an owner of a consumer chain before showing the specific phases of a consumer chain.  Owner. A consumer chain has an owner, which is simply an address. Only the owner can interact (i.e., launch, update, or stop) with the chain. The owner of an Opt In chain is the one who signed the initial transaction to register a consumer chain (more on this later). Naturally, an Opt In chain can change its owner at any point. The owner of a Top N chain is the account of the governance module. Therefore, any changes on a Top N chain have to go through governance proposals.  A consumer chain can reside in five phases: i) registered, ii) initialized, iii) launched, iv) stopped, and v) deleted phase as seen in the diagram below:  Registered phase. In the registered phase, a consumer chain has an assigned a unique identifier, that of consumerId (more on this later) that identifies a consumer chain that is used to interact with the chain (e.g., when a validator opts in on a chain, etc.). A chain is created and resides at the registered phase through the use of a MsgCreateConsumer which response contains the consumerId.MsgCreateConsumer is the first step in creating either a Top N or an Opt In consumer chain.  If all the optional initialization parameters are provided in MsgCreateConsumer, then an Opt In chain can immediately move to the initialized phase (see below) and get scheduled to launch. Note, however that a Top N chain needs at least two more MsgUpdateConsumer messages and one gov proposal to be able to launch.  In the registered phase, it is not yet known if the consumer chain would end up being a Top N or an Opt In chain and hence the owner of the consumer chain at this phase is the one that signed the MsgCreateConsumer.  Initialized phase. The initialized phase means that the chain has set all the needed initialization parameters to launch but has not yet launched. If a chain in the registered phase has not yet set the initialization parameters, it can issue a MsgUpdateConsumermessage to set those parameters. Additionally, MsgUpdateConsumer can be used to set up other parameters, such as the power-shaping parameters. If a chain is in the initialized phase and MsgUpdateConsumer is issued with spawn time being zero, the chain moves back to the registered phase.  In order to move a Top N chain to the initialized phase, we need to issue at least two MsgUpdateConsumer messages:  one to change the owner of the chain to be the account of the governance module;another as part of a governance proposal to set the Top N.  Launched phase. In the launched phase the consumer chain is running and is consuming a subset of the validator set of the provider. When the spawnTimepasses and at least one validator has opted inthe chain can launch and moves to the launched phase. Note that a Top N chain can launch if and only if the spawnTime has passed and the proposal with the MsgUpdateConsumer has successfully passed. While in launched phase, a consumer chain can choose to modify its parameters through MsgUpdateConsumer. Naturally, only the owner of the chain can issue MsgUpdateConsumer, thus for Top N chains, the chain can be updated only through a governance proposal that contains a MsgUpdateConsumer. Additionally, note that after the chain moves to the launched phase, the initialization parameters cannot be updated anymore, but general metadata and power-shaping parameters of the chain can still be updated.  Stopped phase. In the stopped phase the consumer chain stops receiving VSCPackets. A chain moves to the stopped phase, when the owner of the chain sends the MsgRemoveConsumer message.  Deleted phase. In the deleted phase the majority of the state in relation to this consumer chain is deleted from the provider. A chain moves to the deleted phase after the chain has been stopped for an unbonding period. We keep track of the state of the consumer chain for an unbonding period, so that we are able to punish validators for misbehaviors that occurred before the consumer chain stopped. Additionally, we do not fully delete the whole state of this chain, so that we can still query parameters a deleted chain used to have. This is useful for front-ends, etc.  Note that everything described so far and everything that follows applies to consumer chains that transition from standalone chains as well.  ","version":"v6.3.0","tagName":"h3"},{"title":"From chainId to consumerId​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#from-chainid-to-consumerid","content":" A hindrance in moving to Permissionless ICS is chain-id squatting. In a permissionless setting, anyone could issue a transaction to launch a consumer chain with a chainId that might already be used by some other consumer chain. This is a problem because in the current design the majority of stored state for a consumer chain is indexed using the chainId as the key (e.g., see key used to store client ids). To tackle this problem, in Permissionless ICS, we introduce the consumerId that defines a consumer chain and is simply an increasing counter (i.e., counter), thus we can support multiple consumer chains with the same chainId. Another way to understand this is with an analogy between consumer chains and IBC clients: Imagine having multiple IBC clients that each point to different consumer chains, but all share the exact same chainId. It is then up to the user to select the appropriate client (i.e., clientId) based on the actual chain they want to communicate with. Similarly, there can be multiple consumer chains with the exact same chainId, and it is the responsibility of the validators to choose the one they wish to interact with by providing the right consumerId.  Note that with Permissionless ICS, all interactions on a consumer chain have to use the consumerId instead of the chainId. For example, if a validator opts in on a chain using MsgOptIn, the validator has to provide the consumerId. Specifically, for the equivocation evidence, we update the MsgSubmitConsumerMisbehaviour and MsgSubmitConsumerDoubleVotingmessages to include the consumerId, and modify Hermesto include consumerId in those constructed messages as well. Hermes can find out the consumerId by querying the provider's clientId for some consumer chain (i.e., query ccvconsumer provider-info) and then asking the provider chain for the consumerId that corresponds to this clientId. To do this, we store the clientId to consumerId association on the provider and introduce a query to retrieve the clientId given the consumerId.  State​  As a result of using consumerId, we have to migrate a substantial chunk of state to re-index it using consumerId as the key. Currently, in ICS we have state that is indexed by a multitude of keys. In the table below, we see the ones that are associated with a chainId and how often state under those keys gets updated. Additionally, for each key, the table shows whose action can lead to the setting or deletion of the state associated with that key. An action can stem either from: i) a consumer chain (e.g., through a MsgUpdateConsumer message, an IBC packet sent over to the provider, etc.), ii) a provider chain (e.g., at the end of a block some action is taken), or by iii) a validator (e.g., through a MsgAssignConsumerKey message) or a combination of them.  Key\tDescription\tWho can set this?\tWho can delete this?\tHow often are chainId-associated keys updated?ChainToChannelBytePrefix\tStores the CCV channelID for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) ChannelToChainBytePrefix\tStores chainId for a specific channel\tconsumer chain\tconsumer chain\tOnly once (during set up) ChainToClientBytePrefix\tStores the clientID for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) PendingCAPBytePrefix\tStores pending consumer addition proposals\tconsumer chain\tprovider chain\tOnly once (for successful proposal) PendingCRPBytePrefix\tStores pending consumer removal proposals\tconsumer chain\tprovider chain\tOnly once (for successful proposal) ConsumerGenesisBytePrefix\tStores the consumer genesis for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) SlashAcksBytePrefix\tStores slash acks for a specific consumer chain\tconsumer chain\tprovider chain\tEvery time we receive a Slash packet PendingVSCsBytePrefix\tStores VSCPackets for a specific consumer chain\tprovider chain\tprovider chain\tEvery epoch ConsumerValidatorsBytePrefix\tStores consumer key per validator per consumer chain\tvalidator\tconsumer chain\tEvery MsgAssignConsumerKey or MsgOptIn ValidatorsByConsumerAddrBytePrefix\tStores consumer to provider validator address\tvalidator\tconsumer or provider chain\tEvery MsgAssignConsumerKey or MsgOptIn EquivocationEvidenceMinHeightBytePrefix\tStores min height for a consumer chain\tconsumer chain\tconsumer chain\tOnly once (during set up) ProposedConsumerChainByteKey\tStores proposalIDs for consumer chains with proposals in the voting period\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tCreated when the proposal is submitted and deleted when the proposal's voting period ends ConsumerValidatorBytePrefix\tStores consumer validators for a specific chain\tvalidator\tvalidator or consumer chain\tPotentially at every epoch OptedInBytePrefix\tStores opted-in validators for a specific chain\tvalidator\tvalidator or consumer chain\tPotentially at every block TopNBytePrefix\tStores whether a consumer chain is Top N or not\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tEvery parameter update ValidatorsPowerCapPrefix\tStores the power cap of a chain\tconsumer chain\tconsumer chain\tEvery parameter update ValidatorSetCapPrefix\tStores the set cap of a chain\tconsumer chain\tconsumer chain\tEvery parameter update AllowlistPrefix\tStores the allowlist of a chain\tconsumer chain\tconsumer chain\tEvery parameter update DenylistPrefix\tStores the denylist of a chain\tconsumer chain\tconsumer chain\tEvery parameter update ConsumerRewardsAllocationBytePrefix\tStores the ICS rewards per chain\tconsumer or provider chain\tprovider chain\tEvery IBC transfer packet that sends rewards to the provider ConsumerCommissionRatePrefix\tCommission rate per chain per validator\tvalidator\tconsumer chain\tEvery MsgSetConsumerCommissionRate message MinimumPowerInTopNBytePrefix\tStores the minimum power needed to opt in for a chain\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tEvery epoch ConsumerAddrsToPruneV2BytePrefix\tStores consumer addresses to be pruned (as part of VSCMaturedPackets deprecation)\tvalidator or provider chain\tprovider chain\tEvery MsgAssignConsumerKey or MsgOptIn and later during actual pruning  Everything stored under one of the above keys is associated with a chainId and has to be migrated to new state under a consumerId.  ","version":"v6.3.0","tagName":"h3"},{"title":"New Messages​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#new-messages","content":" In this section, we describe the new messages (i.e., MsgCreateConsumer, MsgUpdateConsumer, and MsgRemoveConsumer) that Permissionless ICS introduces.  Create a Consumer Chain​  We first have to create a chain before launching it, irrespectively of whether it is Top N or Opt In. This is done through the following message:  message MsgCreateConsumer { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; // Submitter address. If the message is successfully handled, the ownership of // the consumer chain will given to this address. string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the chain id of the new consumer chain string chain_id = 2; ConsumerMetadata metadata = 3 [ (gogoproto.nullable) = false ]; ConsumerInitializationParameters initialization_parameters = 4; PowerShapingParameters power_shaping_parameters = 5; }   Note that metadata is a required field, while the initialization_parameters and power_shaping_parameters are optional and can later be set using MsgUpdateConsumer.  metadata is of the following type:  message ConsumerMetadata { // the name of the chain string name = 1; // the description of the chain string description = 2; // the metadata (e.g., GitHub repository URL) of the chain string metadata = 3; }   initialization_parameters is of the following type and if all are provided the chain is scheduled to launch:  // ConsumerInitializationParameters are the parameters needed to launch a chain message ConsumerInitializationParameters { // ---------- ---------- ---------- // Following fields are used when the consumer chain launches and are not needed by the provider afterwards. // ---------- ---------- ---------- // the proposed initial height of new consumer chain. // For a completely new chain, this will be {0,1}. However, it may be // different if this is a chain that is converting to a consumer chain. ibc.core.client.v1.Height initial_height = 1 [ (gogoproto.nullable) = false ]; // The hash of the consumer chain genesis state without the consumer CCV // module genesis params. It is used for off-chain confirmation of // genesis.json validity by validators and other parties. bytes genesis_hash = 2; // The hash of the consumer chain binary that should be run by validators on // chain initialization. It is used for off-chain confirmation of binary // validity by validators and other parties. bytes binary_hash = 3; // spawn time is the time on the provider chain at which the consumer chain // genesis is finalized and all validators will be responsible for starting // their consumer chain validator node. google.protobuf.Timestamp spawn_time = 4 [ (gogoproto.nullable) = false, (gogoproto.stdtime) = true ]; // Unbonding period for the consumer, // which should be smaller than that of the provider in general. google.protobuf.Duration unbonding_period = 5 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // ---------- ---------- ---------- // Following fields are used to construct the consumer genesis of the to-be-launched consumer chain // and are set up as params on the consumer chain. Those params can then be directly modified by the consumer chain. // ---------- ---------- ---------- // Sent CCV related IBC packets will timeout after this duration google.protobuf.Duration ccv_timeout_period = 6 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // Sent transfer related IBC packets will timeout after this duration google.protobuf.Duration transfer_timeout_period = 7 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // The fraction of tokens allocated to the consumer redistribution address // during distribution events. The fraction is a string representing a // decimal number. For example &quot;0.75&quot; would represent 75%. string consumer_redistribution_fraction = 8; // BlocksPerDistributionTransmission is the number of blocks between // ibc-token-transfers from the consumer chain to the provider chain. On // sending transmission event, `consumer_redistribution_fraction` of the // accumulated tokens are sent to the consumer redistribution address. int64 blocks_per_distribution_transmission = 9; // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. int64 historical_entries = 10; // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer // chain. it is most relevant for chains performing a sovereign to consumer // changeover in order to maintain the existing ibc transfer channel string distribution_transmission_channel = 11; }   power_shaping_parameters is of the following type:  // PowerShapingParameters contains parameters that shape the validator set that we send to the consumer chain message PowerShapingParameters { // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. uint32 top_N = 1; // `validators_power_cap` corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. // For instance, if `validators_power_cap` is set to 32, no validator can have more than 32% of the total voting power of the // consumer chain. The power cap is intended as a safeguard against a validator having too much power on the consumer // chain and hence &quot;taking over&quot; the consumer chain. uint32 validators_power_cap = 2; // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. uint32 validator_set_cap = 3; // corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate the consumer chain repeated string allowlist = 4; // corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain repeated string denylist = 5; // Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain. uint64 min_stake = 6; // Corresponds to whether inactive validators are allowed to validate the consumer chain. bool allow_inactive_vals = 7; }   This MsgCreateConsumerResponse response contains a single string that is the consumerId for this registered consumer chain  Update a Consumer Chain​  We can issue a MsgUpdateConsumer at any point during the registered, initialized, or launched phase of a chain to update parameters of the consumer chain.  The MsgUpdateConsumer message is as follows:  message MsgUpdateConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the address of the owner of the consumer chain to be updated string owner = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to be updated string consumer_id = 2; // the new owner of the consumer when updated string new_owner_address = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the metadata of the consumer when updated ConsumerMetadata metadata = 4; // initialization parameters can only be updated before a chain has launched ConsumerInitializationParameters initialization_parameters = 5; // the power-shaping parameters of the consumer when updated PowerShapingParameters power_shaping_parameters = 6; }   Note that we need to extensively check the fields of the provided ConsumerInitializationParameters to guarantee that no consumer chain launches with problematic parameters.  For all consumer chains, irrespectively of their phase (even in the deleted phase), we keep a mapping between consumerIdand the underlying ConsumerMetadata, ConsumerInitializationParameters and PowerShapingParameters. This way, we can respond to queries that ask for all the consumer chain's parameters. For example, retrieving the spawn_time of consumer chain with a given consumerId.  MsgUpdateConsumer can be executed multiple times for the same Opt In consumer chain during its initialized phase to potentially change its to-be-launched parameters (e.g., spawnTime).  Remove (Stop) a Consumer Chain​  We introduce the MsgRemoveConsumer message so that we can stop any Opt In chain at any point in time. Note that all relevant state for this consumer chain remains on the provider's state before getting removed after the time of an unbonding period (of the provider) has passed. This is to enable potential slashing for any infraction that might have been incurred until now. Note however that we never recycle previously-used consumerIds. Naturally, this message can only be issued by the owner of the consumer chain.  message MsgRemoveConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the consumer id of the consumer chain to be stopped string consumer_id = 1; // the address of the owner of the consumer chain to be stopped string owner = 2 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   Examples of Launching a Consumer Chain​  The figures below depict some examples of some of the phases a consumer chain resides before launching.    ","version":"v6.3.0","tagName":"h3"},{"title":"Additional Modifications​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#additional-modifications","content":" We need to perform multiple migrations. All state needs to be reindexed based on a consumerId instead of the chainId. Because we only have two consumer chains (i.e., Neutron and Stride) at the moment, this is not going to be an expensive migration even if we have some live consumer chains that are being voted upon. Similarly, all the messages, queries, etc. would need to be changed to operate on a consumerId instead of a chainId.  It is important to migrate any live proposals, such as ConsumerAdditionProposals and MsgConsumerAdditions, etc. when we upgrade before we actually deprecate ConsumerAdditionProposals, MsgConsumerAdditions, etc.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#consequences","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#positive","content":" Easier to launch an Opt In consumer chain because no governance is required.  ","version":"v6.3.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#negative","content":" Extensive migration and overhaul of existing code base (as part of API-breaking changes) that could lead to bugs.  ","version":"v6.3.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.3.0/adrs/adr-019-permissionless-ics#references","content":" CHIPs Discussion phase: Permissionless ICSChain-id squatting ","version":"v6.3.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/build/modules/overview","content":"Overview ICS consists of two main modules: x/provider Provides to consumer chains updated information of opted in validators.Distributes ICS rewards to opted in validators.Jails and slashes validators that misbehave on consumer chains. x/consumer Sends to the consensus engine the validator sets received from the provider chain.Splits consumer block rewards and sends ICS rewards to the provider chain.Notifies the provider chain of downtime infractions. Note that x/types contains types shared by both modules. In addition, the following modules are added to ICS to extend its functionality: x/democracy","keywords":"","version":"v6.3.0"},{"title":"Developing an ICS consumer chain","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/consumer-development/app-integration","content":"","keywords":"","version":"v6.3.0"},{"title":"Basic consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v6.3.0/consumer-development/app-integration#basic-consumer-chain","content":" The source code for the example app can be found here.  Please note that consumer chains do not implement the staking module - part of the validator set of the provider is replicated over to the consumer, meaning that the consumer uses a subset of provider validator set and the stake of the validators on the provider determines their stake on the consumer. Note that after the introduction of Partial Set Security, not all the provider validators have to validate a consumer chain (e.g., if top_N != 100).  Your chain should import the consumer module from x/consumer and register it in the correct places in your app.go. The x/consumer module will allow your chain to communicate with the provider using the ICS protocol. The module handles all IBC communication with the provider, and it is a simple drop-in. You should not need to manage or override any code from the x/consumer module.  ","version":"v6.3.0","tagName":"h2"},{"title":"Democracy consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v6.3.0/consumer-development/app-integration#democracy-consumer-chain","content":" The source code for the example app can be found here.  This type of consumer chain wraps the basic CosmosSDK x/distribution, x/staking and x/governance modules allowing the consumer chain to perform democratic actions such as participating and voting within the chain's governance system.  This allows the consumer chain to leverage those modules while also using the x/consumer module.  With these modules enabled, the consumer chain can mint its own governance tokens, which can then be delegated to prominent community members which are referred to as &quot;representatives&quot; (as opposed to &quot;validators&quot; in standalone chains). The token may have different use cases besides just voting on governance proposals.  ","version":"v6.3.0","tagName":"h2"},{"title":"Standalone chain to consumer chain changeover​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v6.3.0/consumer-development/app-integration#standalone-chain-to-consumer-chain-changeover","content":" See the standalone chain to consumer chain changeover guide for more information on how to transition your standalone chain to a consumer chain. ","version":"v6.3.0","tagName":"h2"},{"title":"x/ccv/consumer","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/build/modules/consumer","content":"","keywords":"","version":"v6.3.0"},{"title":"Overview​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#overview","content":" The ICS consumer module enables consumer chains to use stake locked on a provider chain as collateral for their own proof-of-stake based block production.  The consumer module established a IBC ordered channel to the provider chain. This channel is used by the provider chain to regularly sent validator updates the the consumer chain. The consumer sends these updates to its own consensus engine. This means that the consumer module acts as a staking module of the consumer chain.  Regularly, the consumer module sends a part of the consumer chain's block rewards to the provider chain as ICS rewards.  If one of the validators in the consumer chain's validator set is missing enough blocks (i.e., downtime infraction), the consumer module notifies the provider chain by sending an IBC packet to the provider module. As a result, the misbehaving validator is punished on the provider chain.  ","version":"v6.3.0","tagName":"h2"},{"title":"State​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#state","content":" For clarity, the description of the the consumer module state is split into features. For a more accurate description, check out the x/ccv/consumer/types/keys.go file, which contains the definitions of all the keys.  ","version":"v6.3.0","tagName":"h2"},{"title":"Provider Connection​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#provider-connection","content":" ProviderClientID​  ProviderClientID is the ID of the provider client on which the CCV channel is built.  Format: byte(3) -&gt; string  ProviderChannelID​  ProviderChannelID is the ID of the CCV channel.  Format: byte(4) -&gt; string  ","version":"v6.3.0","tagName":"h3"},{"title":"Changeover​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#changeover","content":" PreCCV​  PreCCV is the flag set when the consumer chain is in the process of a standalone to consumer chain changeover.  Format: byte(7) -&gt; uint64  InitialValSet​  InitialValSet is the initial validator set on the consumer chain.  Format: byte(8) -&gt; GenesisState  Note that only the InitialValSet field of the ProviderInfo field of GenesisState is set, i.e.,  message GenesisState { ... ProviderInfo provider = 14 [ (gogoproto.nullable) = false ]; } message ProviderInfo { // InitialValset filled in on new chain and on restart. repeated .tendermint.abci.ValidatorUpdate initial_val_set = 3 [ (gogoproto.nullable) = false ]; }   InitGenesisHeight​  InitGenesisHeight is the height when the consumer module was initialized (i.e., the InitGenesis method was called).  Format: byte(17) -&gt; uint64  PrevStandaloneChain​  PrevStandaloneChain is the flag set when the consumer chain was previously a standalone chain.  Format: byte(19) -&gt; []byte{}  ","version":"v6.3.0","tagName":"h3"},{"title":"Validator Updates​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#validator-updates","content":" PendingChanges​  PendingChanges are the validator updates received from the provider that were not yet sent to the consensus engine.  Format: byte(5) -&gt; ValidatorSetChangePacketData  Note that only the ValidatorUpdates field of ValidatorSetChangePacketData is set.  CrossChainValidator​  CrossChainValidator is the internal state of a consumer validator with consensus address addr.  Format: byte(16) | addr -&gt; CrossChainValidator, where CrossChainValidator is defined as  message CrossChainValidator { bytes address = 1; int64 power = 2; // pubkey is the consensus public key of the validator, as a Protobuf Any. google.protobuf.Any pubkey = 3 [ (cosmos_proto.accepts_interface) = &quot;cosmos.crypto.PubKey&quot;, (gogoproto.moretags) = &quot;yaml:\\&quot;consensus_pubkey\\&quot;&quot; ]; // deprecated bool opted_out = 4 [deprecated = true]; }   HistoricalInfo​  HistoricalInfo is the header and validator information for a given block. For more details, see the Cosmos SDK docs.  Format: byte(11) | height -&gt; HistoricalInfo, where HistoricalInfo is define in the staking module as  message HistoricalInfo { tendermint.types.Header header = 1 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true]; repeated Validator valset = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true]; }   ","version":"v6.3.0","tagName":"h3"},{"title":"Reward Distribution​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#reward-distribution","content":" LastDistributionTransmission​  LastDistributionTransmission is the block height of the last attempt to send ICS rewards to the provider module.  Format: byte(1) -&gt; LastTransmissionBlockHeight, where LastTransmissionBlockHeight is defined as  message LastTransmissionBlockHeight { int64 height = 1; }   ","version":"v6.3.0","tagName":"h3"},{"title":"Downtime Infractions​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#downtime-infractions","content":" OutstandingDowntime​  OutstandingDowntime is the flag set when a SlashPacket is queued to be sent to the provider for a downtime infraction of a validator with consensus address addr. The flag is unset when receiving from the provider a VSCPacket with a slash acknowledgement (see SlashAcks in ValidatorSetChangePacketData).  Format: byte(14) | addr -&gt; []byte{}  HeightValsetUpdateID​  HeightValsetUpdateID is the validator set update ID associated with a block height.  Format: byte(13) | height -&gt; uint64  PendingPacketsIndex​  PendingPacketsIndex is the next index available to store packet data to be sent to the provider chain (see below).  Format: byte(20) -&gt; uint64  PendingDataPacketsV1​  PendingDataPacketsV1 is the queue of packet data to be sent to the provider chain. In general, packets in this queue will be sent to the provider in the end blocker, unless  the CCV channel is not yet established;the provider client is expired;the last slash packet sent was not yet acknowledged by the provider chain.  Format: byte(15) | index -&gt; ConsumerPacketData, where index is the index of the packet in the queue and ConsumerPacketData is defined as  message ConsumerPacketData { ConsumerPacketDataType type = 1; oneof data { SlashPacketData slashPacketData = 2; VSCMaturedPacketData vscMaturedPacketData = 3; } }   SlashRecord​  SlashRecord is the record storing the state of a SlashPacket sent to the provider chain that was not yet acknowledged. See ADR 008 for more details.  Format: byte(21) -&gt; SlashRecord, where SlashRecord is defined as  message SlashRecord { bool waiting_on_reply = 1; google.protobuf.Timestamp send_time = 2 [ (gogoproto.stdtime) = true, (gogoproto.nullable) = false ]; }   ","version":"v6.3.0","tagName":"h3"},{"title":"State Transitions​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#state-transitions","content":" TBA  ","version":"v6.3.0","tagName":"h2"},{"title":"IBC Callbacks​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#ibc-callbacks","content":" The consumer module is an IBC application that implements the IBC module callback.  ","version":"v6.3.0","tagName":"h2"},{"title":"OnChanOpenInit​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#onchanopeninit","content":" OnChanOpenInit first verifies that the CCV channel was not already created. Then, it validates the channel parameters -- an ordered IBC channel connected on the consumer port and with the counterparty port set to provider -- and asserts that the version matches the expected version (only verions 1 is supported).  Finally, it verifies that the underlying client is the expected client of the provider chain (i.e., provided in the consumer module genesis state).  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanOpenTry​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#onchanopentry","content":" OnChanOpenTry returns an error. MsgChannelOpenTry should be sent to the provider.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanOpenAck​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#onchanopenack","content":" OnChanOpenAck first verifies that the CCV channel was not already created. Then it verifies that the counterparty version matches the expected version (only verions 1 is supported).  If the verification passes, it stores the ProviderFeePoolAddr in the state.  Finally, if the DistributionTransmissionChannel parameter is not set, it initiate the opening handshake for a token transfer channel over the same connection as the CCV channel by calling the ChannelOpenInit method of the IBC module.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanOpenConfirm​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#onchanopenconfirm","content":" OnChanOpenConfirm returns an error. MsgChanOpenConfirm should be sent to the provider.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanCloseInit​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#onchancloseinit","content":" OnChanCloseInit allow relayers to close duplicate OPEN channels, if the channel handshake is completed.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanCloseConfirm​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#onchancloseconfirm","content":" OnChanCloseConfirm is a no-op.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnRecvPacket​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#onrecvpacket","content":" OnRecvPacket unmarshals the IBC packet data into a ValidatorSetChangePacketData struct (see below) and executes the handling logic.  If it is the first packet received, sets the underlying IBC channel as the canonical CCV channel.Collects validator updates to be sent to the consensus engine at the end of the block.Store in state the block height to VSC id (i.e., valset_update_id) mapping.Removed the outstanding downtime flags from the validator for which the jailing for downtime infractions was acknowledged by the provider chain (see the slash_acks field in ValidatorSetChangePacketData).  message ValidatorSetChangePacketData { repeated .tendermint.abci.ValidatorUpdate validator_updates = 1 [ (gogoproto.nullable) = false, (gogoproto.moretags) = &quot;yaml:\\&quot;validator_updates\\&quot;&quot; ]; uint64 valset_update_id = 2; // consensus address of consumer chain validators // successfully jailed on the provider chain repeated string slash_acks = 3; }   ","version":"v6.3.0","tagName":"h3"},{"title":"OnAcknowledgementPacket​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#onacknowledgementpacket","content":" OnAcknowledgementPacket enables the consumer module to confirm that the provider module received the previously sent SlashPacket and it unblocks the sending of the next SlashPacket. This functionality is needed for throttling jailing on the provider chain. For more details, see ADR-008.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnTimeoutPacket​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#ontimeoutpacket","content":" OnTimeoutPacket is a no-op.  ","version":"v6.3.0","tagName":"h3"},{"title":"Messages​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#messages","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"MsgUpdateParams​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#msgupdateparams","content":" MsgUpdateParams updates the consumer module parameters. The params are updated through a governance proposal where the signer is the gov module account address.  message MsgUpdateParams { option (cosmos.msg.v1.signer) = &quot;authority&quot;; // signer is the address of the governance account. string authority = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // params defines the x/consumer parameters to update. interchain_security.ccv.v1.ConsumerParams params = 2 [(gogoproto.nullable) = false]; }   ","version":"v6.3.0","tagName":"h3"},{"title":"BeginBlock​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#beginblock","content":" In the BeginBlock of the consumer module the following actions are performed:  Store in state the block height to VSC id mapping needed for sending to the provider the height of infractions committed on the consumer chain.Track historical entries. This is the same lofic as in the x/staking module.  ","version":"v6.3.0","tagName":"h2"},{"title":"EndBlock​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#endblock","content":" In the EndBlock of the consumer module the following actions are performed:  If PreCCV state is active, i.e., the consumer chain is a previously standalone chain that was just upgraded to include the consumer module, then execute the changeover logic.Otherwise, distribute block rewards internally and once every BlocksPerDistributionTransmission send ICS rewards to the provider chain.Send slash packets to the provider chain reporting infractions validators commited on the consumer chain.Send to the consensus engine validator updates reveived from the provider chain.  ","version":"v6.3.0","tagName":"h2"},{"title":"Hooks​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#hooks","content":" TBA  ","version":"v6.3.0","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#events","content":" TBA  ","version":"v6.3.0","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#parameters","content":" warning The consumer module parameters are set by the provider when creating the consumer genesis (i.e., when launching the consumer chain). As a result, changes of these parameters might results in incompatibilities between different versions of consumers and providers.  The consumer module contains the following parameters.  ","version":"v6.3.0","tagName":"h2"},{"title":"Enabled​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#enabled","content":" Enabled is deprecated.  ","version":"v6.3.0","tagName":"h3"},{"title":"BlocksPerDistributionTransmission​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#blocksperdistributiontransmission","content":" Type\tDefault valueint64\t1000  BlocksPerDistributionTransmission is the number of blocks between rewards transfers from the consumer to the provider.  ","version":"v6.3.0","tagName":"h3"},{"title":"DistributionTransmissionChannel​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#distributiontransmissionchannel","content":" Type\tDefault valuestring\t&quot;&quot;  DistributionTransmissionChannel is the provider chain IBC channel used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  Providing an IBC transfer channel enables a consumer chain to re-use one of the existing channels to the provider for consumer chain rewards distribution. This will preserve the ibc denom that may already be in use. This is especially important for standalone chains transitioning to become consumer chains. For more details, see the changeover procedure.  ","version":"v6.3.0","tagName":"h3"},{"title":"ProviderFeePoolAddrStr​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#providerfeepooladdrstr","content":" Type\tDefault valuestring\t&quot;&quot;  ProviderFeePoolAddrStr is the provider chain fee pool address used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  ","version":"v6.3.0","tagName":"h3"},{"title":"CcvTimeoutPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#ccvtimeoutperiod","content":" Type\tDefault valuetime.Duration\t2419200s (4 weeks)  CcvTimeoutPeriod is the period used to compute the timeout timestamp when sending IBC packets.CcvTimeoutPeriod may have different values on the provider and consumer chains.  ","version":"v6.3.0","tagName":"h3"},{"title":"TransferTimeoutPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#transfertimeoutperiod","content":" Type\tDefault valuetime.Duration\t3600s (1 hour)  TransferTimeoutPeriod is the timeout period for consumer chain reward distribution IBC packets.  ","version":"v6.3.0","tagName":"h3"},{"title":"ConsumerRedistributionFraction​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#consumerredistributionfraction","content":" Type\tDefault valuestring\t&quot;0.75&quot;  ConsumerRedistributionFraction is the fraction of tokens allocated to the consumer redistribution address during distribution events. The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. For example, a consumer with ConsumerRedistributionFraction set to &quot;0.75&quot; would send 75% of its block rewards and accumulated fees to the consumer redistribution address, and the remaining 25% to the provider chain every BlocksPerDistributionTransmission blocks.  ","version":"v6.3.0","tagName":"h3"},{"title":"HistoricalEntries​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#historicalentries","content":" Type\tDefault valueint64\t10000  HistoricalEntries is the number of historical info entries to persist in store (see the staking module parameter with the same name for details).HistoricalEntries is needed since the consumer module acts as a staking module on the consumer chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"UnbondingPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#unbondingperiod","content":" Type\tDefault valuetime.Duration\t1209600s (2 weeks)  UnbondingPeriod is the unbonding period on the consumer chain. It is recommended that every consumer chain set and unbonding period shorter than provider unbonding period, e.g., one week shorter.  ","version":"v6.3.0","tagName":"h3"},{"title":"SoftOptOutThreshold​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#softoptoutthreshold","content":" SoftOptOutThreshold is deprecated.  ","version":"v6.3.0","tagName":"h3"},{"title":"RewardDenoms​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#rewarddenoms","content":" Type\tDefault value[]string\t[]string  RewardDenoms are the denominations which are allowed to be sent to the provider as ICS rewards.  ","version":"v6.3.0","tagName":"h3"},{"title":"ProviderRewardDenoms​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#providerrewarddenoms","content":" Type\tDefault value[]string\t[]string  ProviderRewardDenoms are the denominations coming from the provider which are allowed to be used as ICS rewards. e.g. &quot;uatom&quot;.  ","version":"v6.3.0","tagName":"h3"},{"title":"RetryDelayPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#retrydelayperiod","content":" Type\tDefault valuetime.Duration\t3600s (1 hour)  RetryDelayPeriod is the period at which the consumer retries to send a SlashPacket that was rejected by the provider. For more details, see ADR-008.  ","version":"v6.3.0","tagName":"h3"},{"title":"Client​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#client","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"CLI​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#cli","content":" A user can interact with the consumer module using the CLI.  Query​  The query commands allow users to query consumer state.  interchain-security-cd query ccvconsumer --help   Next Fee Distribution​  The next-fee-distribution command allows to query next fee distribution data.  interchain-security-cd query ccvconsumer next-fee-distribution [flags]   Example interchain-security-cd query ccvconsumer next-fee-distribution Output: data: currentHeight: &quot;967&quot; distribution_fraction: &quot;0.75&quot; lastHeight: &quot;960&quot; nextHeight: &quot;980&quot; toConsumer: &quot;&quot; toProvider: &quot;&quot; total: &quot;&quot;   Provider Info​  The provider-info command allows to query provider info.  interchain-security-cd query ccvconsumer provider-info [flags]   Example interchain-security-cd query ccvconsumer provider-info Output: consumer: chainID: pion-1 channelID: channel-0 clientID: 07-tendermint-0 connectionID: connection-0 provider: chainID: provider channelID: channel-0 clientID: 07-tendermint-0 connectionID: connection-0   Throttle State​  The throttle-state command allows to query on-chain state relevant with slash packet throttling.  interchain-security-cd query ccvconsumer throttle-state [flags]   Example interchain-security-cd query ccvconsumer throttle-state Output: packet_data_queue: - slashPacketData: infraction: INFRACTION_DOWNTIME validator: address: mb06cu8SzQJOdYSzrJAK43Q8at8= power: &quot;500&quot; valset_update_id: &quot;48&quot; type: CONSUMER_PACKET_TYPE_SLASH slash_record: send_time: &quot;2024-10-02T07:58:24.405645924Z&quot; waiting_on_reply: true   Params​  The params command allows to query consumer module parameters.  interchain-security-cd query ccvconsumer params [flags]   Example interchain-security-cd query ccvconsumer params Output: params: blocks_per_distribution_transmission: &quot;1000&quot; ccv_timeout_period: 2419200s consumer_id: &quot;0&quot; consumer_redistribution_fraction: &quot;0.75&quot; distribution_transmission_channel: channel-1 enabled: true historical_entries: &quot;10000&quot; provider_fee_pool_addr_str: cosmos1ap0mh6xzfn8943urr84q6ae7zfnar48am2erhd provider_reward_denoms: [] retry_delay_period: 3600s reward_denoms: [] soft_opt_out_threshold: &quot;0&quot; transfer_timeout_period: 3600s unbonding_period: 1209600s   ","version":"v6.3.0","tagName":"h3"},{"title":"gRPC​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#grpc","content":" A user can query the consumer module using gRPC endpoints.  Next Fee Distribution​  The QueryNextFeeDistribution endpoint queries next fee distribution data.  interchain_security.ccv.consumer.v1.Query/QueryNextFeeDistribution   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryNextFeeDistribution Output: { &quot;data&quot;: { &quot;currentHeight&quot;: &quot;402&quot;, &quot;lastHeight&quot;: &quot;400&quot;, &quot;nextHeight&quot;: &quot;420&quot;, &quot;distributionFraction&quot;: &quot;0.75&quot; } }   Provider Info​  The QueryProviderInfo endpoint queries provider info.  interchain_security.ccv.consumer.v1.Query/QueryProviderInfo   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryProviderInfo Output: { &quot;consumer&quot;: { &quot;chainID&quot;: &quot;pion-1&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; }, &quot;provider&quot;: { &quot;chainID&quot;: &quot;provider&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; } }   Throttle State​  The QueryThrottleState endpoint queries on-chain state relevant with slash packet throttling.  interchain_security.ccv.consumer.v1.Query/QueryThrottleState   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryThrottleState Output: { &quot;slashRecord&quot;: { &quot;waitingOnReply&quot;: true, &quot;sendTime&quot;: &quot;2024-10-02T07:58:24.405645924Z&quot; }, &quot;packetDataQueue&quot;: [ { &quot;type&quot;: &quot;CONSUMER_PACKET_TYPE_SLASH&quot;, &quot;slashPacketData&quot;: { &quot;validator&quot;: { &quot;address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;power&quot;: &quot;500&quot; }, &quot;valsetUpdateId&quot;: &quot;48&quot;, &quot;infraction&quot;: &quot;INFRACTION_DOWNTIME&quot; } } ] }   Params​  The QueryParams endpoint queries consumer module parameters.  interchain_security.ccv.consumer.v1.Query/QueryParams   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryParams Output: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1000&quot;, &quot;distributionTransmissionChannel&quot;: &quot;channel-1&quot;, &quot;providerFeePoolAddrStr&quot;: &quot;cosmos1ap0mh6xzfn8943urr84q6ae7zfnar48am2erhd&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;10000&quot;, &quot;unbondingPeriod&quot;: &quot;1209600s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot;, &quot;consumerId&quot;: &quot;0&quot; } }   ","version":"v6.3.0","tagName":"h3"},{"title":"REST​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.3.0/build/modules/consumer#rest","content":" A user can query the consumer module using REST endpoints.  Next Fee Distribution​  The next-fee-distribution endpoint queries next fee distribution data.  /interchain_security/ccv/consumer/next-fee-distribution   Example curl http://localhost:1317/interchain_security/ccv/consumer/next-fee-distribution Output: { &quot;data&quot;: { &quot;currentHeight&quot;: &quot;402&quot;, &quot;lastHeight&quot;: &quot;400&quot;, &quot;nextHeight&quot;: &quot;420&quot;, &quot;distributionFraction&quot;: &quot;0.75&quot; } }   Provider Info​  The QueryProviderInfo endpoint queries provider info.  /interchain_security/ccv/consumer/provider-info   Example curl http://localhost:1317/interchain_security/ccv/consumer/provider-info Output: { &quot;consumer&quot;: { &quot;chainID&quot;: &quot;pion-1&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; }, &quot;provider&quot;: { &quot;chainID&quot;: &quot;provider&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; } }   Throttle State​  The throttle_state endpoint queries on-chain state relevant with slash packet throttling.  /interchain_security/ccv/consumer/throttle_state   Example curl http://localhost:1317/interchain_security/ccv/consumer/throttle_state Output: { &quot;consumer&quot;: { &quot;chainID&quot;: &quot;pion-1&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; }, &quot;provider&quot;: { &quot;chainID&quot;: &quot;provider&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; } }   Params​  The params endpoint queries consumer module parameters.  /interchain_security/ccv/consumer/params   Example curl http://localhost:1317/interchain_security/ccv/consumer/params Output: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1000&quot;, &quot;distributionTransmissionChannel&quot;: &quot;channel-1&quot;, &quot;providerFeePoolAddrStr&quot;: &quot;cosmos1ap0mh6xzfn8943urr84q6ae7zfnar48am2erhd&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;10000&quot;, &quot;unbondingPeriod&quot;: &quot;1209600s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot;, &quot;consumerId&quot;: &quot;0&quot; } }  ","version":"v6.3.0","tagName":"h3"},{"title":"x/ccv/democracy","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/build/modules/democracy","content":"","keywords":"","version":"v6.3.0"},{"title":"Staking​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.3.0/build/modules/democracy#staking","content":" The x/ccv/democracy/staking module allows the cosmos-sdk x/staking module to be used alongside the interchain security consumer module.  The module uses overrides that allow the full x/staking functionality with one notable difference - the staking module will no longer be used to provide the validator set to the consensus engine.  ","version":"v6.3.0","tagName":"h2"},{"title":"Implications for consumer chains​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.3.0/build/modules/democracy#implications-for-consumer-chains","content":" The x/ccv/democracy/staking allows consumer chains to separate governance from block production. The validator set coming from the provider chain does not need to participate in governance - they only provide infrastructure (create blocks and maintain consensus).  Governators (aka. Governors)​  Validators registered with the x/ccv/democracy/staking module become Governators. Unlike validators, governators are not required to run any chain infrastructure since they are not signing any blocks. However, governators retain a subset of the validator properties:  new governators can be created (via MsgCreateValidator)governators can accept delegationsgovernators can vote on governance proposals (with their self stake and delegations)governators earn block rewards -- the block rewards kept on the consumer (see the ConsumerRedistributionFraction param) are distributed to all governators and their delegators.  With these changes, governators can become community advocates that can specialize in chain governance and they get rewarded for their participation the same way the validators do. Additionally, governators can choose to provide additional infrastructure such as RPC/API access points, archive nodes, indexers and similar software.  Tokenomics​  The consumer chain's token will remain a governance token. The token's parameters (inflation, max supply, burn rate) are completely under the control of the consumer chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.3.0/build/modules/democracy#integration","content":" The x/ccv/democracy/staking module provides these x/staking overrides:   // InitGenesis delegates the InitGenesis call to the underlying x/staking module, // however, it returns no validator updates as validators are tracked via the // consumer chain's x/cvv/consumer module and so this module is not responsible for returning the initial validator set. func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run staking InitGenesis return []abci.ValidatorUpdate{} // do not return validator updates } // EndBlock delegates the EndBlock call to the underlying x/staking module. // However, no validator updates are returned as validators are tracked via the // consumer chain's x/cvv/consumer module. func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates return []abci.ValidatorUpdate{} // do not return validator updates }   To integrate the democracy/staking follow this guide:  1. confirm that no modules are returning validator updates​  warning Only the x/ccv/consumer module should be returning validator updates.  If some of your modules are returning validator updates please disable them while maintaining your business logic:  func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) -\treturn am.keeper.InitGenesis(ctx, &amp;genesisState) + _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run InitGenesis but drop the result +\treturn []abci.ValidatorUpdate{} // return empty validator updates } func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { -\treturn am.keeper.BlockValidatorUpdates(ctx) + _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates +\treturn []abci.ValidatorUpdate{} // return empty validator updates }   2. wire the module in app.go​  You do not need to remove the cosmos-sdk StakingKeeper from your wiring.  import ( ... + ccvstaking &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/staking&quot; ) var ( // replace the staking.AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, - sdkstaking.AppModuleBasic{}, + ccvstaking.AppModuleBasic{}, // replace sdkstaking ... ) ) func NewApp(...) { ... // use sdk StakingKeepeer app.StakingKeeper = stakingkeeper.NewKeeper( appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.MintKeeper = mintkeeper.NewKeeper( appCodec, keys[minttypes.StoreKey], app.StakingKeeper, app.AccountKeeper, app.BankKeeper, authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // no changes required for the distribution keeper app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // keep StakingKeeper! authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) + // pre-initialize ConsumerKeeper to satsfy ibckeeper.NewKeeper +\tapp.ConsumerKeeper = consumerkeeper.NewNonZeroKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), +\t) + +\tapp.IBCKeeper = ibckeeper.NewKeeper( + appCodec, + keys[ibchost.StoreKey], + app.GetSubspace(ibchost.ModuleName), + &amp;app.ConsumerKeeper, + app.UpgradeKeeper, + scopedIBCKeeper, +\t) + +\t// Create CCV consumer and modules +\tapp.ConsumerKeeper = consumerkeeper.NewKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), + scopedIBCConsumerKeeper, + app.IBCKeeper.ChannelKeeper, + &amp;app.IBCKeeper.PortKeeper, + app.IBCKeeper.ConnectionKeeper, + app.IBCKeeper.ClientKeeper, + app.SlashingKeeper, + app.BankKeeper, + app.AccountKeeper, + &amp;app.TransferKeeper, + app.IBCKeeper, + authtypes.FeeCollectorName, +\t) + +\t// Setting the standalone staking keeper is only needed for standalone to consumer changeover chains + // New chains using the democracy/staking do not need to set this +\tapp.ConsumerKeeper.SetStandaloneStakingKeeper(app.StakingKeeper) // change the slashing keeper dependency app.SlashingKeeper = slashingkeeper.NewKeeper( appCodec, legacyAmino, keys[slashingtypes.StoreKey], - app.StakingKeeper, + &amp;app.ConsumerKeeper, // ConsumerKeeper implements StakingKeeper interface authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register slashing module StakingHooks to the consumer keeper +\tapp.ConsumerKeeper = *app.ConsumerKeeper.SetHooks(app.SlashingKeeper.Hooks()) +\tconsumerModule := consumer.NewAppModule(app.ConsumerKeeper, app.GetSubspace(consumertypes.ModuleName)) // register the module with module manager // replace the x/staking module app.MM = module.NewManager( ... - sdkstaking.NewAppModule(appCodec, &amp;app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), + ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }   ","version":"v6.3.0","tagName":"h3"},{"title":"Governance​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.3.0/build/modules/democracy#governance","content":" The x/ccv/democracy/governance module extends the x/governance module with the functionality to filter proposals. The module uses AnteHandler to limit the types of proposals that can be executed. As a result, consumer chains can limit the types of governance proposals that can be executed on chain to avoid inadvertent changes to the ICS protocol that could affect security properties.  ","version":"v6.3.0","tagName":"h2"},{"title":"Integration​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.3.0/build/modules/democracy#integration-1","content":" Add new AnteHandler to your app.   // app/ante/forbidden_proposals.go package ante import ( &quot;fmt&quot; sdk &quot;github.com/cosmos/cosmos-sdk/types&quot; govv1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1&quot; govv1beta1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; ibctransfertypes &quot;github.com/cosmos/ibc-go/v7/modules/apps/transfer/types&quot; &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; &quot;github.com/cosmos/cosmos-sdk/x/params/types/proposal&quot; ) type ForbiddenProposalsDecorator struct { isLegacyProposalWhitelisted func(govv1beta1.Content) bool isModuleWhiteList func(string) bool } func NewForbiddenProposalsDecorator( whiteListFn func(govv1beta1.Content) bool, isModuleWhiteList func(string) bool, ) ForbiddenProposalsDecorator { return ForbiddenProposalsDecorator{ isLegacyProposalWhitelisted: whiteListFn, isModuleWhiteList: isModuleWhiteList, } } func (decorator ForbiddenProposalsDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (newCtx sdk.Context, err error) { currHeight := ctx.BlockHeight() for _, msg := range tx.GetMsgs() { // if the message is MsgSubmitProposal, check if proposal is whitelisted submitProposalMgs, ok := msg.(*govv1.MsgSubmitProposal) if !ok { continue } messages := submitProposalMgs.GetMessages() for _, message := range messages { if sdkMsg, isLegacyProposal := message.GetCachedValue().(*govv1.MsgExecLegacyContent); isLegacyProposal { // legacy gov proposal content content, err := govv1.LegacyContentFromMessage(sdkMsg) if err != nil { return ctx, fmt.Errorf(&quot;tx contains invalid LegacyContent&quot;) } if !decorator.isLegacyProposalWhitelisted(content) { return ctx, fmt.Errorf(&quot;tx contains unsupported proposal message types at height %d&quot;, currHeight) } continue } // not legacy gov proposal content and not whitelisted if !decorator.isModuleWhiteList(message.TypeUrl) { return ctx, fmt.Errorf(&quot;tx contains unsupported proposal message types at height %d&quot;, currHeight) } } } return next(ctx, tx, simulate) } func IsProposalWhitelisted(content v1beta1.Content) bool { switch c := content.(type) { case *proposal.ParameterChangeProposal: return isLegacyParamChangeWhitelisted(c.Changes) default: return false } } func isLegacyParamChangeWhitelisted(paramChanges []proposal.ParamChange) bool { for _, paramChange := range paramChanges { _, found := LegacyWhitelistedParams[legacyParamChangeKey{Subspace: paramChange.Subspace, Key: paramChange.Key}] if !found { return false } } return true } type legacyParamChangeKey struct { Subspace, Key string } // Legacy params can be whitelisted var LegacyWhitelistedParams = map[legacyParamChangeKey]struct{}{ {Subspace: ibctransfertypes.ModuleName, Key: &quot;SendEnabled&quot;}: {}, {Subspace: ibctransfertypes.ModuleName, Key: &quot;ReceiveEnabled&quot;}: {}, } // New proposal types can be whitelisted var WhiteListModule = map[string]struct{}{ &quot;/cosmos.gov.v1.MsgUpdateParams&quot;: {}, &quot;/cosmos.bank.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.staking.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.distribution.v1beta1.MsgUpdateParams&quot;: {}, &quot;/cosmos.mint.v1beta1.MsgUpdateParams&quot;: {}, } func IsModuleWhiteList(typeUrl string) bool { _, found := WhiteListModule[typeUrl] return found }   Add the AnteHandler to the list of supported antehandlers:  // app/ante_handler.go package app import ( ... +\tdemocracyante &quot;github.com/cosmos/interchain-security/v4/app/consumer-democracy/ante&quot; +\tconsumerante &quot;github.com/cosmos/interchain-security/v4/app/consumer/ante&quot; +\ticsconsumerkeeper &quot;github.com/cosmos/interchain-security/v4/x/ccv/consumer/keeper&quot; ) type HandlerOptions struct { ante.HandlerOptions IBCKeeper *ibckeeper.Keeper +\tConsumerKeeper ibcconsumerkeeper.Keeper } func NewAnteHandler(options HandlerOptions) (sdk.AnteHandler, error) { .... anteDecorators := []sdk.AnteDecorator{ ... + consumerante.NewMsgFilterDecorator(options.ConsumerKeeper), + consumerante.NewDisabledModulesDecorator(&quot;/cosmos.evidence&quot;, &quot;/cosmos.slashing&quot;), + democracyante.NewForbiddenProposalsDecorator(IsProposalWhitelisted, IsModuleWhiteList), ... } return sdk.ChainAnteDecorators(anteDecorators...), nil }   Wire the module in app.go.  // app/app.go package app import ( ... sdkgov &quot;github.com/cosmos/cosmos-sdk/x/gov&quot; govkeeper &quot;github.com/cosmos/cosmos-sdk/x/gov/keeper&quot; govtypes &quot;github.com/cosmos/cosmos-sdk/x/gov/types&quot; govv1beta1 &quot;github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1&quot; +\tccvgov &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/governance&quot; ) var ( // use sdk governance module ModuleBasics = module.NewBasicManager( ... sdkgov.NewAppModuleBasic( []govclient.ProposalHandler{ paramsclient.ProposalHandler, upgradeclient.LegacyProposalHandler, upgradeclient.LegacyCancelProposalHandler, }, ), ) ) func NewApp(...) { // retain sdk gov router and keeper registrations sdkgovRouter := govv1beta1.NewRouter() sdkgovRouter. AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler). AddRoute(paramproposal.RouterKey, params.NewParamChangeProposalHandler(app.ParamsKeeper)). AddRoute(upgradetypes.RouterKey, upgrade.NewSoftwareUpgradeProposalHandler(&amp;app.UpgradeKeeper)) govConfig := govtypes.DefaultConfig() app.GovKeeper = *govkeeper.NewKeeper( appCodec, keys[govtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, app.MsgServiceRouter(), govConfig, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.GovKeeper.SetLegacyRouter(sdkgovRouter) // register the module with module manager // replace the x/gov module app.MM = module.NewManager( - sdkgov.NewAppModule(appCodec, app.GovKeeper, app.AccountKeeper, app.BankKeeper, IsProposalWhitelisted, app.GetSubspace(govtypes.ModuleName), IsModuleWhiteList), + ccvgov.NewAppModule(appCodec, app.GovKeeper, app.AccountKeeper, app.BankKeeper, IsProposalWhitelisted, app.GetSubspace(govtypes.ModuleName), IsModuleWhiteList), ... ) }   ","version":"v6.3.0","tagName":"h3"},{"title":"Distribution​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.3.0/build/modules/democracy#distribution","content":" The x/ccv/democracy/distribution module allows the consumer chain to send rewards to the provider chain while retaining the logic of the x/distribution module for internal reward distribution to governators and their delegators.  ","version":"v6.3.0","tagName":"h2"},{"title":"How it works​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.3.0/build/modules/democracy#how-it-works","content":" First, a percentage of the block rewards is sent to the provider chain, where is distributed only to opted-in validators and their delegators. Second, the remaining rewards get distributed to the consumer chain's governators and their delegators. The percentage that is sent to the provider chain corresponds to 1 - ConsumerRedistributionFraction. For example, ConsumerRedistributionFraction = &quot;0.75&quot; means that the consumer chain retains 75% of the rewards, while 25% gets sent to the provider chain  ","version":"v6.3.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.3.0/build/modules/democracy#integration-2","content":" Change the wiring in app.go  import ( ... distrkeeper &quot;github.com/cosmos/cosmos-sdk/x/distribution/keeper&quot; distrtypes &quot;github.com/cosmos/cosmos-sdk/x/distribution/types&quot; sdkdistr &quot;github.com/cosmos/cosmos-sdk/x/distribution&quot; + ccvdistr &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/distribution&quot; ) var ( // replace sdk distribution AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, ccvstaking.AppModuleBasic{}, // make sure you first swap the staking keeper mint.AppModuleBasic{}, - sdkdistr.AppModuleBasic{}, + ccvdistr.AppModuleBasic{}, ) ) func NewApp(...) { .... app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // connect to sdk StakingKeeper consumertypes.ConsumerRedistributeName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register with the module manager app.MM = module.NewManager( ... - sdkdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), + ccvdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }  ","version":"v6.3.0","tagName":"h3"},{"title":"Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure","content":"","keywords":"","version":"v6.3.0"},{"title":"Overview​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#overview","content":" Standalone to consumer changeover procedure can roughly be separated into 4 parts:  ","version":"v6.3.0","tagName":"h2"},{"title":"1. MsgCreateConsumer submitted to the provider chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#1-msgcreateconsumer-submitted-to-the-provider-chain","content":" The MsgCreateConsumer is equivalent to the &quot;normal&quot; MsgCreateConsumer message submitted by new consumer chains.  However, here are the most important notes and differences between a new consumer chain and a standalone chain performing a changeover:  chain_id must be equal to the standalone chain idinitial_height field has additional rules to abide by:  caution { ... &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. stride-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_height&quot;: 101, }, ... }   genesis_hash can be safely ignored because the chain is already running. A hash of the standalone chain's initial genesis may be used binary_hash may not be available ahead of time. All chains performing the changeover go through rigorous testing - if bugs are caught and fixed the hash listed in the proposal may not be the most recent one. spawn_time listed in the proposal MUST be before the upgrade_height listed in the upgrade proposal on the standalone chain.  caution spawn_time must occur before the upgrade_height on the standalone chain is reached because the provider chain must generate the ConsumerGenesis that contains the validator set that will be used after the changeover.  unbonding_period must correspond to the value used on the standalone chain. Otherwise, the clients used for the ccv protocol may be incorrectly initialized. distribution_transmission_channel should be set.  note Populating distribution_transmission_channel will enable the standalone chain to reuse one of the existing channels to the provider for consumer chain rewards distribution. This will preserve the ibc denom that may already be in use. If the parameter is not set, a new channel will be created.  ccv_timeout_period has no important notes transfer_timeout_period has no important notes consumer_redistribution_fraction has no important notes blocks_per_distribution_transmission has no important notes historical_entries has no important notes  ","version":"v6.3.0","tagName":"h3"},{"title":"2. upgrade proposal on standalone chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#2-upgrade-proposal-on-standalone-chain","content":" The standalone chain creates an upgrade proposal to include the interchain-security/x/ccv/consumer module.  caution The upgrade height in the proposal should correspond to a height that is after the spawn_time in the MsgCreateConsumer submitted to the provider chain.  Otherwise, the upgrade is indistinguishable from a regular on-chain upgrade proposal.  ","version":"v6.3.0","tagName":"h3"},{"title":"3. spawn time is reached​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#3-spawn-time-is-reached","content":" When the spawn_time is reached on the provider it will generate a ConsumerGenesis that contains the validator set that will supersede the standalone validator set.  This ConsumerGenesis must be available on the standalone chain during the on-chain upgrade.  ","version":"v6.3.0","tagName":"h3"},{"title":"4. standalone chain upgrade​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#4-standalone-chain-upgrade","content":" Performing the on-chain upgrade on the standalone chain will add the ccv/consumer module and allow the chain to become a consumer of Interchain Security.  caution The ConsumerGenesis must be exported to a file and placed in the correct folder on the standalone chain before the upgrade. The file must be placed at the exact specified location, otherwise the upgrade will not be executed correctly. Usually the file is placed in $NODE_HOME/config, but the file name and the exact directory is dictated by the upgrade code on the standalone chain. please check exact instructions provided by the standalone chain team  After the genesis.json file has been made available, the process is equivalent to a normal on-chain upgrade. The standalone validator set will sign the next couple of blocks before transferring control to provider validator set.  The standalone validator set can still be slashed for any infractions if evidence is submitted within the unboding_period.  Notes​  The changeover procedure may be updated in the future to create a seamless way of providing the validator set information to the standalone chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"Onboarding Checklist​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#onboarding-checklist","content":" This onboarding checklist is slightly different from the one under Onboarding  Additionally, you can check the testnet repo for a comprehensive guide on preparing and launching consumer chains.  ","version":"v6.3.0","tagName":"h2"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.4.1) test the changeover procedure reach out to the ICS team if you are facing issues  ","version":"v6.3.0","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json with CCV data (after spawn time passes). Check if CCV data needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) copy of your governance proposal (as JSON) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"v6.3.0","tagName":"h2"},{"title":"3. Submit a MsgCreateConsumer to the provider​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#3-submit-a-msgcreateconsumer-to-the-provider","content":" Before you submit a MsgCreateConsumer message, please provide a spawn_time that is before the upgrade_height of the upgrade that will introduce the ccv module to your chain.  danger If the spawn_time happens after your upgrade_height the provider will not be able to communicate the new validator set to be used after the changeover.  Additionally, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters to be put in the proposal take note to include a link to your onboarding repository  Example of initialization parameters (compare with the those for chains that launch as consumers):  // ConsumerInitializationParameters provided in MsgCreateConsumer or MsgUpdateConsumer { // Initial height of new consumer chain. &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. standalone-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_height&quot;: 101, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // =&gt; not relevant for changeover procedure &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on standalone chain upgrade // =&gt; not relevant for changeover procedure as it may become stale &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and all validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should should be smaller than that of the provider. &quot;unbonding_period&quot;: 1728000000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 2419200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot; // NOTE: use existing transfer channel if available }   info The changeover procedure can be used together with Partial Set Security. This means, that a standalone chain can choose to only be validated by some of the validators of the provider chain by setting top_N appropriately, or by additionally setting a validators-power cap, validator-set cap, etc. by using the power-shaping parameters.  ","version":"v6.3.0","tagName":"h2"},{"title":"3. Submit an Upgrade Proposal & Prepare for Changeover​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#3-submit-an-upgrade-proposal--prepare-for-changeover","content":" This proposal should add the ccv consumer module to your chain.   proposal upgrade_height must happen after spawn_time in the MsgCreateConsumer advise validators about the exact procedure for your chain and point them to your onboarding repository  ","version":"v6.3.0","tagName":"h2"},{"title":"4. Upgrade time 🚀​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.3.0/consumer-development/changeover-procedure#4-upgrade-time-","content":"  after spawn_time, request ConsumerGenesis from the provider and place it in &lt;CURRENT_USER_HOME_DIR&gt;/.sovereign/config/genesis.json upgrade the binary to the one listed in your UpgradeProposal  The chain starts after at least 66.67% of standalone voting power comes online. The consumer chain is considered interchain secured once the &quot;old&quot; validator set signs a couple of blocks and transfers control to the provider validator set.   provide a repo with onboarding instructions for validators (it should already be listed in the proposal) genesis.json after spawn_time obtained from provider (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) ","version":"v6.3.0","tagName":"h2"},{"title":"Consumer Chain Governance","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/consumer-development/consumer-chain-governance","content":"","keywords":"","version":"v6.3.0"},{"title":"Democracy module​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v6.3.0/consumer-development/consumer-chain-governance#democracy-module","content":" The democracy module provides a governance experience identical to what exists on a standalone Cosmos chain, with one small but important difference. On a standalone Cosmos chain validators can act as representatives for their delegators by voting with their stake, but only if the delegator themselves does not vote. This is a lightweight form of liquid democracy.  Using the democracy module on a consumer chain is the exact same experience, except for the fact that it is not the actual validator set of the chain (since it is a consumer chain, these are the Cosmos Hub validators) acting as representatives. Instead, there is a separate representative role who token holders can delegate to and who can perform the functions that validators do in Cosmos governance, without participating in proof of stake consensus.  For an example, see the Democracy Consumer  ","version":"v6.3.0","tagName":"h2"},{"title":"CosmWasm​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v6.3.0/consumer-development/consumer-chain-governance#cosmwasm","content":" There are several great DAO and governance frameworks written as CosmWasm contracts. These can be used as the main governance system for a consumer chain. Actions triggered by the CosmWasm governance contracts are able to affect parameters and trigger actions on the consumer chain.  For an example, see Neutron.  ","version":"v6.3.0","tagName":"h2"},{"title":"The Whitelist​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v6.3.0/consumer-development/consumer-chain-governance#the-whitelist","content":" Not everything on a consumer chain can be changed by the consumer's governance. Some settings having to do with consensus etc. can only be changed by the provider chain. Consumer chains include a whitelist of parameters that are allowed to be changed by the consumer chain governance. For an example, see Neutron's whitelist. ","version":"v6.3.0","tagName":"h2"},{"title":"Consumer Genesis Transformation","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/consumer-development/consumer-genesis-transformation","content":"","keywords":"","version":"v6.3.0"},{"title":"1. Prerequisite​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v6.3.0/consumer-development/consumer-genesis-transformation#1-prerequisite","content":" used provider and consumer versions require transformation step as indicated in in the compatibility notesinterchain-security-cd application supports the versions used by the consumer and provider  ","version":"v6.3.0","tagName":"h2"},{"title":"2. Export the CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v6.3.0/consumer-development/consumer-genesis-transformation#2-export-the-ccv-data","content":" Export the CCV data from the provider chain as described in the Onboarding and Changeover your following. As a result the CCV data will be stored in a file in JSON format.  ","version":"v6.3.0","tagName":"h2"},{"title":"3. Transform CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v6.3.0/consumer-development/consumer-genesis-transformation#3-transform-ccv-data","content":" To transform the CCV data  to the format supported by the current version of the consumer run the following command: interchain-security-cd genesis transform [genesis-file] where 'genesis-file' is the path to the file containing the CCV data exported in step 2. As a result the CCV data in the new format will be written to standard output.a specific target version of a consumer run the following command: interchain-security-cd genesis transform --to &lt;target_version&gt; [genesis-file] where &lt;target_version is the ICS version the consumer chain is running. Use interchain-security-cd genesis transform --help to get more details about supported target versions and more.  Use the new CCV data as described in the procedure you're following. ","version":"v6.3.0","tagName":"h2"},{"title":"Consumer Offboarding","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/consumer-development/offboarding","content":"Consumer Offboarding To offboard a consumer chain, the owner of the chain has to submit a MsgRemoveConsumer message with the chain's consumerId. If the chain is a Top N chain, the MsgRemoveConsumer has to be submitted through a governance proposal. Otherwise, the message can be submitted simply by the owner of the consumer chain. When the MsgRemoveConsumer executes, the provider chain will stop the chain from the ICS protocol (it will stop sending validator set updates) and the chain is considered to be in the stopped phase. At this phase, validators cannot opt in, change keys, etc. and validators stop receiving rewards. After the chain is stopped, and an unbonding period of time passes, part of the state of the chain is deleted and the chain is considered deleted.","keywords":"","version":"v6.3.0"},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/faq","content":"","keywords":"","version":"v6.3.0"},{"title":"General​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#general","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"What is Interchain Security (ICS)?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#what-is-interchain-security-ics","content":" ICS is an IBC protocol that enables a provider chain (e.g., the Cosmos Hub) to provide security to multiple consumer chains. This means that consumer chains will leverage the stake locked on the provider chain for block production (i.e., a cross-chain proof-of-stake system). ICS allows anyone to launch a consumer chain using a subset, or even the entire, validator set from the provider chain. Note that validators need to run separate infrastructure for the provider and consumer chains, resulting in different networks that only share (a subset of) the validator set.  ","version":"v6.3.0","tagName":"h3"},{"title":"What is the difference between ICS and Partial Set Security (PSS)?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#what-is-the-difference-between-ics-and-partial-set-security-pss","content":" ICS is a protocol. PSS is a feature of ICS that allows a provider chain to share only a subset of its validator set with a consumer chain. PSS differentiates between TopN and Opt-In consumer chains. For TopN chains, the validator subset is determined by the top N% provider validators by voting power. For Opt-In chains, the validator subset is determined by validators opting in to validate the consumer chains. PSS allows for flexible tradeoffs between security, decentralization, and the budget a consumer chain spends on rewards to validators.  For more details, see the PSS feature.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consumer Chains​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#consumer-chains","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"What are consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#what-are-consumer-chains","content":" Consumer chains are blockchains operated by (a subset of) the validators of the provider chain. The ICS protocol ensures that consumer chains get information about which validators should validate on them. This information consists of the opted in validators and their power on the consumer chains. Note that the validators' power on the consumer chains is a function of their stake locked on the provider chain.  Consumer chains are run on infrastructure (virtual or physical machines) distinct from the provider chain, have their own configurations and operating requirements.  Consumer chains are free to choose how they wish to operate and which modules to include. For example, they can choose to use CosmWasm either in a permissioned or a permissionless way. Also, consumer chains are free to perform software upgrades at any time without impacting the provider chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"How to become a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#how-to-become-a-consumer-chain","content":" To become a consumer chain use this checklist and check the App integration section.  ","version":"v6.3.0","tagName":"h3"},{"title":"What happens to consumers if the provider is down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#what-happens-to-consumers-if-the-provider-is-down","content":" In case the provider chain halts or experiences difficulties, the consumer chains will keep operating - the provider chain and consumer chains represent different networks that only share (a subset of) the validator set. As the validators run separate infrastructure on these networks, the provider chain liveness does not impact the liveness of consumer chains.  Every consumer chain communicates with the provider chain via a CCV channel -- an IBC ordered channel. If any of the packets sent over the CCV channel timeout (see the CCVTimeoutPeriod param), then the channel is closed and, consequently, the consumer chain transitions to a Proof of Authority (PoA) chain. This means that the validator set on the consumer will no longer be updated with information from the provider.  ","version":"v6.3.0","tagName":"h3"},{"title":"What happens to provider if any of the consumers are down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#what-happens-to-provider-if-any-of-the-consumers-are-down","content":" Consumer chains do not impact the livness of the provider chain.The ICS protocol is concerned only with validator set management, and the only communication that the provider requires from the consumer is information about validator activity (essentially keeping the provider informed about slash events).  ","version":"v6.3.0","tagName":"h3"},{"title":"Can consumer chains have their own token?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#can-consumer-chains-have-their-own-token","content":" As any other Cosmos SDK chains, consumer chains can issue their own token and manage inflation parameters. Note that the ICS protocol does not impact the transaction fee system on the consumer chains. This means consumer chains can use any token (including their own token) to pay gas fees. For more details, see the democracy modules.  ","version":"v6.3.0","tagName":"h3"},{"title":"Can consumer chains have their own governance?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#can-consumer-chains-have-their-own-governance","content":" Yes. ICS allows consumer chains to separate governance from block production. Validator operators (with their stake locked on the provider) are responsible for block production, while representatives (aka governators, governors) are responsible for on-chain governance. For more details, see the democracy modules.  ","version":"v6.3.0","tagName":"h3"},{"title":"Can a consumer chain modify its power shaping parameters?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#can-a-consumer-chain-modify-its-power-shaping-parameters","content":" Yes, by issuing a MsgUpdateConsumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"Can a Top N consumer chain become Opt-In or vice versa?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#can-a-top-n-consumer-chain-become-opt-in-or-vice-versa","content":" Yes, by issuing a MsgUpdateConsumer (see Permissionless ICS)  ","version":"v6.3.0","tagName":"h3"},{"title":"Validators​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#validators","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"How can validators opt in to validate a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#how-can-validators-opt-in-to-validate-a-consumer-chain","content":" Check the validator guide to Partial Set Security.  An important note is that validator the top N% of the provider chain validator set are automatically opted in on Top N consumer chains.  ","version":"v6.3.0","tagName":"h3"},{"title":"Can validators opt in to an Opt-in chain after the spawn time if nobody else opted in?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#can-validators-opt-in-to-an-opt-in-chain-after-the-spawn-time-if-nobody-else-opted-in","content":" No, the consumer chain does not launch if nobody opted in by the spawn time. At least one validator, regardless of its voting power, must opt in before the spawn time in order for the chain can start.  ","version":"v6.3.0","tagName":"h3"},{"title":"How does a validator know which consumers chains it has to validate?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#how-does-a-validator-know-which-consumers-chains-it-has-to-validate","content":" In order for a validator to keep track of all the chains it has to validate, the validator can use thehas-to-validate query.  ","version":"v6.3.0","tagName":"h3"},{"title":"How many chains can a validator opt in to?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#how-many-chains-can-a-validator-opt-in-to","content":" There is no limit in the number of consumers chains a validator can choose to opt in to.  ","version":"v6.3.0","tagName":"h3"},{"title":"How can validators assign consumer keys?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#how-can-validators-assign-consumer-keys","content":" Check the Key Assignment guide for specific instructions.  Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  Also note that validators can assign consensus keys before a consumer chain is launched (e.g., during the voting period for Top N consumer chains).  ","version":"v6.3.0","tagName":"h3"},{"title":"What are the benefits for validators running consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#what-are-the-benefits-for-validators-running-consumer-chains","content":" The consumer chains sends a portion of its block rewards (e.g., transaction fees and inflation) to the provider chain as defined by the ConsumerRedistributionFraction param. These rewards are sent periodically to the provider (via IBC transfers), where they are distributed ONLY to the opted in validators and their delegators. For more details, see the Reward Distribution feature.  ","version":"v6.3.0","tagName":"h3"},{"title":"Can validators set per consumer chain commission rates?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#can-validators-set-per-consumer-chain-commission-rates","content":" Yes. See the validator guide to Partial Set Security.  ","version":"v6.3.0","tagName":"h3"},{"title":"What are the risks for validators running consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#what-are-the-risks-for-validators-running-consumer-chains","content":" Validators that perform an equivocation or a light-client attack on a consumer chain are slashed on the provider chain. This is done by submitting a proof of the equivocation or the light-client attack to the provider chain.  In addition, consumer chains send IBC packets via the CCV channels informing the provider when opted in validators should be jailed for downtime. It is important to notice that validators are not slashed for downtime on consumer chains. The downtime logic is custom to the consumer chain. For example, Cosmos SDK chains can use the slashing module to configure the downtime window.  For more details, see the slashing feature.  ","version":"v6.3.0","tagName":"h3"},{"title":"Can validators run the provider and consumer chains on the same machine?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#can-validators-run-the-provider-and-consumer-chains-on-the-same-machine","content":" In theory yes. In practice, we recommend validators to run the provider and consumer chains in separate environments for fault containment, i.e., failures of one machine do not impact the entire system.  ","version":"v6.3.0","tagName":"h3"},{"title":"Can validators opt out of validating a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#can-validators-opt-out-of-validating-a-consumer-chain","content":" Validators can always opt out from an Opt-In consumer chain. Validators can only opt out from a TopN chain if they do not belong to the top N% validators.  ","version":"v6.3.0","tagName":"h3"},{"title":"Can all validators opt out of an Opt-in chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#can-all-validators-opt-out-of-an-opt-in-chain","content":" Note that if all validators opt out of an Opt-In consumer chain, then the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"v6.3.0","tagName":"h3"},{"title":"How to connect to the testnets?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#how-to-connect-to-the-testnets","content":" Check out the Joining Interchain Security testnet section.  ","version":"v6.3.0","tagName":"h3"},{"title":"Integrators​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#integrators","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Which relayers are supported?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#which-relayers-are-supported","content":" Currently supported versions:  Hermes v1.8.0+  ","version":"v6.3.0","tagName":"h3"},{"title":"How to check when the next validator update will be sent to the consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.3.0/faq#how-to-check-when-the-next-validator-update-will-be-sent-to-the-consumer-chains","content":" Validator updates are sent to consumer chains every BlocksPerEpoch blocks. Depending on the status of relayers between the Hub and the consumer chains, it might take a while for the validator updates to be processed and applied on the consumer chains.  To query how many blocks are left until the next epoch starts, run the following command:  interchain-security-pd query provider blocks-until-next-epoch  ","version":"v6.3.0","tagName":"h3"},{"title":"Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/features/key-assignment","content":"","keywords":"","version":"v6.3.0"},{"title":"Rules​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.3.0/features/key-assignment#rules","content":" A key can be assigned to any active (i.e., in the registered, initialized, or launched phase) chain.Validator A cannot assign consumer key K to consumer chain X if there is already a validator B (B!=A) using K on the provider.Validator A cannot assign consumer key K to consumer chain X if there is already a validator B using K on X.A new validator on the provider cannot use a consensus key K if K is already used by any validator on any consumer chain.  ","version":"v6.3.0","tagName":"h2"},{"title":"Adding a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.3.0/features/key-assignment#adding-a-key","content":" warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  First, create a new node on the consumer chain using the equivalent:  consumerd init &lt;moniker&gt;   Then query your node for the consensus key.  consumerd tendermint show-validator # {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, make an assign-consensus-key transaction on the provider chain in order to inform the provider chain about the consensus key you will be using for a specific consumer chain.  gaiad tx provider assign-consensus-key &lt;consumer-id&gt; '&lt;pubkey&gt;' --from &lt;tx-signer&gt; --home &lt;home_dir&gt; --gas 900000 -b sync -y -o json   consumer-id is the string identifier of the consumer chain, as assigned on the provider chainconsumer-pub-key has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}  Check that the key was assigned correctly by querying the provider:  gaiad query provider validator-consumer-key &lt;consumer-id&gt; cosmosvalcons1e....3xsj3ayzf4uv6   You must use a valcons address. You can obtain it by querying your node on the provider gaiad tendermint show-address  OR  gaiad query provider validator-provider-key &lt;consumer-id&gt; consumervalcons1e....123asdnoaisdao   You must use a valcons address. You can obtain it by querying your node on the consumer consumerd tendermint show-address  OR  gaiad query provider all-pairs-valconsensus-address &lt;consumer-id&gt;   You just need to use the consumerId of consumer to query all pairs valconsensus address with consumer-pub-key for each of pair  ","version":"v6.3.0","tagName":"h2"},{"title":"Changing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.3.0/features/key-assignment#changing-a-key","content":" To change your key, simply repeat all of the steps listed above. Take note that your old key will be remembered for at least the unbonding period of the consumer chain so any slashes can be correctly applied  ","version":"v6.3.0","tagName":"h2"},{"title":"Removing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.3.0/features/key-assignment#removing-a-key","content":" To remove a key, simply switch it back to the consensus key you have assigned on the provider chain by following steps in the Adding a key section and using your provider consensus key. ","version":"v6.3.0","tagName":"h2"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/features/partial-set-security","content":"Partial Set Security Partial Set Security (PSS) is a complete revamp of the Hub's security offering. It allows consumer chains to leverage only a subset of validators from the provider chain, which offers more flexibility than the previous Replicated Security model. By introducing the top_N parameter, each consumer chain can choose the extent of security needed: Top N: Requires the top N% validators from the provider chain to secure the consumer chain. This guarantees that the validators with the most power on the provider will validate the consumer chain, while others can voluntarily opt in. Opt-In: If the top_N parameter is set to zero, no validator is mandated to secure the consumer chain. Instead, any validator from the provider chain can opt in using a dedicated transaction. An advantage of Top N chains is that they are guaranteed to receive at least a certain fraction of the market cap of the provider chain in security. In turn, Top N chains need to be approved by governance, since some validators will be forced to validate on them. Thus, Top N chains should typically expect to need to provide a strong case for why they should be added to the provider chain, and they should make sure they offer enough rewards to incentivize validators and delegators to vote for their proposal. Opt-In chains, on the other hand, are more flexible. Validators are never forced to validate these chains and simply opt in if they want to. Because of this, Opt-In chains can be launch completely permissionlessly by sending a transaction to the provider chain. As a trade-off though, Opt-In chains do not get a fixed amount of security as a relation of the market cap of the provider as top N chains do, so Opt-In chains might want to keep an eye on how many validators have opted in to validate their chain and adjust their reward emissions accordingly to incentivize validators. Note that Top N consumer chains can become Opt-In chains or vice versa via a MsgUpdateConsumer message. Partial Set Security is handled only by the provider chain - the consumer chains are simply sent validator sets, and they are not aware that this represents only a subset of the provider chain's validator set.","keywords":"","version":"v6.3.0"},{"title":"Power Shaping","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/features/power-shaping","content":"","keywords":"","version":"v6.3.0"},{"title":"Power Shaping Configuration​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.3.0/features/power-shaping#power-shaping-configuration","content":" Currently, ICS supports the following power shaping parameters.  ","version":"v6.3.0","tagName":"h2"},{"title":"Capping the validator set size​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.3.0/features/power-shaping#capping-the-validator-set-size","content":" The consumer chain can specify a maximum number of validators it wants to have in its validator set. This can be used to limit the number of validators in the set, which can be useful for chains that want to have a smaller validator set for faster blocks or lower overhead. If more validators than the maximum size have opted in on a consumer chain, only the validators with the highest power, up to the specified maximum, will validate the consumer chain.  Note that this parameter only applies to Opt In consumer chains (i.e., with Top N = 0).  ","version":"v6.3.0","tagName":"h3"},{"title":"Capping the validator powers​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.3.0/features/power-shaping#capping-the-validator-powers","content":" The consumer chain can specify a power cap which corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. The validators-power cap is intended as a safeguard against a validator having too much power on the consumer chain and hence &quot;taking over&quot; the consumer chain. For example, if the validators-power cap is set to 32%, then no single validator can have more than 32% of the total voting power on the consumer, and thus no single validator would be able to halt the consumer by going offline.  To respect this power cap, the voting powers of the validators that run the consumer chain are decremented or incremented accordingly. It is important to note that the voting powers of validators on the provider do not change. For example, assume that the provider chain has among others, validators A, B, C, and D with voting powers 100, 1, 1, 1 respectively. Assume that only those 4 validators opt in on a consumer chain. Without a power cap set, validator Awould have 100 / (100 + 1 + 1 + 1) = ~97% of the total voting power on the consumer chain, while validators B, C, and D would have 1 /(100 + 1 + 1 + 1) = ~1% of the total voting power on the consumer chain. If the power cap is set to 30%, then the voting power of A would be reduced from 100 to 30 on the consumer chain, the voting power of B would be increased from 1 to 25, and the power of C and D would be increased from 1 to 24. After those modifications, A would have 30 / (30 + 25 + 24 + 24) = ~29% of the total voting power of the consumer chain, B would have 25 / (30 + 25 + 24 + 24) = ~25%, and C and D would both have 24 / (30 + 25 + 24 + 24) = ~23%. Naturally, there are many ways to change the voting powers of validators to respect the power cap, and ICS chooses one of them.  Note that respecting the power cap might NOT always be possible. For example, if we have a consumer chain with only 5 validators and the power cap is set to 10%, then it is not possible to respect the power cap. If the voting power of each validator is capped to a maximum of 10% of the total consumer chain's voting power, then the total voting power of the consumer chain would add up to 50% which obviously does not make sense (percentages should add up to 100%). In cases where it is not feasible to respect the power cap, all validators on the consumer chain will have equal voting power in order to minimize the power of a single validator. Thus, in the example of 5 validators and a power cap set to 10%, all validators would end up having 20% of the total voting power on the consumer chain. Therefore, power-cap operates on a best-effort basis.  Note that rewards are distributed proportionally to validators with respect to their capped voting power on the consumer and not their voting power on the provider. For more information, read on Reward Distribution.  ","version":"v6.3.0","tagName":"h3"},{"title":"Allowlist and denylist​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.3.0/features/power-shaping#allowlist-and-denylist","content":" The consumer chain can specify a list of validators that are allowed or disallowed from participating in the validator set. If an allowlist is set, all validators not on the allowlist cannot validate the consumer chain. If a validator is on both lists, the denylist takes precedence, that is, they cannot validate the consumer chain. By default, both lists are empty -- there are no restrictions on which validators are eligible to opt in.  warning Note that if denylisting is used in a Top N consumer chain, then the chain might not be secured by N% of the total provider's power. For example, consider that the top validator V on the provider chain has 10% of the voting power, and we have a Top 50% consumer chain, then if V is denylisted, the consumer chain would only be secured by at least 40% of the provider's power.  ","version":"v6.3.0","tagName":"h3"},{"title":"Minimum validator stake​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.3.0/features/power-shaping#minimum-validator-stake","content":" The consumer chains can specify a minimum amount of stake that any validator must have on the provider chain to be eligible to opt in. For example, setting this to 1000 would mean only validators with at least 1000 tokens staked on the provider chain can validate the consumer chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"Allow inactive validators​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.3.0/features/power-shaping#allow-inactive-validators","content":" The consumer chains can specify whether validators outside of the provider's active set are eligible to opt in. This can be useful for chains that want to have a larger validator set than the provider chain, or for chains that want to have a more decentralized validator set. Consumer chains that enable this feature should strongly consider setting a minimum validator stake to ensure that only validators with some reputation/stake can validate the chain. By default, this parameter is set to false, i.e., validators outside of the provider's active set are not eligible to opt in.  ","version":"v6.3.0","tagName":"h3"},{"title":"Setting Power Shaping Parameters​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.3.0/features/power-shaping#setting-power-shaping-parameters","content":" All the power shaping parameters can be set by the consumer chain in the MsgCreateConsumer or MsgUpdateConsumer messages. They operate solely on the provider chain, meaning the consumer chain simply receives the validator set after these rules have been applied and does not have any knowledge about whether they are applied.  When setting power shaping parameters, please consider the following guidelines:  Do not cap the validator set size too low.Notice that this number is the maximum number of validators that will ever validate the consumer chain. If this number is too low, the chain will be very limited in the amount of stake that secures it. The validator set size cap should only be used if there are strong reasons to prefer fewer validators.Be aware of the interaction between capping the validator powers capping the validator set size.For example, if there are only 3 validators, and the cap is 20%, this will not be possible (since even splitting the power fairly would mean that each validator has 33% of the power, so is above the cap). Also note that the smaller this value is, the more the original voting power gets distorted, which could discourage large validators from deciding to opt in to the chain.Do not have allowlist contain too few validators.If the allowlist is non empty, then only validators on the allowlist can validate the chain. Thus, an allowlist containing too few validators is a security risk, e.g., the validators on the allowlist get jailed on the provider.Do not have denylist contain too many validators.If the denylist is non empty, then the validators on the denylist cannot validate the chain. Thus, a denylist containing too many validators is a security risk, e.g., the validators on the denylist represents a large fraction of the provider's power.  In general, when setting these parameters, consider that the voting power distribution in the future might be very different from the one right now, and that the chain should be secure even if the power distribution changes significantly.  The power shaping parameters of a launched consumer chain can be changed through a MsgUpdateConsumer message.  The power shaping parameters can be seen by querying the list of consumer chains:  interchain-security-pd query provider list-consumer-chains  ","version":"v6.3.0","tagName":"h2"},{"title":"Permissionless ICS","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/features/permissionless","content":"","keywords":"","version":"v6.3.0"},{"title":"From chainId to consumerId​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.3.0/features/permissionless#from-chainid-to-consumerid","content":" With Permissionless ICS, anyone can issue a transaction to launch a consumer chain. As a result, the chainId of a consumer chain cannot uniquely identify a consumer chain from the point of view of the provider, because we could have multiple consumer chains with the exact same chainId. Because of this, Permissionless ICS introduces the notion of a consumerId. The provider associates for each consumer chain a unique consumerId. A consumer chain can then interact (e.g., update chain parameters) with its chain by utilizing this consumerId. Additionally, validators can interact (e.g., assign a consumer key, opt in, etc.) with a consumer chain by using the consumer's consumerId.  ","version":"v6.3.0","tagName":"h2"},{"title":"Phases of a Consumer Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.3.0/features/permissionless#phases-of-a-consumer-chain","content":" A consumer chain can reside in one of the phases shown in the table below.  Phase\tDescriptionRegistered\tThe consumer chain was created with MsgCreateConsumer and has received the consumer's associated consumerId. The chain cannot launch yet. Initialized\tThe consumer chain has set all the initialization parameters and is ready to launch at spawnTime. Launched\tThe consumer chain has launched and is running. The provider chain is sending VSCPackets to the consumer. Stopped\tThe consumer chain is stopped and the provider chain is not sending VSCPackets to the consumer. The consumer chain is slated to be deleted. Deleted\tThe majority of the state of the consumer chain on the provider is deleted. Basic metadata of the consumer chain, such as the chainId, etc. are not deleted.  The following diagram shows the phases and the actions that need to take place to move from one phase to another.    ","version":"v6.3.0","tagName":"h2"},{"title":"Owner of a Consumer Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.3.0/features/permissionless#owner-of-a-consumer-chain","content":" A consumer chain (either Opt In or Top N) has an owner. An Opt In chain is owned by the address that initially sent and signed the MsgCreateConsumer message. A Top N chain is owned by the governance module and can only be updated through governance proposals.  Note that the owner of a chain can be changed at any later point in time by providing a new_owner_address message in the MsgUpdateConsumer message. As a result, an Opt In chain can change its owner to be the governance module in order to transform to Top N chain, and a Top N chain can change its owner to something that is not the governance module to become an Opt In chain (see below).  ","version":"v6.3.0","tagName":"h2"},{"title":"Launch an Opt In Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.3.0/features/permissionless#launch-an-opt-in-chain","content":" To launch an Opt In chain, we have to send a MsgCreateConsumer message. This message returns the newly created consumerIdassociated with this consumer. The chain is considered to be in the registered phase at this point and its owner is the one that signed the MsgCreateConsumer message. If the optional initialization_parameters are provided in the MsgCreateConsumer, then the chain is considered to be in the initialized phase and the chain can launch at the spawnTime provided in the initialization_parameters.  If no initialization_parameters are provided in MsgCreateConsumer, the consumer can later set those parameters by issuing a MsgUpdateConsumer. The chain would then move to the initialized phase and be slated to launch.  info An Opt In can only launch at spawnTime if at least one validator is opted in at spawnTime.  ","version":"v6.3.0","tagName":"h2"},{"title":"Launch a Top N Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.3.0/features/permissionless#launch-a-top-n-chain","content":" To launch a Top N chain, we need to issue a MsgCreateConsumer to retrieve the consumerId. At this stage, the chain corresponds to an Opt In chain and the owner of the chain is the one that signed the MsgCreateConsumer. For the chain to become Top N we need to issue a message and a governance proposal:  A MsgUpdateConsumer message to change the owner of the chain to be that of the governance module, that is to cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn.A governance proposal that includes a MsgUpdateConsumer that sets the TopN of the consumer chain.  warning If top_N, validators_power_cap, or some other argument is not included in the power-shaping parameters, then it is considered that the default value is set for this argument. For example, if a Top 50% chain wants to only modify validators_power_capfrom 35 to 40, then the power-shaping parameters in MsgUpdateConsumer still need to include that top_N is 50. Otherwisetop_N would be set to its default value of 0, and the chain would become an Opt-In chain. To be safe, if you include power-shaping parameters in the MsgUpdateConsumer, always include top_N and all the power-shaping parameters. The same applies for the initialization parameters.  ","version":"v6.3.0","tagName":"h2"},{"title":"Transform an Opt In Chain to Top N and Vice Versa​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.3.0/features/permissionless#transform-an-opt-in-chain-to-top-n-and-vice-versa","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"From Opt In to Top N​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.3.0/features/permissionless#from-opt-in-to-top-n","content":" This corresponds to the case of launching a Top N chain. The Opt In chain has to issue a MsgUpdateConsumer to change the owner of the consumer to be that of the governance module and to issue a governance proposal that includes a MsgUpdateConsumer and sets the TopN of the consumer chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"From Top N to Opt In​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.3.0/features/permissionless#from-top-n-to-opt-in","content":" A consumer chain can move from Top N to Opt In by issuing a governance proposal that includes a MsgUpdateConsumerthat sets TopN to 0 and also sets the owner of the chain to not be the governance module anymore. ","version":"v6.3.0","tagName":"h3"},{"title":"Consumer Onboarding Checklist","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/consumer-development/onboarding","content":"","keywords":"","version":"v6.3.0"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.3.0/consumer-development/onboarding#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.10.2) reach out to the ICS team if you are facing issues  ","version":"v6.3.0","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.3.0/consumer-development/onboarding#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json without the consumer module genesis (before the spawn time passes). Make sure the genesis time is within the trusting period (i.e., one day before launch time or shorter). genesis.json with the consumer module genesis (after the spawn time passes). Check if the consumer module genesis needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"v6.3.0","tagName":"h2"},{"title":"3. Submit MsgCreateConsumer (and MsgUpdateConsumer) messages​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.3.0/consumer-development/onboarding#3-submit-msgcreateconsumer-and-msgupdateconsumer-messages","content":" Before you start your chain, you need to submit a MsgCreateConsumer message that generates and returns back theconsumerId that should be used in any upcoming interactions by the consumer chain or the validators that interact with your chain. Additionally, you need to decide whether your chain should be an Opt-In chain or a Top N chain (see Partial Set Security) and act accordingly (see Permissionless ICS).  If you create a Top N chain through, please consider allowing at least a day between your proposal passing and the chain spawn time. This will allow the validators, other node operators and the community to prepare for the chain launch. If possible, please set your spawn time so people from different parts of the globe can be available in case of emergencies. Ideally, you should set your spawn time to be between 12:00 UTC and 20:00 UTC so most validator operators are available and ready to respond to any issues.  Additionally, for a Top N chain, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters take note to include a link to your onboarding repository describe the purpose and benefits of running your chain if desired, decide on power-shaping parameters (see Power Shaping)  Example of initialization parameters:  // ConsumerInitializationParameters provided in MsgCreateConsumer or MsgUpdateConsumer { // Initial height of new consumer chain. // For a completely new chain, this will be {1,1}. &quot;initial_height&quot; : { &quot;revision_height&quot;: 1, &quot;revision_number&quot;: 1, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // It is used for off-chain confirmation of genesis.json validity by validators and other parties. &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on chain initialization. // It is used for off-chain confirmation of binary validity by validators and other parties. &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should be smaller than that of the provider. &quot;unbonding_period&quot;: 1728000000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 2419200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot; }   Example of power-shaping parameters:  // PowerShaping parameters provided in MsgCreateConsumer or MsgUpdateConsumer { // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. &quot;top_N&quot;: 0, // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis. &quot;validators_power_cap&quot;: 0, // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. &quot;validator_set_cap&quot;: 0, // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate // the consumer chain. &quot;allowlist&quot;: [&quot;cosmosvalcons...&quot;], // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. &quot;denylist&quot;: [&quot;cosmosvalcons...&quot;], // Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain. &quot;min_stake&quot;: 0, // Corresponds to whether inactive validators are allowed to validate the consumer chain. &quot;allow_inactive_vals&quot;: false }   Example of allowlisted reward denoms:  // AllowlistedRewardDenoms provided in MsgCreateConsumer or MsgUpdateConsumer { &quot;denoms&quot;: [&quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;, &quot;ibc/054892D6BB43AF8B93AAC28AA5FD7019D2C59A15DAFD6F45C1FA2BF9BDA22454&quot;] }   caution For opt-in consumer chains, make sure that at least one validator opts in before the spawn time elapses. Otherwise the launch process will be aborted and the spawn time needs to be updated by submitting a MsgUpdateConsumer message.  ","version":"v6.3.0","tagName":"h2"},{"title":"4. Launch​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.3.0/consumer-development/onboarding#4-launch","content":" The consumer chain starts after at least 66.67% of its voting power comes online. Note that this means 66.67% of the voting power in the consumer validator set, which will be comprised of all validators that either opted in to the chain or are part of the top N% of the provider chain (and are thus automatically opted in). The consumer chain is considered interchain secured once the appropriate CCV channels are established and the first validator set update is propagated from the provider to the consumer   provide a repo with onboarding instructions for validators genesis.json with the consumer module section populated (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) have a block explorer in place to track chain activity &amp; health  ","version":"v6.3.0","tagName":"h2"},{"title":"Establish CCV channel​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.3.0/consumer-development/onboarding#establish-ccv-channel","content":" Once the consumer chain is launched, the CCV channel needs to be established. The following instructions are setting both the connection and channel using Hermes:  #!/bin/bash # CONSUMER_CLIENT_ID is created on CONSUMER upon genesis CONSUMER_CLIENT_ID=&quot;&lt;consumer-client-id&gt;&quot; CONSUMER_CHAIN_ID=&quot;&lt;consumer-chain-id&gt;&quot; # PROVIDER_CLIENT_ID is created on PROVIDER upon CONSUMER spawn time: gaiad q provider list-consumer-chains PROVIDER_CLIENT_ID=&quot;&lt;provider-client-id&gt;&quot; PROVIDER_CHAIN_ID=&quot;&lt;provider-chain-id&gt;&quot; CONFIG=$1 if [ -z &quot;$CONFIG&quot; ]; then CONFIG=$HOME/.hermes/config.toml fi if [ ! -f &quot;$CONFIG&quot; ]; then echo &quot;no config file found at $CONFIG&quot; exit 1 fi output=$(hermes --json --config $CONFIG create connection --a-chain $CONSUMER_CHAIN_ID --a-client $CONSUMER_CLIENT_ID --b-client $PROVIDER_CLIENT_ID | tee /dev/tty) json_output=$(echo &quot;$output&quot; | grep 'result') a_side_connection_id=$(echo &quot;$json_output&quot; | jq -r '.result.a_side.connection_id') output=$(hermes --json --config $CONFIG create channel --a-chain $CONSUMER_CHAIN_ID --a-port consumer --b-port provider --order ordered --a-connection $a_side_connection_id --channel-version 1 | tee /dev/tty) json_output=$(echo &quot;$output&quot; | grep 'result') echo &quot;---- DONE ----&quot; echo &quot;$json_output&quot; | jq # hermes start  ","version":"v6.3.0","tagName":"h3"},{"title":"Reward Distribution","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/features/reward-distribution","content":"","keywords":"","version":"v6.3.0"},{"title":"Reward distribution with power capping​","type":1,"pageTitle":"Reward Distribution","url":"/interchain-security/v6.3.0/features/reward-distribution#reward-distribution-with-power-capping","content":" If a consumer chain has set a validators-power cap, then the total received rewards are distributed proportionally to validators with respect to their capped voting power on the consumer and notwith respect to their voting power on the provider.  For example, assume that the provider chain has 4 validators, A, B, C, and D with voting powers 100, 1, 1, 1 respectively. So, validators A, B, C, and D have ~97%, ~1%, ~1%, and ~1% of the total voting power of the provider respectively. Now, assume that all those 4 validators opt in on a consumer chain that has set a validators-power cap set to 30%. As a result, validators A, B, C, and D have their powers modified (only) on the consumer chain to 30, 25, 24, and 24 and now have ~29%, ~25%, ~23%, and ~23% of the total voting power of the consumer. Roughly speaking, when rewards are sent from the consumer to the provider, validator A would get ~29% of the rewards because it has 29% of the total voting power on the consumer, regardless of A's 97% of the total power on the provider. Similarly, validator B would get 25% of the rewards, etc.  ","version":"v6.3.0","tagName":"h2"},{"title":"Whitelisting Reward Denoms​","type":1,"pageTitle":"Reward Distribution","url":"/interchain-security/v6.3.0/features/reward-distribution#whitelisting-reward-denoms","content":" The ICS distribution system works by allowing consumer chains to send rewards to a module address on the provider called the ConsumerRewardsPool. Only whitelisted denoms from the ConsumerRewardsPool are then distributed to validators and their delegators.  The whitelisted denoms can be adjusted through governance by sending a MsgChangeRewardDenoms message.MsgChangeRewardDenoms is used to update the set of denoms accepted by the provider as rewards. Note that a MsgChangeRewardDenoms is only accepted on the provider chain if at least one of the denomsToAdd or denomsToRemove fields is populated with at least one denom. Also, a denom cannot be repeated in both sets.  An example of a MsgChangeRewardDenoms message:  { &quot;@type&quot;: &quot;/interchain_security.ccv.provider.v1.MsgChangeRewardDenoms&quot;, &quot;denoms_to_add&quot;: [ &quot;ibc/42C7464F6415DC7529A8C7581FE0991C7A090D60176BC90998B1DAF75B868635&quot; ], &quot;denoms_to_remove&quot;: [], &quot;authority&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot; }   Besides native provider denoms (e.g., uatom for the Cosmos Hub), please use the ibc/* denom trace format. For example, for untrn transferred over the path transfer/channel-569, the denom trace can be queried using the following command:  &gt; gaiad query ibc-transfer denom-hash transfer/channel-569/untrn hash: 0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5   Then use the resulting hash when adding or removing denoms. For example:   &quot;denoms_to_add&quot;: [ &quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot; ]   To query the list of whitelisted reward denoms on the Cosmos Hub, use the following command:  &gt; gaiad q provider registered-consumer-reward-denoms denoms: - ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 - ibc/6B8A3F5C2AD51CD6171FA41A7E8C35AD594AB69226438DB94450436EA57B3A89 - uatom   tip Use the following command to get a human readable denom from the ibc/* denom trace format: &gt; gaiad query ibc-transfer denom-trace ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 denom_trace: base_denom: untrn path: transfer/channel-569  ","version":"v6.3.0","tagName":"h2"},{"title":"Inactive Validators Integration Guide","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/integrators/integrating_inactive_validators","content":"Inactive Validators Integration Guide With the inactive validators feature of Interchain Security, validators outside of the active set on the provider chain can validate on consumer chains that allow this. Technically, this is achieved by increasing the MaxValidators parameter in the staking module, to let additional validators be part of the set of bonded validators. However, to keep the set of validators participating in consensus on the Cosmos Hub the same, we introduce the MaxProviderConsensusValidators parameter in the provider module, which will restrict the number of validators that actively validate on the provider chain. To clarify the terminology: bonded validators are all validators that are bonded on the Cosmos Hub, and active validators are all validators that actively participate in consensus on the Cosmos Hub. Before the introduction of the feature, these two terms were equivalent: every bonded validator was active, and every active validator was bonded. After the introduction of this feature, it still holds that every active validator is bonded, but not every bonded validator is active. Importantly, only active validators receive inflation rewards from ATOM; only active validators may vote on behalf of their delegators in governance, and only active validators can get slashed for downtime (because only those validators participate in consensus and produce blocks). Apart from these differences, bonded but inactive validators are just like active validators - they can receive delegations, and they can validate on consumer chains (and receive rewards for this) just like active validators. The following queries will change after this upgrade: /cosmos/staking/v1beta1/pool / query staking pool The bonded_tokens will include the stake of all bonded validators. As the number of bonded validators will be increased as part of the upgrade, the number of bonded_tokens is expected to have a sudden increase after the upgrade is applied. All queries in the staking module that return a Validator All bonded validators will show with Status=Bonded. To identify active validators, query the validator set from Tendermint (https://docs.cometbft.com/v0.37/rpc/#/Info/validators or query comet-validator-set [height]), which will return the set of all active validators.","keywords":"","version":"v6.3.0"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/introduction/overview","content":"","keywords":"","version":"v6.3.0"},{"title":"Why Interchain Security?​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/introduction/overview#why-interchain-security","content":" Tailored security.Consumer chains can choose the right level of security based on their needs: Chains can choose to inherit the whole validator set from the provider, or they can launch as an opt-in chain with a subset of the provider validators. Additionally, consumer chains have the power to shape the validator set to their specific requirements by setting allow &amp; deny lists, capping its size, etc. This allows for a wide range of security tradeoffs. For example, it enables emerging projects to deploy on consumer chains that don’t need high level of security.Permissionless deployment.Opt-in consumer chains -- consumers that do not compel any validator to participate -- can be launched permissionlessly. User can create and update opt-in consumer chains by submitting transactions to the provider chain. Provider validators that are eligible can opt in on any consumer they wish to validate.Separation of governance from block production.Consumer chains can separate their governance mechanism from block production. Block production is handled by provider validators, which means it is an extension of the proof-of-state (PoS) mechanism on the provider chain. Governance on the consumer chains can rely on the same PoS mechanism (using the same stake locked on the provider), but it doesn't have to. For example, consumer chains can have a governance system based on proof-of-authority (PoA) or on PoS using the consumer token (which would make the consumer token a governance token). This also allows the governance to be more decentralized without affecting consensus (i.e., increasing the number of validators usually leads to slower block production).Distribution of block rewards.Consumer chains can choose how to distribute the block rewards (i.e., inflation and fees), what percentage to send to the provider as payment for block production, and what percentage to keep on-chain. The rewards kept on-chain can then be distributed to the community DAO (the consumer's governance) or can be used in the protocol in other ways.No validator search.Consumer chains do not have their own validator sets, and so do not need to find validators one by one. Validators from the provider chain validate on the consumer chain with their stake on the provider chain, earning additional rewards. For the consumer chain, this comes with the benefit of exposing their chain to the wider audience of the provider chain.Instant sovereignty.Consumers can run arbitrary app logic similar to standalone chains. At any time in the future, a consumer chain can elect to become a completely standalone chain, with its own validator set.Block-space sharding.Consumer chains are Cosmos appchains, which means that transactions on these chains do not compete with any other applications. As a result, there will be no unexpected congestion, and performance will generally be much better than on a shared smart contract platform such as Ethereum.  ","version":"v6.3.0","tagName":"h2"},{"title":"Core protocol​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/introduction/overview#core-protocol","content":" Validator updates. Once an IBC connection and channel are established between a provider and consumer chain, the provider will continually send validator set updates to the consumer over IBC. Note the provider only sends updates for opted in validators. The consumer uses these validator set updates to update its own validator set in the consensus engine (e.g., CometBFT).  Slashing and jailing.If the opted-in validators misbehave on the consumer chains, then they will be punished on the provider chain. ICS currently differentiates between two types of infractions -- double signing and downtime. Double signing on consumer chains results in the misbehaving validators having their provider stake slashed and being permanently jailed on the provider, while downtime on consumer chains results in the misbehaving validators being temporarily jailed. Note that jailing entails removing the validator from the provider active validator set and, consequently, from any of the consumer validator sets. This entails the validator will miss out on both staking and ICS rewards.  Tokenomics and rewards.Consumer chains are free to create their own native token which can be used for fees, and can be created on the consumer chain in the form of inflationary rewards. These rewards can be used to incentivize user behavior, for example, LPing or staking. A percentage of these fees and rewards will be sent to provider chain to be distributed among the opted in validators and their delegators. The percentage is completely customizable by the developers and subject to governance. ","version":"v6.3.0","tagName":"h2"},{"title":"Terminology","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/introduction/terminology","content":"","keywords":"","version":"v6.3.0"},{"title":"Shared Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.3.0/introduction/terminology#shared-security","content":" Shared Security is a family of technologies that include optimistic rollups, zk-rollups, sharding and Interchain Security. Basically, any protocol or technology that can allow one blockchain to lend/share its proof-of-stake security with another blockchain or off-chain process.  ","version":"v6.3.0","tagName":"h2"},{"title":"Interchain Security (ICS)​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.3.0/introduction/terminology#interchain-security-ics","content":" Interchain Security is the Cosmos-specific category of Shared Security that uses IBC (Inter-Blockchain Communication).  ","version":"v6.3.0","tagName":"h2"},{"title":"Consumer Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.3.0/introduction/terminology#consumer-chain","content":" Chain that is secured by the validator set of the provider, instead of its own. Interchain Security allows a subset of the provider chain's validator set to validate blocks on the consumer chain.  ","version":"v6.3.0","tagName":"h2"},{"title":"Replicated Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.3.0/introduction/terminology#replicated-security","content":" A particular protocol/implementation of Interchain Security that fully replicates the security and decentralization of a validator set across multiple blockchains. Replicated security has also been referred to as &quot;Interchain Security V1&quot;, a legacy term for the same protocol. That is, a &quot;provider chain&quot; such as the Cosmos Hub can share its exact validator set with multiple consumer chains by communicating changes in its validator set over IBC. Note that since the introduction of Partial Set Security, a TopN consumer chain with N 100% fully replicates the security and decentralization of the provider chain.  ","version":"v6.3.0","tagName":"h2"},{"title":"Partial Set Security (PSS)​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.3.0/introduction/terminology#partial-set-security-pss","content":" A major feature of Interchain Security (also referred to as &quot;Interchain Security V2&quot;) that allows a provider chain to share only a subset of its validator set with a consumer chain. This subset can be determined by the top N% validators by voting power, or by validators opting in to validate the consumer chain. PSS allows for more flexible security tradeoffs than Replicated Security.  ","version":"v6.3.0","tagName":"h2"},{"title":"Permissionless ICS​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.3.0/introduction/terminology#permissionless-ics","content":" Permissionless ICS is the latest version of ICS that allows to launch Opt In chains in a permissionless way (i.e., without requiring a governance proposal).  ","version":"v6.3.0","tagName":"h2"},{"title":"Standalone Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.3.0/introduction/terminology#standalone-chain","content":" Chain that is secured by its own validator set. This chain does not participate in Interchain Security.  ","version":"v6.3.0","tagName":"h2"},{"title":"Changeover Procedure​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.3.0/introduction/terminology#changeover-procedure","content":" Chains that were not initially launched as consumers of Interchain Security can still participate in the protocol and leverage the economic security of the provider chain. The process where a standalone chain transitions to being a replicated consumer chain is called the changeover procedure and is part of the ICS protocol. After the changeover, the new consumer chain will retain all existing state, including the IBC clients, connections and channels already established by the chain.  ","version":"v6.3.0","tagName":"h2"},{"title":"Mesh Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.3.0/introduction/terminology#mesh-security","content":" A protocol built on IBC that allows delegators on a Cosmos chain to re-delegate their stake to validators in another chain's own validator set, using the original chain's token (which remains bonded on the original chain). For a deeper exploration of Mesh Security, see Replicated vs. Mesh Security on the Informal Blog. ","version":"v6.3.0","tagName":"h2"},{"title":"Consumer Initiated Slashing","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/features/slashing","content":"","keywords":"","version":"v6.3.0"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.3.0/features/slashing#downtime-infractions","content":" Downtime infractions are reported by consumer chains and are acted upon on the provider as soon as they are received. Instead of slashing, the provider will only jail offending validator for the duration of time established by the provider chain parameters. Note that validators are only jailed for downtime on consumer chains that they opted in to validate on, or in the case of Top N chains, where they are automatically opted in by being in the Top N% of the validator set on the provider.  For preventing malicious consumer chains from harming the provider, slash throttling (also known as jail throttling) ensures that only a fraction of the provider validator set can be jailed at any given time.  ","version":"v6.3.0","tagName":"h2"},{"title":"Equivocation Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.3.0/features/slashing#equivocation-infractions","content":" Equivocation infractions are reported by external agents (e.g., relayers) that can submit to the provider evidence of light client or double signing attacks observed on a consumer chain. The evidence is submitted by sending MsgSubmitConsumerMisbehaviour or MsgSubmitConsumerDoubleVoting messages to the provider. When valid evidence is received, the malicious validators are slashed, jailed, and tombstoned on the provider. This is enabled through the cryptographic verification of equivocation feature. For more details, see ADR-005 and ADR-013.  ","version":"v6.3.0","tagName":"h2"},{"title":"Report equivocation infractions through CLI​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.3.0/features/slashing#report-equivocation-infractions-through-cli","content":" The ICS provider module offers two commands for submitting evidence of misbehavior originating from a consumer chain. Below are two examples illustrating the process on Cosmos Hub.  Use the following command to submit evidence of double signing attacks:  gaiad tx provider submit-consumer-double-voting [consumer-id] [path/to/evidence.json] [path/to/infraction_header.json] --from node0 --home ../node0 --chain-id $CID   Example of evidence.json { &quot;vote_a&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;tBBWTqjECl31S/clZGoxLdDqs93kTvy3qhpPqET/laY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;ai2qCLgVZAFph4FJ4Cqw5QW1GZKR4zjOv0bI/Um5AIc=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.565207Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;signature&quot;: &quot;y9yILm9hmv45BZwAaaq9mS1FpH7QeAIJ5Jkcc3U2/k5uks9cuqr4NTIwaIrqMSMKwxVyqiR56xmCT59a6AngAA==&quot; }, &quot;vote_b&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;3P06pszgPatuIdLTP5fDWiase4SYHIq9YXGSbRk9/50=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;S+SbOMxFRzfeNNpX9/jyFMz94VwBKk7Dpx6ZyvSYyNU=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.599273Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;validator_index&quot;: 0, &quot;signature&quot;: &quot;DGFcn4Um1t2kXW60+JhMk5cj7ZFdE5goKVOGiZkLwnNv43+6aGmOWjoq0SHYVzM4MwSwOwbhgZNbkWX+EHGUBw==&quot; }, &quot;total_voting_power&quot;: 300, &quot;validator_power&quot;: 100, &quot;timestamp&quot;: &quot;2023-11-20T12:57:51.267308Z&quot; }   Example of infraction_header.json { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: 11, &quot;app&quot;: 2 }, &quot;chain_id&quot;: &quot;consumer&quot;, &quot;height&quot;: 22, &quot;time&quot;: &quot;2023-11-20T12:57:40.479686Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;L63hyLJ+y9+fpb7WYKdmmBhPHwbfEGQEuKmvGzyBPiY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 18, &quot;hash&quot;: &quot;euzRQjN7MjGtM6skXM4B8wOgAldWGfZSJRA9JRlO42s=&quot; } }, &quot;last_commit_hash&quot;: &quot;qdDJwVziW3pPqmf8QDGZG+5HVd3OF7fCVh2Z8KQqNVU=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;next_validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;last_results_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: 22, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;PKrS32IEZoFY2q2S3iQ68HQL751ieBhf5Eu/Y5Z/QPg=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;8UuA7Oqw5AH/KOacpmHVSMOIDe4l2eC8VmdH2mzcpiM=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076538Z&quot;, &quot;signature&quot;: &quot;bSOH4+Vg2I37zeJphOguGOD0GK3JzM1ghSgJd0UlW/DHn1u9Hvv4EekHuCu6qwRLZcuS/ZxNlmr9qYNfxX3bDA==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:07:00Z&quot;, &quot;signature&quot;: &quot;7bXSDtlOwGK/gLEsFpTWOzm2TFoaARrWQUpbgWEwKtLlUs7iE06TOvJ3yPPfTfqqN/qYnvxxgjl0M0EhUWu5Bg==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076519Z&quot;, &quot;signature&quot;: &quot;Pb6G4bCg4wafmV89WNnzXxbSCknZUHnSQfSCE5QMFxPtSUIN4A7SK5m7yltqMJF5zkyenlFiEI4J3OZ4KCjCAw==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.057451Z&quot;, &quot;signature&quot;: &quot;j3EasIHNYA6MxW/PiWyruzHsjVsBV9t11W6Qx800WMm/+P+CkfR+UZAp7MPTvKZEZFuh3GUsBtyfb/vA+jJWCw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 }, { &quot;address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;UgN2JsjPy2WLh7dzJRBkUQtdgNoT4/uGj7kbIVqqHT8=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;5svW8261x+cZosp2xIhqzgt2tyuawrSDyHlpbgS3BC4=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } }, &quot;trusted_height&quot;: { &quot;revision_height&quot;: 18 }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 }, { &quot;address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;FCmIw7hSuiAoWk/2f4LuGQ+3zx5101xiqU8DoC5wGkg=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;2DrZF0roNnnvEy4NS2aY811ncKg=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;MI9c6sphsWlx0RAHCYOjMRXMFkTUaEYwOiOKG/0tsMs=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;73aN0uOc5b/Zfq2Xcjl0kH2r+tw=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;gWNcDup4mdnsuqET4QeFRzVb+FnSP4Vz3iNMj5wvWXk=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } } }   Use the following command to submit evidence of light client attacks:  gaiad tx provider submit-consumer-misbehaviour [consumer-id] [path/to/misbehaviour.json] --from node0 --home ../node0 --chain-id $CID   Example of misbehaviour.json { &quot;client_id&quot;: &quot;07-tendermint-0&quot;, &quot;header_1&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;W2xVqzPw03ZQ1kAMpcpht9WohwMzsGnyKKNjPYKDF6U=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;PGTquCtnTNFFY5HfEFz9f9pA7PYqjtQfBwHq6cxF/Ux8OI6nVqyadD9a84Xm7fSm6mqdW+T6YVfqIKmIoRjJDQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;0e39yoBorwORAH/K9qJ7D1N1Yr7CutMiQJ+oiIK39eMhuoK3UWzQyMGRLzDOIDupf8yD99mvGVVAlNIODlV3Dg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;lhc2tkwydag9D1iLQhdDCE8GgrHP94M1LbHFYMoL9tExaEq6RiFW/k71TQH5x96XQ9XYOznMIHKC2BDh4GlnAQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;8xeSBf0nSFs/X/rQ9CZLzwkJJhQBLA2jKdPGP3MlULxm992XxrOsIYq47u1daxvSsn6ql5OVYjzBNU0qbPpvCA==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } }, &quot;header_2&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;IZM8NKS+8FHB7CBmgB8Nz7BRVVXiiyqMQDvHFUvgzxo=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;pLIEZ4WSAtnMsgryujheHSq4+YG3RqTfMn2ZxgEymr0wyi+BNlQAKRtRfesm0vfYxvjzc/jhGqtUqHtSIaCwCQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;XG7iTe/spWyTUkT7XDzfLMpYqrdyqizE4/X4wl/W+1eaQp0WsCHYnvPU3x9NAnYfZzaKdonZiDWs7wacbZTcDg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;TqegK7ORuICSy++wVdPHt8fL2WfPlYsMPv1XW79wUdcjnQkezOM50OSqYaP4ua5frIZsn+sWteDrlqFTdkl3BA==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;dhvp3XlIaCxx5MFDs0TCkAPHSm0PS2EtJzYAx2c/7MWdLwUJFZrAUTeimQE2c9i9ro91cjZn/vI0/oFRXab6Aw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } } }   ","version":"v6.3.0","tagName":"h3"},{"title":"Report equivocation infractions with Hermes​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.3.0/features/slashing#report-equivocation-infractions-with-hermes","content":" Ensure you have a well-configured Hermes v1.7.3+ relayer effectively relaying packets between a consumer chain and a provider chain. The following command demonstrates how to run a Hermes instance in evidence mode to detect misbehaviors on a consumer chain and automatically submit the evidence to the provider chain.  hermes evidence --chain &lt;CONSUMER-CHAIN-ID&gt;   Note that hermes evidence takes a --check-past-blocks option giving the possibility to look for older evidence (default is 100). ","version":"v6.3.0","tagName":"h3"},{"title":"Joining Neutron","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/validators/joining-neutron","content":"","keywords":"","version":"v6.3.0"},{"title":"Resources​","type":1,"pageTitle":"Joining Neutron","url":"/interchain-security/v6.3.0/validators/joining-neutron#resources","content":" Neutron docs ","version":"v6.3.0","tagName":"h2"},{"title":"Validator Instructions for Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/validators/changeover-procedure","content":"","keywords":"","version":"v6.3.0"},{"title":"Timeline​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#timeline","content":" Upgrading standalone chains can be best visualised using a timeline, such as the one available Excalidraw graphic by Stride.  There is some flexibility with regards to how the changeover procedure is executed, so please make sure to follow the guides provided by the team doing the changeover.    ","version":"v6.3.0","tagName":"h2"},{"title":"1. ConsumerAdditionProposal on provider chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#1-consumeradditionproposal-on-provider-chain","content":" This step will add the standalone chain to the list of consumer chains secured by the provider. This step dictates the spawn_time. After spawn_time the CCV state (initial validator set of the provider) will be available to the consumer.  To obtain it from the provider use:  gaiad q provider consumer-genesis stride-1 -o json &gt; ccv-state.json jq -s '.[0].app_state.ccvconsumer = .[1] | .[0]' genesis.json ccv-state.json &gt; ccv.json   Transformation of the exported consumer genesis state to the target version of the consumer might be needed in case the provider and consumer formats are incompatible. Refer to the compatibility notes here to check if data transformation is needed for your case. Instructions on how to transform the exported CCV genesis state (ccv-state.json in the example above) to the required target version can be found here  ","version":"v6.3.0","tagName":"h3"},{"title":"2. SoftwareUpgradeProposal on the standalone/consumer chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#2-softwareupgradeproposal-on-the-standaloneconsumer-chain","content":" This upgrade proposal will introduce ICS to the standalone chain, making it a consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"3. Assigning a consumer key​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#3-assigning-a-consumer-key","content":" After spawn_time, make sure to assign a consumer key if you intend to use one.  Instructions are available here  ","version":"v6.3.0","tagName":"h3"},{"title":"4. Perform the software upgrade on standalone chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#4-perform-the-software-upgrade-on-standalone-chain","content":" Please use instructions provided by the standalone chain team and make sure to reach out if you are facing issues. The upgrade preparation depends on your setup, so please make sure you prepare ahead of time.  danger The ccv.json from step 1. must be made available on the machine running the standalone/consumer chain at standalone chain upgrade_height. This file contains the initial validator set and parameters required for normal ICS operation. Usually, the file is placed in $NODE_HOME/config but this is not a strict requirement. The exact details are available in the upgrade code of the standalone/consumer chain.  Performing this upgrade will transition the standalone chain to be a consumer chain.  After 3 blocks, the standalone chain will stop using the &quot;old&quot; validator set and begin using the provider validator set.  ","version":"v6.3.0","tagName":"h3"},{"title":"FAQ​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#faq","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Can I reuse the same validator key for the consumer chain that I am already using on the standalone chain? Will I need to perform a AssignConsumerKey tx with this key before spawn time?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#can-i-reuse-the-same-validator-key-for-the-consumer-chain-that-i-am-already-using-on-the-standalone-chain-will-i-need-to-perform-a-assignconsumerkey-tx-with-this-key-before-spawn-time","content":" Validators must either assign a key or use the same key as on the provider.  If you are validating both the standalone and the provider, you can use your current standalone key with some caveats:  you must submit an AssignConsumerKey tx with your current standalone validator keyit is best to submit AssignConsumerKey tx before spawn_timeif you do not submit the Tx, it is assumed that you will be re-using your provider key to validate the standalone/consumer chain  ","version":"v6.3.0","tagName":"h3"},{"title":"Can I continue using the same node that was validating the standalone chain?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#can-i-continue-using-the-same-node-that-was-validating-the-standalone-chain","content":" Yes.  Please assign your consensus key as stated above.  ","version":"v6.3.0","tagName":"h3"},{"title":"Can I set up a new node to validate the standalone/consumer chain after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#can-i-set-up-a-new-node-to-validate-the-standaloneconsumer-chain-after-it-transitions-to-interchain-security","content":" Yes.  If you are planning to do this please make sure that the node is synced with standalone network and to submit AssignConsumerKey tx before spawn_time.  ","version":"v6.3.0","tagName":"h3"},{"title":"What happens to the standalone validator set after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#what-happens-to-the-standalone-validator-set-after-it-transitions-to-interchain-security","content":" The standalone chain validators will stop being validators after the first 3 blocks are created while using Interchain Security. The standalone validators will become governors and still can receive delegations if the consumer chain is using the consumer-democracy module.  Governors DO NOT VALIDATE BLOCKS.  Instead, they can participate in the governance process and take on other chain-specific roles.  ","version":"v6.3.0","tagName":"h3"},{"title":"Credits​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.3.0/validators/changeover-procedure#credits","content":" Thank you Stride team for providing detailed instructions about the changeover procedure. ","version":"v6.3.0","tagName":"h2"},{"title":"Joining Stride","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/validators/joining-stride","content":"","keywords":"","version":"v6.3.0"},{"title":"Note​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v6.3.0/validators/joining-stride#note","content":" Stride re-uses an existing transfer channel to send consumer rewards to the provider chain, in order to preserve existing transfer IBC denom between stride-1 and cosmoshub-4.  ","version":"v6.3.0","tagName":"h2"},{"title":"Resources​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v6.3.0/validators/joining-stride#resources","content":" Stride docsChangeover procedure timelineChangeover upgrade docs ","version":"v6.3.0","tagName":"h2"},{"title":"Joining Interchain Security testnet","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/validators/joining-testnet","content":"","keywords":"","version":"v6.3.0"},{"title":"Introduction​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.3.0/validators/joining-testnet#introduction","content":" This short guide will teach you how to join the Interchain Security testnet.  The experience gained in the testnet will prepare you for validating interchain secured chains.  tip Provider and consumer chain represent distinct networks and infrastructures operated by the same validator set. For general information about running cosmos-sdk based chains check out the validator basics and Running a Node section of Cosmos SDK docs  ","version":"v6.3.0","tagName":"h2"},{"title":"Joining the provider chain​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.3.0/validators/joining-testnet#joining-the-provider-chain","content":" A comprehensive guide is available here.  ","version":"v6.3.0","tagName":"h2"},{"title":"Initialization​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.3.0/validators/joining-testnet#initialization","content":" First, initialize your $NODE_HOME using the provider chain binary.  NODE_MONIKER=&lt;your_node&gt; CHAIN_ID=provider NODE_HOME=&lt;path_to_your_home&gt; gaiad init $NODE_MONIKER --chain-id $CHAIN_ID --home $NODE_HOME   Add your key to the keyring - more details available here.  In this example we will use the test keyring-backend. This option is not safe to use in production.  gaiad keys add &lt;key_moniker&gt; --keyring-backend test # save the address as variable for later use MY_VALIDATOR_ADDRESS=$(gaiad keys show my_validator -a --keyring-backend test)   Before issuing any transactions, use the provider testnet faucet to add funds to your address.  curl https://faucet.rs-testnet.polypore.xyz/request?address=$MY_VALIDATOR_ADDRESS&amp;chain=provider # example output: { &quot;address&quot;: &quot;cosmos17p3erf5gv2436fd4vyjwmudakts563a497syuz&quot;, &quot;amount&quot;: &quot;10000000uatom&quot;, &quot;chain&quot;: &quot;provider&quot;, &quot;hash&quot;: &quot;10BFEC53C80C9B649B66549FD88A0B6BCF09E8FCE468A73B4C4243422E724985&quot;, &quot;status&quot;: &quot;success&quot; }   Then, use the account associated with the keyring to issue a create-validator transaction which will register your validator on chain.  gaiad tx staking create-validator \\ --amount=1000000uatom \\ --pubkey=$(gaiad tendermint show-validator) \\ --moniker=&quot;choose a moniker&quot; \\ --chain-id=$CHAIN_ID&quot; \\ --commission-rate=&quot;0.10&quot; \\ --commission-max-rate=&quot;0.20&quot; \\ --commission-max-change-rate=&quot;0.01&quot; \\ --min-self-delegation=&quot;1000000&quot; \\ --gas=&quot;auto&quot; \\ --gas-prices=&quot;0.0025uatom&quot; \\ --from=&lt;key_moniker&gt;   tip Check this guide to edit your validator.  After this step, your validator is created and you can start your node and catch up to the rest of the network. It is recommended that you use statesync to catch up to the rest of the network.  You can use this script to modify your config.toml with the required statesync parameters.  # create the statesync script $: cd $NODE_HOME $: touch statesync.sh $ chmod 700 statesync.sh # make executable   Paste the following instructions into the statesync.sh:  #!/bin/bash SNAP_RPC=&quot;https://rpc.provider-state-sync-01.rs-testnet.polypore.xyz:443&quot; LATEST_HEIGHT=$(curl -s $SNAP_RPC/block | jq -r .result.block.header.height); \\ BLOCK_HEIGHT=$((LATEST_HEIGHT - 2000)); \\ TRUST_HASH=$(curl -s &quot;$SNAP_RPC/block?height=$BLOCK_HEIGHT&quot; | jq -r .result.block_id.hash) sed -i.bak -E &quot;s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1true| ; \\ s|^(rpc_servers[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$SNAP_RPC,$SNAP_RPC\\&quot;| ; \\ s|^(trust_height[[:space:]]+=[[:space:]]+).*$|\\1$BLOCK_HEIGHT| ; \\ s|^(trust_hash[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$TRUST_HASH\\&quot;|&quot; $NODE_HOME/config/config.toml   Then, you can execute the script:  $: ./statesync.sh # setup config.toml for statesync   Finally, copy the provider genesis and start your node:  $: GENESIS_URL=https://github.com/cosmos/testnets/raw/master/interchain-security/provider/provider-genesis.json $: wget $GENESIS_URL -O genesis.json $: genesis.json $NODE_HOME/config/genesis.json # start the service $: gaiad start --x-crisis-skip-assert-invariants --home $NODE_HOME --p2p.seeds=&quot;08ec17e86dac67b9da70deb20177655495a55407@provider-seed-01.rs-testnet.polypore.xyz:26656,4ea6e56300a2f37b90e58de5ee27d1c9065cf871@provider-seed-02.rs-testnet.polypore.xyz:26656&quot;   Additional scripts to setup your nodes are available here and here. The scripts will configure your node and create the required services - the scripts only work in linux environments.  ","version":"v6.3.0","tagName":"h2"},{"title":"Joining consumer chains​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.3.0/validators/joining-testnet#joining-consumer-chains","content":" tip We strongly recommend that you assign a separate key for each consumer chain. Check out this guide to learn more about key assignment in interchain security.  To join consumer chains, simply replicate the steps above for each consumer using the correct consumer chain binaries.  info When running the provider chain and consumers on the same machine please update the PORT numbers for each of them and make sure they do not overlap (otherwise the binaries will not start). Important ports to re-configure: --rpc.laddr--p2p.laddr--api.address--grpc.address--grpc-web.address  ","version":"v6.3.0","tagName":"h2"},{"title":"Re-using consensus key​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.3.0/validators/joining-testnet#re-using-consensus-key","content":" To reuse the key on the provider and consumer chains, simply initialize your consumer chain and place the priv_validator_key.json into the home directory of your consumer chain (&lt;consumer_home&gt;/config/priv_validator_key.json).  When you start the chain, the consensus key will be the same on the provider and the consumer chain.  ","version":"v6.3.0","tagName":"h2"},{"title":"Assigning consensus keys​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.3.0/validators/joining-testnet#assigning-consensus-keys","content":" Whenever you initialize a new node, it will be configured with a consensus key you can use.  # machine running consumer chain consumerd init &lt;node_moniker&gt; --home &lt;home_path&gt; --chain-id consumer-1 # use the output of this command to get the consumer chain consensus key consumerd tendermint show-validator # output: {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, let the provider know which key you will be using for the consumer chain:  # machine running the provider chain gaiad tx provider assign-consensus-key consumer-id '&lt;consumer_pubkey&gt;' --from &lt;key_moniker&gt; --home $NODE_HOME --gas 900000 -b sync -y -o json   After this step, you are ready to copy the consumer genesis into your nodes's /config folder, start your consumer chain node and catch up to the network. ","version":"v6.3.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/validators/overview","content":"","keywords":"","version":"v6.3.0"},{"title":"Startup sequence overview​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#startup-sequence-overview","content":" An Opt In consumer chain cannot start and be secured by the validator set of the provider unless there is at least one validator opted in on the chain at spawn_time. A Top N consumer chain cannot start unless the governance proposal containing the MsgUpdateConsumer has passed.  Each chain defines a spawn_time - the timestamp when the consumer chain genesis is finalized and the consumer chain clients get initialized on the provider.  tip Validators are required to run consumer chain binaries only after spawn_time has passed.  Please note that any additional instructions pertaining to specific consumer chain launches will be available before spawn time. The chain start will be stewarded by the Cosmos Hub team and the teams developing their respective consumer chains.  The image below illustrates the startup sequence  ","version":"v6.3.0","tagName":"h2"},{"title":"1. Consumer Chain init + 2. Genesis generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#1-consumer-chain-init--2-genesis-generation","content":" Consumer chain team initializes the chain genesis.json and prepares binaries which will be listed in the initialization parameters of either MsgCreateConsumer or MsgUpdateConsumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"3. Create the chain on the provider​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#3-create-the-chain-on-the-provider","content":" Consumer chain team (or their advocates) submits a MsgCreateConsumer message (and potentially later a governance proposal with a MsgUpdateConsumer message if it is a Top N chain). The most important parameters for validators are:  spawn_time - the time after which the consumer chain must be startedgenesis_hash - hash of the pre-ccv genesis.json; the file does not contain any validator info -&gt; the information is available only after the proposal is passed and spawn_time is reachedbinary_hash - hash of the consumer chain binary used to validate the software builds  ","version":"v6.3.0","tagName":"h3"},{"title":"4. CCV Genesis state generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#4-ccv-genesis-state-generation","content":" After reaching spawn_time the provider chain will automatically create the CCV validator states that will be used to populate the corresponding fields in the consumer chain genesis.json. The CCV validator set consists of the validator set on the provider at spawn_time.  The state can be queried on the provider chain (in this case the Cosmos Hub):   gaiad query provider consumer-genesis &lt;consumer-id&gt; -o json &gt; ccvconsumer_genesis.json   This is used by the launch coordinator to create the final genesis.json that will be distributed to validators in step 5.  ","version":"v6.3.0","tagName":"h3"},{"title":"5. Updating the genesis file​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#5-updating-the-genesis-file","content":" Upon reaching the spawn_time the initial validator set state will become available on the provider chain. The initial validator set is included in the final genesis.json of the consumer chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"6. Chain start​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#6-chain-start","content":" info The consumer chain will start producing blocks as soon as 66.67% of the provider chain's voting power comes online (on the consumer chain). The relayer should be started after block production commences.  The new genesis.json containing the initial validator set will be distributed to validators by the consumer chain team (launch coordinator). Each validator should use the provided genesis.json to start their consumer chain node.  tip Please pay attention to any onboarding repositories provided by the consumer chain teams. Recommendations are available in Consumer Onboarding Checklist. Another comprehensive guide is available in the Interchain Security testnet repo.  ","version":"v6.3.0","tagName":"h3"},{"title":"7. Creating IBC connections​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#7-creating-ibc-connections","content":" Finally, to fully establish interchain security an IBC relayer is used to establish connections and create the required channels.  warning The relayer can establish the connection only after the consumer chain starts producing blocks.  hermes create connection --a-chain &lt;consumer chain ID&gt; --a-client 07-tendermint-0 --b-client &lt;client assigned by provider chain&gt; hermes create channel --a-chain &lt;consumer chain ID&gt; --a-port consumer --b-port provider --order ordered --a-connection connection-0 --channel-version 1 hermes start   ","version":"v6.3.0","tagName":"h3"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#downtime-infractions","content":" At present, the consumer chain can report evidence about downtime infractions to the provider chain. The min_signed_per_window and signed_blocks_window can be different on each consumer chain and are subject to changes via consumer chain governance.  info Causing a downtime infraction on any consumer chain will not incur a slash penalty. Instead, the offending validator will be jailed on the provider chain and consequently on all consumer chains. To unjail, the validator must wait for the jailing period to elapse on the provider chain and submit an unjail transaction on the provider chain. After unjailing on the provider, the validator will be unjailed on all consumer chains. More information is available in Downtime Slashing documentation  ","version":"v6.3.0","tagName":"h2"},{"title":"Double-signing Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#double-signing-infractions","content":" To learn more about equivocation handling in interchain security check out the Slashing documentation section.  ","version":"v6.3.0","tagName":"h2"},{"title":"Key assignment​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#key-assignment","content":" Validators can use different consensus keys on the provider and each of the consumer chains. The consumer chain consensus key must be registered on the provider before use.  For more information check out the Key assignment overview and guide  ","version":"v6.3.0","tagName":"h2"},{"title":"References:​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.3.0/validators/overview#references","content":" Cosmos Hub Validators FAQCosmos Hub Running a validatorStartup SequenceSubmit Unjailing Transaction ","version":"v6.3.0","tagName":"h2"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators","content":"","keywords":"","version":"v6.3.0"},{"title":"Messages​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#messages","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"How to opt in to a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#how-to-opt-in-to-a-consumer-chain","content":" warning A validator is automatically opted in to a Top N chain if the validator belongs to the top N% of the validators on the provider chain.  In a Top N chain, a validator that does not belong to the top N% of the validators on the provider can still choose to opt in to a consumer chain. In other words, validators can opt in, in both Opt-In and Top N chains.  A validator can opt in to a consumer chain by issuing the following message:  interchain-security-pd tx provider opt-in &lt;consumer-id&gt; &lt;optional consumer-pub-key&gt;   where  consumer-id is the consumer id identifier of the consumer chain the validator wants to opt in to;consumer-pub-key corresponds to the public key the validator wants to use on the consumer chain, and it has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}.  A validator can opt in to any active consumer chain, so a validator can opt in to a chain even before it launches. A validator can use the following command to retrieve the currently existing consumer chains:  interchain-security-pd query provider list-consumer-chains   By setting the consumer-pub-key, a validator can both opt in to a chain and assign a public key on a consumer chain. Note that a validator can always assigna new consumer key at a later stage. The key-assignment rulesstill apply when setting consumer-pub-key when opting in.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  Note that a validator is only eligible for consumer rewards from a consumer chain if the validator is opted into that chain.  ","version":"v6.3.0","tagName":"h3"},{"title":"How to opt out from a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#how-to-opt-out-from-a-consumer-chain","content":" A validator can opt out from a consumer by issuing the following message:  interchain-security-pd tx provider opt-out &lt;consumer-chain-id&gt;   where  consumer-id is the consumer identifier of the consumer chain.  The opting out mechanism has the following rules:  A validator cannot opt out from a Top N chain if it belongs to the top N% validators of the provider.If a validator moves from the Top N to outside of the top N% of the validators on the provider, it will notbe automatically opted-out. The validator has to manually opt out.A validator should stop its node on a consumer chain only after opting out and confirming through the has-to-validatequery (see below) that it does not have to validate the consumer chain any longer. Otherwise, the validator risks getting jailed for downtime.  warning If all validators opt out from an Opt-In chain, the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"v6.3.0","tagName":"h3"},{"title":"How to set specific per consumer chain commission rate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#how-to-set-specific-per-consumer-chain-commission-rate","content":" A validator can choose to set a different commission rate on each of the consumer chains. This can be done with the following command:  interchain-security-pd tx provider set-consumer-commission-rate &lt;consumer-id&gt; &lt;commission-rate&gt;   where  consumer-id is the consumer identifier of the consumer chain;comission-rate decimal in [minRate, 1] where minRate corresponds to the minimum commission rate set on the provider chain (see min_commission_rate in interchain-security-pd query staking params).  If a validator does not set a commission rate on a consumer chain, the commission rate defaults to their commission rate on the provider chain.  Validators can set their commission rate even for consumer chains that they are not currently opted in on, and the commission rate will be applied when they opt in. This is particularly useful for Top N chains, where validators might be opted in automatically, so validators can set the commission rate in advance.  If a validator opts out and then back in, this will not reset their commission rate back to the default. Instead, their set commission rate still applies.  ","version":"v6.3.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#queries","content":" PSS introduces a number of queries to assist validators in determining which consumer chains they have to validate, their commission rate per chain, etc.  ","version":"v6.3.0","tagName":"h2"},{"title":"Which chains does a validator have to validate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#which-chains-does-a-validator-have-to-validate","content":" Naturally, a validator is aware of the Opt-In chains it has to validate because in order to validate an Opt-In chain, a validator has to manually opt in to the chain. This is not the case for Top N chains where a validator might be required to validate such a chain without explicitly opting in if it belongs to the top N% of the validators on the provider.  We introduce the following query:  interchain-security-pd query provider has-to-validate &lt;provider-validator-address&gt;   that can be used by validator with provider-validator-address address to retrieve the list of chains that it has to validate.  warning For a validator, the list of chains returned by has-to-validate is the list of chains the validator should be validating to avoid getting jailed for downtime.  ","version":"v6.3.0","tagName":"h3"},{"title":"How do you know how much voting power you need to have to be in the top N for a chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#how-do-you-know-how-much-voting-power-you-need-to-have-to-be-in-the-top-n-for-a-chain","content":" This can be seen as part of the list-consumer-chains query:  interchain-security-pd query provider list-consumer-chains   where the min_power_in_top_N field shows the minimum voting power required to be automatically opted in to the chain.  Note that list-consumer-chains shows the minimal voting power right now, but the automatic opt-in happens only when epochs end on the provider. In consequence, a validators power might be large enough to be automatically opted in during an epoch, but if their power is sufficiently decreased before the epoch ends, they will not be opted in automatically.  ","version":"v6.3.0","tagName":"h3"},{"title":"How to retrieve all the opted-in validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-opted-in-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-opted-in-validators &lt;consumer-id&gt;   we can see all the opted-in validators on consumer-id that were manually or automatically opted in.  ","version":"v6.3.0","tagName":"h3"},{"title":"How to retrieve all the consumer validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-consumer-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-validators &lt;consumer-id&gt;   we can see all the consumer validators (i.e., validator set) of consumer-id. The consumer validators are the ones that are currently (or in the future, see warning) validating the consumer chain. A consumer validator is an opted-in validator but not vice versa. For example, an opted-in validator V might not be a consumer validator because V is denylisted or because V is removed due to a validator-set cap.  Note that the returned consumer validators from this query do not necessarily correspond to the validator set that is validating the consumer chain at this exact moment. This is because the VSCPacket sent to a consumer chain might be delayed and hence this query might return the validator set that the consumer chain would have at some future point in time.  ","version":"v6.3.0","tagName":"h3"},{"title":"How can we see the commission rate a validator has set on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.3.0/validators/partial-set-security-for-validators#how-can-we-see-the-commission-rate-a-validator-has-set-on-a-consumer-chain","content":" Using the following query:  interchain-security-pd query provider validator-consumer-commission-rate &lt;consumer-id&gt; &lt;provider-validator-address&gt;   we retrieve the commission rate set by validator with provider-validator-address address on consumer-id. ","version":"v6.3.0","tagName":"h3"},{"title":"Consumer chain validator rewards","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/validators/withdraw_rewards","content":"","keywords":"","version":"v6.3.0"},{"title":"Withdrawing rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.3.0/validators/withdraw_rewards#withdrawing-rewards","content":" Here are example steps for withdrawing rewards from consumer chains in the provider chain  info The examples used are from rs-testnet, the Interchain Security persistent testnet. Validator operator address: cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6Self-delegation address: cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf  Prior to withdrawing rewards, query balances for self-delegation address:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;1000000000000&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;   ","version":"v6.3.0","tagName":"h2"},{"title":"Querying validator rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.3.0/validators/withdraw_rewards#querying-validator-rewards","content":" Query rewards for the validator address:  gaiad q distribution rewards cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 rewards: - amount: &quot;158.069895000000000000&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;841842390516.072526500000000000&quot; denom: uatom   The ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD denom represents rewards from a consumer chain.  ","version":"v6.3.0","tagName":"h2"},{"title":"Withdrawing rewards and commission​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.3.0/validators/withdraw_rewards#withdrawing-rewards-and-commission","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"1. Withdraw rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.3.0/validators/withdraw_rewards#1-withdraw-rewards","content":" gaiad tx distribution withdraw-rewards cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 --from cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf --commission --chain-id provider --gas auto --fees 500uatom -b block -y txhash: A7E384FB1958211B43B7C06527FC7D4471FB6B491EE56FDEA9C5634D76FF1B9A   ","version":"v6.3.0","tagName":"h3"},{"title":"2. Confirm withdrawal​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.3.0/validators/withdraw_rewards#2-confirm-withdrawal","content":" After withdrawing rewards self-delegation address balance to confirm rewards were withdrawn:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;216&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;2233766225342&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;  ","version":"v6.3.0","tagName":"h3"},{"title":"Cosmos Hub - Interchain Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0","content":"Cosmos Hub - Interchain Security Welcome to the official documentation for the Cosmos Hub's Interchain Security (ICS) - a platform for launching Cosmos-SDK chains. The Cosmos Hub is the best place to launch a chain. With the recent launch of the Partial Set Security and Permissionless features, it's easier than ever to leverage the Cosmos Hub validators, stake, and community for your chain. ICS provides powerful capabilities for permissionlessly launching your chain and shaping your validator set. Here you can find information about Interchain Security, consumer chain development and instructions for validator onboarding. Basic Concepts Get started with the basic concepts and ideas. FAQ Frequently asked questions about the protocol and its implications Start Building Click here to start building with Interchain Security Onboarding Checklist Checklist to help you integrate Interchain Security, get support and onboard validators Become an ICS Validator Start validating on consumer chains Assign Consumer Keys Learn how to assign separate key on the consumer chains","keywords":"","version":"v6.4.0"},{"title":"ADR 001: Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#changelog","content":" 2022-12-01: Initial Draft2024-03-01: Updated to take into account they key-assigment-replacement deprecation.  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#context","content":" KeyAssignment is the name of the feature that allows validator operators to use different consensus keys for each consumer chain validator node that they operate.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#decision","content":" It is possible to change the keys at any time by submitting a transaction (i.e., MsgAssignConsumerKey).  ","version":"v6.4.0","tagName":"h2"},{"title":"State required​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#state-required","content":" ValidatorConsumerPubKey - Stores the validator assigned keys for every consumer chain.  ConsumerValidatorsBytePrefix | len(chainID) | chainID | providerConsAddress -&gt; consumerKey   ValidatorByConsumerAddr - Stores the mapping from validator addresses on consumer chains to validator addresses on the provider chain. Needed for the consumer initiated slashing sub-protocol.  ValidatorsByConsumerAddrBytePrefix | len(chainID) | chainID | consumerConsAddress -&gt; providerConsAddress   ConsumerAddrsToPrune - Stores the mapping from VSC ids to consumer validators addresses. Needed for pruning ValidatorByConsumerAddr.  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; []consumerConsAddresses   ","version":"v6.4.0","tagName":"h3"},{"title":"Protocol overview​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#protocol-overview","content":" On receiving a MsgAssignConsumerKey(chainID, providerAddr, consumerKey) message:  // get validator from staking module validator, found := stakingKeeper.GetValidator(providerAddr) if !found { return ErrNoValidatorFound } providerConsAddr := validator.GetConsAddr() // make sure consumer key is not in use consumerAddr := utils.TMCryptoPublicKeyToConsAddr(consumerKey) if _, found := GetValidatorByConsumerAddr(ChainID, consumerAddr); found { return ErrInvalidConsumerConsensusPubKey } // check whether the consumer chain is already registered // i.e., a client to the consumer was already created if _, consumerRegistered := GetConsumerClientId(chainID); consumerRegistered { // get the previous key assigned for this validator on this consumer chain oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr) if found { // mark this old consumer key as prunable once the VSCMaturedPacket // for the current VSC ID is received oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) vscID := GetValidatorSetUpdateId() AppendConsumerAddrsToPrune(chainID, vscID, oldConsumerAddr) } } else { // if the consumer chain is not registered, then remove the previous reverse mapping if oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr); found { oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) DeleteValidatorByConsumerAddr(chainID, oldConsumerAddr) } } // set the mapping from this validator's provider address to the new consumer key SetValidatorConsumerPubKey(chainID, providerConsAddr, consumerKey) // set the reverse mapping: from this validator's new consensus address // on the consumer to its consensus address on the provider SetValidatorByConsumerAddr(chainID, consumerAddr, providerConsAddr)   When a new consumer chain is registered, i.e., a client to the consumer chain is created, the provider constructs the consumer CCV module part of the genesis state (see MakeConsumerGenesis).  func (k Keeper) MakeConsumerGenesis(chainID string) (gen consumertypes.GenesisState, nextValidatorsHash []byte, err error) { // ... // get initial valset from the staking module var updates []abci.ValidatorUpdate{} stakingKeeper.IterateLastValidatorPowers(func(providerAddr sdk.ValAddress, power int64) (stop bool) { validator := stakingKeeper.GetValidator(providerAddr) providerKey := validator.TmConsPublicKey() updates = append(updates, abci.ValidatorUpdate{PubKey: providerKey, Power: power}) return false }) // applies the key assignment to the initial validator for i, update := range updates { providerAddr := utils.TMCryptoPublicKeyToConsAddr(update.PubKey) if consumerKey, found := GetValidatorConsumerPubKey(chainID, providerAddr); found { updates[i].PubKey = consumerKey } } gen.InitialValSet = updates // get a hash of the consumer validator set from the update updatesAsValSet := tendermint.PB2TM.ValidatorUpdates(updates) hash := tendermint.NewValidatorSet(updatesAsValSet).Hash() return gen, hash, nil }   Note that key assignment works hand-in-hand with epochs. For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. Specifically, for each validator in the set we store among others, the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacketwith all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   where DiffValidators internally checks if the consumer public key for a validator has changed since the last epoch and if so generates a validator update. This way, a validator can change its consumer public key for a consumer chain an arbitrary amount of times and only the last set consumer public key would be taken into account.  On receiving a SlashPacket from a consumer chain with id chainID for a infraction of a validator data.Validator:  func HandleSlashPacket(chainID string, data ccv.SlashPacketData) (success bool, err error) { // ... // the slash packet validator address may be known only on the consumer chain; // in this case, it must be mapped back to the consensus address on the provider chain consumerAddr := sdk.ConsAddress(data.Validator.Address) providerAddr, found := GetValidatorByConsumerAddr(chainID, consumerAddr) if !found { // the validator has the same key on the consumer as on the provider providerAddr = consumerAddr } // ... }   On receiving a VSCMatured:  func OnRecvVSCMaturedPacket(packet channeltypes.Packet, data ccv.VSCMaturedPacketData) exported.Acknowledgement { // ... // prune previous consumer validator address that are no longer needed consumerAddrs := GetConsumerAddrsToPrune(chainID, data.ValsetUpdateId) for _, addr := range consumerAddrs { DeleteValidatorByConsumerAddr(chainID, addr) } DeleteConsumerAddrsToPrune(chainID, data.ValsetUpdateId) // ... }   On stopping a consumer chain:  func (k Keeper) StopConsumerChain(ctx sdk.Context, chainID string, closeChan bool) (err error) { // ... // deletes all the state needed for key assignments on this consumer chain // ... }   ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#positive","content":" Validators can use different consensus keys on the consumer chains.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#negative","content":" None  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#neutral","content":" The consensus state necessary to create a client to the consumer chain must use the hash returned by the MakeConsumerGenesis method as the nextValsHash.The consumer chain can no longer check the initial validator set against the consensus state on InitGenesis.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/v6.4.0/adrs/adr-001-key-assignment#references","content":" Key assignment issue ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 003: Equivocation governance proposal","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal#changelog","content":" 2023-02-06: Initial draft2023-11-30: Change status to deprecated  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal#status","content":" Deprecated  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal#context","content":" Note: ADR deprecated as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  We want to limit the possibilities of a consumer chain to execute actions on the provider chain to maintain and ensure optimum security of the provider chain.  For instance, a malicious consumer consumer chain can send slash packet to the provider chain, which will slash a validator without the need of providing an evidence.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal#decision","content":" To protect against a malicious consumer chain, slash packets unrelated to downtime are ignored by the provider chain. Thus, an other mechanism is required to punish validators that have committed a double-sign on a consumer chain.  A new kind of governance proposal is added to the provider module, allowing to slash and tombstone a validator for double-signing in case of any harmful action on the consumer chain.  If such proposal passes, the proposal handler delegates to the evidence module to process the equivocation. This module ensures the evidence isn’t too old, or else ignores it (see code). Too old is determined by 2 consensus params :  evidence.max_age_duration number of nanoseconds before an evidence is considered too oldevidence.max_age_numblocks number of blocks before an evidence is considered too old.  On the hub, those parameters are equals to  // From https://cosmos-rpc.polkachu.com/consensus_params?height=13909682 (...) &quot;evidence&quot;: { &quot;max_age_num_blocks&quot;: &quot;1000000&quot;, &quot;max_age_duration&quot;: &quot;172800000000000&quot;, (...) }, (...)   A governance proposal takes 14 days, so those parameters must be big enough so the evidence provided in the proposal is not ignored by the evidence module when the proposal passes and is handled by the hub.  For max_age_num_blocks=1M, the parameter is big enough if we consider the hub produces 12k blocks per day (blocks_per_year/365 = 436,0000/365). The evidence can be up to 83 days old (1,000,000/12,000) and not be ignored.  For max_age_duration=172,800,000,000,000, the parameter is too low, because the value is in nanoseconds so it’s 2 days. Fortunately the condition that checks those 2 parameters uses a AND, so if max_age_num_blocks condition passes, the evidence won’t be ignored.  ","version":"v6.4.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal#positive","content":" Remove the possibility from a malicious consumer chain to “attack” the provider chain by slashing/jailing validators.Provide a more acceptable implementation for the validator community.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal#negative","content":" Punishment action of double-signing isn’t “automated”, a governance proposal is required which takes more time.You need to pay 250ATOM to submit an equivocation evidence.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal#neutral","content":" ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/v6.4.0/adrs/adr-003-equivocation-gov-proposal#references","content":" PR that ignores non downtime slash packet : https://github.com/cosmos/interchain-security/pull/692PR that adds the governance slash proposal: https://github.com/cosmos/interchain-security/pull/703 ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 004: Denom DOS fixes","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes#changelog","content":" 5/9/2023: ADR created  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes#context","content":" The provider and consumer modules are vulnerable to similar issues involving an attacker sending millions of denoms to certain addresses and causing the chain to halt. This ADR outlines both fixes since they are similar. Both fixes involve processing only denoms that are on a whitelist to avoid iterating over millions of junk denoms but have different requirements and are implemented in different ways.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes#decision","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Provider​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes#provider","content":" Put the distribution module's FeePoolAddress back on the blocklist so that it cannot receive funds from users.Create a new address called ConsumerRewardPool and unblock it, allowing funds to be sent to it.Create a set of strings in the store for allowed ConsumerRewardDenoms.Create an endpoint called RegisterConsumerRewardDenom which deducts a fee from the sender's account, sends it to the community pool and adds a string to the ConsumerRewardDenoms set.Create a parameter called ConsumerRewardDenomRegistrationFee which determines the fee which is charged to register a consumer reward denom in the step above.Create a function called TransferRewardsToFeeCollector which gets the entire ConsumerRewardDenoms set from the store, iterates over it, and for each entry: Gets the balance of this denom for the ConsumerRewardPool accountSends the entire balance out to the FeePoolAddress using SendCoinsFromModuleToModule which is not affected by the blocklist. Run TransferRewardsToFeeCollector in the endblock  Now, nobody can send millions of junk denoms to the FeePoolAddress because it is on the block list. If they send millions of junk denoms to the ConsumerRewardPool, this does not matter because all balances are not iterated over, only those which are in the ConsumerRewardDenoms set.  We also add a new tx: register-consumer-reward-denom, and a new query: registered-consumer-reward-denoms  ","version":"v6.4.0","tagName":"h3"},{"title":"Consumer​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes#consumer","content":" Create a new param RewardDenoms with a list of stringsCreate a new param ProviderRewardDenoms with a list of stringsCreate a function AllowedRewardDenoms which iterates over ProviderRewardDenoms and converts each denom to its ibc-prefixed denom using the provider chain's ibc channel information, then concatenates the RewardDenoms list and returns the combined list of allowed denoms.In SendRewardsToProvider, instead of iterating over the balances of all denoms in the ToSendToProvider address, iterate over AllowedRewardDenoms  Now, if somebody sends millions of junk denoms to ToSendToProvider, they will not be iterated over. Only the RewardDenoms and ProviderRewardDenoms will be iterated over. Since we do not require this feature to be permissionless on the consumer, the registration fee process is not needed.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes#positive","content":" Denom DOS is no longer possible on either provider or consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/v6.4.0/adrs/adr-004-denom-dos-fixes#negative","content":" Consumer chain teams must pay a fee to register a denom for distribution on the provider, and add some extra parameters in their genesis file. ","version":"v6.4.0","tagName":"h3"},{"title":"x/ccv/provider","type":0,"sectionRef":"#","url":"/interchain-security/v6.3.0/build/modules/provider","content":"","keywords":"","version":"v6.3.0"},{"title":"Overview​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#overview","content":" The ICS provider module enables a proof-of-stake chain (known as the provider chain) to share (parts of) its security with other chains (known as consumer chains). This basically mean that consumer chains can run as proof-of-stake chains using (parts of) the stake locked on the provider as collateral.  The provider module has the following functionalities:  The permissionless creation of consumer chains.The customization of the consumer chains validator sets.The option for validators to opt in to validate the consumer chains they want.The distribution of rewards from consumer chains to the opted in validators.The slashing and jailing of validators commiting infractions on consumer chains based on cryptographic evidence.  ","version":"v6.3.0","tagName":"h2"},{"title":"State​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#state","content":" For clarity, the description of the the provider module state is split into features. For a more accurate description, check out the x/ccv/provider/types/keys.go file, which contains the definitions of all the keys.  ","version":"v6.3.0","tagName":"h2"},{"title":"Consumer Lifecycle​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#consumer-lifecycle","content":" ConsumerId​  ConsumerId is the consumer ID of the next consumer chain to be created.  Format: byte(43) -&gt; uint64  ConsumerIdToChainId​  ConsumerIdToChainId is the chain ID of a given consumer chain.  Format: byte(44) | len(consumerId) | []byte(consumerId) -&gt; string  ConsumerIdToOwnerAddress​  ConsumerIdToOwnerAddress is the account address of the owner of a given consumer chain.  Format: byte(45) | len(consumerId) | []byte(consumerId) -&gt; string  ConsumerIdToMetadataKey​  ConsumerIdToMetadataKey is the metadata of a given consumer chain.  Format: byte(46) | len(consumerId) | []byte(consumerId) -&gt; ConsumerMetadata  ConsumerIdToPhase​  ConsumerIdToPhase is the phase of a given consumer chain.  Format: byte(49) | len(consumerId) | []byte(consumerId) -&gt; ConsumerPhase, where ConsumerPhase is defined as  enum ConsumerPhase { option (gogoproto.goproto_enum_prefix) = false; // UNSPECIFIED defines an empty phase. CONSUMER_PHASE_UNSPECIFIED = 0; // REGISTERED defines the phase in which a consumer chain has been assigned a unique consumer id. // A chain in this phase cannot yet launch. CONSUMER_PHASE_REGISTERED = 1; // INITIALIZED defines the phase in which a consumer chain has set all the needed parameters to launch but // has not yet launched (e.g., because the `spawnTime` of the consumer chain has not yet been reached). CONSUMER_PHASE_INITIALIZED = 2; // LAUNCHED defines the phase in which a consumer chain is running and consuming a subset of the validator // set of the provider. CONSUMER_PHASE_LAUNCHED = 3; // STOPPED defines the phase in which a previously-launched chain has stopped. CONSUMER_PHASE_STOPPED = 4; // DELETED defines the phase in which the state of a stopped chain has been deleted. CONSUMER_PHASE_DELETED = 5; }   ConsumerIdToRemovalTime​  ConsumerIdToRemovalTime is the removal time of a given consumer chain in the stopped phase.  Format: byte(50) | len(consumerId) | []byte(consumerId) -&gt; time.Time  SpawnTimeToConsumerIds​  SpawnTimeToConsumerIds are the IDs of initialized consumer chains ready to be launched at a timestamp ts.  Format: byte(51) | ts -&gt; ConsumerIds, where ConsumerIds is defined as  message ConsumerIds { repeated string ids = 1; }   RemovalTimeToConsumerIds​  RemovalTimeToConsumerIds are the IDs of stopped consumer chains ready to be removed at a timestamp ts.  Format: byte(52) | ts -&gt; ConsumerIds, where ConsumerIds is defined as  ","version":"v6.3.0","tagName":"h3"},{"title":"Consumer Launch​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#consumer-launch","content":" ConsumerIdToInitializationParameters​  ConsumerIdToInitializationParameters are the initialization parameters of a given consumer chain.  Format: byte(47) | len(consumerId) | []byte(consumerId) -&gt; ConsumerInitializationParameters  ConsumerIdToChannelId​  ConsumerIdToChannelId is the ID of the CCV channel associated with a consumer chain.  Format: byte(5) | []byte(consumerId) -&gt; string  ChannelIdToConsumerId​  ChannelIdToConsumerId is the consumer ID associated with a CCV channel.  Format: byte(6) | []byte(channelId) -&gt; string  ConsumerIdToClientId​  ConsumerIdToClientId is the ID of the client associated with a consumer chain. This is the underlying client of the corresponding CCV channel.  Format: byte(7) | []byte(consumerId) -&gt; string  ClientIdToConsumerId​  ClientIdToConsumerId is the consumer ID associated with an IBC client (i.e., the underlying client of the corresponding CCV channel).  Format: byte(53) | len(clientId) | []byte(clientId) -&gt; string  ConsumerGenesis​  ConsumerGenesis is the genesis state of the consumer module associated with a consumer chain.  Format: byte(14) | []byte(consumerId) -&gt; ConsumerGenesisState  ","version":"v6.3.0","tagName":"h3"},{"title":"Key Assingment​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#key-assingment","content":" ConsumerValidators​  TODO: ConsumerValidators and ConsumerValidator are too similar.  ConsumerValidators is the public key assigned by a given validator with addr as its provider consensus address (i.e., sdk.ConsAddress) on a given consumer chain.  Format: byte(22) | len(consumerId) | []byte(consumerId) | addr -&gt; crypto.PublicKey, where crypto is &quot;github.com/cometbft/cometbft/proto/tendermint/crypto&quot;.  ValidatorsByConsumerAddr​  ValidatorsByConsumerAddr is the consensus address on the provider chain of a validator with addr as its consensus address on a given consumer chain.  Format: byte(23) | len(consumerId) | []byte(consumerId) | addr -&gt; sdk.ConsAddress.  ConsumerAddrsToPruneV2​  ConsumerAddrsToPruneV2 stores the list of consumer consensus addresses that can be prunned at a timestamp ts as they are no longer needed.  Format: byte(40) | len(consumerId) | []byte(consumerId) | ts -&gt; AddressList, where AddressList is defined as  message AddressList { repeated bytes addresses = 1; }   ","version":"v6.3.0","tagName":"h3"},{"title":"Power Shaping​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#power-shaping","content":" ConsumerIdToPowerShapingParameters​  ConsumerIdToPowerShapingParameters are the power-shaping parameters of a given consumer chain.  Format: byte(48) | len(consumerId) | []byte(consumerId) -&gt; PowerShapingParameters  ConsumerValidator​  ConsumerValidator is the ConsensusValidator record of a provider validator on a given consumer chain, i.e.,  message ConsensusValidator { // validator's consensus address on the provider chain bytes provider_cons_addr = 1; // voting power the validator has during this epoch int64 power = 2; // public key the validator uses on the consumer chain during this epoch tendermint.crypto.PublicKey public_key = 3; // height the validator had when it FIRST became a consumer validator int64 join_height = 4; }   Format: byte(31) | len(consumerId) | []byte(consumerId) | addr -&gt; ConsensusValidator, with addr the validator's consensus address on the provider chain.  OptedIn​  OptedIn is the list of provider validators that opted in to validate on a given consumer chain. Note that opting in doesn't guarantee a spot in the consumer validator set.  Format: byte(32) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  Allowlist​  Allowlist is the list of provider validators that are eligible to validate a given consumer chain.  Format: byte(36) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  Denylist​  Denylist is the list of provider validators that are not eligible to validate a given consumer chain. Note that validator can opt in regardless of whether they are eligible or not.  Format: byte(37) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  MinimumPowerInTopN​  MinimumPowerInTopN is the minimum voting power a provider validator must have to be required to validate a given TopN consumer chain.  Format: byte(40) | len(consumerId) | []byte(consumerId) -&gt; uint64  ","version":"v6.3.0","tagName":"h3"},{"title":"Validator Set Updates​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#validator-set-updates","content":" ValidatorSetUpdateId​  ValidatorSetUpdateId is an incrementing sequence number that is used as a unique identifier for validator set updates sent to the consumer chains. The validator set update ID is incremented every epoch.  Format: byte(2) -&gt; uint64  PendingVSCs​  PendingVSCs is the list of VSCPackets that are queued to be sent to a given consumer chain.  Format: byte(17) | []byte(consumerId) -&gt; ValidatorSetChangePackets, where ValidatorSetChangePackets is defined as  message ValidatorSetChangePackets { repeated ValidatorSetChangePacketData list = 1 [ (gogoproto.nullable) = false ]; }   LastProviderConsensusVals​  LastProviderConsensusVals is the last validator set sent to the consensus engine of the provider chain.  Format: byte(42) | addr -&gt; ConsensusValidator, with addr the validator's consensus address on the provider chain and ConsensusValidator defined as  message ConsensusValidator { // validator's consensus address on the provider chain bytes provider_cons_addr = 1; // voting power the validator has during this epoch int64 power = 2; // public key the validator uses on the consumer chain during this epoch tendermint.crypto.PublicKey public_key = 3; // height the validator had when it FIRST became a consumer validator int64 join_height = 4; }   ","version":"v6.3.0","tagName":"h3"},{"title":"Reward Distribution​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#reward-distribution","content":" ConsumerRewardDenoms​  ConsumerRewardDenoms is storing the list of whitelisted denoms that are accepted as ICS rewards. Note that denoms that are not whitelisted can still be transfer to the consumer_rewards_pool account on the provider module, but they will not be distributed to validators and their delegators.  Format: byte(27) | []byte(denom) -&gt; []byte{}  ConsumerRewardsAllocation​  ConsumerRewardsAllocation is the allocation of ICS rewards for a given consumer chain. This is used to distribute ICS rewards only to the validators that are part of the consumer chain validator set.  Format: byte(38) | []byte(consumerId) -&gt; ConsumerRewardsAllocation, where ConsumerRewardsAllocation is defined as  message ConsumerRewardsAllocation { repeated cosmos.base.v1beta1.DecCoin rewards = 1 [ (gogoproto.nullable) = false, (amino.dont_omitempty) = true, (gogoproto.castrepeated) = &quot;github.com/cosmos/cosmos-sdk/types.DecCoins&quot; ]; }   ConsumerCommissionRate​  ConsumerCommissionRate is the commission rate set by a provider validator for a given consumer chain.  Format: byte(39) | len(consumerId) | []byte(consumerId) | addr -&gt; math.LegacyDec, with addr the validator's consensus address on the provider chain and math is &quot;cosmossdk.io/math&quot;.  ","version":"v6.3.0","tagName":"h3"},{"title":"Consumer Infractions​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#consumer-infractions","content":" SlashMeter​  SlashMeter is the meter used for the throttling mechanism as the allowance of voting power that can be jailed over time. It is decremented by the amount of voting power jailed whenever a validator is jailed for downtime, and periodically replenished as decided by on-chain params. See ADR 002 for more details.  Format: byte(3) -&gt; math.Int  SlashMeterReplenishTimeCandidate​  SlashMeterReplenishTimeCandidate is the next UTC time the SlashMeter could potentially be replenished. Note that this value is the next time the SlashMeter will be replenished if and only if the SlashMeter is not full. Otherwise this value will be updated in every future block until the slash meter becomes not full.  Format: byte(4) -&gt; time.Time  ValsetUpdateBlockHeight​  ValsetUpdateBlockHeight is the block height associated with a validator set update ID vscId. This is used for mapping infraction heights on consumer chains to heights on the provider chain via the validator set update IDs (together with InitChainHeight).  Format: byte(13) | vscId -&gt; uint64  InitChainHeight​  InitChainHeight is the block height on the provider when the CCV channel of a given consumer chain was established (i.e., the channel opening handshake was completed). This is used for mapping infraction heights on consumer chains to heights on the provider chain (together with ValsetUpdateBlockHeight).  Format: byte(16) | []byte(consumerId) -&gt; uint64  SlashAcks​  SlashAcks are addresses of validators for which SlashPackets for downtime infractions received from a given consumer chain were handled. These addresses are sent together with the validator updates to the consumer chain as confirmation that the downtime infractions were dealt with.  Format: byte(15) | []byte(consumerId) -&gt; SlashAcks, where SlashAcks is defined as  message SlashAcks { repeated string addresses = 1; }   EquivocationEvidenceMinHeight​  EquivocationEvidenceMinHeight is the minimum height of a valid evidence of equivocation on a given consumer chain.  Format: byte(29) | []byte(consumerId) -&gt; uint64  ","version":"v6.3.0","tagName":"h3"},{"title":"State Transitions​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#state-transitions","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"Consumer chain phases​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#consumer-chain-phases","content":" The following diagram describes the phases of a consumer chain from the perspective of the provider module:    ","version":"v6.3.0","tagName":"h3"},{"title":"IBC Callbacks​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#ibc-callbacks","content":" The consumer module is an IBC application that implements the IBC module callback.  ","version":"v6.3.0","tagName":"h2"},{"title":"OnChanOpenInit​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#onchanopeninit","content":" OnChanOpenInit returns an error. MsgChannelOpenInit should be sent to the consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanOpenTry​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#onchanopentry","content":" OnChanOpenTry validates the parameters of the CCV channel -- an ordered IBC channel connected on the provider port and with the counterparty port set to consumer -- and asserts that the counterparty version matches the expected version (only verions 1 is supported).  If the validation passes, the provider module verifies that the underlying client is the expected client of the consumer chain (i.e., the client created during the consumer chain launch) and that no other CCV channel exists for this consumer chain.  Finally, it sets the ProviderFeePoolAddr as part of the metadata.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanOpenAck​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#onchanopenack","content":" OnChanOpenAck returns an error. MsgChannelOpenAck should be sent to the consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanOpenConfirm​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#onchanopenconfirm","content":" OnChanOpenConfirm first verifies that no other CCV channel exists for this consumer chain. Note that this is a sanity check. Then, it sets the channel mapping in the state.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanCloseInit​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#onchancloseinit","content":" OnChanCloseInit returns an error. MsgChannelCloseInit should be sent to the consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnChanCloseConfirm​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#onchancloseconfirm","content":" OnChanCloseConfirm is a no-op.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnRecvPacket​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#onrecvpacket","content":" OnRecvPacket unmarshals the IBC packet data into a SlashPacketData struct (see below) and executes the handling logic.  Validate the fields in SlashPacketData: validator has a valid address and a non-zero power;infraction is either downtime or double-singing;the provider has in state a mapping from valset_update_id to a block height. If it is a double-signing infraction, then just log it and return.Verify that the consumer chain is launched and the validator is opted in.Update the meter used for jail throttling.Jail the validator on the provider chain.Store in state the ACK that the downtime infraction was handled. This will be sent to the consumer with the next validator updates to enable it to send other downtime infractions for this validator.  message SlashPacketData { tendermint.abci.Validator validator = 1 [ (gogoproto.nullable) = false, (gogoproto.moretags) = &quot;yaml:\\&quot;validator\\&quot;&quot; ]; // map to the infraction block height on the provider uint64 valset_update_id = 2; // tell if the slashing is for a downtime or a double-signing infraction cosmos.staking.v1beta1.Infraction infraction = 3; }   Note that IBC packets with VSCMaturedPacketData data are dropped. For more details, check out ADR 018.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnAcknowledgementPacket​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#onacknowledgementpacket","content":" OnAcknowledgementPacket stops and eventually removes the consumer chain associated with the channel on which the MsgAcknowledgement message was received.  ","version":"v6.3.0","tagName":"h3"},{"title":"OnTimeoutPacket​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#ontimeoutpacket","content":" OnTimeoutPacket stops and eventually removes the consumer chain associated with the channel on which the MsgTimeout message was received.  ","version":"v6.3.0","tagName":"h3"},{"title":"Messages​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#messages","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"MsgUpdateParams​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgupdateparams","content":" MsgUpdateParams updates the provider module parameters. The params are updated through a governance proposal where the signer is the gov module account address.  message MsgUpdateParams { option (cosmos.msg.v1.signer) = &quot;authority&quot;; // authority is the address of the governance account. string authority = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // params defines the x/provider parameters to update. Params params = 2 [(gogoproto.nullable) = false]; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgChangeRewardDenoms​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgchangerewarddenoms","content":" MsgChangeRewardDenoms updates the list of whitelisted denoms accepted by the provider as ICS rewards. The list of accepted denoms is updated through a governance proposal where the signer is the gov module account address.  Note that this message replaces ChangeRewardDenomsProposal, which is deprecated.  message MsgChangeRewardDenoms { option (cosmos.msg.v1.signer) = &quot;authority&quot;; // the list of consumer reward denoms to add repeated string denoms_to_add = 1; // the list of consumer reward denoms to remove repeated string denoms_to_remove = 2; // signer address string authority = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgCreateConsumer​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgcreateconsumer","content":" MsgCreateConsumer enables a user to create a consumer chain.  Both the chain_id and metadata fields are mandatory. The initialization_parameters, power_shaping_parameters, and allowlisted_reward_denoms fields are optional. The parameters not provided are set to their zero value.  The owner of the created consumer chain is the submitter of the message. This message cannot be submitted as part of a governance proposal, i.e., the submitter cannot be the gov module account address. As a result, if the power_shaping_parameters are provided, then power_shaping_parameters.top_N must be set to zero (i.e., opt-in consumer chain).  To create a top-n consumer chain, the following steps are require:  Create a opt-in consumer chain (via MsgCreateConsumer).Change the ownership of the consuemr chain to the gov module account address (via MsgUpdateConsumer).Change power_shaping_parameters.top_N to a value in [50, 100] trough a governance proposal with a MsgUpdateConsumer message.  If the initialization_parameters field is set and initialization_parameters.spawn_time &gt; 0, then the consumer chain will be scheduled to launch at spawn_time.  message MsgCreateConsumer { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; // Submitter address. If the message is successfully handled, the ownership of // the consumer chain will given to this address. string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the chain id of the new consumer chain string chain_id = 2; ConsumerMetadata metadata = 3 [ (gogoproto.nullable) = false ]; ConsumerInitializationParameters initialization_parameters = 4; PowerShapingParameters power_shaping_parameters = 5; // allowlisted reward denoms by the consumer chain AllowlistedRewardDenoms allowlisted_reward_denoms = 6; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgUpdateConsumer​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgupdateconsumer","content":" MsgUpdateConsumer enables the owner of a consumer chain to update its parameters (e.g., set a new owner).  Note that only the owner (i.e., signer) and consumer_id fields are mandatory. The others field are optional. Not providing one of them will leave the existing values unchanged. Providing one of metadata, initialization_parameters, power_shaping_parameters, or allowlisted_reward_denomswill update all the containing fields. If one of the containing fields is missing, it will be set to its zero value. For example, updating the initialization_parameters without specifying the spawn_time, will set the spawn_time to zero.  If the initialization_parameters field is set and initialization_parameters.spawn_time &gt; 0, then the consumer chain will be scheduled to launch at spawn_time. Updating the spawn_time from a positive value to zero will remove the consumer chain from the list of scheduled to launch chains. If the consumer chain is already launched, updating the initialization_parameters is no longer possible.  If the power_shaping_parameters field is set and power_shaping_parameters.top_N is positive, then the owner needs to be the gov module account address.  If the new_owner_address field is set to a value different than the gov module account address, then top_N needs to be zero.  message MsgUpdateConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the address of the owner of the consumer chain to be updated string owner = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to be updated string consumer_id = 2; // the new owner of the consumer when updated string new_owner_address = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the metadata of the consumer when updated ConsumerMetadata metadata = 4; // initialization parameters can only be updated before a chain has launched ConsumerInitializationParameters initialization_parameters = 5; // the power-shaping parameters of the consumer when updated PowerShapingParameters power_shaping_parameters = 6; // allowlisted reward denoms by the consumer chain AllowlistedRewardDenoms allowlisted_reward_denoms = 7; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgRemoveConsumer​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgremoveconsumer","content":" MsgRemoveConsumer enables the owner of a launched consumer chain to remove it from the provider chain. The message will first stop the consumer chain, which means the provider will stop sending it validator updates over IBC. Then, once the unbonding period elapses, the consumer chain is removed from the provider state.  message MsgRemoveConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the consumer id of the consumer chain to be stopped string consumer_id = 1; // the address of the owner of the consumer chain to be stopped string owner = 2 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgOptIn​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgoptin","content":" MsgOptIn enables a validator to opt in to validate a consumer chain. Note that validators can opt in to validate consumer chains that are not launched yet. The signer of the message needs to match the validator address on the provider.  Note that opting in doesn't guarantee a spot in the consumer chain's validator set. Use the has-to-validate query to check if the validator is part of the consumer chain's validator set. For more details, check out the validator guide to Partial Set Security.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  The consumer_key field is optional. It enables the validator to set the consensus public key to use on the consumer chain. The validator can assing (or re-assing) this key also later via MsgAssignConsumerKey.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons. This is especially important since the introduction of thePermissionless ICS featurethat allows multiple consumer chains to have the same chain ID. A validator using the same consensus key to validate on two chains with the same chain ID might get slashed for double signing.  message MsgOptIn { option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; option (cosmos.msg.v1.signer) = &quot;signer&quot;; // [DEPRECATED] use `consumer_id` instead string chain_id = 1 [deprecated = true]; // the validator address on the provider string provider_addr = 2 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // (optional) The consensus public key to use on the consumer in json string format corresponding to proto-any, // for example `{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}`. // This field is optional and can remain empty (i.e., `consumer_key = &quot;&quot;`). A validator can always change the // consumer public key at a later stage by issuing a `MsgAssignConsumerKey` message. string consumer_key = 3; // submitter address string signer = 4 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to opt in to string consumer_id = 5; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgAssignConsumerKey​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgassignconsumerkey","content":" MsgAssignConsumerKey enables a validator to assign the consensus public key to use on a consumer chain. Without assigning a specific key, the validator will need to use the same key as on the provider chain.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons. This is especially important since the introduction of thePermissionless ICS featurethat allows multiple consumer chains to have the same chain ID. A validator using the same consensus key to validate on two chains with the same chain ID might get slashed for double signing.  The signer of the message needs to match the validator address on the provider.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details, check out the description of the Key Assignment feature.  message MsgAssignConsumerKey { option (cosmos.msg.v1.signer) = &quot;signer&quot;; option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; // [DEPRECATED] use `consumer_id` instead string chain_id = 1 [deprecated = true]; // The validator address on the provider string provider_addr = 2 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // The consensus public key to use on the consumer. // in json string format corresponding to proto-any, ex: // `{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}` string consumer_key = 3; string signer = 4 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to assign a consensus public key to string consumer_id = 5; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgOptOut​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgoptout","content":" MsgOptOut enables a validator to opt out from validating a launched consumer chain. The signer of the message needs to match the validator address on the provider.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on optin out, check out the validator guide to Partial Set Security.  message MsgOptOut { option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; option (cosmos.msg.v1.signer) = &quot;signer&quot;; // [DEPRECATED] use `consumer_id` instead string chain_id = 1 [deprecated = true]; // the validator address on the provider string provider_addr = 2 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // submitter address string signer = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to opt out from string consumer_id = 4; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgSetConsumerCommissionRate​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgsetconsumercommissionrate","content":" MsgSetConsumerCommissionRate enables validators to set a per-consumer chain commission rate. The rate is a decimal in [minRate, 1], with minRate corresponding to the minimum commission rate set on the provider chain (see min_commission_rate in interchain-security-pd query staking params).  The signer of the message needs to match the validator address on the provider.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on setting per-consumer chain commission rates, check out the validator guide to Partial Set Security.  message MsgSetConsumerCommissionRate { option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; option (cosmos.msg.v1.signer) = &quot;signer&quot;; // The validator address on the provider string provider_addr = 1 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // [DEPRECATED] use `consumer_id` instead string chain_id = 2 [deprecated = true]; // The rate to charge delegators on the consumer chain, as a fraction string rate = 3 [ (cosmos_proto.scalar) = &quot;cosmos.Dec&quot;, (gogoproto.customtype) = &quot;cosmossdk.io/math.LegacyDec&quot;, (gogoproto.nullable) = false ]; // submitter address string signer = 4 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to set the commission rate string consumer_id = 5; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgSubmitConsumerMisbehaviour​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgsubmitconsumermisbehaviour","content":" MsgSubmitConsumerMisbehaviour enables users to submit to the provider evidence of a light client attack that occured on a consumer chain. This message can be submitted directly by users, e.g., via the CLI command tx provider submit-consumer-misbehaviour, or by a relayer that can be set to automatically detect consumer chain misbehaviors, e.g., Hermes.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on reporting light client attacks that occured on consumer chains, check out the guide on equivocation infractions.  message MsgSubmitConsumerMisbehaviour { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // The Misbehaviour of the consumer chain wrapping // two conflicting IBC headers ibc.lightclients.tendermint.v1.Misbehaviour misbehaviour = 2; // the consumer id of the consumer chain where the misbehaviour occurred string consumer_id = 3; }   ","version":"v6.3.0","tagName":"h3"},{"title":"MsgSubmitConsumerDoubleVoting​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#msgsubmitconsumerdoublevoting","content":" MsgSubmitConsumerDoubleVoting enables users to submit to the provider evidence of a double signing infraction that occured on a consumer chain. This message can be submitted directly by users, e.g., via the CLI command tx provider submit-consumer-double-voting, or by a relayer that can be set to automatically detect consumer chain misbehaviors, e.g., Hermes.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on reporting double signing infractions that occured on consumer chains, check out the guide on equivocation infractions.  message MsgSubmitConsumerDoubleVoting { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // The equivocation of the consumer chain wrapping // an evidence of a validator that signed two conflicting votes tendermint.types.DuplicateVoteEvidence duplicate_vote_evidence = 2; // The light client header of the infraction block ibc.lightclients.tendermint.v1.Header infraction_block_header = 3; // the consumer id of the consumer chain where the double-voting took place string consumer_id = 4; }   ","version":"v6.3.0","tagName":"h3"},{"title":"BeginBlock​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#beginblock","content":" In the BeginBlock of the provider module the following actions are performed:  Launch every consumer chain that has a spawn time that already passed. Compute the initial validator set.Create the genesis state for the consumer module. Note that the genesis state contains the consumer module parameters and both the client state and consensus state needed for creating a provider client on the consumer chain.Create a consumer client. Remove every stopped consumer chain for which the removal time has passed.Replenish the throttling meter if necessary.Distribute ICS rewards to the opted in validators.  Note that for every consumer chain, the computation of its initial validator set is based on the consumer's power shaping parametersand the validators that opted in on that consumer.  ","version":"v6.3.0","tagName":"h2"},{"title":"EndBlock​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#endblock","content":" In the EndBlock of the provider module the following actions are performed:  Store in state the VSC id to block height mapping needed for determining the height of infractions on consumer chains.Prune the no-longer needed public keys assigned by validators to use when validating on consumer chains.Send validator updates to the consensus engine. The maximum number of validators is set through the MaxProviderConsensusValidators param.At the begining of every epoch, for every launched consumer chain, compute the next consumer validator set and send it to the consumer chain via an IBC packet;increment the VSC id.  Note that for every consumer chain, the computation of its validator set is based on the consumer's power shaping parametersand the validators that opted in on that consumer.  ","version":"v6.3.0","tagName":"h2"},{"title":"Hooks​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#hooks","content":" TBA  ","version":"v6.3.0","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#events","content":" TBA  ","version":"v6.3.0","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#parameters","content":" The provider module contains the following parameters.  ","version":"v6.3.0","tagName":"h2"},{"title":"TemplateClient​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#templateclient","content":" TemplateClient is a template of an IBC ClientState used for launching consumer chains.  ","version":"v6.3.0","tagName":"h3"},{"title":"TrustingPeriodFraction​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#trustingperiodfraction","content":" Type\tDefault valuestring\t&quot;0.66&quot;  TrustingPeriodFraction is used to used to compute the trusting period of IBC clients (for both provider and consumer chains) as UnbondingPeriod / TrustingPeriodFraction. Note that a light clients must be updated within the trusting period in order to avoid being frozen.  The param is set as a string, and converted to a sdk.Dec when used.  ","version":"v6.3.0","tagName":"h3"},{"title":"CcvTimeoutPeriod​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#ccvtimeoutperiod","content":" Type\tDefault valuetime.Duration\t2419200s (4 weeks)  CcvTimeoutPeriod is the period used to compute the timeout timestamp when sending IBC packets. For more details, see the IBC specification of Channel &amp; Packet Semantics.  warning If a sent packet is not relayed within this period, then the packet times out. The CCV channel used by the interchain security protocol is closed, and the corresponding consumer is removed.  CcvTimeoutPeriod may have different values on the provider and consumer chains.CcvTimeoutPeriod on the provider must be larger than consumer unbonding period.  ","version":"v6.3.0","tagName":"h3"},{"title":"SlashMeterReplenishPeriod​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#slashmeterreplenishperiod","content":" Type\tDefault valuetime.Duration\t3600s (1 hour)  SlashMeterReplenishPeriod is the time interval at which the meter for jail throttling is replenished. The meter is replenished to an amount equal to the allowance for that block, or SlashMeterReplenishFraction * CurrentTotalVotingPower.  ","version":"v6.3.0","tagName":"h3"},{"title":"SlashMeterReplenishFraction​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#slashmeterreplenishfraction","content":" Type\tDefault valuestring\t&quot;0.05&quot;  SlashMeterReplenishFraction is the fraction (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs. This param also serves as a maximum fraction of total voting power that the slash meter can hold.  The param is set as a string, and converted to a sdk.Dec when used.  ","version":"v6.3.0","tagName":"h3"},{"title":"ConsumerRewardDenomRegistrationFee​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#consumerrewarddenomregistrationfee","content":" ConsumerRewardDenomRegistrationFee is deprecated.  ","version":"v6.3.0","tagName":"h3"},{"title":"BlocksPerEpoch​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#blocksperepoch","content":" Type\tDefault valueint64\t600  BlocksPerEpoch is the number of blocks in an ICS epoch. The provider sends validator updates to the consumer chains only once per epoch.  warning It is recommended for the length of an ICS epoch to not exceed a day. Large epochs would lead to delays in validator updates sent to the consumer chains, which might impact the security of the consumer chains.  ","version":"v6.3.0","tagName":"h3"},{"title":"NumberOfEpochsToStartReceivingRewards​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#numberofepochstostartreceivingrewards","content":" Type\tDefault valueint64\t24  NumberOfEpochsToStartReceivingRewards is the number of ICS epochs that a validator needs to wait after opting in on a consumer chain before being eligible to ICS reawards from that consumer.  ","version":"v6.3.0","tagName":"h3"},{"title":"MaxProviderConsensusValidators​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#maxproviderconsensusvalidators","content":" Type\tDefault valueint64\t180  MaxProviderConsensusValidators is the maximum number of validators sent to the provider consensus enginer. This was introduced with the Inactive Provider Validators featureand it replaces the MaxValidators staking module parameter. As a result, the provider chain can differentiate betweenbonded validators, i.e., validators that have stake locked on the provider chain, and active validator, i.e., validators that participate actively in the provider chain's consensus.  ","version":"v6.3.0","tagName":"h3"},{"title":"Client​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#client","content":" ","version":"v6.3.0","tagName":"h2"},{"title":"CLI​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#cli","content":" A user can interact with the provider module using the CLI.  Query​  The query commands allow users to query provider state.  interchain-security-pd query provider --help   Consumer Genesis​  The consumer-genesis command allows to query for consumer chain genesis state by consumer id.  interchain-security-pd query provider consumer-genesis [consumer-id] [flags]   Example interchain-security-pd query provider consumer-genesis 0 Output: new_chain: true params: blocks_per_distribution_transmission: &quot;1000&quot; ccv_timeout_period: 2419200s consumer_id: &quot;0&quot; consumer_redistribution_fraction: &quot;0.75&quot; distribution_transmission_channel: &quot;&quot; enabled: true historical_entries: &quot;10000&quot; provider_fee_pool_addr_str: &quot;&quot; provider_reward_denoms: [] retry_delay_period: 3600s reward_denoms: [] soft_opt_out_threshold: &quot;0&quot; transfer_timeout_period: 3600s unbonding_period: 1209600s provider: client_state: allow_update_after_expiry: false allow_update_after_misbehaviour: false chain_id: provider frozen_height: revision_height: &quot;0&quot; revision_number: &quot;0&quot; latest_height: revision_height: &quot;25&quot; revision_number: &quot;0&quot; max_clock_drift: 10s proof_specs: - inner_spec: child_order: - 0 - 1 child_size: 33 empty_child: null hash: SHA256 max_prefix_length: 12 min_prefix_length: 4 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false - inner_spec: child_order: - 0 - 1 child_size: 32 empty_child: null hash: SHA256 max_prefix_length: 1 min_prefix_length: 1 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false trust_level: denominator: &quot;3&quot; numerator: &quot;1&quot; trusting_period: 1197504s unbonding_period: 1814400s upgrade_path: - upgrade - upgradedIBCState consensus_state: next_validators_hash: 632730A03DEF630F77B61DF4092629007AE020B789713158FABCB104962FA54F root: hash: Jcck4b/HHJOcjcVjTdMi8qHB4SeCpWpfLiN9DtB99oA= timestamp: &quot;2024-09-25T09:18:40.262655625Z&quot; initial_val_set: - power: &quot;500&quot; pub_key: ed25519: RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10= - power: &quot;500&quot; pub_key: ed25519: Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is= - power: &quot;500&quot; pub_key: ed25519: mAN6RXYxSM4MNGSIriYiS7pHuwAcOHDQAy9/wnlSzOI=   List Consumer Chains​  The list-consumer-chains command allows to query consumer chains supported by the provider chain. An optional integer parameter can be passed for phase filtering of consumer chains, (Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5).`  interchain-security-pd query provider list-consumer-chains [phase] [limit] [flags]   Example interchain-security-pd query provider list-consumer-chains 3 Output: chains: - allow_inactive_vals: true allowlist: [] chain_id: pion-1 client_id: 07-tendermint-0 consumer_id: &quot;0&quot; denylist: [&quot;cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6&quot;] metadata: description: description of your chain and all other relevant information metadata: some metadata about your chain name: pion-1 min_power_in_top_N: &quot;500&quot; min_stake: &quot;0&quot; phase: CONSUMER_PHASE_LAUNCHED top_N: 60 validator_set_cap: 0 validators_power_cap: 0 pagination: next_key: null total: &quot;1&quot;   Validator Consumer Key Assignment​  The validator-consumer-key command allows to query assigned validator consensus public key for a consumer chain.  interchain-security-pd query provider validator-consumer-key [consumer-id] [provider-validator-address] [flags]   Example interchain-security-pd query provider validator-consumer-key 0 cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6 Output: consumer_address: cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk   Validator Provider Key​  The validator-provider-key command allows to query validator consensus public key for the provider chain.  interchain-security-pd query provider validator-provider-key [consumer-id] [consumer-validator-address] [flags]   Example interchain-security-pd query provider validator-provider-key 0 cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk Output: provider_address: cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj   Throttle State​  The throttle-state command allows to query on-chain state relevant to slash packet throttling.  interchain-security-pd query provider throttle-state [flags]   Example interchain-security-pd query provider throttle-state Output: next_replenish_candidate: &quot;2024-09-26T07:59:51.336971970Z&quot; slash_meter: &quot;1500&quot; slash_meter_allowance: &quot;1511&quot;   Registered Consumer Reward Denoms​  The registered-consumer-reward-denoms command allows to query registered consumer reward denoms.  interchain-security-pd query provider registered-consumer-reward-denoms [flags]   Example interchain-security-pd query provider registered-consumer-reward-denoms Output: denoms: - ibc/3C3D7B3BE4ECC85A0E5B52A3AEC3B7DFC2AA9CA47C37821E57020D6807043BE9 - ibc/D549749C93524DA1831A4B3C850DFC1BA9060261BEDFB224B3B0B4744CD77A70   All Pairs Valconsensus Address​  The all-pairs-valconsensus-address command allows to query all pairs of valconsensus address by consumer id.  interchain-security-pd query provider all-pairs-valconsensus-address [consumer-id] [flags]   Example interchain-security-pd query provider all-pairs-valconsensus-address 0 Output: pair_val_con_addr: - consumer_address: cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk consumer_key: ed25519: Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is= provider_address: cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6   Provider Parameters​  The params command allows to query provider parameters information.  interchain-security-pd query provider params [flags]   Example interchain-security-pd query provider params Output: blocks_per_epoch: &quot;3&quot; ccv_timeout_period: 2419200s consumer_reward_denom_registration_fee: amount: &quot;10000000&quot; denom: stake max_provider_consensus_validators: &quot;180&quot; number_of_epochs_to_start_receiving_rewards: &quot;24&quot; slash_meter_replenish_fraction: &quot;1.0&quot; slash_meter_replenish_period: 3600s template_client: allow_update_after_expiry: false allow_update_after_misbehaviour: false chain_id: &quot;&quot; frozen_height: revision_height: &quot;0&quot; revision_number: &quot;0&quot; latest_height: revision_height: &quot;0&quot; revision_number: &quot;0&quot; max_clock_drift: 10s proof_specs: - inner_spec: child_order: - 0 - 1 child_size: 33 empty_child: null hash: SHA256 max_prefix_length: 12 min_prefix_length: 4 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false - inner_spec: child_order: - 0 - 1 child_size: 32 empty_child: null hash: SHA256 max_prefix_length: 1 min_prefix_length: 1 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false trust_level: denominator: &quot;3&quot; numerator: &quot;1&quot; trusting_period: 0s unbonding_period: 0s upgrade_path: - upgrade - upgradedIBCState trusting_period_fraction: &quot;0.66&quot;   Consumer Opted In Validators​  The consumer-opted-in-validators command allows to query opted-in validators for a given consumer chain.  interchain-security-pd query provider consumer-opted-in-validators [consumer-id] [flags]   Example interchain-security-pd query provider consumer-opted-in-validators 0 Output: validators_provider_addresses: - cosmosvalcons1qmq08eruchr5sf5s3rwz7djpr5a25f7xw4mceq - cosmosvalcons1nx7n5uh0ztxsynn4sje6eyq2ud6rc6klc96w39 - cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6   Consumer Validators​  The consumer-validators command allows to query the last set consumer-validator set for a given consumer chain.  interchain-security-pd query provider consumer-validators [consumer-id] [flags]   Example interchain-security-pd query provider consumer-validators 0 Output: validators: - consumer_commission_rate: &quot;0.100000000000000000&quot; consumer_key: ed25519: RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10= consumer_power: &quot;511&quot; description: details: &quot;&quot; identity: &quot;&quot; moniker: validatoralice security_contact: &quot;&quot; website: &quot;&quot; jailed: false power: &quot;0&quot; provider_address: cosmosvalcons1qmq08eruchr5sf5s3rwz7djpr5a25f7xw4mceq provider_commission_rate: &quot;0.100000000000000000&quot; provider_operator_address: cosmosvaloper19pe9pg5dv9k5fzgzmsrgnw9rl9asf7ddtrgtng provider_power: &quot;511&quot; provider_tokens: &quot;511000000&quot; rate: &quot;0.000000000000000000&quot; status: BOND_STATUS_BONDED validates_current_epoch: true - consumer_commission_rate: &quot;0.100000000000000000&quot; consumer_key: ed25519: mAN6RXYxSM4MNGSIriYiS7pHuwAcOHDQAy9/wnlSzOI= consumer_power: &quot;500&quot; description: details: &quot;&quot; identity: &quot;&quot; moniker: validatorbob security_contact: &quot;&quot; website: &quot;&quot; jailed: false power: &quot;0&quot; provider_address: cosmosvalcons1nx7n5uh0ztxsynn4sje6eyq2ud6rc6klc96w39 provider_commission_rate: &quot;0.100000000000000000&quot; provider_operator_address: cosmosvaloper1dkas8mu4kyhl5jrh4nzvm65qz588hy9qakmjnw provider_power: &quot;500&quot; provider_tokens: &quot;500000000&quot; rate: &quot;0.000000000000000000&quot; status: BOND_STATUS_BONDED validates_current_epoch: true   Has to Validate​  The has-to-validate command allows to query the consumer chains list a given validator has to validate.  interchain-security-pd query provider has-to-validate [provider-validator-address] [flags]   Example interchain-security-pd query provider has-to-validate cosmoscons1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj Output: consumer_ids: - &quot;0&quot; - &quot;2&quot;   Validator Consumer Commission Rate​  The validator-consumer-commission-rate command allows to query the consumer commission rate a validator charges on a consumer chain.  interchain-security-pd query provider validator-consumer-commission-rate [consumer-id] [provider-validator-address] [flags]   Example interchain-security-pd query provider validator-consumer-commission-rate 0 cosmoscons1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj Output: rate: &quot;0.750000000000000000&quot;   Blocks Until Next Epoch​  The blocks-until-next-epoch command allows to query the number of blocks until the next epoch begins and validator updates are sent to consumer chains  interchain-security-pd query provider blocks-until-next-epoch [flags]   Example interchain-security-pd query provider blocks-until-next-epoch Output: blocks_until_next_epoch: &quot;286&quot;   Consumer Id From Client Id​  The consumer-id-from-client-id command allows to query the consumer id of the chain associated with the provided client id.  interchain-security-pd query provider consumer-id-from-client-id [client-id] [flags]   Example interchain-security-pd query provider consumer-id-from-client-id 07-tendermint-0 Output: consumer_id: &quot;0&quot;   Consumer Chain​  The consumer-chain command allows to query the consumer chain associated with the consumer id.  interchain-security-pd query provider consumer-chain [consumer-id] [flags]   Example interchain-security-pd query provider consumer-chain 0 Output: chain_id: pion-1 consumer_id: &quot;0&quot; init_params: binary_hash: YmluX2hhc2g= blocks_per_distribution_transmission: &quot;1000&quot; ccv_timeout_period: 2419200s consumer_redistribution_fraction: &quot;0.75&quot; distribution_transmission_channel: &quot;&quot; genesis_hash: Z2VuX2hhc2g= historical_entries: &quot;10000&quot; initial_height: revision_height: &quot;1&quot; revision_number: &quot;0&quot; spawn_time: &quot;2024-09-26T06:55:14.616054Z&quot; transfer_timeout_period: 3600s unbonding_period: 1209600s metadata: description: description of your chain and all other relevant information metadata: some metadata about your chain name: pion-1 owner_address: cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn phase: CONSUMER_PHASE_LAUNCHED power_shaping_params: allow_inactive_vals: false allowlist: [] denylist: [] min_stake: 0 top_N: 100 validator_set_cap: 0 validators_power_cap: 0   Transactions​  The tx commands allows users to interact with the provider module.  interchain-security-pd tx provider --help   Assign Consumer Key​  The assign-consensus-key command allows to assign a consensus public key to use for a consumer chain.  interchain-security-pd tx provider assign-consensus-key [consumer-id] [consumer-pubkey] [flags]   Example interchain-security-pd tx provider assign-consensus-key 0 \\ '{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}' \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Note that the consumer pubkey can be obtained by using interchain-security-cd tendermint show-validator command.  Create Consumer​  The create-consumer command allows to create a consumer chain.  interchain-security-pd tx provider create-consumer [consumer-parameters] [flags]   Example interchain-security-pd tx provider create-consumer path/to/create-consumer-msg.json \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where create-consumer-msg.json contains: { &quot;chain_id&quot; : &quot;pion-1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;{\\&quot;forge_json_url\\&quot;: \\&quot;...\\&quot;, \\&quot;stage\\&quot;: \\&quot;mainnet\\&quot;}&quot; } }   Update Consumer​  The update-consumer command allows to update a consumer chain.  interchain-security-pd tx provider update-consumer [consumer-parameters] [flags]   Example interchain-security-pd tx provider update-consumer path/to/update-consumer.json \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where update-consumer-msg.json contains: { &quot;consumer_id&quot; : &quot;0&quot;, &quot;owner_address&quot;: &quot;cosmos1p3ucd3ptpw902fluyjzhq3ffgq4ntddac9sa3s&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;{\\&quot;forge_json_url\\&quot;: \\&quot;...\\&quot;, \\&quot;stage\\&quot;: \\&quot;mainnet\\&quot;}&quot; }, &quot;initialization_parameters&quot;:{ &quot;initial_height&quot;:{ &quot;revision_number&quot;: 1, &quot;revision_height&quot;: 1 }, &quot;genesis_hash&quot;: &quot;&quot;, &quot;binary_hash&quot;: &quot;&quot;, &quot;spawn_time&quot;: &quot;2024-09-29T12:57:43Z&quot;, &quot;unbonding_period&quot;: 1728000000000000, &quot;ccv_timeout_period&quot;: 2419200000000000, &quot;transfer_timeout_period&quot;: 1800000000000, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;blocks_per_distribution_transmission&quot;: &quot;1500&quot;, &quot;historical_entries&quot;: &quot;1000&quot;, &quot;distribution_transmission_channel&quot;: &quot;&quot; }, &quot;power_shaping_parameters&quot;:{ &quot;top_N&quot;: 0, &quot;validators_power_cap&quot;: 10, &quot;validator_set_cap&quot;: 50, &quot;allowlist&quot;:[&quot;cosmosvalcons1l9qq4m300z8c5ez86ak2mp8znftewkwgjlxh88&quot;], &quot;denylist&quot;:[], &quot;min_stake&quot;: 1000, &quot;allow_inactive_vals&quot;:true }, &quot;allowlisted_reward_denoms&quot;: { &quot;denoms&quot;: [&quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;] } }   Remove Consumer​  The remove-consumer command allows to remove a consumer chain.  interchain-security-pd tx provider remove-consumer [consumer-id] [flags]   Example interchain-security-pd tx provider remove-consumer 0   Opt In​  The opt-in command allows a validator to opt in to a consumer chain and optionally set a consensus public key.  interchain-security-pd tx provider opt-in [consumer-id] [consumer-pubkey] [flags]   Example interchain-security-pd tx provider opt-in 0 \\ '{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}' \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Opt Out​  The opt-out command allows validators to opt out from consumer chains.  interchain-security-pd tx provider opt-out [consumer-id] [flags]   Example interchain-security-pd tx provider opt-out 0 \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Set Consumer Commission Rate​  The set-consumer-commission-rate command allows to set a per-consumer chain commission rate.  interchain-security-pd tx provider set-consumer-commission-rate [consumer-id] [commission-rate] [flags]   Example interchain-security-pd tx provider set-consumer-commission-rate 0 0.5 \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Submit Consumer Double Voting​  The submit-consumer-double-voting command allows to submit a double voting evidence for a consumer chain.  interchain-security-pd tx provider submit-consumer-double-voting [consumer-id] [evidence] [infraction_header] [flags]   Example interchain-security-pd tx provider submit-consumer-double-voting 0 path/to/evidence.json path/to/infraction_header.json \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where evidence.json contains: { &quot;vote_a&quot;: { &quot;type&quot;: &quot;SIGNED_MSG_TYPE_PREVOTE&quot;, &quot;height&quot;: &quot;59&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;paTPgLrLCZmw5ctQWlaMLJhXLckafakKN9skJbTiCHA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;pVOTT8MO00rk0HAeVQgzdP3wjIOzN5X5tfPLTtXIn2g=&quot; } }, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.146234009Z&quot;, &quot;validator_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;validator_index&quot;: 1, &quot;signature&quot;: &quot;Z9C1oU5AEyFqXVmQ0LKNlaVa+tGh++95EB5HYe0i61PlREOmo/OTLlWedr8kuAThBu/1CpaLz446hYjISAKqBQ==&quot;, &quot;extension&quot;: null, &quot;extension_signature&quot;: null }, &quot;vote_b&quot;: { &quot;type&quot;: &quot;SIGNED_MSG_TYPE_PREVOTE&quot;, &quot;height&quot;: &quot;59&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;07tksQsQ0gVBphgP4eeyGII9tEaLUuCauQcmwar9ktk=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;nND/ClxCtoSJ9fC7Jyy884ab+nDh+PnHwI28T2fELCE=&quot; } }, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.051976301Z&quot;, &quot;validator_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;validator_index&quot;: 1, &quot;signature&quot;: &quot;QscqC9ilH4gL7+3GPqLMWly+UkO+p0JgcinDZtfHOM4fYosZhx+TzhLrrXNExYpwX3D8qQHmJlLCcXLqbo7aCA==&quot;, &quot;extension&quot;: null, &quot;extension_signature&quot;: null }, &quot;total_voting_power&quot;: &quot;1500&quot;, &quot;validator_power&quot;: &quot;500&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:45.945436342Z&quot; } and infraction_header.json contains: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;0&quot; }, &quot;chain_id&quot;: &quot;pion-1&quot;, &quot;height&quot;: &quot;59&quot;, &quot;time&quot;: &quot;2024-09-26T09:34:45.945436342Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;t8HcmkQbchpGE1CxqdhcogoT+yD5VIm+cRGLcosTtxE=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;fTediSh8XttUUoxWJLPIxO6iWecqdMMsegD2svBtR5E=&quot; } }, &quot;last_commit_hash&quot;: &quot;2U4mFcB6+FffQeFPUaHkd+eBtEV5/5d3Zy0Lk58dwIs=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;D26N3CL1zQt7yn+JUQ8Dcb2vCYG7QmHMiMfY+nGxhts=&quot;, &quot;next_validators_hash&quot;: &quot;D26N3CL1zQt7yn+JUQ8Dcb2vCYG7QmHMiMfY+nGxhts=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;k/RW/WMOYCS89VBhKMHIRYb30a30JkZ+puyp9ESTBiA=&quot;, &quot;last_results_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;59&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;07tksQsQ0gVBphgP4eeyGII9tEaLUuCauQcmwar9ktk=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;nND/ClxCtoSJ9fC7Jyy884ab+nDh+PnHwI28T2fELCE=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;BsDz5HzFx0gmkIjcLzZBHTqqJ8Y=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.271500717Z&quot;, &quot;signature&quot;: &quot;bXA2WgQVVlHAkn9mGIfoUvgn3C+EJCzNGTAjnhoQJwLkh1Okg3oYmwZRz+UGbc95kXyVO7kQSXhavt0ZPcJ4AA==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.305955426Z&quot;, &quot;signature&quot;: &quot;YG1OcUhpTKFz+Uo8halNmkw0s6n333+m53laZvyQSHM5gqOG4h8jzij2u9sU4H404OJMgdj+1GTxuHmQ8jWFBg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;tBw6QBQpY6pbEt3RxOWJDAs5JrE=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.255694467Z&quot;, &quot;signature&quot;: &quot;EYOC/yo+RaosEVhwBy0bZFjVwHCR7rRZo/FmTRWpAIXZHBVrIiX3iVzRUwn78lsfbaoT97TsqRX61bAiJDM6BA==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;BsDz5HzFx0gmkIjcLzZBHTqqJ8Y=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;-1000&quot; }, { &quot;address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;mAN6RXYxSM4MNGSIriYiS7pHuwAcOHDQAy9/wnlSzOI=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;500&quot; }, { &quot;address&quot;: &quot;tBw6QBQpY6pbEt3RxOWJDAs5JrE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;500&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;BsDz5HzFx0gmkIjcLzZBHTqqJ8Y=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;-1000&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;0&quot; }, &quot;trusted_validators&quot;: null }   Submit Consumer Misbehaviour​  The submit-consumer-misbehaviour command allows to submit an IBC misbehaviour for a consumer chain.  interchain-security-pd tx provider submit-consumer-misbehaviour [consumer-id] [misbehaviour] [flags]   Example interchain-security-pd tx provider submit-consumer-misbehaviour 0 path/to/consumer-misbehaviour.json --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where consumer-misbehaviour.json contains: { &quot;client_id&quot;: &quot;07-tendermint-0&quot;, &quot;header_1&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;0&quot; }, &quot;chain_id&quot;: &quot;pion-1&quot;, &quot;height&quot;: &quot;95&quot;, &quot;time&quot;: &quot;2024-09-26T09:15:52.845591095Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;PUph0B9N9X+LdrstqOoGf+W+OS6oHetQUa+0fpcRnF8=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;SlVkAlM1uq3DjgTk0NbZftLlFwOEJrau1Wnhg3jEH3A=&quot; } }, &quot;last_commit_hash&quot;: &quot;Hxe4aLTULJ7qxJ10XsQfluKyU1Rn+d+cgDeTm2AATqU=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;next_validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;uGHlqLiNp+ZCjE889JDFKnrNkRpZ5xZ5OOamXrCNcOc=&quot;, &quot;last_results_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;95&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;hkUUob+4UVRE4uJW53fY9UYViGTs2v6P5Sb/hUFYyak=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;0tx9pRIzYJ3vwrYyOgMC8zxf/sSJUtNVm9DBKM8Yxo0=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:15:53.852414554Z&quot;, &quot;signature&quot;: &quot;iiQCCxsCOoNVb2smAVmDO62o9HLf+I4rWk8o86uA1ZoFun/lk1bwrocaMp1It1SjVo/szYsX6Hp5rP1IwcAjDg==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;20&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } }, &quot;header_2&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;0&quot; }, &quot;chain_id&quot;: &quot;consu&quot;, &quot;height&quot;: &quot;95&quot;, &quot;time&quot;: &quot;2024-09-26T09:15:54.044450012Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;MG9B1h4R9Xb4GRjvaNydD5NSqT37OOjGDcatCZpBlco=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;3jQh26/9EuNAAEL6v2tRuGhKtkotoyTqGtduOOn++vk=&quot; } }, &quot;last_commit_hash&quot;: &quot;s1hUy5e7i+GrH5IGW1ck4YHK2CDTY4fjnSiNMInJBWc=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;next_validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;bWRmShMthwEAB3lIVMgB673gH5vTdoqfn223M3Xrk6Q=&quot;, &quot;last_results_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;95&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;z3MJTCXppRYoIEPOrneYzw/U0CSiYF3zsUv67ynxM6Q=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;BFSlw7bqXxBHl9O5O9sCUB01nbe0T0KGOmv7yyr8KYU=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:15:55.054809888Z&quot;, &quot;signature&quot;: &quot;oi+TQ0yoDEeXyBchFIql9AGxbufnx3FzDKsCp4B8tx42ropD8tyotKOjk0OMuZQC5aMMRndRfKiYYsWiOrcpAg==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;20&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } } }   ","version":"v6.3.0","tagName":"h3"},{"title":"gRPC​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#grpc","content":" A user can query the provider module using gRPC endpoints.  Consumer Genesis​  The QueryConsumerGenesis endpoint queries a consumer chain genesis state by consumer id.  interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 \\ interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis Output: { &quot;genesisState&quot;: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;1000&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot; }, &quot;provider&quot;: { &quot;clientState&quot;: { &quot;chainId&quot;: &quot;provider&quot;, &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;57024s&quot;, &quot;unbondingPeriod&quot;: &quot;86400s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: { &quot;revisionHeight&quot;: &quot;10&quot; }, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;consensusState&quot;: { &quot;timestamp&quot;: &quot;2024-09-26T08:19:42.708111Z&quot;, &quot;root&quot;: { &quot;hash&quot;: &quot;xbZV/9QyM3PYzY/HyJAsNogaaJVJtyAGROTcXuqxHas=&quot; }, &quot;nextValidatorsHash&quot;: &quot;/zLB6RSu9omrO5L0tnDK03hCOUibwl/7eeVC3hTP7so=&quot; }, &quot;initialValSet&quot;: [ { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;E9bJ6bi7X9MG9s3djQ4MmBxshis9W15y7UzXCxp2Yuk=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;power&quot;: &quot;100&quot; } ] }, &quot;newChain&quot;: true } }   List Consumer Chains​  The QueryConsumerChains endpoint queries consumer chains supported by the provider chain. An optional integer parameter can be passed for phase filtering of consumer chains, (Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5).`  interchain_security.ccv.provider.v1.Query/QueryConsumerChains   Example grpcurl -plaintext -d '{&quot;phase&quot;: &quot;1&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChains Output: { &quot;chains&quot;: [ { &quot;chainId&quot;: &quot;pion-1&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;2&quot; }, { &quot;chainId&quot;: &quot;dash-2&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;dash-2&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;4&quot; }, ], &quot;pagination&quot;: { &quot;total&quot;: &quot;6&quot; } }   Validator Consumer Key Assignment​  The QueryValidatorConsumerAddr endpoint queries the address assigned by a validator for a consumer chain.  interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;, &quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr Output: { &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot; }   Validator Provider Key​  The QueryValidatorProviderAddr endpoint queries the provider chain address given a consumer chain validator address.  interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;, &quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr Output: { &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot; }   Throttle State​  The QueryThrottleState queries the main on-chain state relevant to slash packet throttling.  interchain_security.ccv.provider.v1.Query/QueryThrottleState   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryThrottleState Output: { &quot;slashMeter&quot;: &quot;15&quot;, &quot;slashMeterAllowance&quot;: &quot;15&quot;, &quot;nextReplenishCandidate&quot;: &quot;2024-09-26T14:27:38.066958Z&quot; }   Registered Consumer Reward Denoms​  The QueryRegisteredConsumerRewardDenoms command allows to query registered consumer reward denoms  interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms Output: { &quot;denoms&quot;: [ &quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;, &quot;ibc/054892D6BB43AF8B93AAC28AA5FD7019D2C59A15DAFD6F45C1FA2BF9BDA22454&quot;, &quot;uatom&quot; ] }   All Pairs Valconsensus Address​  The QueryAllPairsValConsAddrByConsumer endpoint queries the list of pair valconsensus address between provider and consumer chain.  interchain_security.ccv.provider.v1.Query/QueryAllPairsValConsAddrByConsumer   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryAllPairsValConsAddrByConsumer Output: { &quot;pairValConAddr&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6&quot;, &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; } } ] }   Provider Parameters​  The QueryParams endpoint queries all current values of provider parameters.  interchain_security.ccv.provider.v1.Query/QueryParams   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryParams Output: { &quot;params&quot;: { &quot;templateClient&quot;: { &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;0s&quot;, &quot;unbondingPeriod&quot;: &quot;0s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: {}, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;trustingPeriodFraction&quot;: &quot;0.66&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;slashMeterReplenishPeriod&quot;: &quot;3600s&quot;, &quot;slashMeterReplenishFraction&quot;: &quot;0.05&quot;, &quot;consumerRewardDenomRegistrationFee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocksPerEpoch&quot;: &quot;5&quot;, &quot;numberOfEpochsToStartReceivingRewards&quot;: &quot;24&quot;, &quot;maxProviderConsensusValidators&quot;: &quot;180&quot; } }   Consumer Opted In Validators​  The QueryConsumerChainOptedInValidators endpoint queries opted-in validators for a given consumer chain.  interchain_security.ccv.provider.v1.Query/QueryConsumerChainOptedInValidators   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChainOptedInValidators Output: { &quot;validatorsProviderAddresses&quot;: [ &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot; ] }   Consumer Validators​  The QueryConsumerValidators endpoint queries the latest set consumer-validator set for a given consumer ID. Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment because a VSCPacket could be delayed to be delivered on the consumer chain.  interchain_security.ccv.provider.v1.Query/QueryConsumerValidators   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerValidators Output: { &quot;validators&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;101&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;bob&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1a7u5k6f54ua3tptl9yn6u82yrvayet6sxn9ywn&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;101000000&quot;, &quot;providerPower&quot;: &quot;101&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;coordinator&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1jk2pp655zxy2gazhxj50s8jk3750y8np6wz4lm&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;alice&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper19vfen9jn3uk3e6rrkt3pxansunujnlm40wpdvg&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true } ] }   Has to Validate​  The QueryConsumerChainsValidatorHasToValidate endpoint queries a list of consumer chains that a given validator must validate.  interchain_security.ccv.provider.v1.Query/QueryConsumerChainsValidatorHasToValidate   Example grpcurl -plaintext -d '{&quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChainsValidatorHasToValidate Output: { &quot;consumerIds&quot;: [ &quot;0&quot;, &quot;2&quot; ] }   Validator Consumer Commission Rate​  The QueryValidatorConsumerCommissionRate endpoint queries the consumer commission rate a validator charges on a consumer chain.  interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerCommissionRate   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;, &quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerCommissionRate Output: { &quot;rate&quot;: &quot;750000000000000000&quot; }   Blocks Until Next Epoch​  The QueryBlocksUntilNextEpoch endpoint allows to query the number of blocks until the next epoch begins and validator updates are sent to consumer chains.  interchain_security.ccv.provider.v1.Query/QueryBlocksUntilNextEpoch   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryBlocksUntilNextEpoch Output: { &quot;blocks_until_next_epoch&quot;:&quot;4&quot; }   Consumer Id From Client Id​  The QueryConsumerIdFromClientId endpoint allows to query the consumer id of the chain associated with the provided client id.  interchain_security.ccv.provider.v1.Query/QueryConsumerIdFromClientId   Example grpcurl -plaintext -d '{&quot;client_id&quot;:&quot;07-tendermint-0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerIdFromClientId Output: { &quot;consumerId&quot;: &quot;0&quot; }   Consumer Chain​  The QueryConsumerChain command allows to query the consumer chain associated with the consumer id.  interchain_security.ccv.provider.v1.Query/QueryConsumerChain   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChain { &quot;consumerId&quot;: &quot;0&quot;, &quot;chainId&quot;: &quot;pion-1&quot;, &quot;ownerAddress&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_LAUNCHED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;description of your chain and all other relevant information&quot;, &quot;description&quot;: &quot;some metadata about your chain&quot;, &quot;metadata&quot;: &quot;pion-1&quot; }, &quot;initParams&quot;: { &quot;initialHeight&quot;: { &quot;revisionHeight&quot;: &quot;1&quot; }, &quot;genesisHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;binaryHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;spawnTime&quot;: &quot;2023-03-11T17:02:14.718477Z&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;historicalEntries&quot;: &quot;1000&quot; }, &quot;powerShapingParams&quot;: { &quot;topN&quot;: 100, &quot;validatorSetCap&quot;: 50, &quot;minStake&quot;: &quot;1000&quot;, &quot;allowInactiveVals&quot;: true } }   ","version":"v6.3.0","tagName":"h3"},{"title":"REST​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.3.0/build/modules/provider#rest","content":" A user can query the provider module using REST endpoints.  Consumer Genesis​  The consumer_genesis endpoint queries a consumer chain genesis state by consumer id.  interchain_security/ccv/provider/consumer_genesis/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_genesis/0 Output: { &quot;genesisState&quot;: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;1000&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot; }, &quot;provider&quot;: { &quot;clientState&quot;: { &quot;chainId&quot;: &quot;provider&quot;, &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;57024s&quot;, &quot;unbondingPeriod&quot;: &quot;86400s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: { &quot;revisionHeight&quot;: &quot;10&quot; }, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;consensusState&quot;: { &quot;timestamp&quot;: &quot;2024-09-26T08:19:42.708111Z&quot;, &quot;root&quot;: { &quot;hash&quot;: &quot;xbZV/9QyM3PYzY/HyJAsNogaaJVJtyAGROTcXuqxHas=&quot; }, &quot;nextValidatorsHash&quot;: &quot;/zLB6RSu9omrO5L0tnDK03hCOUibwl/7eeVC3hTP7so=&quot; }, &quot;initialValSet&quot;: [ { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;E9bJ6bi7X9MG9s3djQ4MmBxshis9W15y7UzXCxp2Yuk=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;power&quot;: &quot;100&quot; } ] }, &quot;newChain&quot;: true } }   List Consumer Chains​  The consumer_chains endpoint queries consumer chains supported by the provider chain. An optional integer parameter can be passed for phase filtering of consumer chains, (Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5).`  interchain_security/ccv/provider/consumer_chains/{phase}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_chains/3 Output: { &quot;chains&quot;: [ { &quot;chainId&quot;: &quot;pion-1&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;2&quot; }, { &quot;chainId&quot;: &quot;dash-2&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;dash-2&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;4&quot; }, ], &quot;pagination&quot;: { &quot;total&quot;: &quot;6&quot; } }   Validator Consumer Key Assignment​  The validator_consumer_addr endpoint queries the address assigned by a validator for a consumer chain.  /interchain_security/ccv/provider/validator_consumer_addr/{consumer_id}/{provider_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/validator_consumer_addr/0/cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj Output: { &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot; }   Validator Provider Key​  The validator_provider_addr endpoint queries the provider chain address given a consumer chain validator address.  /interchain_security/ccv/provider/validator_provider_addr/{consumer_id}/{consumer_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/validator_provider_addr/0/cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk Output: { &quot;providerAddress&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot; }   Throttle State​  The throttle_state queries the main on-chain state relevant to slash packet throttling.  &quot;/interchain_security/ccv/provider/throttle_state&quot;   Example curl http://localhost:1317/interchain_security/ccv/provider/throttle_state Output: { &quot;slashMeter&quot;: &quot;15&quot;, &quot;slashMeterAllowance&quot;: &quot;15&quot;, &quot;nextReplenishCandidate&quot;: &quot;2024-09-26T14:27:38.066958Z&quot; }   Registered Consumer Reward Denoms​  The registered_consumer_reward_denoms endpoint allows to query registered consumer reward denoms  interchain_security/ccv/provider/registered_consumer_reward_denoms   Example curl http://localhost:1317/interchain_security/ccv/provider/registered_consumer_reward_denoms Output: { &quot;denoms&quot;: [ &quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;, &quot;ibc/054892D6BB43AF8B93AAC28AA5FD7019D2C59A15DAFD6F45C1FA2BF9BDA22454&quot;, &quot;uatom&quot; ] }   All Pairs Valconsensus Address​  The address_pairs endpoint queries the list of pair valconsensus address between provider and consumer chain.  interchain_security/ccv/provider/address_pairs/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/address_pairs/0 Output: { &quot;pairValConAddr&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6&quot;, &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; } } ] }   Provider Parameters​  The params endpoint queries all current values of provider parameters  interchain_security/ccv/provider/params   Example curl http://localhost:1317/interchain_security/ccv/provider/params Output: { &quot;params&quot;: { &quot;templateClient&quot;: { &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;0s&quot;, &quot;unbondingPeriod&quot;: &quot;0s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: {}, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;trustingPeriodFraction&quot;: &quot;0.66&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;slashMeterReplenishPeriod&quot;: &quot;3600s&quot;, &quot;slashMeterReplenishFraction&quot;: &quot;0.05&quot;, &quot;consumerRewardDenomRegistrationFee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocksPerEpoch&quot;: &quot;5&quot;, &quot;numberOfEpochsToStartReceivingRewards&quot;: &quot;24&quot;, &quot;maxProviderConsensusValidators&quot;: &quot;180&quot; } }   Consumer Opted In Validators​  The opted_in_validators endpoint queries opted-in validators for a given consumer chain  /interchain_security/ccv/provider/opted_in_validators/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/opted_in_validators/0 Output: { &quot;validatorsProviderAddresses&quot;: [ &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot; ] }   Consumer Validators​  The consumer_validators endpoint queries the latest set consumer-validator set for a given consumer ID Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment because a VSCPacket could be delayed to be delivered on the consumer chain.  /interchain_security/ccv/provider/consumer_validators/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_validators/0 Output: { &quot;validators&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;101&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;bob&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1a7u5k6f54ua3tptl9yn6u82yrvayet6sxn9ywn&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;101000000&quot;, &quot;providerPower&quot;: &quot;101&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;coordinator&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1jk2pp655zxy2gazhxj50s8jk3750y8np6wz4lm&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;alice&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper19vfen9jn3uk3e6rrkt3pxansunujnlm40wpdvg&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true } ] }   Has to Validate​  The consumer_chains_per_validator endpoint queries a list of consumer chains that a given validator must validate.  interchain_security/ccv/provider/consumer_chains_per_validator/{provider_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_chains_per_validator/cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph Output: { &quot;consumerIds&quot;: [ &quot;0&quot;, &quot;2&quot; ] }   Validator Consumer Commission Rate​  The consumer_commission_rate endpoint queries the consumer commission rate a validator charges on a consumer chain.  /interchain_security/ccv/provider/consumer_commission_rate/{consumer_id}/{provider_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_commission_rate/0/cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph Output: { &quot;rate&quot;: &quot;0.100000000000000000&quot; }   Blocks Until Next Epoch​  The blocks_until_next_epoch endpoint allows to query the number of blocks until the next epoch begins and validator updates are sent to consumer chains  interchain_security/ccv/provider/blocks_until_next_epoch   Example curl http://localhost:1317/interchain_security/ccv/provider/blocks_until_next_epoch Output: { &quot;blocks_until_next_epoch&quot;:&quot;3&quot; }   Consumer Id From Client Id​  The consumer_id endpoint allows to query the consumer id of the chain associated with the provided client id  /interchain_security/ccv/provider/consumer_id/{client_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_id/07-tendermint-0 Output: { &quot;consumer_id&quot;:&quot;0&quot; }   Consumer Chain​  The consumer_chain endpoint allows to query the consumer chain associated with the consumer id.  interchain_security/ccv/provider/consumer_chain/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_chain/0 Output: { &quot;consumerId&quot;: &quot;0&quot;, &quot;chainId&quot;: &quot;pion-1&quot;, &quot;ownerAddress&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_LAUNCHED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;description of your chain and all other relevant information&quot;, &quot;description&quot;: &quot;some metadata about your chain&quot;, &quot;metadata&quot;: &quot;pion-1&quot; }, &quot;initParams&quot;: { &quot;initialHeight&quot;: { &quot;revisionHeight&quot;: &quot;1&quot; }, &quot;genesisHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;binaryHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;spawnTime&quot;: &quot;2023-03-11T17:02:14.718477Z&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;historicalEntries&quot;: &quot;1000&quot; }, &quot;powerShapingParams&quot;: { &quot;topN&quot;: 100, &quot;validatorSetCap&quot;: 50, &quot;minStake&quot;: &quot;1000&quot;, &quot;allowInactiveVals&quot;: true } }  ","version":"v6.3.0","tagName":"h3"},{"title":"ADR 005: Cryptographic verification of equivocation evidence","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#changelog","content":" 5/1/2023: First draft7/23/2023: Add light client attacks handling9/6/2023: Add double signing attacks handling11/3/2023: Update limitations to clarify amnesia attacks are ignored  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#context","content":" Currently, we use a governance proposal to slash validators for equivocation (double signing and light client attacks). Every proposal needs to go through a (two weeks) voting period before it can be approved. Given a three-week unbonding period, this means that an equivocation proposal needs to be submitted within one week since the infraction occurred.  This ADR proposes a system to slash validators automatically for equivocation, immediately upon the provider chain's receipt of the evidence. Another thing to note is that we intend to introduce this system in stages, since even the partial ability to slash and/or tombstone is a strict improvement in security. The feature is implemented in two parts, each with its dedicated endpoint. One endpoint handles light client attacks, while the other handles double signing attacks.  ","version":"v6.4.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack","content":" In a nutshell, the light client is a process that solely verifies a specific state machine's consensus without executing the transactions. The light clients get new headers by querying multiple nodes, called primary and witness nodes.  Light clients download new headers committed on chain from a primary. Headers can be verified in two ways: sequentially, where the block height of headers is serial, or using skipping. This second verification method allows light clients to download headers with nonconsecutive block height, where some intermediate headers are skipped (see Tendermint Light Client, Figure 1 and Figure 3). Additionally, light clients are cross-checking new headers obtained from a primary with witnesses to ensure all nodes share the same state.  A light client attack occurs when a Byzantine validator sends invalid headers to a light client. As the light client doesn't execute transactions, it can be deceived into trusting corrupted application state transitions. For instance, if a light client receives header A from the primary and header B from a witness for the same block height H, and both headers are successfully verified, it indicates a light client attack. Note that in this case, either the primary or the witness or both are malicious.  The types of light client attacks are defined by analyzing the differences between the conflicting headers. There are three types of light client attacks: lunatic attack, equivocation attack, and amnesia attack. For details, see the CometBFT specification.  When a light client agent detects two conflicting headers, it will initially verify their traces (see cometBFT detector) using its primary and witness nodes. If these headers pass successful verification, the Byzantine validators will be identified based on the header's commit signatures and the type of light client attack. The agent will then transmit this information to its nodes using a LightClientAttackEvidence evidence to be eventually voted on and added to a block. Note that from a light client agent perspective, it is not possible to establish whether a primary or a witness node, or both, are malicious. Therefore, it will create and send two evidences: one against the primary (sent to the witness), and one against the witness (sent to the primary). Both nodes will then verify it before broadcasting it and adding it to the evidence pool. If an evidence is finally committed to a block, the chain's evidence module will execute it, resulting in the jailing and the slashing of the validators responsible for the light client attack.  Light clients are a core component of IBC. In the event of a light client attack, IBC relayers notify the affected chains by submitting an IBC misbehavior message. A misbehavior message includes the conflicting headers that constitute a light client attack evidence. Upon receiving such a message, a chain will first verify whether these headers would have convinced its light client. This verification is achieved by checking the header states against the light client consensus states (see IBC misbehaviour handler). If the misbehaviour is successfully verified, the chain will then &quot;freeze&quot; the light client, halting any further trust in or updating of its states.  ","version":"v6.4.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack","content":" A double signing attack, also known as equivocation, occurs when a validator votes for two different blocks in the same round of the CometBFT consensus. This consensus mechanism operates with multiple voting rounds at each block height, and it strictly prohibits sending two votes of the same type during a round (see CometBFT State Machine Overview).  When a node observes two votes from the same peer, it will use these two votes to create a DuplicateVoteEvidenceevidence and gossip it to the other nodes in the network (see CometBFT equivocation detection). Each node will then verify the evidence according to the CometBFT rules that define a valid double signing infraction, and based on this verification, they will decide whether to add the evidence to a block. During the evidence verification process, the signatures of the conflicting votes must be verified successfully. Note that this is achieved using the public key of the misbehaving validator, along with the chain ID of the chain where the infraction occurred (see CometBFT equivocation verification).  Once a double signing evidence is committed to a block, the consensus layer will report the equivocation to the evidence module of the Cosmos SDK application layer. The application will, in turn, punish the malicious validator through jailing, tombstoning and slashing (see handleEquivocationEvidence).  ","version":"v6.4.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#decision","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack-1","content":" In the first part of the feature, we introduce a new endpoint: HandleConsumerMisbehaviour(ctx sdk.Context, misbehaviour ibctmtypes.Misbehaviour). The main idea is to leverage the current IBC misbehaviour handling and update it to solely jail and slash the validators that performed a light client attack. Note that in this context, we assume that chains connected via a light client share a subset of the validator set of the provider.  This endpoint reuses the IBC client libraries to verify that the misbehaviour headers would have fooled the light client. Additionally, it’s crucial that the endpoint logic results in the slashing and jailing of validators under the same conditions as a light client agent detector. Therefore, the endpoint ensures that the two conditions are met: the headers in the misbehaviour message have the same block height, and the light client isn’t expired.  After having successfully verified a misbehaviour, the endpoint executes the jailing and slashing of the malicious validators similarly as in the evidence module.  ","version":"v6.4.0","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack-1","content":" In the second part of the feature, we introduce a new endpoint HandleConsumerDoubleVoting( ctx sdk.Context, evidence *tmtypes.DuplicateVoteEvidence, chainID string, pubkey cryptotypes.PubKey). Simply put, the handling logic verifies a double signing evidence against a provided public key and chain ID and, if successful, executes the jailing of the malicious validator who double voted.  We define a newMsgSubmitConsumerDoubleVoting message to report a double voting evidence observed on a consumer chain to the endpoint of the provider chain. This message contains two fields: a double signing evidenceduplicate_vote_evidence and a light client header for the infraction block height, referred to as infraction_block_header. The latter provides the malicious validator's public key and the chain ID required to verify the signature of the votes contained in the evidence.  Note that double signing evidence is not verified using the same conditions as in the implementation CometBFT (seeverify(evidence types.Evidence) method). Specifically, we do not check that the evidence hasn't expired. More details can be found in the &quot;Current limitations&quot; section below.  Upon a successful equivocation verification, the misbehaving validator is jailed for the maximum time (see DoubleSignJailEndTimein the SDK evidence module).  ","version":"v6.4.0","tagName":"h3"},{"title":"Current limitations:​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#current-limitations","content":" We cannot derive an infraction height from the evidence, so it is only possible to jail validators, not actually slash them. To explain the technical reasons behind this limitation, let's recap the initial consumer initiated slashing logic. In a nutshell, consumer heights are mapped to provider heights through VSCPackets, namely through the so called vscIDs. When an infraction occurs on the consumer, a SlashPacket containing the vscID obtained from mapping the consumer infraction height is sent to the provider. Upon receiving the packet, the provider maps the consumer infraction height to a local infraction height, which is used to slash the misbehaving validator. In the context of untrusted consumer chains, all their states, including vscIDs, could be corrupted and therefore cannot be used for slashing purposes. For the same reasons explained above, the age of a consumer double signing evidence can't be verified, either using its infraction height or its unsigned timestamp. Note that changes the jailing behaviour, potentially leading to a validator's jailing based on some &quot;old&quot; evidence from a consumer, which wouldn't occur if the consumer were a standalone chain. In the first stage of this feature, validators are jailed indefinitely without being tombstoned. The underlying reason is that a malicious validator could take advantage of getting tombstoned to avoid being slashed on the provider (see comment). Currently, the endpoint can only handle equivocation light client attacks. This is because the lunatic attacks require the endpoint to possess the ability to dissociate which header is conflicted or trusted upon receiving a misbehavior message. Without this information, it's not possible to extract the Byzantine validators from the conflicting headers (see comment). In addition, &quot;amnesia&quot; attacks are ignored, similar to CometBFT (see ADR-056).  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#positive","content":" It is now possible for the provider chain to jail validators who committed light client or double signing attacks on a consumer chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#negative","content":" N/A  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/v6.4.0/adrs/adr-005-cryptographic-equivocation-verification#references","content":" ICS misbehaviour handling PRConsumer double voting handler PRArchitectural diagramsADR on equivocation slashing ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 007: Pause validator unbonding during equivocation proposal","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#changelog","content":" 2023-05-16: Initial Draft2023-11-30: Change the status to rejected  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#status","content":" Rejected  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#context","content":" Note: ADR rejected as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  Currently, if an equivocation slashing proposal is created after more than one week has passed since the equivocation, it is possible that the validator in question could unbond and get away without being slashed, since the unbonding period is 3 weeks, and the voting period is 2 weeks. For this reason, it might be good to pause unbondings for validators named in an equivocation slashing proposal until the proposal's voting period is over.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#decision","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"How​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#how","content":" Pausing the unbonding period is already possible thanks to the changes in thestaking module of the cosmos-sdk:  stakingKeeper.PutUnbondingOnHold pauses an unbonding periodstakingKeeper.UnbondingCanComplete unpauses an unbonding period  These methods use a reference counter under the hood, that gets incremented every time PutUnbondingOnHold is called, and decreased whenUnbondingCanComplete is called instead. A specific unbonding is considered fully unpaused when its underlying reference counter reaches 0. Therefore, as long as we safeguard consistency - i.e. we make sure we eventually decrement the reference counter for each time we have incremented it - we can safely use this existing mechanism without conflicts with the Completion of Unbonding Operations system.  ","version":"v6.4.0","tagName":"h3"},{"title":"When pause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-pause","content":" The unbonding period (if there is any unbonding) should be paused once an equivocation proposal enters the voting period. For that, the gov module's hook AfterProposalDeposit can be used.  If the hook is triggered with a an equivocation proposal in voting period, then for each equivocation of the proposal, the unbonding operations of the related validator that were initiated after the equivocation block time must be paused  i.e. the underlying reference counter has to be increased.  Note that even after the voting period has started, a proposal can receive additional deposits. The hook is triggered however at arrival of a deposit, so a check to verify that the proposal is not already in voting period is required.  ","version":"v6.4.0","tagName":"h3"},{"title":"When unpause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#when-unpause","content":" We can use a gov module's hook also here and it isAfterProposalVotingPeriodEnded.  If the hook is triggered with an equivocation proposal, then for each associated equivocation, the unbonding operations of the related validator that were initiated between the equivocation block time and the start of the proposal voting period must be unpaused - i.e. decrease the underlying reference counter - regardless of the proposal outcome.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#positive","content":" Validators subject to an equivocation proposal cannot finish unbonding their tokens before the end of the voting period.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#negative","content":" A malicious consumer chain could forge slash packets enabling submission of an equivocation proposal on the provider chain, resulting in the freezing of validator's unbondings for an undeterminated amount of time.Misbehavior on a consumer chain can potentially go unpunished, if no one submits an equivocation proposal in time, or if the proposal doesn't pass.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#neutral","content":" This feature can't be used for social slashing, because an equivocation proposal is only accepted if there's a slash log for the related validator(s), meaning the consumer chain has reported the equivocation to the provider chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/v6.4.0/adrs/adr-007-pause-unbonding-on-eqv-prop#references","content":" https://github.com/cosmos/interchain-security/issues/747https://github.com/cosmos/interchain-security/pull/791 ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 002: Jail Throttling","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#changelog","content":" 2023-01-26: Initial Draft2023-02-07: Property refined, ADR ready to review/merge2023-11-22: Refactor for better understanding  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#context","content":" The CCV spec is based around the assumption that the provider binary and all consumers binaries are non-malicious, and follow the defined protocols. In practice, this assumption may not hold. A malicious consumer binary could potentially include code which is able to send many slash/jail packets at once to the provider.  Before the throttling feature was implemented, the following attack was possible. Attacker(s) would create provider validators just below the provider's active set. Using a malicious consumer binary, slash packets would be relayed to the provider, that would slash/jail a significant portion (or all) of honest validator at once. Control of the provider would then pass over to the attackers' validators. This enables the attacker(s) to halt the provider. Or even worse, commit arbitrary state on the provider, potentially stealing all tokens bridged to the provider over IBC.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#decision","content":" The throttling feature was designed to slow down the mentioned attack from above, allowing validators and the community to appropriately respond to the attack, i.e., this feature limits (enforced by on-chain params) the rate that the provider validator set can be jailed over time.  ","version":"v6.4.0","tagName":"h2"},{"title":"Required State​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#required-state","content":" Slash meter: There exists one slash meter on the provider which stores an amount of voting power (integer), corresponding to an allowance of validators that can be jailed over time. This meter is initialized to a certain value on genesis, decremented by the amount of voting power jailed whenever a slash packet is handled, and periodically replenished as decided by on-chain params.  Global entry queue: There exists a single queue which stores &quot;global slash entries&quot;. These entries allow the provider to appropriately handle slash packets sent from any consumer in FIFO ordering. This queue is responsible for coordinating the order that slash packets (from multiple chains) are handled over time.  Per-chain data queue: For each established consumer, there exists a queue which stores &quot;throttled packet data&quot;, i.e.,pending slash packet data is queued together with pending VSC matured packet data in FIFO ordering. Order is enforced by IBC sequence number. These &quot;per-chain&quot; queues are responsible for coordinating the order that slash packets are handled in relation to VSC matured packets from the same chain.  Note: The reason for a multiple-queue design is the VSC Maturity and Slashing Order property (see spec). There are other ways to ensure such a property (like a queue of linked lists, etc.), but the proposed approach seemed to be the most understandable and easiest to implement with a KV store.  ","version":"v6.4.0","tagName":"h3"},{"title":"Params​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#params","content":" SlashMeterReplenishPeriod -- the period after which the slash meter is replenished.  SlashMeterReplenishFraction -- the portion (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs. This param also serves as a maximum fraction of total voting power that the slash meter can hold.  MaxThrottledPackets -- the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value. This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness.  ","version":"v6.4.0","tagName":"h3"},{"title":"Protocol Overview​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#protocol-overview","content":" OnRecvSlashPacket​  Upon the provider receiving a slash packet from any of the established consumers during block execution, two things occur:  A global slash entry is queued.The data of such a packet is added to the per-chain queue.  OnRecvVSCMaturedPacket​  Upon the provider receiving a VSCMatured packet from any of the established consumers during block execution, the VSCMatured packet data is added to the per-chain queue.  Endblocker​  In the EndBlock of the provider CCV module, there are three actions performed:  replenish the slash meter;handle the leading VSCMaturedPackets;and handle the throttle queues.  Slash Meter Replenishment​  Once the slash meter becomes not full, it'll be replenished after SlashMeterReplenishPeriod by incrementing the meter with its allowance for the replenishment block, where allowance = SlashMeterReplenishFraction * currentTotalVotingPower. The slash meter will never exceed its current allowance (function of the total voting power for the block) in value.  Note a few things:  The slash meter can go negative in value, and will do so when handling a single slash packet that jails a validator with significant voting power. In such a scenario, the slash meter may take multiple replenishment periods to once again reach a positive value (or 0), meaning no other slash packets may be handled for multiple replenishment periods.Total voting power of a chain changes over time, especially as validators are jailed. As validators are jailed, total voting power decreases, and so does the jailing allowance. See below for more detailed throttling property discussion.The voting power allowance added to the slash meter during replenishment will always be greater than or equal to 1. If the SlashMeterReplenishFraction is set too low, integer rounding will put this minimum value into effect. That is, if SlashMeterReplenishFraction * currentTotalVotingPower &lt; 1, then the effective allowance would be 1. This min value of allowance ensures that there's some packets handled over time, even if that is a very long time. It's a crude solution to an edge case caused by too small of a replenishment fraction.  The behavior described above is achieved by executing CheckForSlashMeterReplenishment() every EndBlock, BEFORE HandleThrottleQueues() is executed.  Handle Leading VSCMaturedPackets​  In every block, it is possible that VSCMaturedPacket data was queued before any slash packet data. Since this &quot;leading&quot; VSCMatured packet data does not have to be throttled (see VSC Maturity and Slashing Order), we can handle all VSCMatured packet data at the head of the queue, before the any throttling or packet data handling logic executes.  Handle Throttle Queues​  In every EndBlock, the following logic is executed to handle data from the throttle queues.  meter := getSlashMeter() // Keep iterating as long as the meter has a positive (or 0) value, and global slash entries exist while meter.IsPositiveOrZero() &amp;&amp; entriesExist() { // Get next entry in queue entry := getNextGlobalSlashEntry() // Decrement slash meter by the voting power that will be removed from the valset from handling this slash packet valPower := entry.getValPower() meter = meter - valPower // Using the per-chain queue, handle the single slash packet using its queued data, // then handle all trailing VSCMatured packets for this consumer handleSlashPacketAndTrailingVSCMaturedPackets(entry) // Delete entry in global queue, delete handled data entry.Delete() deleteThrottledSlashPacketData() deleteTrailingVSCMaturedPacketData() }   ","version":"v6.4.0","tagName":"h3"},{"title":"System Properties​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#system-properties","content":" All CCV system properties should be maintained by implementing this feature, see CCV spec - Consumer Initiated Slashing.  One implementation-specific property introduced is that if any of the chain-specific packet data queues become larger than MaxThrottledPackets, then the provider binary will panic, and the provider chain will halt. Therefore this param should be set carefully. See SetThrottledPacketDataSize. This behavior ensures that if the provider binaries are queuing up more packet data than machines can handle, the provider chain halts deterministically between validators.  ","version":"v6.4.0","tagName":"h3"},{"title":"Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#main-throttling-property","content":" Using on-chain params and the sub protocol defined, slash packet throttling is implemented such that the following property holds under some conditions.  First, we introduce the following definitions:  A consumer initiated slash attack &quot;starts&quot; when the first slash packet from such an attack is received by the provider.The &quot;initial validator set&quot; for the attack is the validator set that existed on the provider when the attack started.There is a list of honest validators such that if they are jailed, X% of the initial validator set will be jailed.  For the Throttling Property to hold, the following assumptions must be true:  We assume the total voting power of the chain (as a function of delegations) does not increase over the course of the attack.No validator has more than SlashMeterReplenishFraction of total voting power on the provider.SlashMeterReplenishFraction is large enough that SlashMeterReplenishFraction * currentTotalVotingPower &gt; 1, i.e., the replenish fraction is set high enough that we can ignore the effects of rounding.SlashMeterReplenishPeriod is sufficiently longer than the time it takes to produce a block.  Note if these assumptions do not hold, throttling will still slow down the described attack in most cases, just not in a way that can be succinctly described. It's possible that more complex properties can be defined.  Throttling Property: The time it takes to jail/tombstone X% of the initial validator set will be greater than or equal toSlashMeterReplenishPeriod⋅XSlashMeterReplenishFraction−2⋅SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod} \\cdot \\frac{X}{\\mathit{SlashMeterReplenishFraction}} - 2 \\cdot \\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriod⋅SlashMeterReplenishFractionX​−2⋅SlashMeterReplenishPeriod.  Intuition Let's use the following notation: CCC: Number of replenishment cyclesPPP: SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriodFFF: SlashMeterReplenishFraction\\mathit{SlashMeterReplenishFraction}SlashMeterReplenishFractionVmaxV_{\\mathit{max}}Vmax​: Max power of a validator as a fraction of total voting power In CCC number of replenishment cycles, the fraction of total voting power that can be removed, aaa, is a≤F⋅C+Vmaxa \\leq F \\cdot C + V_{\\mathit{max}}a≤F⋅C+Vmax​ (where VmaxV_{\\mathit{max}}Vmax​ is there to account for the power fraction of the last validator removed, one which pushes the meter to the negative value). So, we need at least C≥a−VmaxFC \\geq \\frac{a - V_{\\mathit{max}}}{F}C≥Fa−Vmax​​ cycles to remove aaa fraction of the total voting power. Since we defined the start of the attack to be the moment when the first slash request arrives, then FFF fraction of the initial validator set can be jailed immediately. For the remaining X−FX - FX−F fraction of the initial validator set to be jailed, it takes at least C≥(X−F)−VmaxFC \\geq \\frac{(X - F) - V_{\\mathit{max}}}{F}C≥F(X−F)−Vmax​​ cycles. Using the assumption that Vmax≤FV_{\\mathit{max}} \\leq FVmax​≤F (assumption 2), we get C≥X−2FFC \\geq \\frac{X - 2F}{F}C≥FX−2F​ cycles. In order to execute CCC cycles, we need C⋅PC \\cdot PC⋅P time. Thus, jailing the remaining X−FX - FX−F fraction of the initial validator set corresponds to P⋅(X−2F)F\\frac{P \\cdot (X - 2F)}{F}FP⋅(X−2F)​ time. In other words, the attack must take at least P⋅XF−2P\\frac{P \\cdot X}{F} - 2PFP⋅X​−2P time (in the units of replenish period PPP).  This property is useful because it allows us to reason about the time it takes to jail a certain percentage of the initial provider validator set from consumer initiated slash requests. For example, if SlashMeterReplenishFraction is set to 0.06, then it takes no less than 4 replenishment periods to jail 33% of the initial provider validator set on the Cosmos Hub. Note that as of writing this on 11/29/22, the Cosmos Hub does not have a validator with more than 6% of total voting power.  Note also that 4 replenishment period is a worst case scenario that depends on well crafted attack timings.  ","version":"v6.4.0","tagName":"h3"},{"title":"How Unjailing Affects the Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#how-unjailing-affects-the-main-throttling-property","content":" Note that the jailing allowance is directly proportional to the current total voting power of the provider chain. Therefore, if honest validators don't unjail themselves during the attack, the total voting power of the provider chain will decrease over the course of the attack, and the attack will be slowed down, main throttling property is maintained.  If honest validators do unjail themselves, the total voting power of the provider chain will still not become higher than when the attack started (unless new token delegations happen), therefore the main property is still maintained. Moreover, honest validators unjailing themselves helps prevent the attacking validators from gaining control of the provider.  In summary, the throttling mechanism as designed has desirable properties whether or not honest validators unjail themselves over the course of the attack.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#positive","content":" The described attack is slowed down in seemingly all cases.If certain assumptions hold, the described attack is slowed down in a way that can be precisely time-bounded.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#negative","content":" Throttling introduces a vector for a malicious consumer chain to halt the provider, see issue below. However, this is sacrificing liveness in a edge case scenario for the sake of security. As an improvement, using retries would fully prevent this attack vector.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#neutral","content":" Additional state is introduced to the provider chain.VSCMatured and slash packet data is not always handled in the same block that it is received.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/v6.4.0/adrs/adr-002-throttle#references","content":" Original issue inspiring throttling featureIssue on DOS vectorConsideration of another attack vector ","version":"v6.4.0","tagName":"h2"},{"title":"Throttle with retries","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries","content":"","keywords":"","version":"v6.4.0"},{"title":"ADR 008: Throttle with retries​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#adr-008-throttle-with-retries","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#changelog","content":" 6/9/23: Initial draft6/22/23: added note on consumer pending packets storage optimization7/14/23: Added note on upgrade order  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#context","content":" For context on why the throttling mechanism exists, see ADR 002.  Note the terms slash throttling and jail throttling are synonymous, since in Interchain Security a SlashPacket simply jails a validator for downtime infractions.  Currently the throttling mechanism is designed so that provider logic (slash meter, etc.) dictates how many SlashPackets can be handled over time. Throttled SlashPackets are persisted on the provider, leading to multiple possible issues. Namely:  If SlashPackets or VSCMaturedPackets are actually throttled/queued on the provider, state can grow and potentially lead to a DoS attack. We have short term solutions around this, but overall they come with their own weaknesses. See #594.If a jailing attack described in ADR 002 were actually to be carried out with the current throttling design, we'd likely have to halt the provider, and perform an emergency upgrade and/or migration to clear the queues of SlashPackets that were deemed to be malicious. Alternatively, validators would just have to tough it out and wait for the queues to clear, during which all/most validators would be jailed. Right after being jailed, validators would have to unjail themselves promptly to ensure safety. The coordination required to maintain safety in such a scenario is not ideal.  As a solution, we can improve the throttling mechanism to instead queue/persist relevant data on each consumer, and have consumers retry slash requests as needed.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#decision","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Consumer changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#consumer-changes","content":" Note the consumer already queues up both SlashPackets and VSCMaturedPackets via AppendPendingPacket. Those packets are dequeued in every EndBlock in SendPackets and sent to the provider.  Instead, we will now introduce the following logic on EndBlock:  Slash packets will always be sent to the provider once they're at the head of the queue. However, once sent, the consumer will not send any subsequent VSCMaturedPackets from the queue until the provider responds with an acknowledgement that the sent SlashPacket has been handled, i.e., validator was jailed. That is, SlashPackets block the sending of subsequent VSCMaturedPackets in the consumer queue.If two SlashPackets are at the head of the queue, the consumer will send the first SlashPacket, and then wait for a success acknowledgement from the provider before sending the second SlashPacket. This seems like it'd simplify implementation.VSCMaturedPackets at the head of the queue (i.e., NOT following a SlashPacket) can be sent immediately, and do not block any other packets in the queue, since the provider always handles them immediately.  To prevent the provider from having to keep track of what SlashPackets have been rejected, the consumer will have to retry the sending of SlashPackets over some period of time. This can be achieved with an on-chain consumer param, i.e., RetryDelayPeriod. To reduce the amount of redundant re-sends, we recommend setting RetryDelayPeriod ~ SlashMeterReplenishmentPeriod, i.e., waiting for the provider slash meter to be replenished before resending the rejected SlashPacket.  Note to prevent weird edge case behavior, a retry would not be attempted until either a success or failure acknowledgement has been received from the provider.  With the behavior described, we maintain very similar behavior to the previous throttling mechanism regarding the timing that SlashPackets and VSCMaturedPackets are handled on the provider. Obviously the queueing and blocking logic is moved, and the two chains would have to send more messages between one another (only in the case the throttling mechanism is triggered).  In the normal case, when no or a few SlashPackets are being sent, the VSCMaturedPackets will not be delayed, and hence unbonding will not be delayed.  For the implementation of this design, see throttle_retry.go.  Consumer pending packets storage optimization​  In addition to the mentioned consumer changes, an optimization will need to be made to the consumer's pending packets storage to properly implement the feature from this ADR.  The consumer ccv module previously queued &quot;pending packets&quot; to be sent in each EndBlock in SendPackets. These packets are queued in state with a protobuf list of ConsumerPacketData. For a single append operation, the entire list is deserialized, then a packet is appended to that list, and the list is serialized again. See older version of AppendPendingPacket. That is, a single append operation has O(N) complexity, where N is the size of the list.  This poor append performance isn't a problem when the pending packets list is small. But with this ADR being implemented, the pending packets list could potentially grow to the order of thousands of entries when SlashPackets need to be resent.  We can improve the append time for this queue by converting it from a protobuf-esq list, to a queue implemented with sdk-esq code. The idea is to persist a uint64 index that will be incremented each time you queue up a packet. You can think of this as storing the tail of the queue. Then, packet data will be keyed by that index, making the data naturally ordered byte-wise for sdk's iterator. The index will also be stored in the packet data value bytes, so that the index can later be used to delete certain packets from the queue.  Two things are achieved with this approach:  More efficient packet append/enqueue timesThe ability to delete select packets from the queue (previously all packets were deleted at once)  ","version":"v6.4.0","tagName":"h3"},{"title":"Provider changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#provider-changes","content":" The main change needed for the provider is the removal of queuing logic for SlashPackets and VSCMaturedPackets upon being received.  Instead, the provider will consult the slash meter to determine if a SlashPacket can be handled immediately. If not, the provider will return an acknowledgement message to the consumer communicating that the SlashPacket could not be handled, and needs to be sent again in the future (retried).  VSCMaturedPackets will always be handled immediately upon being received by the provider.  Note spec. Specifically the section on VSC Maturity and Slashing Order. Previously the onus was on the provider to maintain this property via queuing packets and handling them FIFO.  Now this property will be maintained by the consumer sending packets in the correct order, and blocking the sending of VSCMaturedPackets as needed. Then, the ordered IBC channel will ensure that SlashPackets and VSCMaturedPackets are received in the correct order on the provider.  The provider's main responsibility regarding throttling will now be to determine if a received SlashPacket can be handled via slash meter etc., and appropriately acknowledge to the sending consumer.  Handling VSCMaturedPackets immediately​  Why the provider can handle VSCMatured packets immediately​  A VSCMaturedPacket communicates to the provider that sufficient time passed on the consumer since the corresponding VSCPacket has been applied (on the consumer) such that infractions committed on the consumer could have been submitted.  If the consumer is following the queuing/blocking protocol described, then no bad behavior occurs and the VSC Maturity and Slashing Order property is maintained.  If a consumer sends VSCMaturedPackets too leniently -- the consumer is malicious and sends duplicate VSCMaturedPackets, or sends the packets sooner than the CCV protocol specifies -- then the provider needs to handle VSCMaturedPackets immediately to prevent DOS, state bloat, or other issues. The only possible negative outcome is that the malicious consumer may not be able to jail a validator who should have been jailed. The malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  If a consumer blocks the sending of VSCMaturedPackets, then unbonding operations on the provider will be delayed, but only until the VSC timeout period has elapsed. At that time, the consumer is removed. Again the malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  ","version":"v6.4.0","tagName":"h3"},{"title":"Splitting of PRs and Upgrade Order​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#splitting-of-prs-and-upgrade-order","content":" This feature will implement consumer changes in #1024.  ❗These changes should be deployed to production for all consumers before the provider changes are deployed to production.  In other words, the consumer changes in #1024 are compatible with the current (&quot;v1&quot;) provider implementation of throttling that's running on the Cosmos Hub as of July 2023.  Once all consumers have deployed the changes in #1024, the provider changes from #1321 can be deployed to production, fully enabling v2 throttling.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#consequences","content":" Consumers will now have to manage their own queues, and retry logic.Consumers still aren't trustless, but the provider is now less susceptible to mismanaged or malicious consumers.Recovering from the &quot;jailing attack&quot; is more elegant.Some issues like #1001 will now be handled implicitly by the improved throttling mechanism.SlashPackets and VSCMaturedPackets can be handled immediately once received by the provider if the slash meter allows.In general, we reduce the amount of computation that happens in the provider EndBlock.  ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#positive","content":" We no longer have to reason about a &quot;global queue&quot; and a &quot;chain specific queue&quot;, and keeping those all in-sync. Now SlashPackets and VSCMaturedPackets queuing is handled on each consumer individually.Due to the above, the throttling protocol becomes less complex overall.We no longer have to worry about throttle related DoS attack on the provider, since no queuing exists on the provider.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#negative","content":" Increased number of IBC packets being relayed anytime throttling logic is triggered.Consumer complexity increases, since consumers now have manage queuing themselves, and implement packet retry logic.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#neutral","content":" Core throttling logic on the provider remains unchanged, i.e., slash meter, replenishment cycles, etc.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/v6.4.0/adrs/adr-008-throttle-retries#references","content":" EPIC tracking the changes proposed by this ADRADR 002: Jail Throttling#594 ","version":"v6.4.0","tagName":"h2"},{"title":"Soft Opt-Out","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out","content":"","keywords":"","version":"v6.4.0"},{"title":"ADR 009: Soft Opt-Out​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#adr-009-soft-opt-out","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#changelog","content":" 6/13/23: Initial draft of ADR. Feature already implemented and in production.6/19/24: Change status to deprecated  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#status","content":" Deprecated Deprecated by Partial Set Security  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#context","content":" Some small validators may not have the resources needed to validate all consumer chains. Therefore a need exists to allow the bottom x% of validators to opt-out of validating a consumer chain. Meaning downtime infractions for these validators are dropped without ever reaching the provider.  This document specifies a modification to the ccv protocol which allows the bottom x% of the validator set by power to opt out of validating consumer chains without being jailed or otherwise punished for it. The feature is implemented with entirely consumer-side code.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#decision","content":" A consumer param exists, known as SoftOptOutThreshold, which is a string decimal in the range of [0, 0.2], that determines the portion of validators which are allowed to opt out of validating that specific consumer.  In every consumer beginblocker, a function is ran which determines the so called smallest non opt-out voting power. Validators with voting power greater than or equal to this value must validate the consumer chain, while validators below this value may opt out of validating the consumer chain.  The smallest non opt-out voting power is recomputed every beginblocker in UpdateSmallestNonOptOutPower(). In a nutshell, the method obtains the total voting power of the consumer, iterates through the full valset (ordered power ascending) keeping track of a power sum, and when powerSum / totalPower &gt; SoftOptOutThreshold, the SmallestNonOptOutPower is found and persisted.  Then, whenever the Slash() interface is executed on the consumer, if the voting power of the relevant validator being slashed is less than SmallestNonOptOutPower for that block, the slash request is dropped and never sent to the provider.  ","version":"v6.4.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#positive","content":" Small validators can opt out of validating specific consumers without being punished for it.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#negative","content":" The bottom x% is still part of the total voting power of the consumer chain. This means that if the soft opt-out threshold is set to 10% for example, and every validator in the bottom 10% opts out from validating the consumer, then a 24% downtime of the remaining voting power would halt the chain. This may be especially problematic during consumer upgrades.In nominal scenarios, consumers with soft opt out enabled will be constructing slash packets for small vals, which may be dropped. This is wasted computation, but necessary to keep implementation simple. Note that the sdk's full downtime logic is always executed on the consumer, which can be computationally expensive and slow down certain blocks.In a consumer chain, when a validator that has opted out becomes the proposer, there will naturally be no proposal made and validators would need to move to the next consensus round for the same height to reach a decision. As a result, we would need more time to finalize blocks on a consumer chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#neutral","content":" Validators in the bottom of the valset who don't have to validate, may receive large delegation(s) which suddenly boost the validator to the subset that has to validate. This may catch the validator off guard.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/v6.4.0/adrs/adr-009-soft-opt-out#references","content":" Original issue with some napkin math #784 ","version":"v6.4.0","tagName":"h2"},{"title":"Standalone to Consumer Changeover","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover","content":"","keywords":"","version":"v6.4.0"},{"title":"ADR 010: Standalone to Consumer Changeover​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#adr-010-standalone-to-consumer-changeover","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#changelog","content":" 6/30/23: Feature completed, first draft of ADR.  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#status","content":" Implemented  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#context","content":" Stride will be the first consumer to &quot;changeover&quot; from a standalone cosmos blockchain, to a consumer chain secured by the Cosmos Hub. This document outlines the changes made to support this changeover process.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#decision","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Process​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#process","content":" Prior to the changeover, the consumer chain will have an existing staking keeper and validator set, these may be referred to as the &quot;standalone staking keeper&quot; and &quot;standalone validator set&quot; respectively.  The first step in the changeover process is to submit a ConsumerAdditionProposal. If the proposal passes, the provider will create a new IBC client for the consumer at spawn time, with the provider's validator set. A consumer genesis will also be constructed by the provider for validators to query. Within this consumer genesis contains the initial validator set for the consumer to apply after the changeover.  Next, the standalone consumer chain runs an upgrade which adds the CCV module, and is properly setup to execute changeover logic.  The consumer upgrade height must be reached after the provider has created the new IBC client. Any Interchain Security validators who will run the consumer, but are not a part of the sovereign validator set, must sync up a full node before the consumer upgrade height is reached. The disk state of said full node will be used to run the consumer chain after the changeover has completed.  The meat of the changeover logic is that the consumer chain validator set is updated to that which was specified by the provider via the queried consumer genesis. Validators which were a part of the old set, but not the new set, are given zero voting power. Once these validator updates are given to Comet, the set is committed, and in effect 2 blocks later (see FirstConsumerHeight).  A relayer then establishes the new IBC connection between the provider and consumer. The CCV channel handshake is started on top of this connection. Once the CCV channel is established and VSC packets are being relayed, the consumer chain is secured by the provider.  ","version":"v6.4.0","tagName":"h3"},{"title":"Changes to CCV Protocol​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#changes-to-ccv-protocol","content":" Consumer Genesis state is updated to include a PreCCV boolean. When this boolean is set true in the consumer genesis JSON, special logic is executed on InitGenesis to trigger the changeover process on the consumer's first endblocker after the upgrade which adds the CCV module. Note that InitGenesis is not automatically called during chain upgrades, so the consumer must manually call the consumer's InitGenesis method in an upgrade handler.The ConsumerAdditionProposal type is updated to include a DistributionTransmissionChannel field. This field allows the consumer to use an existing IBC transfer channel to send rewards as a part of the CCV protocol. Consumers that're not changing over from a standalone chain will leave this field blank, indicating that a new transfer channel should be created on top of the same connection as the CCV channel.The CCV consumer keeper is updated to contain an optional reference to the standalone staking keeper. The standalone staking keeper is used to slash for infractions that happened before the changeover was completed. Ie. any infraction from a block height before the changeover, that is submitted after the changeover, will call the standalone staking keeper's slash method. Note that a changeover consumer's standalone staking keeper becomes a democracy module keeper, so it is possible for a governance token to be slashed.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#positive","content":" Existing cosmos chains are now able to onboard over to a consumer chain secured by a provider.The previous staking keepers for such chains can be transitioned to democracy staking module keepers.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#negative","content":" The delineation between different types of consumers in this repo becomes less clear. Ie. there is code in the democracy consumer's app.go that only applies to a previously standalone chain, but that file also serves as the base for a normal democracy consumer launched with RS from genesis.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/v6.4.0/adrs/adr-010-standalone-changeover#references","content":" EPIC: Standalone to Consumer Changeover #756Changeover diagram from Stride ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 011: Improving testing and increasing confidence","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#changelog","content":" 2023-08-11: Proposed, first draft of ADR.  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#status","content":" Proposed  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#context","content":" Testing, QA, and maintenance of interchain-security libraries is an ever-evolving area of software engineering we have to keep incrementally improving. The purpose of the QA process is to catch bugs as early as possible. In an ideal development workflow a bug should never reach production. A bug found in the specification stage is a lot cheaper to resolve than a bug discovered in production (or even in testnet). Ideally, all bugs should be found during the CI execution, and we hope that no bugs will ever even reach the testnet (although nothing can replace actual system stress test under load interacting with users).  During development and testnet operation the following types of bugs were the most commonly found:  improper iterator usageunbounded array access/iterationimproper input handling and validationimproper cached context usagenon-determinism check (improper use of maps in go, relying on random values)KV store management and/or how keys are defineddeserialization issues arising from consumer/provider versioning mismatch  Such bugs can be discovered earlier with better tooling. Some of these bugs can induce increases in block times, chain halts, state corruption, or introduce an attack surface which is difficult to remove if other systems have started depending on that behavior.  Current state of testing​  Our testing suites consist of multiple parts, each with their own trade-offs and benefits with regards to code coverage, complexity and confidence they provide.  ","version":"v6.4.0","tagName":"h2"},{"title":"Unit testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#unit-testing","content":" Unit testing is employed mostly for testing single-module functionality. It is the first step in testing and often the most practical. While highly important, unit tests often test a single piece of code and don't test relationships between different moving parts, this makes them less valuable when dealing with multi-module interactions.  Unit tests often employ mocks to abstract parts of the system that are not under test. Mocks are not equivalent to actual models and should not be treated as such.  Out of all the approaches used, unit testing has the most tools available and the coverage can simply be displayed as % of code lines tested. Although this is a very nice and very easy to understand metric, it does not speak about the quality of the test coverage.  Since distributed systems testing is a lot more involved, unit tests are oftentimes not sufficient to cover complex interactions. Unit tests are still necessary and helpful, but in cases where unit tests are not helpful e2e or integration tests should be favored.  ","version":"v6.4.0","tagName":"h3"},{"title":"Integration testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#integration-testing","content":" With integration testing we test the multi-module interactions while isolating them from the remainder of the system. Integration tests can uncover bugs that are often missed by unit tests.  It is very difficult to gauge the actual test coverage imparted by integration tests and the available tooling is limited. In interchain-security we employ the ibc-go/testing framework to test interactions in-memory.  At present, integration testing does not involve the consensus layer - it is only concerned with application level state and logic.  ","version":"v6.4.0","tagName":"h3"},{"title":"End-to-end testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#end-to-end-testing","content":" In our context end-to-end testing comprises of tests that use the actual application binaries in an isolated environment (e.g. docker container). During test execution the inputs are meant to simulate actual user interaction, either by submitting transactions/queries using the command line or using gRPC/REST APIs and checking for state changes after an action has been performed. With this testing strategy we also include the consensus layer in all of our runs. This is the closest we can get to testing user interactions without starting a full testnet.  End-to-end testing strategies vary between different teams and projects and we strive to unify our approach to the best of our ability (at least for ICS and gaia).  The available tooling does not give us significant (or relevant) line of code coverage information since most of the tools are geared towards analyzing unit tests and simple code branch evaluation.  We aim to adapt our best practices by learning from other similar systems and projects such as cosmos-sdk, ibc-go and CometBFT.  ","version":"v6.4.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#decision","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"1. Connect specifications to code and tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#1-connect-specifications-to-code-and-tooling","content":" Oftentimes, specifications are disconnected from the development and QA processes. This gives rise to problems where the specification does not reflect the actual state of the system and vice-versa. Usually specifications are just text files that are rarely used and go unmaintained after a while, resulting in consistency issues and misleading instructions/expectations about system behavior.  Decision context and hypothesis​  Specifications written in a dedicated and executable specification language are easier to maintain than the ones written entirely in text. Additionally, we can create models based on the specification OR make the model equivalent to a specification.  Models do not care about the intricacies of implementation and neither do specifications. Since both models and specifications care about concisely and accurately describing a system (such as a finite state machine), we see a benefit of adding model based tools (such as quint) to our testing and development workflows.  Main benefit​  MBT tooling can be used to generate test traces that can be executed by multiple different testing setups.  ","version":"v6.4.0","tagName":"h3"},{"title":"2. Improve e2e tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#2-improve-e2e-tooling","content":" Matrix tests​  Instead of only running tests against current main branch we should adopt an approach where we also:  run regression tests against different released software versions (ICS v1 vs v2 vs v3)run non-determinism tests to uncover issues quickly  Matrix tests can be implemented using CometMock and refactoring our current e2e CI setup.  Introducing e2e regression testing​  This e2e test suite would execute using a cronjob in our CI (nightly, multiple times a day etc.)  Briefly, the same set of traces is run against different maintained versions of the software and the main branch. This would allow us to discover potential issues during development instead of in a testnet scenarios.  The most valuable issues that can be discovered in this way are state breaking changes, regressions and version incompatibilities.  The setup is illustrated by the image below.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  USES: ICS v1 PROVIDER\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv1 consumer (sdk45,ibc4.3)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v2 consumer (sdk45, ibc4.4)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v3 consumer (sdk47, ibc7)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main consumer\t❌\t❌\t❌\t❌\t❌\t❌\t❌\t❌ neutron\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌ stride\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌  Introducing e2e CometMock tests​  CometMock is a mock implementation of the CometBFT consensus engine. It supports most operations performed by CometBFT while also being lightweight and relatively easy to use.  CometMock tests allow more nuanced control of test scenarios because CometMock can &quot;fool&quot; the blockchain app into thinking that a certain number of blocks had passed.This allows us to test very nuanced scenarios, difficult edge cases and long-running operations (such as unbonding operations).  Examples of tests made easier with CometMock are listed below:  regression testsnon-determinism testsupgrade testsstate-breaking changes  With CometMock, the matrix test approach can also be used. The image below illustrates a CometMock setup that can be used to discover non-deterministic behavior and state-breaking changes.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  SCENARIO\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv3 provi + v3 consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main provi + main consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ commit provi + commit consu\t✅\t❌\t✅\t❌\t✅\t✅\t❌\t❌  Briefly; multiple versions of the application are run against the same CometMock instance and any deviations in app behavior would result in app hash errors (the apps would be in different states after performing the same set of actions).  ","version":"v6.4.0","tagName":"h3"},{"title":"3. Introduce innovative testing approaches​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#3-introduce-innovative-testing-approaches","content":" When discussing e2e testing, some very important patterns emerge - especially if test traces are used instead of ad-hoc tests written by hand.  We see a unique opportunity to clearly identify concerns and modularize the testing architecture.  The e2e testing frameworks can be split into a pipeline consisting of 3 parts: model, driver and harness.  Model​  Model is the part of the system that can emulate the behavior of the system under test. Ideally, it is very close to the specification and is written in a specification language such as quint, TLA+ or similar. One of the purposes of the model is that it can be used to generate test traces.  Driver​  The purpose of the driver is to accept test traces (generated by the model or written by hand), process them and provide inputs to the next part of the pipeline.  Basically, the driver sits between the model and the actual infrastructure on which the test traces are being executed on.  Harness​  Harness is the infrastructure layer of the pipeline that accepts inputs from the driver.  There can be multiple harnesses as long as they can perform four things:  bootstrap a test execution environment (local, docker, k8s…)accept inputs from driversperform the action specified by the driverreport results after performing actions  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#consequences","content":" The procedure outlined in this ADR is not an all-or-nothing approach. Concepts introduced here do not rely on each other, so this ADR may only be applied partially without negative impact on test coverage and code confidence.  ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#positive","content":" introduction of maintainable MBT solutions  improvement over the current &quot;difftest&quot; setup that relies on an opinionated typescript model and go driver  increased code coverage and confidence  using CometMock allows us to run more tests in less timeadding matrix e2e tests allows us to quickly pinpoint differences between code versions  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#negative","content":" It might be easier to forgo the MBT tooling and instead focus on pure property based testing  PBT proof of conceptproperty based testing in go  The solutions are potentially expensive if we increase usage of the CI pipeline - this is fixed by running &quot;expensive&quot; tests using a cronjob, instead of running them on every commit.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#neutral","content":" The process of changing development and testing process is not something that can be thought of and delivered quickly. Luckily, the changes can be rolled out incrementally without impacting existing workflows.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/v6.4.0/adrs/adr-011-improving-test-confidence#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  https://github.com/cosmos/gaia/issues/2427https://github.com/cosmos/gaia/issues/2420ibc-go e2e tests ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 012: Separate Releasing","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#changelog","content":" 0.0202020202020202: Initial draft of idea in #8010.01652892561983471: Put idea in this ADR0.05: Reject this ADR  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#status","content":" Rejected  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#context","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Spike results​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#spike-results","content":" I explored the idea of #801 with this spike branch. Here's my conclusions:  Splitting this repo to have multiple go.mods is possible. However there are various intricacies involved in decoupling the package hierarchy to have x/ccv/types as the lowest level dep, with x/ccv/consumer and x/ccv/provider being one dep layer above, with high-level tests depending on all three of the mentioned packages. I'd estimate this decoupling would take 2-5 workdays to finish, and require significant review effort.  ","version":"v6.4.0","tagName":"h3"},{"title":"Why go.mod split is not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#why-gomod-split-is-not-the-way-to-go","content":" Let's take a step back and remember the issue we're trying to solve - We need a clean way to decouple semver/releasing for the consumer and provider modules. After more consideration, splitting up go.mods gives us little benefit in achieving this. Reasons:  The go.mod dependency system is tied to git tags for the entire repo (ex: require github.com/cometbft/cometbft v0.37.2 refers to a historical tag for the entire cometbft repo).It'd be an odd dev experience to allow modules to reference past releases of other modules in the same repo. When would we ever want the consumer module to reference a past release of the types module for example?If we allow for go.mod replace statements to build from local source code, why split up the package deps at all?Splitting go.mods adds a bunch of complexity with go.work files and all that shiz. VSCode does not play well with multiple module repos either.  ","version":"v6.4.0","tagName":"h3"},{"title":"Why separate repos is cool but also not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#why-separate-repos-is-cool-but-also-not-the-way-to-go","content":" All this considered, the cleanest solution to decoupling semver/releasing for the consumer and provider modules would be to have multiple repos, each with their own go.mod (3-4 repos total including high level tests). With this scheme we could separately tag each repo as changes are merged, they could share some code from types being an external dep, etc.  I don't think any of us want to split up the monorepo, that's a lot of work and seems like bikeshedding. There's another solution that's very simple..  ","version":"v6.4.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#decision","content":" Slightly adapting the current semver ruleset:  A library API breaking change to EITHER the provider or consumer module will result in an increase of the MAJOR version number for BOTH modules (X.y.z-provider AND X.y.z-consumer).A state breaking change (change requiring coordinated upgrade and/or state migration) will result in an increase of the MINOR version number for the AFFECTED module(s) (x.Y.z-provider AND/OR x.Y.z-consumer).Any other changes (including node API breaking changes) will result in an increase of the PATCH version number for the AFFECTED module(s) (x.y.Z-provider AND/OR x.y.Z-consumer).  ","version":"v6.4.0","tagName":"h2"},{"title":"Example release flow​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#example-release-flow","content":" We upgrade main to use a new version of SDK. This is a major version bump, triggering a new release for both the provider and consumer modules, v5.0.0-provider and v5.0.0-consumer.  A state breaking change is merged to main for the provider module. We release only a v5.1.0-provider off main.Another state breaking change is merged to main for the provider module. We release only a v5.2.0-provider off main.At this point, the latest consumer version is still v5.0.0-consumer. We now merge a state breaking change for the consumer module to main, and consequently release v5.1.0-consumer. Note that v5.1.0-consumer is tagged off a LATER commit from main than v5.2.0-provider. This is fine, as the consumer module should not be affected by the provider module's state breaking changes.Once either module sees a library API breaking change, we bump the major version for both modules. For example, we merge a library API breaking change to main for the provider module. We release v6.0.0-provider and v6.0.0-consumer off main. Note that most often, a library API breaking change will affect both modules simultaneously (example being bumping sdk version).  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#positive","content":" Consumer repos have clear communication of what tagged versions are relevant to them. Consumer devs should know to never reference an ICS version that starts with provider, even if it'd technically build.Consumer and provider modules do not deviate as long as we continually release off a shared main branch. Backporting remains relatively unchanged besides being explicit about what module(s) your changes should affect.No code changes, just changes in process. Very simple.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#negative","content":" ~~Slightly more complexity.~~Considerably more complex to manage the ICS library. This is because ICS needs to support multiple versions of SDK (e.g., 0.45, 0.47, 0.50). In addition, ICS needs to support a special fork of SDK (with LSM included) for the Cosmos Hub. This means that instead of focusing on main the development team needs to manage multiple release branches with different dependency trees.This solution does not allow having provider and consumer on separate versions of e.g. the Cosmos SDK.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#neutral","content":" ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/v6.4.0/adrs/adr-012-separate-releasing#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  #801#801 comment ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 014: Epochs","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs#changelog","content":" 2024-01-05: Proposed, first draft of ADR.2024-02-29: Updated so that it describes the implementation where we store the whole consumer validator set.  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs#context","content":" In every block that the provider valset changes, a VSCPacket must be sent to every consumer and a corresponding VSCMaturedPacket sent back. Given that the validator powers may change very often on the provider chain (e.g., the Cosmos Hub), this approach results in a large workload for the relayers. Although the validator powers may change very often, these changes are usually small and have an insignificant impact on the chain's security. In other words, the valset on the consumers can be slightly outdated without affecting security. As a matter of fact, this already happens due to relaying delays.  As a solution, this ADR introduces the concept of epochs. An epoch consists of multiple blocks. The provider sends VSCPackets once per epoch. A VSCPacket contains all the validator updates that are needed by a consumer chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs#decision","content":" The implementation of epochs requires the following changes:  For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. For each validator in the set we store i) its voting power, and ii) the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. The initial consumer validator set for a chain is set during the creation of the consumer genesis.We introduce the BlocksPerEpoch param that sets the number of blocks in an epoch. By default, BlocksPerEpoch is set to be 600 which corresponds to 1 hour, assuming 6 seconds per block. This param can be changed through a governance proposal. In the provider EndBlock we check BlockHeight() % BlocksPerEpoch() == 0to decide when an epoch has ended.At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacket with all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   Note that a validator can change its consumer public key for a specific consumer chain an arbitrary amount of times during a block and during an epoch. Then, when we generate the validator updates in DiffValidators, we have to check whether the current consumer public key (retrieved by calling GetValidatorConsumerPubKey) is different from the consumer public key the validator was using in the current epoch.  ","version":"v6.4.0","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs#positive","content":" Reduce the cost of relaying.Reduce the amount of IBC packets needed for ICS.Simplifies key-assignment code because we only need to check if the consumer_public_key has been modified since the last epoch to generate an update.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs#negative","content":" Increase the delay in the propagation of validator set changes (but for reasonable epoch lengths on the order of ~hours or less, this is unlikely to be significant).  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs#neutral","content":" N/A  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/v6.4.0/adrs/adr-014-epochs#references","content":" EPIC ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 013: Slashing on the provider for consumer equivocation","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#changelog","content":" 1st Sept. 2023: Initial draft  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#context","content":" This ADR presents some approaches on how to slash on the provider chain validators that performed equivocations on consumer chains. Currently, the provider chain can receive and verify evidence of equivocation, but it cannot slash the misbehaving validator.  In the remainder of this section, we explain how slashing is performed on a single chain and show why slashing on the provider for equivocation on the consumer is challenging.  Note that future versions of the Cosmos SDK, CometBFT, and ibc-go could modify the way we slash, etc. Therefore, a future reader of this ADR, should note that when we refer to Cosmos SDK, CometBFT, and ibc-go we specifically refer to their v0.47, v0.37 and v7.3.0 versions respectively.  ","version":"v6.4.0","tagName":"h2"},{"title":"Single-chain slashing​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#single-chain-slashing","content":" Slashing is implemented across the slashingand staking modules. The slashing module's keeper calls the staking module's Slash() method, passing among others, the infractionHeight (i.e., the height when the equivocation occurred), the validator's power at the infraction height, and the slashFactor (currently set to 5% in case of equivocation on the Cosmos Hub).  Slashing undelegations and redelegations​  To slash undelegations, Slash goes through all undelegations and checks whether they started before or after the infraction occurred. If an undelegation started before the infractionHeight, then it is not slashed, otherwise it is slashed by slashFactor.  The slashing of redelegations happens in a similar way, meaning that Slash goes through all redelegations and checks whether the redelegations started before or after the infractionHeight.  Slashing delegations​  Besides undelegations and redelegations, the validator's delegations need to also be slashed. This is performed by deducting the appropriate amount of tokens from the validator. Note that this deduction is computed based on the voting power the misbehaving validator had at the height of the equivocation. As a result of the tokens deduction, the tokens per sharereduce and hence later on, when delegators undelegate or redelegate, the delegators retrieve back less tokens, effectively having their tokens slashed. The rationale behind this slashing mechanism, as mentioned in the Cosmos SDK documentation  [...] is to simplify the accounting around slashing. Rather than iteratively slashing the tokens of every delegation entry, instead the Validators total bonded tokens can be slashed, effectively reducing the value of each issued delegator share.  This approach of slashing delegations does not utilize theinfractionHeight in any way and hence the following scenario could occur:  a validator V performs an equivocation at a height Hia new delegator D delegates to V after height Hievidence of the equivocation by validator V is receivedthe tokens of delegator D are slashed  In the above scenario, delegator D is slashed, even though D's voting power did not contribute to the infraction.  Old evidence​  In the single-chain case, old evidence (e.g., from 3 years ago) is ignored. This is achieved throughCometBFT that ignores old evidence based on the parameters MaxAgeNumBlocks and MaxAgeDuration (see here). Additionally, note that when the evidence is sent by CometBFT to the application, the evidence is rechecked in the evidence module of Cosmos SDK and if it is old, the evidence is ignored. In Cosmos Hub, the MaxAgeNumBlocks is set to 1000000 (i.e., ~70 days if we assume we need ~6 sec per block) and MaxAgeDuration is set to 172800000000000 ns (i.e., 2 days). Because of this check, we can easily exclude old evidence.  ","version":"v6.4.0","tagName":"h3"},{"title":"Slashing for equivocation on the consumer​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#slashing-for-equivocation-on-the-consumer","content":" In the single-chain case, slashing requires both the infractionHeight and the voting power. In order to slash on the provider for an equivocation on a consumer, we need to have both the provider's infractionHeight and voting power. Note that the infractionHeight on the consumer chain must be mapped to a height on the provider chain. Unless we have a way to find the corresponding infractionHeight and power on the provider chain, we cannot slash for equivocation on the consumer in the same way as we would slash in the single-chain case.  The challenge of figuring out the corresponding infractionHeight and power values on the provider chain is due to the following trust assumption:  We trust the consensus layer and validator set of the consumer chains, but we do not trust the application layer.  As a result, we cannot trust anything that stems from the application state of a consumer chain.  Note that when a relayer or a user sends evidence through a MsgSubmitConsumerDoubleVoting message, the provider gets access to DuplicateVoteEvidence:  type DuplicateVoteEvidence struct { VoteA *Vote `json:&quot;vote_a&quot;` VoteB *Vote `json:&quot;vote_b&quot;` // abci specific information TotalVotingPower int64 ValidatorPower int64 Timestamp time.Time }   The &quot;abci specific information&quot; fields cannot be trusted because they are not signed. Therefore, we can use neither ValidatorPower for slashing on the provider chain, nor the Timestamp to check the evidence age. We can get the infractionHeight from the votes, but this infractionHeight corresponds to the infraction height on the consumer and not on the provider chain. Similarly, when a relayer or a user sends evidence through a MsgSubmitConsumerMisbehaviour message, the provider gets access to Misbehaviour that we cannot use to extract the infraction height, power, or the time on the provider chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"Proposed solution​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#proposed-solution","content":" As a first iteration, we propose the following approach. At the moment the provider receives evidence of equivocation on a consumer:  slash all the undelegations and redelegations using slashFactor;slash all delegations using as voting power the sum of the voting power of the misbehaving validator and the power of all the ongoing undelegations and redelegations.  Evidence expiration: Additionally, because we cannot infer the actual time of the evidence (i.e., the timestamp of the evidence cannot be trusted), we do not consider evidence expiration and hence old evidence is never ignored (e.g., the provider would act on 3 year-old evidence of equivocation on a consumer). Additionally, we do not need to store equivocation evidence to avoid slashing a validator more than once, because we do not slash tombstoned validators and we tombstone a validator when slashed.  We do not act on evidence that was signed by a validator consensus key that is pruned when we receive the evidence. We prune a validator's consensus key if the validator has assigned a new consumer key (using MsgAssignConsumerKey) and an unbonding period on the consumer chain has elapsed (see key assignment ADR). Note that the provider chain is informed that the unbonding period has elapsed on the consumer when the provider receives a VSCMaturedPacket and because of this, if the consumer delays the sending of a VSCMaturedPacket, we would delay the pruning of the key as well.  ","version":"v6.4.0","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#implementation","content":" The following logic needs to be added to the HandleConsumerDoubleVoting and HandleConsumerMisbehaviour methods:  undelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetUnbondingDelegationsFromValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // undelegation no longer eligible for slashing, skip it continue } undelegationsInTokens = undelegationsInTokens.Add(entry.InitialBalance) } } redelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetRedelegationsFromSrcValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // redelegation no longer eligible for slashing, skip it continue } redelegationsInTokens = redelegationsInTokens.Add(entry.InitialBalance) } } infractionHeight := 0 undelegationsAndRedelegationsInPower = sdk.TokensToConsensusPower(undelegationsInTokens.Add(redelegationsInTokens)) totalPower := validator's voting power + undelegationsAndRedelegationsInPower slashFraction := k.slashingKeeper.SlashFractionDoubleSign(ctx) k.stakingKeeper.Slash(ctx, validatorConsAddress, infractionHeight, totalPower, slashFraction, DoubleSign)   Infraction height: We provide a zero infractionHeight to the Slash method in order to slash all ongoing undelegations and redelegations (see checks in Slash, SlashUnbondingDelegation, and SlashRedelegation).  Power: We pass the sum of the voting power of the misbehaving validator when the evidence was received (i.e., at evidence height) and the power of all the ongoing undelegations and redelegations. If we assume that the slashFactor is 5%, then the voting power we pass is power + totalPower(undelegations) + totalPower(redelegations). Hence, when the Slash method slashes all the undelegations and redelegations it would end up with 0.05 * power + 0.05 * totalPower(undelegations) + 0.05 * totalPower(redelegations) - 0.05 * totalPower(undelegations) - 0.05 * totalPower(redelegations) = 0.05 * power and hence it would slash 5% of the validator's power when the evidence is received.  ","version":"v6.4.0","tagName":"h3"},{"title":"Positive​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#positive","content":" With the proposed approach we can quickly implement slashing functionality on the provider chain for consumer chain equivocations. This approach does not need to change the staking module and therefore does not change in any way how slashing is performed today for a single chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#negative","content":" We definitely slash more when it comes to undelegations and redelegations because we slash for all of them without considering an infractionHeight.We potentially slash more than what we would have slashed if we knew the voting power at the corresponding infractionHeight in the provider chain.We slash on old evidence of equivocation on a consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/v6.4.0/adrs/adr-013-equivocation-slashing#references","content":" ADR 005: Cryptographic verification of equivocation evidenceEPIC tracking cryptographic equivocation featureCosmos Hub Forum discussion on cryptographic equivocation slashing ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 016: Security aggregation","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#changelog","content":" 2024-04-24: Initial draft of ADR  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#status","content":" Proposed  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#context","content":" Security Aggregation enables staking of tokens from external sources such as Ethereum or Bitcoin to Cosmos blockchains. By integrating Security Aggregation, a Cosmos blockchain can be secured by both native tokens and external tokens (e.g. ETH, BTC).  Security Aggregation consists of the following parts:  A mechanism for delegating external tokens to Cosmos validators, such as Babylon or EigenLayer AVS contract.An oracle that tracks how much external stake has been delegated to each Cosmos validator and provides price feeds for external tokens.Power mixing: a mechanism to combine external and native stake to derive the power of each validator.A reward distribution protocol that enables sending back rewards to the external source.  External staking information is received from an oracle together with price information of related stakes. The CosmosLayer derives validator powers based on external and native staking information and initiates rewarding of external depositors.  This ADR describes the Cosmos modules of the solution.  ","version":"v6.4.0","tagName":"h2"},{"title":"Alternative Approaches​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#alternative-approaches","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Rewards​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#rewards","content":" As an alternative to sending rewards back to the external chains, stakers could be rewarded on the Cosmos chain. This would require a mapping of external addresses to addresses on Cosmos chain for each staker on external source. In addition detailed external staking information such as staking addresses, amount of stakes per staker and validator, etc. have to be provided by the oracle.  ","version":"v6.4.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#decision","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#rewards-will-be-sent-back-to-external-chains-instead-of-paying-rewards-for-external-stakers-on-cosmos-chain","content":" Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain  due to amount of additional staking information to be sent and tracked by the oracledue to the additional complexity of managing external and Cosmos addresses  ","version":"v6.4.0","tagName":"h3"},{"title":"Detailed Design​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#detailed-design","content":" The Power Mixing feature and Reward Distribution protocol are an integral part of the Security Aggregation solution. The Power Mixing module provides the capability of deriving validator power based on stake originated from external sources such as Ethereum/Bitcoin and the native staking module. The Reward Distribution manages the process of sending rewards to external stakers.  ","version":"v6.4.0","tagName":"h2"},{"title":"Power Mixing​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#power-mixing","content":" Power Mixing provides the final validator powers based on staking information of the native chain and the external stakes. The information about external staking and related price feeds are received from an oracle. Once the final validator powers are determined the result is submitted to the underlying CometBFT consensus layer by updating the validator set.  Requirements:  validator updates are performed on each EndBlocka validator's power is determined based on its native on-chain stakes and external stakesprice information of staked tokens is used to determine a validator’s power, e.g. price ratio (price of native on-chain token / price of external stake)price information of native/external tokens are received from an oraclestaking information from external sources received from the oraclenative staking information are received from the Cosmos SDK Staking Moduleset of validator stakes from oracle always have the current price, full set of validators, and current stakes  The Power Mixing implementation  queries current validators and their powers from x/stakingand from oracle (see below).calculates power updates by mixing power values of external and internal sources Following pseudocode snippet shows a possible implementation of how power mixing feature works.  // PowerSource is an abstract entity providing validator powers which // are used by the mixer. This can be an oracle, staking module or an // IBC connected bridge. type PowerSource interface { GetValidatorUpdates() []abci.ValidatorUpdate } // MixPowers calculates power updates by mixing validator powers from different sources func (k *Keeper) MixPowers(source ...PowerSource) []abci.ValidatorUpdate { var valUpdate []abci.ValidatorUpdate for _, ps := range source { // mix powers from two sets of validator updates an return set of validator updates // with aggregated powers valUpdate = mixPower(valUpdate, ps.GetValidatorUpdates()) } return valUpdate } func (k *keeper) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { // GetPowerSources (including local staking module) registeredPowerSource := GetPowerSources() return k.MixPowers(registeredPowerSource...) }   Integration with ICS provider​  The provider module updates the validator set on CometBFT instead of the SDK staking module (x/staking). The provider implementation will intervene in this behavior and ensure that the validator updates are taken from the Power Mixing feature.  External power sources are managed by the provider module. Only registered power sources can provide input to the Power Mixing feature. Power sources will be assigned a unique identifier which will be used by the oracle, provider module and the power mixing and rewarding feature.  Updates with the next validator set are sent to consumer chains on each epoch (see EndBlockVSU()). When collecting the validator updates for each consumer chain (see QueueVSCPackets()), the validator powers of the bonded validators will be updated with the validator powers from the external sources using the Power Mixing module. These updates are sent as part of the VSC packets to all registered consumer chains.  Integration with ICS consumer​  Consumer chains receive validator updates as part of VSC packets from the provider. These packets contain validator powers which were already mixed with external staked powers.  ","version":"v6.4.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#queries","content":" // GetValidatorUpdates returns the power mixed validator results from the provided sources service Query { rpc GetValidatorUpdates(PowerMixedValUpdateRequest) PowerMixedValUpdateResponse {}; } // PowerMixedValUpdateRequest contains the list of power sources on which the // power mixing should be based on message PowerMixedValUpdateRequest { repeated PowerSource sources; } // PowerMixedValUpdateResponse returns the validator set with the updated powers // from the power mixing feature message PowerMixedValUpdateResponse { repeated abci.ValidatorUpdate val_set }   The following queries will be provided by the oracle  service Query { rpc GetExtValidators(GetExtValidatorRequest) returns (ExtValidatorsResponse) { option (google.api.http).get = &quot;oracle/v1/get_validators&quot;; }; } message GetExtValidatorRequest {} // ExtValidatorsResponse is the response from GetExtValidators queries message ExtValidatorsResponse { repeated ExtValPower powers; } // ExtValPower represents a validator with its staking and token information, // where: // `power_source_identifier` is the identifier of the registered power source // `validator_address` is the address of the validator // `stakes` is the total amount of stakes for a validator // `denom` is the source token of the stake e.g. ETH,BTC // `price_ratio` is the ratio of price of the external token to the price of the 'local' token message ExtValPower { string power_source_identifier; string validator_address; uint64 stakes; string denom; float price_ratio; } // GetPrice returns a price feed for a given token service Query { rpc GetPrice(GetPriceRequest) returns (GetPriceResponse) { option (google.api.http).get = &quot;/oracle/v1/get_price&quot;; }; }   For security reasons the amount of external stakes needs to be limited. Limitation of external staking could be driven by governance and is not subject of this version of the ADR.  ","version":"v6.4.0","tagName":"h3"},{"title":"Reward Handler​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#reward-handler","content":" For native staked tokens the Distribution Module of the Cosmos SDK is taking care of sending the rewards to stakers. For stakes originated from external chains (Ethereum/Bitcoin) the Reward Handler module sends rewards to EigenLayer/Babylon. The transfer of rewards is done using a bridge between the Cosmos chain and the external provider chain.  Note: currently there's no support paying rewards on EigenLayer (see here)  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#positive","content":" Allow external depositors to stake their tokens to secure a Cosmos chain  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#negative","content":" Dependency to external sources e.g (price feeds) for validator power calculationSecurity impact  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#neutral","content":" Additional complexity for staking  ","version":"v6.4.0","tagName":"h3"},{"title":"Questions:​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#questions","content":" Slashing: subject of this ADR? (Defined but not activated currently on EigenLayer).  ","version":"v6.4.0","tagName":"h2"},{"title":"References​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/v6.4.0/adrs/adr-016-securityaggregation#references","content":" EigenLayerBabylon ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 018: Remove VSCMatured Packets","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#changelog","content":" 19/06/2024: Create initial draft  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#context","content":" The idea of removing VSCMatured packets was first suggested by Jae Kwon over a conversation in 2022. As a result of that conversation, an ADR was proposed to halt consumer chain if VSC packets are no longer received. The ADR was not accepted due to other considerations regarding the safety of consumer chains. See this blog post for more details.  The consumer module on the consumer chains is a representation of the Hub’s staking module, i.e., it provides an asynchronous view of the voting powers and indirectly of the locked collateral. The key word here is asynchronous, which means that (in theory) there is no bound on the lag between the Hub’s view of stake and the consumer’s view of stake. The reasons for this asynchrony are relaying delays and chain liveness (e.g., a consumer could be down for a long period of time without affecting the liveness of the staking module on the Hub).  The current version of ICS uses VSCMaturedPackets to create on the consumers a partially synchronous view of the Hub’s staking module. Partially synchronous means that the lag between the Hub’s view of stake and the consumer’s view of stake is bounded, because consumers that exceed this lag are forcibly removed from the protocol. Basically, unlocking collateral from the Hub is being delayed until the consumers’ UnbondingPeriod elapses. The reason the view is only partially synchronous is that eventually the collateral is unlocked, i.e., if VSCMaturedPackets are not received from a consumer for VscTimeoutPeriod (default: 5 weeks), then the consumer is removed from ICS and the collateral is unlocked. Note that keeping the stake locked “forever” would affect the Hub’s liveness, so it’s not a viable option.  The issue is that whatever attack is possible with an asynchronous view of the staking module, it is eventually possible with the partially synchronous view as well. For example, an attacker could wait for VscTimeoutPeriod for the collateral to be unlocked and then send invalid headers to third-party chains that are not aware the consumer's collateral is no longer locked on the Hub (i.e., the consumer is no longer part of ICS).  Moreover, with the introduction of PSS, a consumer’s validator set could “lie” about its UnbondingPeriod elapsing by sending VSCMaturedPackets earlier. This would result in a discrepancy between a light client’s view of the UnbondingPeriod and the actual Hub’s UnbondingPeriod.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#decision","content":" This ADR proposes the removal of VSCMaturedPackets. The reason is twofold. First, VSCMaturedPackets provide a &quot;false&quot; sense of correctness as the attack described above is still possible. Second, VSCMaturedPackets add considerable complexity to the ICS protocol -- an extra message plus the pausing of unbonding operations that can affect the UX.  To simplify the upgrading process, removing VSCMaturedPackets can be done in two releases:  (R1) Update the provider to drop VSCMaturedPackets.(R2) Update the consumer to stop sending VSCMaturedPackets.  As a result, once the provider chain runs R1, the consumers can start upgrading to R2.  ","version":"v6.4.0","tagName":"h2"},{"title":"Provider Changes (R1)​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#provider-changes-r1","content":" Parameters​  Deprecate the InitTimeoutPeriod and VscTimeoutPeriod parameters.  State​  Add the following key prefix to the state:  ConsumerAddrsToPruneV2BytePrefix -- the byte prefix for storing consumer validators addresses that need to be pruned. These are stored as ConsumerAddrsToPruneV2BytePrefix | len(chainID) | chainID | ts -&gt; (consumer_address1, consumer_address2, ...) where ts is the timestamp at which the consumer validators addresses can be pruned.  Migrate the consumer validator addresses stored under the ConsumerAddrsToPruneBytePrefix to the new prefix ConsumerAddrsToPruneV2BytePrefix. Note that these consumer validators addresses are stored as  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; (consumer_address1, consumer_address2, ...)   where vscID is the ID of the first VSCPacket sent after these consumer validator addresses were changed. These means that we can use the VscSendTimestamps to compute the timestamps when these consumer validator addresses can be pruned, i.e.,  func MigrateConsumerAddrsToPrune() iterator := sdk.KVStorePrefixIterator(store, []byte{providertypes.ConsumerAddrsToPruneBytePrefix}) for ; iterator.Valid(); iterator.Next() { chainID, vscID, _ := providertypes.ParseChainIdAndUintIdKey(providertypes.ConsumerAddrsToPruneBytePrefix, iterator.Key()) // use the VscSendTimestamp index to compute the timestamp at which this consumer addresses can be pruned vscSendTimestampKey := providertypes.ChainIdAndUintIdKey(providertypes.VscSendTimestampBytePrefix, chainID, vscID) timeBz := store.Get(vscSendTimestampKey) sentTime, _ := sdk.ParseTimeBytes(timeBz) pruneTs := sentTime.Add(sk.UnbondingTime(ctx)) var addrs providertypes.AddressList addrs.Unmarshal(iterator.Value()) for _, addr := range addrs.Addresses { consumerAddr := providertypes.NewConsumerConsAddress(addr) pk.AppendConsumerAddrsToPrune(ctx, chainID, pruneTs, consumerAddr) } } }   Remove the following key prefixes from the state. Note that these removals require state migration.  MaturedUnbondingOpsByteKey -- the byte key that stores the list of all unbonding operations ids that have matured from a consumer chain perspective.UnbondingOpBytePrefix -- the byte prefix that stores a record of all the ids of consumer chains that need to unbond before a given unbonding operation can unbond on this chain.UnbondingOpIndexBytePrefix -- the byte prefix of the index for looking up which unbonding operations are waiting for a given consumer chain to unbond.InitTimeoutTimestampBytePrefix -- the byte prefix for storing the init timeout timestamp for a given consumer chainID.VscSendTimestampBytePrefix -- the byte prefix for storing the list of VSC sending timestamps for a given consumer chainID.ConsumerAddrsToPruneBytePrefix -- the byte prefix for storing the mapping from VSC IDs to consumer validators addresses that need to be pruned.  State Transitions​  Removing VSCMaturedPackets affects three ICS sub-protocols (see HandleVSCMaturedPacket): unbonding operations pausing, VSCPackets timeout, and key assignment pruning. The first two are no longer needed, while the third (key assignment pruning) needs to be redesigned to not depend on VSCMaturedPackets.  Removing unbonding operations pausing:  Make the AfterUnbondingInitiated hook a no-op. As a result, unbonding operations are no longer paused.Stop calling the UnbondingCanComplete method from the staking keeper. This entails, it is no longer necessary to append MaturedUnbondingOps and the completeMaturedUnbondingOps method can be removed.Note, that during the upgrade, all unbonding operations stored under the UnbondingOpBytePrefix prefix need to be completed (via the UnbondingCanComplete method from the staking keeper).Remove the init timeout timestamp logic from the following methods: CreateConsumerClient, SetConsumerChain, and EndBlockCCR.  Removing VSCPackets timeout:  Stop setting VSC send timestamps when sending VSCPackets.Stop removing the VSC send timestamps when receiving VSCMaturedPackets.Remove the logic from EndBlockCCR that checks if the first VSC send timestamp in iterator plus VscTimeoutPeriod exceeds the current block time.  Redesign key assignment pruning. The reason for keeping &quot;old&quot; consumer addresses is to enable slashing / jailing validators that misbehave on consumer chains, i.e., the slashing logic uses the GetProviderAddrFromConsumerAddr method that accesses the mapping from validator addresses on consumer chains to validator addresses on the provider chain (ValidatorsByConsumerAddrBytePrefix). Thus, &quot;old&quot; consumer addresses are no longer needed after the provider's UnbondingPeriod elapses. This means that once a validator changes its key on a consumer, we can prune the address corresponding to the &quot;old&quot; key after UnbondingPeriod. This requires the following changes:  Adapt the AppendConsumerAddrsToPrune() method to use the timestamp at which it is safe to prune the consumer validator address (instead of the current vscID).Add a new method ConsumeConsumerAddrsToPrune(ts) that returns the list of consumer addresses that can be pruned at timestamp ts.Adapt the PruneKeyAssignments() method to call ConsumeConsumerAddrsToPrune(ctx.BlockTime()).Call the PruneKeyAssignments() method from every EndBlock() instead of calling it from HandleVSCMaturedPacket().  Queries​  Remove the oldest_unconfirmed_vsc query.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consumer Changes (R2)​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#consumer-changes-r2","content":" Parameters​  Given that currently relayers use the consumer UnbondingPeriod (see ConsumerParams), this param cannot be deprecated. Note that Hermes queries the UnbondingPeriod for sanity checks and to set the default trusting period when it is not specified. As a result, the UnbondingTime method from the staking interface will continue to be used to retrieve the consumer's UnbondingPeriod.  State​  Remove the following key prefixes from the state:  PacketMaturityTimeBytePrefix -- the byte prefix that will store maturity time for each received VSC packet  Note that these removals require state migration.  State Transitions​  To stop the consumer chains from sending VSCMaturedPackets, it is sufficient to not store the maturity time of VSCPackets when receiving them, i.e., do not call SetPacketMaturityTime from the OnRecvVSCPacket() method. Note that eventually, no additional VSCMaturedPackets will be added to the sending queue as QueueVSCMaturedPackets iterates over elapsed maturity times. In addition, to clean up the code, the QueueVSCMaturedPackets must be removed.  Messages​  VSCMaturedPacketData is deprecated. Note that this is a wire-breaking change -- older consumer versions will send VSCMaturedPackets and older provider versions will expect to receive VSCMaturedPackets.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#positive","content":" Remove feature that provides a &quot;false&quot; sense of correctness.Remove unnecessary complexity, from both ICS and Cosmos SDK.Remove one IBC packet and, thus, reduce relaying cost.Remove unbonding pausing logic that could affect the UX.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#negative","content":" Large refactor that might introduce unexpected bugs.Consumer chains are no longer removed if the duration between creating a client and creating the CCV channel exceeds InitTimeoutPeriod. This means that if the CCV channel is not created on time, the client expires and the consumer chain can no longer start without a ClientUpdate proposal or re-submitting a ConsumerAdditionProposal.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#neutral","content":" Consumer chains are no longer removed after a VscTimeoutPeriod of inactivity. Note that consumers are still removed if their CCV channel expires, which usually happens after two weeks instead of five weeks (the default value for VscTimeoutPeriod).  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/v6.4.0/adrs/adr-018-remove-vscmatured#references","content":" PR #712 -- Proposal to set an expiration date on the consumer chain updated on each VSCPacket received to ensure the chain is up-to-date.Learning to Live with “Unbonding Pausing” blog post. ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 017: ICS with Inactive Provider Validators","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#changelog","content":" 15th May 2024: Initial draft  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#context","content":" Currently, only validators in the active set on the provider can validate on consumer chains, which limits the number of validators that can participate in Interchain Security (ICS). Validators outside of the active set might be willing to validate on consumer chains, but we might not want to make the provider validator set larger, e.g. to not put more strain on the consensus engine. This runs the risk of leaving consumer chains with too few validators.  The purpose of this ADR is to allow validators that are not part of the consensus process on the provider chain (because they are inactive) to validate on consumer chains.  In the context of this ADR, &quot;consensus validator set&quot; is the set of validators participating in the consensus protocol, and &quot;staking validator set&quot; is the set of validators viewed as active by the staking module.  Currently, the staking module, provider module, and CometBFT interact in this way:    The staking module keeps a list of validators. The MaxValidators validators with the largest amount of stake are &quot;active&quot; validators. MaxValidators is a parameter of the staking module. The staking module sends these validators to CometBFT to inform which validators make up the next consensus validators, that is, the set of validators participating in the consensus process. Separately, the provider module reads the list of bonded validators and sends this to the consumer chain, after shaping it according to which validators are opted in and the parameters set by the consumer chain for allowlist, denylist, etc.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#decision","content":" The proposed solution to allow validators that are not participating in the consensus process on the provider (inactive validators) is to change 3 main things:  a) increase the MaxValidators parameter of the staking module  b) do not take the updates for CometBFT directly from the bonded validators in the staking module, by wrapping the staking modules EndBlocker with a dummy EndBlocker that doesn't return any validator updates. Instead, we adjust the provider module to return validator updates on its EndBlocker. These validator updates are obtained by filtering the bonded validators to send only the first MaxProviderConsensusValidators (sorted by largest amount of stake first) many validators to CometBFT  c) use the enlarged list of bonded validators from the staking module as basis for the validator set that the provider module sends to consumer chains (again after applying power shaping and filtering out validators that are not opted in).  In consequence, the provider chain can keep a reasonably-sized consensus validator set, while giving consumer chains a much larger pool of potential validators.    Some additional considerations:  Migration: In the migration, the last consensus validator set will be set to the last active validator set from the view of the staking module. Existing consumer chains are migrated to have a validator set size cap (otherwise, they could end up with a huge validator set including all the staking-but-not-consensus-active validators from the provider chain)Slashing: Validators that are not part of the active set on the provider chain can still be jailed for downtime on a consumer chain (via an Interchain Security SlashPacket sent to the provider, who will then jail the validator), but they are not slashed for downtime on the provider chain. This is achieved without any additional changes to the slashing module, because the slashing module checks for downtime by looking at the consensus participants reported by CometBFT, and thus with the proposed solution, validators that are not part of the consensus validators on the provider chain are not considered for downtime slashing (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/slashing/abci.go#L22).Rewards: Validators that are not part of the active set on the provider chain can still receive rewards on the consumer chain, but they do not receive rewards from the provider chain. This change is achieved without further changes to staking or reward distributions, because similar to downtime, rewards are based on the consensus validator set (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/distribution/abci.go#L28)  ","version":"v6.4.0","tagName":"h2"},{"title":"Changes to the state​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#changes-to-the-state","content":" The following changes to the state are required:  Introduce the MaxProviderConsensusValidators parameter to the provider module, which is the number of validators that the provider module will send to the consensus engine.Store the provider consensus validator set in the provider module state under the LastProviderConsensusValsPrefix key. This is the last set of validators that the provider sent to the consensus engine. This is needed to compute the ValUpdates to send to the consensus engine (by diffing the current set with this last sent set).Increase the MaxValidators parameter of the staking module to the desired size of the potential validator set of consumer chains.Introduce extra per-consumer-chain parameters: MinStake: is the minimum amount of stake a validator must have to be considered for validation on the consumer chain.AllowInactiveVals: is a boolean that determines whether validators that are not part of the active set on the provider chain can validate on the consumer chain. If this is set to true, validators outside the active set on the provider chain can validate on the consumer chain. If this is set to true, validators outside the active set on the provider chain cannot validate on the consumer chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"Risk Mitigations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#risk-mitigations","content":" To mitigate risks from validators with little stake, we introduce a minimum stake requirement for validators to be able to validate on consumer chains, which can be set by each consumer chain independently, with a default value set by the provider chain.  Additional risk mitigations are to increase the active set size slowly, and to monitor the effects on the network closely. For the first iteration, we propose to increase the active set size to 200 validators (while keeping the consensus validators to 180), thus letting the 20 validators with the most stake outside of the active set validate on consumer chains.  ","version":"v6.4.0","tagName":"h2"},{"title":"Testing Scenarios​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#testing-scenarios","content":" In the following,  bonded validators refers to all validators that have bonded stake,active validators refers to the validators that take part in consensus,inactive validators refers to bonded validators that are not active validators.  ","version":"v6.4.0","tagName":"h2"},{"title":"Scenario 1: Inactive validators should not be considered by governance​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#scenario-1-inactive-validators-should-not-be-considered-by-governance","content":" Inactive validators should not be considered for the purpose of governance. In particular, the quorum should depend only on active validators.  We test this by:  creating a provider chain (either with 3 active validators, or with only 1 active validator), a quorum of 50%, and 3 validators with alice=300, bob=299, charlie=299 stakewe create a governance proposalalice votes for the proposalwe check that the proposal has the right status: in the scenario where we have 3 active validators, the proposal should not have passed, because alice alone is not enough to fulfill the quorumin the scenario where we have 1 active validator, the proposal should have passed, because alice is the only active validator, and thus fulfills the quorum  Tested by the e2e tests inactive-provider-validators-governance (scenario with 1 active val) and inactive-provider-validators-governance-basecase (scenario with 3 active vals).  ","version":"v6.4.0","tagName":"h3"},{"title":"Scenario 2: Inactive validators should not get rewards from the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#scenario-2-inactive-validators-should-not-get-rewards-from-the-provider-chain","content":" Inactive validators should not get rewards from the provider chain.  This can be tested by starting a provider chain with inactive validators and checking the rewards of inactive validators.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"Scenario 3: Inactive validators should get rewards from consumer chains​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#scenario-3-inactive-validators-should-get-rewards-from-consumer-chains","content":" An inactive validator that is validating on a consumer chain should receive rewards in the consumer chain token.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"Scenario 4: Inactive validators should not get slashed/jailed for downtime on the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#scenario-4-inactive-validators-should-not-get-slashedjailed-for-downtime-on-the-provider-chain","content":" This can be tested by having an inactive validator go offline on the provider chain for long enough to accrue downtime. The validator should be neither slashed nor jailed for downtime.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"Scenario 5: Inactive validators should get jailed for consumer downtime on the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#scenario-5-inactive-validators-should-get-jailed-for-consumer-downtime-on-the-provider-chain","content":" This can be tested by having an inactive validator go offline on a consumer chain for long enough to accrue downtime. The consumer chain should send a SlashPacket to the provider chain, which should jail the validator.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"Scenario 6: Inactive validators should not be counted when computing the minimum power in the top N​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#scenario-6-inactive-validators-should-not-be-counted-when-computing-the-minimum-power-in-the-top-n","content":" This can be tested like this:  Start a provider chain with validator powers alice=300, bob=200, charlie=100 and 2 max provider consensus validators So alice and bob will validate on the provider Start a consumer chain with top N = 51%. Without inactive validators, this means both alice and bob have to validate. But since charlie is inactive, this means bob is not in the top N Verify that alice is in the top N, but bob is not  Checked as part of the e2e test inactive-vals-topN.  ","version":"v6.4.0","tagName":"h3"},{"title":"Scenario 7: Mint does not consider inactive validators​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#scenario-7-mint-does-not-consider-inactive-validators","content":" To compute the inflation rate, only the active validators should be considered.  We can check this by querying the inflation rate change over subsequent blocks.  We start a provider chain with these arguments  3 validators with powers alice=290, bob=280, charlie=270either 1 or 3 active validatorsa bonded goal of 300 tokens (this is given in percent, but we simplify here)  If we have 3 validators active, then the inflation rate should decrease between blocks, because the bonded goal is exceeded as all validators are bonded. If we have only 1 validator active, then the inflation rate should increase between blocks, because the bonded goal is not met.  Checked as part of the e2e tests inactive-vals-mint (scenario with 1 active val) and mint-basecase (scenario with 3 active vals).  ","version":"v6.4.0","tagName":"h3"},{"title":"Scenarios 8: Inactive validators can validate on consumer chains​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#scenarios-8-inactive-validators-can-validate-on-consumer-chains","content":" An inactive validator can opt in and validate on consumer chains (if min stake allows it)  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"Scenario 9: MinStake parameters is respected​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#scenario-9-minstake-parameters-is-respected","content":" Validators that don't meet the criteria for a consumer chain cannot validate on it.  Checked in the e2e tests min-stake.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#positive","content":" Validators outside of the active set can validate on consumer chains without having an impact on the consensus engine of the provider chainConsumer chains can have a much larger validator set than the provider chain if they prefer this e.g. for decentralization reasonsConsumer chain teams can, with much less cost than today, start up their own consumer chain node to keep the chain running (in a centralized manner) even if no hub validators have opted in to validate on the chain. This is useful to stop the chain from ending up with an empty validator set and becoming recoverable only with a hardfork  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#negative","content":" Allowing validators from the inactive set brings with it some additional risks. In general, consumer chains will now face some of the problems also faced by standalone chains. It’s reasonable to assume that the validator set on the hub has a minimum amount of operational quality due to being battle tested and decentralized, and consumer chains with validators from outside the hub active set cannot rely on this as much anymore.  Sybil attacks​  With the restricted size of the active set today, it’s clear that the set is at least minimally competitive and it is not trivial to spin up multiple nodes as a validator.  When we make the “potential validator set” much larger, we should assume that it becomes much less competitive to be part of that set, and thus trivial for single entities to control many of those validators.  Reputational damage is not a deterrent​  For validators in the active set, we typically assume that if they would misbehave, they pay a large reputational cost. This represents delegators deciding to switch validators (potentially even on chains other than the one the misbehaviour happened on), and loss of credibility in the ecosystem. With the much larger active set, it seems prudent to assume that reputational damage is not a deterrent for many validators. They might only have minimal amounts of delegated stake and control most of it themselves, so they might not be deterred from performing actions that would usually bring reputational damage.  Additional negative consequences​  The provider keeper will need to implement the staking keeper interface, and modules need to be wired up to either the staking or provider keeper, depending on whether they need the consensus or staking validator setThis will impact how future modules are integrated, since we will need to consider whether those modules should consider the consensus validators or the bonded validators (which other modules might assume to be the same)  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#neutral","content":" There might be validators that are bonded, but not validating on any chain at all. This is not a problem, but it might be a bit confusing.  ","version":"v6.4.0","tagName":"h3"},{"title":"Alternative considerations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#alternative-considerations","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Modifying the staking module​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#modifying-the-staking-module","content":" We could instead adapt the staking module with a similar change. This might be better if it turns out that the staking module active set is used in many other places.  ","version":"v6.4.0","tagName":"h3"},{"title":"Allowing unbonding validators to validate​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#allowing-unbonding-validators-to-validate","content":" Instead of increasing the active set size, we could allow validators that are unbonded (but still exist on the provider) to validate consumer chains. For this, we would need to:  Modify the VSC updates to consider the set of all validators, even unbonded ones, instead of just active onesAdjust our downtime jailing/equivocation slashing logic to work correctly with unbonded validators. This is very hard, because redelegations are not usually tracked for unbonded validators.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/v6.4.0/adrs/adr-017-allowing-inactive-validators#references","content":" Security Aggregation has similar concerns where the staking validator set will differ from the consensus validator set ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 015: Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#changelog","content":" 2024-01-22: Proposed, first draft of ADR.  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#context","content":" Currently, in Replicated Security, the entire validator set of the provider chain is used to secure consumer chains. There are at least three concerns with this approach. First, a large number of validators might be forced to validate consumer chains they are not interested in securing. Second, it is costly for small validators to secure additional chains. This concern is only partially addressed through soft opt-out that allows small validators to opt out from validating consumer chains. Third and for the above reasons, it is challenging for a new consumer chain to join Replicated Security.  As a solution, we present Partial Set Security (PSS). As the name suggests, PSS allows for every consumer chain to be secured by only a subset of the provider validator set. In what follows we propose the exact steps we need to take to implement PSS. This is a first iteration of PSS, and therefore we present the most minimal solution that make PSS possible.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#decision","content":" In Replicated Security, all the provider validators have to secure every consumer chain (with the exception of those validators allowed to opt out through the soft opt-out feature).  In PSS, we allow validators to opt in and out of validating any given consumer chain. This has one exception: we introduce a parameter N for each consumer chain and require that the validators in top N% of the provider's voting power have to secure the consumer chain. Validators outside of the top N% can dynamically opt in if they want to validate on the consumer chain.  For example, if a consumer chain has N = 95%, then it ultimately receives the same security it receives today with Replicated Security (with a default SoftOptOutThreshold of 5%). On the other hand, if a consumer chain has N = 0%, then no validator is forced to validate the chain, but validators can opt in to do so instead.  For the remainder of this ADR, we call a consumer chain Top N if it has joined as a Top N chain with N &gt; 0 and Opt In chain otherwise. An Opt In consumer chain is secured only by the validators that have opted in to secure that chain.  We intend to implement PSS using a feature branch off v4.0.0 interchain security.  ","version":"v6.4.0","tagName":"h2"},{"title":"How do consumer chains join?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#how-do-consumer-chains-join","content":" As a simplification and to avoid chain id squatting, a consumer chain can only join PSS through a governance proposal and not in a permissionless way.  However, this proposal type will be modified so that it requires a lower quorum percentage than normal proposal, and every validator who voted &quot;YES&quot; on the proposal will form the consumer chain's initial validator set.  Consumer chains join PSS the same way chains now join Replicated Security, namely through a ConsumerAdditionProposal proposal. We extend ConsumerAdditionProposal with one optional field:  uint32 top_N: Corresponds to the percentage of validators that join under the Top N case. For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators have to validate the proposed consumer chain.top_N can be 0 or include any value in [50, 100]. A chain can join with top_N == 0 as an Opt In, or with top_N ∈ [50, 100] as a Top N chain.  In case of a Top N chain, we restrict the possible values of top_N from (0, 100] to [50, 100]. By having top_N &gt;= 50 we can guarantee that we cannot have a successful attack, assuming that at most 1/3 of provider validators can be malicious. This is because, a Top N chain with N &gt;= 50% would have at least 1/3 honest validators, which is sufficient to stop attacks. Additionally, by having N &gt;= 50% (and hence N &gt; (VetoThreshold = 33.4%)) we enable the top N validators to Veto any ConsumerAdditionProposal for consumer chains they do not want to validate.  If a proposal has the top_N argument wrongly set, it should get rejected in [ValidateBasic] (https://github.com/cosmos/interchain-security/blob/v4.0.0/x/ccv/provider/types/proposal.go#L86).  In the code, we distinguish whether a chain is Top N or Opt In by checking whether top_N is zero or not.  In a future version of PSS, we intend to introduce a ConsumerModificationProposal so that we can modify the parameters of a consumer chain, e.g, a chain that is Opt In to become Top N, etc.  State &amp; Query​  We augment the provider module’s state to keep track of the top_N value for each consumer chain. The key to store this information would be:  topNBytePrefix | len(chainID) | chainID   To create the above key, we can use ChainIdWithLenKey.  Then in the keeper we introduce methods as follows:  func (k Keeper) SetTopN(ctx sdk.Context, chainID string, topN uint32) func (k Keeper) IsTopN(ctx sdk.Context, chainID string) bool func (k Keeper) IsOptIn(ctx sdk.Context, chainID string) bool // returns the N if Top N chain, otherwise an error func (k Keeper) GetTopN(ctx sdk.Context, chainID string) (uint32, error)   We also extend the interchain-security-pd query provider list-consumer-chains query to return information on whether a consumer chain is an Opt In or a Top N chain and with what N. This way, block explorers can present informative messages such as &quot;This chain is secured by N% of the provider chain&quot; for consumer chains.  ","version":"v6.4.0","tagName":"h3"},{"title":"How do validators opt in?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#how-do-validators-opt-in","content":" A validator can opt in by sending a new type of message that we introduce in tx.proto.  message MsgOptIn { // the chain id of the consumer chain to opt in to string chainID = 1; // the provider address of the validator string providerAddr = 2; // (optional) the consensus public key to use on the consumer optional string consumerKey = 3; }   Note that in a Top N consumer chain, the top N% provider validators have to validate the consumer chain. Nevertheless, validators in the bottom (100 - N)% can opt in to validate as well. Provider validators that belong or enter the top N% validators are automatically opted in to validate a Top N consumer chain. This means that if a validator V belongs to the top N% validators but later falls (e.g., due to undelegations) to the bottom (100 - N)%, V is still considered opted in and has to validate unless V sends a MsgOptOut message (see below). By automatically opting in validators when they enter the top N% validators and by forcing top N% validators to explicitly opt out in case they fall to the (100 - N)% bottom validators we simplify the design of PSS.  Note that a validator can send a MsgOptIn message even if the consumer chain is not yet running. To do this we reuse the IsConsumerProposedOrRegistered. If the chainID does not exist, the MsgOptIn should fail, as well as if the provider address does not exist.  Optionally, a validator that opts in can provide a consumerKey so that it assigns a different consumer key (from the provider) to the consumer chain. Naturally, a validator can always change the consumer key on a consumer chain by sending a MsgAssignConsumerKey message at a later point in time, as is done in Replicated Security.  State &amp; Query​  For each validator, we store a pair (blockHeight, isOptedIn) that contains the block height the validator opted in and whether the validator is currently opted in or not, under the key:  optedInBytePrefix | len(chainID) | chainID | addr   By using a prefix iterator on optedInBytePrefix | len(chainID) | chainID we retrieve all the opted in validators.  We introduce the following Keeper methods.  // returns all the validators that have opted in on chain `chainID` func (k Keeper) GetOptedInValidators(ctx sdk.Context, chainID string) []Validators func (k Keeper) IsValidatorOptedIn(ctx sdk.Context, chainID string, val Validator) bool   We introduce the following two queries:  interchain-security-pd query provider optedInValidators $chainID interchain-security-pd query provider hasToValidate $providerAddr   One query to retrieve the validators that are opted in and hence the validators that need to validate the consumer chain and one query that given a validator's address returns all the chains this validator has to validate.  When do validators opt in?​  As described earlier, validators can manually opt in by sending a MsgOptIn message. Additionally, in a Top N chain, a validator is automatically opted in when it moves from the bottom (100 - N)% to the top N% validators.  Lastly, validators can also opt in if they vote Yes during the ConsumerAdditionProposal that introduces a consumer chain. This simplifies validators operations because they do not have to send an additional message to opt in.  Because the Tally method deletes the votes after reading them, we cannot check the votes of the validators after the votes have been tallied. To circumvent this, we introduce a hook for AfterProposalVote and keep track of all the votes cast by a validator. If a validator casts more than one vote, we only consider the latest vote. Finally, we only consider a validator has opted in if it casts a 100% Yes vote in case of a weighted vote.  ","version":"v6.4.0","tagName":"h3"},{"title":"How do validators opt out?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#how-do-validators-opt-out","content":" Validators that have opted in on a chain can opt out by sending the following message:  message MsgOptOut { // the chain id of the consumer chain to opt out from string chainID = 1; // the provider address of the validator string providerAddr = 2; }   Validators can only opt out after a consumer chain has started and hence the above message returns an error if the chain with chainID is not running. Additionally, a validator that belongs to the top N% validators cannot opt out from a Top N chain and hence a MsgOptOut would error in such a case.  State &amp; Query​  We also update the state of the opted-in validators when a validator has opted out by removing the opted-out validator.  Note that only opted-in validators can be punished for downtime on a consumer chain. For this, we use historical info of all the validators that have opted in; We can examine the blockHeight stored under the key optedInBytePrefix | len(chainID) | chainID | addr to see if a validator was opted in. This way we can jail validators for downtime knowing that indeed the validators have opted in at some point in the past. Otherwise, we can think of a scenario where a validator V is down for a period of time, but before V gets punished for downtime, validator V opts out, and then we do not know whether V should be punished or not.  ","version":"v6.4.0","tagName":"h3"},{"title":"When does a consumer chain start?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#when-does-a-consumer-chain-start","content":" A Top N consumer chain always starts at the specified date (spawn_time) if the ConsumerAdditionProposal has passed. An Opt In consumer chain only starts if at least one validator has opted in. We check this in BeginBlockInit:  func (k Keeper) BeginBlockInit(ctx sdk.Context) { propsToExecute := k.GetConsumerAdditionPropsToExecute(ctx) for _, prop := range propsToExecute { chainID := prop.ChainId if !k.IsTopN(ctx, chainID) &amp;&amp; len(k.GetOptedInValidators(ctx, chainID)) == 0 { // drop the proposal ctx.Logger().Info(&quot;could not start chain because no validator has opted in&quot;) continue } ...   ","version":"v6.4.0","tagName":"h3"},{"title":"How do we send the partial validator sets to the consumer chains?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#how-do-we-send-the-partial-validator-sets-to-the-consumer-chains","content":" A consumer chain should only be validated by opted in validators. We introduce logic to do this when we queue the VSCPackets. The logic behind this, is not as straightforward as it seems because CometBFT does not receive the validator set that has to validate a chain, but rather a delta of validator updates. For example, to remove an opted-out validator from a consumer chain, we have to send a validator update with a power of 0, similarly to what is done in the assignment of consumer keys. We intend to update this ADR at a later stage on how exactly we intend to implement this logic.  ","version":"v6.4.0","tagName":"h3"},{"title":"How do we distribute rewards?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#how-do-we-distribute-rewards","content":" Currently, rewards are distributed as follows: The consumer periodically sends rewards on the provider ConsumerRewardsPool address. The provider then transfers those rewards to the fee collector address and those transferred rewards are distributed to validators and delegators.  In PSS, we distribute rewards only to validators that actually validate the consumer chain. To do this, we have a pool associated with each consumer chain and consumers IBC transfer the rewards to this pool. We then extract the rewards from each consumer pool and distribute them to the opted in validators.  Note that we only distribute rewards to validators that have been opted in for some time (e.g., 10000 blocks) to avoid cases where validators opt in just to receive rewards and then opt out immediately afterward.  ","version":"v6.4.0","tagName":"h3"},{"title":"Misbehaviour​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#misbehaviour","content":" Fraud votes​  In an Opt In chain, a set of validators might attempt to perform an attack. To deter such potential attacks, PSS allows for the use of fraud votes. A fraud vote is a governance proposal that enables the slashing of validators that performed an attack. Due to their inherent complexity, we intend to introduce fraud votes in a different ADR and at a future iteration of PSS.  Double signing​  We do not change the way slashing for double signing and light client attacks functions. If a validator misbehaves on a consumer, then we slash that validator on the provider.  Downtime​  We do not change the way downtime jailing functions. If a validator is down on a consumer chain for an adequate amount of time, we jail this validator on the provider but only if the validator was opted in on this consumer chain in the recent past.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#positive","content":" Easier for new consumer chains to consume the provider's chain economic security because proposals are more likely to pass if not everyone is forced to validate. Smaller validators are not forced to validate chains anymore if they do not want to. We can deprecate the soft opt-out implementation.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#negative","content":" A consumer chain does not receive the same economic security as with Replicated Security (assuming the value of SoftOptOutThreshold is 5%), unless it is a Top N chain with N &gt;= 95%.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/v6.4.0/adrs/adr-015-partial-set-security#references","content":" PSS: Permissionless vs premissioned-lite opt-in consumer chainsCHIPs discussion phase: Partial Set Security (updated)PSS: Exclusive vs Inclusive Top-NInitial PSS ADR and notes #1518Replicated vs. Mesh Security ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 020: Customizable Slashing and Jailing","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#changelog","content":" 2024-07-19: Initial draft of ADR2024-08-23: Generalize ADR to make slashing and jailing customizable  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#context","content":" Interchain Security (ICS) is a cross-chain staking protocol -- it uses the stake on the provider chain as collateral for the Proof of Stake (PoS) on the consumer chains. This means that the voting power of validators validating (aka producing blocks) on the consumer chains is a function of their stake on the provider. Moreover, if these validators misbehave on the consumer chains, they get punished on the provider chain. ICS is currently differentiating between two types of infractions -- equivocation and downtime. Depending on the infraction type, the misbehaving validators might be jailed (i.e., removed from the provider validator set) and / or slashed (i.e., a portion of their stake on the provider is being burned). For example, validators double signing on consumer chains get slashed and are permanently jailed, while validators not validating sufficient blocks are temporarily jailed.  This means that ICS consumer chains get their economical security from the provider. However, this might come at a high cost.  ","version":"v6.4.0","tagName":"h2"},{"title":"The Cost of PoS​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#the-cost-of-pos","content":" One of the cost of validating on the consumer chains is operational -- validators need to run and monitor full nodes of every consumer chain they opt in for. Although this cost varies from validator team to validator team (depending on how efficiently they can run their infrastructure), it doesn't depend on the total stake (or voting power) of the validators, so we can think of it as constant. The other cost of validating comes from the risk of getting slashed or jailed.  Most chains in Cosmos (including the Cosmos Hub) use delegated PoS -- users delegate their tokens to validators, which stake them in return for voting power. Therefore, validators act as representatives chosen by their delegators to represent their interests. However, delegators share the risk of their validators getting slashed or jailed:  When validators get slashed, a portion of their stake is being burned, including a portion of the tokens delegated by users. As validators don't need to have their own stake, it is possible that delegators take all the risk of validators misbehaving.When validators get jailed, they no longer receive block rewards (neither from the provider nor from the consumer chains). This also applies to their delegators. As a result, delegators might choose to restake their tokens with another validator. The longer the validators are jailed, the more likely is that delegators will restake. Thus, by getting jailed, validators risk damaging their reputation.  Misbehaviors don't need to be malicious, e.g., most cases of double signing infractions are due to misconfiguration. This means that, by opting in on multiple consumer chains, validators and their delegators incur a higher risk. As a result, validators and their delegators want to be compensated for this additional risk, which makes the current design of ICS expensive.  This ADR addresses the high cost of ICS by allowing consumer chains to customize the slashing and jailing conditions. Basically, every consumer chain can decide the punishment for every type of infraction. This enables consumer chains to tradeoff economical security against cost.  ","version":"v6.4.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#decision","content":" To reduce the cost of ICS, consumer chains will be able to customize the slashing and jailing for every type of infraction. As a result, consumer chains can decide on the amount of economic security they want and validators (and their delegators) can decide on the amount of additional risk they want to incur.  For every consumer chain, we introduce the following slashing and jailing parameters:  message InfractionParameters { SlashJailParameters double_sign = 1; SlashJailParameters downtime = 2; } message SlashJailParameters { bytes slash_fraction = 1 [ (cosmos_proto.scalar) = &quot;cosmos.Dec&quot;, (gogoproto.customtype) = &quot;cosmossdk.io/math.LegacyDec&quot;, (gogoproto.nullable) = false, (amino.dont_omitempty) = true ]; // use time.Unix(253402300799, 0) for permanent jailing google.protobuf.Duration jail_duration = 2; }   Currently, we consider only two infraction types -- double signing and downtime.  By default, every consumer chain will have the following slashing and jailing parameters:  double_sign.slash_fraction: 0.05 // same as on the provider double_sign.jail_duration: time.Unix(253402300799, 0) // permanent jailing, same as on the provider downtime.slash_fraction: 0 // no slashing for downtime on the consumer downtime.jail_duration: 600s // same as on the provider   These parameters can be updated by the consumer chain owner at any given time (via MsgCreateConsumer or MsgUpdateConsumer). However, the changes will come into effect after a period equal to the staking module's unbonding period elapses. This will allow validators that don't agree with the changes to opt out and not be affected by them. Also, to avoid malicious chains attacking the provider validator set, these params will be bounded by the values on the provider chain:  double_sign.slash_fraction &lt;= 0.05 // 5% downtime.slash_fraction &lt;= 0.0001 // 0.1% downtime.jail_duration &lt;= 600s // 10 minutes   Although consumer chains can set any values to these parameters (within the allowed bounds), we recommend the following settings, depending on the type of consumer chain.  Proof-of-Stake (PoS) Consumer Chains. These are chains that have the full economical security of the provider validators that opted in. This means that all slashing and jailing parameters are the same as on the provider. double_sign.slash_fraction: 0.05 double_sign.jail_duration: time.Unix(253402300799, 0) downtime.slash_fraction: 0.0001 downtime.jail_duration: 600s Proof-of-Reputation (PoR) Consumer Chains. double_sign.slash_fraction: 0 // no slashing double_sign.jail_duration: time.Unix(253402300799, 0) downtime.slash_fraction: 0 // no slashing downtime.jail_duration: 600s This means that when validators that opt in misbehave on PoR consumer chains, their stake on the provider is not being slashed, instead they are just jailed on the provider. As a result, delegators incur (almost) no risk if their validators opt in on multiple PoR consumer chains. If their validators are jailed, then the delegators can redelegate to other validators. Note though that delegators cannot redelegate multiple times, which means that if the new validators also get permanently jailed, the delegators need to wait for the unbonding period to elapse. Testnet Consumer Chains. double_sign.slash_fraction: 0 // no slashing double_sign.jail_duration: 0 // no jailing downtime.slash_fraction: 0 // no slashing downtime.jail_duration: 0 // no jailing This means that validators are not punished for infractions on consumer chains. This setting is ideal for testing consumer chains before going in production, as neither validators nor their delegators incur any risk from the validators opting in on these consumer chains.  This means that both PoR and testnet consumer chains need only to cover the operational costs of the validators that opt in. For example, if we take $600 as the cost of running a validator node, a budget of $3000 will be sufficient to cover the cost of four validators running such a consumer chain and have $150 profit per validator as incentive. In practice, this can be implemented via the per-consumer-chain commission rate that allows validators to have different commission rates on different consumer chains.  ","version":"v6.4.0","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#implementation","content":" The implementation of this feature involves the following steps:  Add the InfractionParameters to MsgCreateConsumer.On slashing events (for either downtime or double signing infractions), use the corresponding slash_fraction set by the consumer chain.On jailing events (for either downtime or double signing infractions), use the corresponding jail_duration set by the consumer chain.Cryptographic equivocation evidence received for PoR chains results in the misbehaving validators only being tombstoned and not slashed.(Optional) Add the InfractionParameters to MsgUpdateConsumer, i.e., allow consumer chains to update the slashing and jailing parameters, but the changes will come into effect after a period equal to the staking module's unbonding period elapses to allow for validators to opt out.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#positive","content":" Reduce the cost of ICS by removing the risk of slashing delegators.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#negative","content":" Reduce the economical security of consumer chains with weaker slashing conditions.  Economic Security Model without Slashing​  The economic security model of most Cosmos chains relies on the following properties:  validators are not anonymous, which means that they could be legally liable if they are malicious;the delegated PoS mechanism creates a reputation-based network of validators;most validators have most of their stake coming from delegations (i.e., nothing at stake, besides reputation);it is relatively difficult to enter the active validator set and even more so to climb the voting power ladder.  These properties enable us to make the following assumption:  Being permanently removed from the provider validator set is strong enough of a deterrent to misbehaving on consumer chains.  The additional economical security a consumer gets from slashing is limited: Since most of the stake is delegated, slashing punishes delegators more than validators.  One benefit of slashing is that it acts as a deterrent for someone buying a large amount of staking tokens in order to attack a consumer chain. For example, an attacker could get $15,000,000 worth of ATOM, which would give them around 1% voting power on the Cosmos Hub (at the time of this writing). On a consumer chain, this voting power could be amplified depending on the other validators that opt in. However, by having the right power shaping settings, the voting power of validators can be capped. This means that even if the attacker manages to double sign without getting slashed, as long as they don't have 1/3+ of the voting power, they cannot benefit from the attack. Moreover, the attacker might lose due to other factors, such as token toxicity.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#neutral","content":" NA  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/v6.4.0/adrs/adr-020-cutomizable_slashing_and_jailing#references","content":"","version":"v6.4.0","tagName":"h2"},{"title":"ADR 021: Consumer Chain Clients","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#changelog","content":" 2024-08-14: Initial draft of ADR  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#status","content":" Proposed  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#context","content":" In this document, host chain and remote chain are used in the following context: a light client of a remote chain is in the state of a host chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"IBC Client Updates​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#ibc-client-updates","content":" IBC Client Updates require two pieces of information:  A header (and a validator set) that originates from the consensus engine of the remote chain, i.e., message Header { .tendermint.types.SignedHeader signed_header = 1 .tendermint.types.ValidatorSet validator_set = 2 ibc.core.client.v1.Height trusted_height = 3 .tendermint.types.ValidatorSet trusted_validators = 4 } Note that the header also contain Commit information, i.e., the signatures that got the block committed. The client state, that is initialized when the client is created and then maintained through client updates. Two important fields of the client state are the UnbondingPeriod (i.e., duration of the staking unbonding period) and the TrustingPeriod, which must be smaller than the UnbondingPeriod (see the Tendermint Security Model in the Tendermint Light Client paper). The TrustingPeriod is the duration, since the timestamp of the latest header the client got updated to, during which new headers are accepted for updating the client. The UnbondingPeriod originates from the application of the remote chain (i.e., a staking module param), which means the TrustingPeriod originates from the remote application as well. if HeaderExpired(trustedHeader, trustingPeriod, now) { return ErrOldHeaderExpired{trustedHeader.Time.Add(trustingPeriod), now} } // HeaderExpired return true if the given header expired. func HeaderExpired(h *types.SignedHeader, trustingPeriod time.Duration, now time.Time) bool { expirationTime := h.Time.Add(trustingPeriod) return !expirationTime.After(now) } In other words, a new header received at timestamp ts is rejected if the following inequality holds for any trusted header h: // h is a header of the remote chain // h.T is a timestamp on the remote chain // ts is a timestamp on the host chain h.T + TrustingPeriod &lt;= ts The following figure describes the algorithm used by the host chain to reject headers outside of the TrustingPeriod. Details Intuition behind the trusting period.The trusting period is there to make sure that the validators that signed for the trusted header have their collateral still locked so that in case they misbehave (i.e., light client attack), this collateral can be slashed. Note that the validators that signed the trusted header are responsible for the untrusted header (for both Sequential Verification and Skipping Verification). For more details, see Figure 1 and 3 in the Tendermint Light Client paper:  ","version":"v6.4.0","tagName":"h3"},{"title":"Updating Consumers' IBC Clients​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#updating-consumers-ibc-clients","content":" In the context of ICS, the provider is one of the host chains and the consumers are the remote chains. Note that other third-party chains could be host chains as well.  Consumer chains have their own consensus engine — validators that opt in need to run full nodes of the consumer chains, which consist of both consensus and application layer. This means that consumers produce headers and a relayer could use those headers to update the consumer’s IBC clients on other chains (the provider included). However, consumer chains don’t have their own staking module.  In ICS, the provider is the “staking module” of the consumer chains — validators lock collateral on the provider and as a result can produce blocks on consumer chains. The consumer module on the consumer chains is just a representation of the provider’s staking module, i.e., it provides an asynchronous view of the voting powers and indirectly of the locked collateral. The key word here is asynchronous, which means that (in theory) there is no bound on the lag between the provider’s view of stake and the consumer’s view of stake. The reasons for this asynchrony are relaying delays and chain liveness (e.g., a consumer could be down for a long period of time without affecting the liveness of the staking module on the provider).  The following figure describes the problem of using the same condition (based on the trusting period), i.e.,  // hc is a header of the consumer chain // hc.T is a timestamp on the consumer chain // ts is a timestamp on the host chain hc.T + TrustingPeriod &lt;= ts   to reject consumer headers outside of the TrustingPeriod. The issue is that the time period hc.T and T (the time at which the validator set V was locked on the provider) depends on the consumer chain, i.e., the consumer chain can choose an arbitrary time when to send V to CometBFT. As a result, even if hc.T + TrustingPeriod &gt; ts (i.e., the header is received within the trusting period), if hc.T - T is large enough, then the stake of V could be already unlocked on the provider.    Note that before the removal of VSCMaturedPackets, the consumers had a partially synchronous view of the provider’s staking module. Partially synchronous means that the lag between the provider’s view of stake and the consumer’s view of stake is bounded, because consumers that exceeded this lag were forcibly removed from the protocol. The issue was that whatever attack is possible with an asynchronous view of the staking module, it is eventually possible with the partially synchronous view as well. For more details on this, please check out ADR 018.  This ADR proposes a solution to this synchrony issue -- it uses IBC conditional clients to create a synchronous view of the provider’s staking module.  ","version":"v6.4.0","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#decision","content":" The idea is to extend the IBC light clients for ICS consumer chains to accept a new header received at timestamp ts only if, given any trusted header h, h.ProviderTime + TrustingPeriod &gt; ts, where h.ProviderTime is the timestamp on the provider when h.Valset locked its stake.  The implementation of this feature consists of three parts:  Store h.ProviderTime (the timestamps when the consumer validator sets locked their stake) in the provider state. Note that this state can be pruned once the provider unbonding period elapses.Extend the IBC light client logic on the host chains to reject headers received at timestamp ts if, given any trusted header h,h.ProviderTime + TrustingPeriod &lt;= ts. Note that this logic must existing both on the provider chain and on third party chains (including other consumer chains).For cases when the host chain is different than the provider chain, enable relayers to work with IBC conditional clients.  The remainder of this section is addressing the first part and the second part for the case when the host chain is the provider chain. The second part for the case when the host chain is different than the provider chain and the third part are outside the scope of this ADR.  ","version":"v6.4.0","tagName":"h2"},{"title":"Store Provider Timestamps​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#store-provider-timestamps","content":" Currently, the provider module stores the validator set for every consumer chain. This is done by calling SetConsumerValSet() at the end of every epoch when queueing new VSCPackets. This is the timestamp when the validator set locked its stake (i.e., h.ProviderTime). For consumer chain clients, the provider needs to store these timestamps.  State​  ConsumerValidatorTimestampKey - Stores the latest timestamp when the validator set V of a consumer chain with consumerID locked its stake on the provider chain.  ConsumerValidatorTimestampBytePrefix | len(consumerID) | consumerID | valsetHash -&gt; V.lockTs   where valsetHash is the hash of V. Note that this hash is the same as the one in the headers produced by the consumer chain validated by V. Also, note that V.lockTs is the same as h.ProviderTime above.  The guarantee provided by the provider chain is that the stake of V will be locked until V.lockTs + UnbondingPeriod. This is sufficient information for consumer chain clients to decide whether new headers are outside the trusting period. This guarantee has two consequences. First, it is sufficient to store the latest timestamp: If a consumer chain has the same validator set V over multiple epochs, the only relevant information is the timestamp until when V's stake will be locked on the provider and this can be derived from V.lockTs. Second, this state can be pruned once the unbonding period elapses, i.e., once the provider block time exceeds V.lockTs + UnbondingPeriod.  Query​  To query the timestamps when consumer validator sets are locked on the provider, the following query is introduced:  interchain-security-pd query provider valsetLockTs $consumerID $valsetHash   ","version":"v6.4.0","tagName":"h3"},{"title":"ICS Conditional Clients on the Provider​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#ics-conditional-clients-on-the-provider","content":" If the host chain is different than the provider chain, then it needs to use IBC conditional clients to connect to consumer chains. These conditional clients would need to query the provider chain before they can accept a new header from the consumer chains. In practice, a relayer would send all the information needed (i.e., the new header and the timestamp when the provider locked the stake corresponding to the validator set that signed the trusted header) and the conditional client will verify this information using the existing light client of the provider chain. Note that this is also the case for consumer chains acting as host chain and connecting to other consumer chains.  This section focuses though on the case when the host chain is the provider chain. As the additional information needed is already on the host chain, there is no need for a conditional client. Instead, the provider module needs to act as a &quot;middleware&quot; for all IBC ClientUpdate messages coming from consumer chains and reject headers that were signed by validators outside of the trusting period.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#positive","content":" Improve the security of IBC communication with consumer chains.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#negative","content":" The liveness of consumer chains IBC channels depends on the liveness of the provider. Note though that as long as the provider client on the third-party chain is not expiring, the IBC channels of the consumer chains will remain live.For IBC to work, third-party chains need to have conditional clients of the consumer chains. This includes also other consumer chains.Additional state is needed on the provider chain to store previous consumer validator sets. This state can be pruned once the unbonding period elapses.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#neutral","content":" N/A  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/v6.4.0/adrs/adr-021-consumer-chain-clients#references","content":" ADR 018: Remove VSCMatured PacketsIBC conditional clientsQuerier Approach for Conditional ClientsOriginal conditional client idea in the IBC specs ","version":"v6.4.0","tagName":"h2"},{"title":"ADR 019: Permissionless Interchain Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#changelog","content":" 27th of June, 2024: Initial draft12th of September, 2024: Updated to take into account message changes, etc.  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#status","content":" Accepted  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#context","content":" Currently, a consumer chain can join Interchain Security (ICS) only through a governance proposal. A governance proposal was needed before the introduction of Partial Set Security (PSS) because validators were required to validate a consumer chain. However, after the introduction of PSS, a consumer chain can be either Top N or Opt In. If a chain is an Opt In chain, then no validator is required to validate this chain unless they choose to. Because of this, we can launch an Opt In consumer chain without going through a governance proposal.  This ADR presents Permissionless ICS, a way in which an Opt In consumer chain can join ICS without needing a governance proposal but by simply issuing a transaction.  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#decision","content":" In Permissionless ICS, launching an Opt In chain can be done by issuing a transaction. Naturally, Permissionless ICS does not eliminate governance proposals, as proposals are still necessary for Top N chains. Nevertheless, a Top N chain can transform to an Opt In chain through a gov proposal and vice versa.  ","version":"v6.4.0","tagName":"h2"},{"title":"The Phases of a Consumer Chain​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#the-phases-of-a-consumer-chain","content":" We first present the notion of an owner of a consumer chain before showing the specific phases of a consumer chain.  Owner. A consumer chain has an owner, which is simply an address. Only the owner can interact (i.e., launch, update, or stop) with the chain. The owner of an Opt In chain is the one who signed the initial transaction to register a consumer chain (more on this later). Naturally, an Opt In chain can change its owner at any point. The owner of a Top N chain is the account of the governance module. Therefore, any changes on a Top N chain have to go through governance proposals.  A consumer chain can reside in five phases: i) registered, ii) initialized, iii) launched, iv) stopped, and v) deleted phase as seen in the diagram below:  Registered phase. In the registered phase, a consumer chain has an assigned a unique identifier, that of consumerId (more on this later) that identifies a consumer chain that is used to interact with the chain (e.g., when a validator opts in on a chain, etc.). A chain is created and resides at the registered phase through the use of a MsgCreateConsumer which response contains the consumerId.MsgCreateConsumer is the first step in creating either a Top N or an Opt In consumer chain.  If all the optional initialization parameters are provided in MsgCreateConsumer, then an Opt In chain can immediately move to the initialized phase (see below) and get scheduled to launch. Note, however that a Top N chain needs at least two more MsgUpdateConsumer messages and one gov proposal to be able to launch.  In the registered phase, it is not yet known if the consumer chain would end up being a Top N or an Opt In chain and hence the owner of the consumer chain at this phase is the one that signed the MsgCreateConsumer.  Initialized phase. The initialized phase means that the chain has set all the needed initialization parameters to launch but has not yet launched. If a chain in the registered phase has not yet set the initialization parameters, it can issue a MsgUpdateConsumermessage to set those parameters. Additionally, MsgUpdateConsumer can be used to set up other parameters, such as the power-shaping parameters. If a chain is in the initialized phase and MsgUpdateConsumer is issued with spawn time being zero, the chain moves back to the registered phase.  In order to move a Top N chain to the initialized phase, we need to issue at least two MsgUpdateConsumer messages:  one to change the owner of the chain to be the account of the governance module;another as part of a governance proposal to set the Top N.  Launched phase. In the launched phase the consumer chain is running and is consuming a subset of the validator set of the provider. When the spawnTimepasses and at least one validator has opted inthe chain can launch and moves to the launched phase. Note that a Top N chain can launch if and only if the spawnTime has passed and the proposal with the MsgUpdateConsumer has successfully passed. While in launched phase, a consumer chain can choose to modify its parameters through MsgUpdateConsumer. Naturally, only the owner of the chain can issue MsgUpdateConsumer, thus for Top N chains, the chain can be updated only through a governance proposal that contains a MsgUpdateConsumer. Additionally, note that after the chain moves to the launched phase, the initialization parameters cannot be updated anymore, but general metadata and power-shaping parameters of the chain can still be updated.  Stopped phase. In the stopped phase the consumer chain stops receiving VSCPackets. A chain moves to the stopped phase, when the owner of the chain sends the MsgRemoveConsumer message.  Deleted phase. In the deleted phase the majority of the state in relation to this consumer chain is deleted from the provider. A chain moves to the deleted phase after the chain has been stopped for an unbonding period. We keep track of the state of the consumer chain for an unbonding period, so that we are able to punish validators for misbehaviors that occurred before the consumer chain stopped. Additionally, we do not fully delete the whole state of this chain, so that we can still query parameters a deleted chain used to have. This is useful for front-ends, etc.  Note that everything described so far and everything that follows applies to consumer chains that transition from standalone chains as well.  ","version":"v6.4.0","tagName":"h3"},{"title":"From chainId to consumerId​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#from-chainid-to-consumerid","content":" A hindrance in moving to Permissionless ICS is chain-id squatting. In a permissionless setting, anyone could issue a transaction to launch a consumer chain with a chainId that might already be used by some other consumer chain. This is a problem because in the current design the majority of stored state for a consumer chain is indexed using the chainId as the key (e.g., see key used to store client ids). To tackle this problem, in Permissionless ICS, we introduce the consumerId that defines a consumer chain and is simply an increasing counter (i.e., counter), thus we can support multiple consumer chains with the same chainId. Another way to understand this is with an analogy between consumer chains and IBC clients: Imagine having multiple IBC clients that each point to different consumer chains, but all share the exact same chainId. It is then up to the user to select the appropriate client (i.e., clientId) based on the actual chain they want to communicate with. Similarly, there can be multiple consumer chains with the exact same chainId, and it is the responsibility of the validators to choose the one they wish to interact with by providing the right consumerId.  Note that with Permissionless ICS, all interactions on a consumer chain have to use the consumerId instead of the chainId. For example, if a validator opts in on a chain using MsgOptIn, the validator has to provide the consumerId. Specifically, for the equivocation evidence, we update the MsgSubmitConsumerMisbehaviour and MsgSubmitConsumerDoubleVotingmessages to include the consumerId, and modify Hermesto include consumerId in those constructed messages as well. Hermes can find out the consumerId by querying the provider's clientId for some consumer chain (i.e., query ccvconsumer provider-info) and then asking the provider chain for the consumerId that corresponds to this clientId. To do this, we store the clientId to consumerId association on the provider and introduce a query to retrieve the clientId given the consumerId.  State​  As a result of using consumerId, we have to migrate a substantial chunk of state to re-index it using consumerId as the key. Currently, in ICS we have state that is indexed by a multitude of keys. In the table below, we see the ones that are associated with a chainId and how often state under those keys gets updated. Additionally, for each key, the table shows whose action can lead to the setting or deletion of the state associated with that key. An action can stem either from: i) a consumer chain (e.g., through a MsgUpdateConsumer message, an IBC packet sent over to the provider, etc.), ii) a provider chain (e.g., at the end of a block some action is taken), or by iii) a validator (e.g., through a MsgAssignConsumerKey message) or a combination of them.  Key\tDescription\tWho can set this?\tWho can delete this?\tHow often are chainId-associated keys updated?ChainToChannelBytePrefix\tStores the CCV channelID for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) ChannelToChainBytePrefix\tStores chainId for a specific channel\tconsumer chain\tconsumer chain\tOnly once (during set up) ChainToClientBytePrefix\tStores the clientID for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) PendingCAPBytePrefix\tStores pending consumer addition proposals\tconsumer chain\tprovider chain\tOnly once (for successful proposal) PendingCRPBytePrefix\tStores pending consumer removal proposals\tconsumer chain\tprovider chain\tOnly once (for successful proposal) ConsumerGenesisBytePrefix\tStores the consumer genesis for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) SlashAcksBytePrefix\tStores slash acks for a specific consumer chain\tconsumer chain\tprovider chain\tEvery time we receive a Slash packet PendingVSCsBytePrefix\tStores VSCPackets for a specific consumer chain\tprovider chain\tprovider chain\tEvery epoch ConsumerValidatorsBytePrefix\tStores consumer key per validator per consumer chain\tvalidator\tconsumer chain\tEvery MsgAssignConsumerKey or MsgOptIn ValidatorsByConsumerAddrBytePrefix\tStores consumer to provider validator address\tvalidator\tconsumer or provider chain\tEvery MsgAssignConsumerKey or MsgOptIn EquivocationEvidenceMinHeightBytePrefix\tStores min height for a consumer chain\tconsumer chain\tconsumer chain\tOnly once (during set up) ProposedConsumerChainByteKey\tStores proposalIDs for consumer chains with proposals in the voting period\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tCreated when the proposal is submitted and deleted when the proposal's voting period ends ConsumerValidatorBytePrefix\tStores consumer validators for a specific chain\tvalidator\tvalidator or consumer chain\tPotentially at every epoch OptedInBytePrefix\tStores opted-in validators for a specific chain\tvalidator\tvalidator or consumer chain\tPotentially at every block TopNBytePrefix\tStores whether a consumer chain is Top N or not\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tEvery parameter update ValidatorsPowerCapPrefix\tStores the power cap of a chain\tconsumer chain\tconsumer chain\tEvery parameter update ValidatorSetCapPrefix\tStores the set cap of a chain\tconsumer chain\tconsumer chain\tEvery parameter update AllowlistPrefix\tStores the allowlist of a chain\tconsumer chain\tconsumer chain\tEvery parameter update DenylistPrefix\tStores the denylist of a chain\tconsumer chain\tconsumer chain\tEvery parameter update ConsumerRewardsAllocationBytePrefix\tStores the ICS rewards per chain\tconsumer or provider chain\tprovider chain\tEvery IBC transfer packet that sends rewards to the provider ConsumerCommissionRatePrefix\tCommission rate per chain per validator\tvalidator\tconsumer chain\tEvery MsgSetConsumerCommissionRate message MinimumPowerInTopNBytePrefix\tStores the minimum power needed to opt in for a chain\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tEvery epoch ConsumerAddrsToPruneV2BytePrefix\tStores consumer addresses to be pruned (as part of VSCMaturedPackets deprecation)\tvalidator or provider chain\tprovider chain\tEvery MsgAssignConsumerKey or MsgOptIn and later during actual pruning  Everything stored under one of the above keys is associated with a chainId and has to be migrated to new state under a consumerId.  ","version":"v6.4.0","tagName":"h3"},{"title":"New Messages​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#new-messages","content":" In this section, we describe the new messages (i.e., MsgCreateConsumer, MsgUpdateConsumer, and MsgRemoveConsumer) that Permissionless ICS introduces.  Create a Consumer Chain​  We first have to create a chain before launching it, irrespectively of whether it is Top N or Opt In. This is done through the following message:  message MsgCreateConsumer { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; // Submitter address. If the message is successfully handled, the ownership of // the consumer chain will given to this address. string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the chain id of the new consumer chain string chain_id = 2; ConsumerMetadata metadata = 3 [ (gogoproto.nullable) = false ]; ConsumerInitializationParameters initialization_parameters = 4; PowerShapingParameters power_shaping_parameters = 5; }   Note that metadata is a required field, while the initialization_parameters and power_shaping_parameters are optional and can later be set using MsgUpdateConsumer.  metadata is of the following type:  message ConsumerMetadata { // the name of the chain string name = 1; // the description of the chain string description = 2; // the metadata (e.g., GitHub repository URL) of the chain string metadata = 3; }   initialization_parameters is of the following type and if all are provided the chain is scheduled to launch:  // ConsumerInitializationParameters are the parameters needed to launch a chain message ConsumerInitializationParameters { // ---------- ---------- ---------- // Following fields are used when the consumer chain launches and are not needed by the provider afterwards. // ---------- ---------- ---------- // the proposed initial height of new consumer chain. // For a completely new chain, this will be {0,1}. However, it may be // different if this is a chain that is converting to a consumer chain. ibc.core.client.v1.Height initial_height = 1 [ (gogoproto.nullable) = false ]; // The hash of the consumer chain genesis state without the consumer CCV // module genesis params. It is used for off-chain confirmation of // genesis.json validity by validators and other parties. bytes genesis_hash = 2; // The hash of the consumer chain binary that should be run by validators on // chain initialization. It is used for off-chain confirmation of binary // validity by validators and other parties. bytes binary_hash = 3; // spawn time is the time on the provider chain at which the consumer chain // genesis is finalized and all validators will be responsible for starting // their consumer chain validator node. google.protobuf.Timestamp spawn_time = 4 [ (gogoproto.nullable) = false, (gogoproto.stdtime) = true ]; // Unbonding period for the consumer, // which should be smaller than that of the provider in general. google.protobuf.Duration unbonding_period = 5 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // ---------- ---------- ---------- // Following fields are used to construct the consumer genesis of the to-be-launched consumer chain // and are set up as params on the consumer chain. Those params can then be directly modified by the consumer chain. // ---------- ---------- ---------- // Sent CCV related IBC packets will timeout after this duration google.protobuf.Duration ccv_timeout_period = 6 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // Sent transfer related IBC packets will timeout after this duration google.protobuf.Duration transfer_timeout_period = 7 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // The fraction of tokens allocated to the consumer redistribution address // during distribution events. The fraction is a string representing a // decimal number. For example &quot;0.75&quot; would represent 75%. string consumer_redistribution_fraction = 8; // BlocksPerDistributionTransmission is the number of blocks between // ibc-token-transfers from the consumer chain to the provider chain. On // sending transmission event, `consumer_redistribution_fraction` of the // accumulated tokens are sent to the consumer redistribution address. int64 blocks_per_distribution_transmission = 9; // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. int64 historical_entries = 10; // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer // chain. it is most relevant for chains performing a sovereign to consumer // changeover in order to maintain the existing ibc transfer channel string distribution_transmission_channel = 11; }   power_shaping_parameters is of the following type:  // PowerShapingParameters contains parameters that shape the validator set that we send to the consumer chain message PowerShapingParameters { // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. uint32 top_N = 1; // `validators_power_cap` corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. // For instance, if `validators_power_cap` is set to 32, no validator can have more than 32% of the total voting power of the // consumer chain. The power cap is intended as a safeguard against a validator having too much power on the consumer // chain and hence &quot;taking over&quot; the consumer chain. uint32 validators_power_cap = 2; // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. uint32 validator_set_cap = 3; // corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate the consumer chain repeated string allowlist = 4; // corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain repeated string denylist = 5; // Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain. uint64 min_stake = 6; // Corresponds to whether inactive validators are allowed to validate the consumer chain. bool allow_inactive_vals = 7; }   This MsgCreateConsumerResponse response contains a single string that is the consumerId for this registered consumer chain  Update a Consumer Chain​  We can issue a MsgUpdateConsumer at any point during the registered, initialized, or launched phase of a chain to update parameters of the consumer chain.  The MsgUpdateConsumer message is as follows:  message MsgUpdateConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the address of the owner of the consumer chain to be updated string owner = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to be updated string consumer_id = 2; // the new owner of the consumer when updated string new_owner_address = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the metadata of the consumer when updated ConsumerMetadata metadata = 4; // initialization parameters can only be updated before a chain has launched ConsumerInitializationParameters initialization_parameters = 5; // the power-shaping parameters of the consumer when updated PowerShapingParameters power_shaping_parameters = 6; }   Note that we need to extensively check the fields of the provided ConsumerInitializationParameters to guarantee that no consumer chain launches with problematic parameters.  For all consumer chains, irrespectively of their phase (even in the deleted phase), we keep a mapping between consumerIdand the underlying ConsumerMetadata, ConsumerInitializationParameters and PowerShapingParameters. This way, we can respond to queries that ask for all the consumer chain's parameters. For example, retrieving the spawn_time of consumer chain with a given consumerId.  MsgUpdateConsumer can be executed multiple times for the same Opt In consumer chain during its initialized phase to potentially change its to-be-launched parameters (e.g., spawnTime).  Remove (Stop) a Consumer Chain​  We introduce the MsgRemoveConsumer message so that we can stop any Opt In chain at any point in time. Note that all relevant state for this consumer chain remains on the provider's state before getting removed after the time of an unbonding period (of the provider) has passed. This is to enable potential slashing for any infraction that might have been incurred until now. Note however that we never recycle previously-used consumerIds. Naturally, this message can only be issued by the owner of the consumer chain.  message MsgRemoveConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the consumer id of the consumer chain to be stopped string consumer_id = 1; // the address of the owner of the consumer chain to be stopped string owner = 2 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   Examples of Launching a Consumer Chain​  The figures below depict some examples of some of the phases a consumer chain resides before launching.    ","version":"v6.4.0","tagName":"h3"},{"title":"Additional Modifications​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#additional-modifications","content":" We need to perform multiple migrations. All state needs to be reindexed based on a consumerId instead of the chainId. Because we only have two consumer chains (i.e., Neutron and Stride) at the moment, this is not going to be an expensive migration even if we have some live consumer chains that are being voted upon. Similarly, all the messages, queries, etc. would need to be changed to operate on a consumerId instead of a chainId.  It is important to migrate any live proposals, such as ConsumerAdditionProposals and MsgConsumerAdditions, etc. when we upgrade before we actually deprecate ConsumerAdditionProposals, MsgConsumerAdditions, etc.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#positive","content":" Easier to launch an Opt In consumer chain because no governance is required.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#negative","content":" Extensive migration and overhaul of existing code base (as part of API-breaking changes) that could lead to bugs.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/v6.4.0/adrs/adr-019-permissionless-ics#references","content":" CHIPs Discussion phase: Permissionless ICSChain-id squatting ","version":"v6.4.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/intro","content":"","keywords":"","version":"v6.4.0"},{"title":"Table of Contents​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/adrs/intro#table-of-contents","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Accepted​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/adrs/intro#accepted","content":" ADR 001: Key AssignmentADR 002: Jail ThrottlingADR 004: Denom DOS fixesADR 005: Cryptographic verification of equivocation evidenceADR 008: Throttle with retriesADR 010: Standalone to Consumer ChangeoverADR 013: Slashing on the provider for consumer equivocationADR 014: EpochsADR 015: Partial Set SecurityADR 017: ICS with Inactive Provider ValidatorsADR 018: Remove VSCMatured PacketsADR 019: Permissionless Interchain SecurityADR 020: Customizable Slashing and Jailing  ","version":"v6.4.0","tagName":"h3"},{"title":"Proposed​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/adrs/intro#proposed","content":" ADR 011: Improving testing and increasing confidenceADR 016: Security aggregationADR 021: Consumer Chain ClientsADR 022: Fault Resolutions  ","version":"v6.4.0","tagName":"h3"},{"title":"Rejected​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/adrs/intro#rejected","content":" ADR 007: Pause validator unbonding during equivocation proposalADR 012: Separate Releasing  ","version":"v6.4.0","tagName":"h3"},{"title":"Deprecated​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/adrs/intro#deprecated","content":" ADR 003: Equivocation governance proposalADR 009: Soft Opt-Out ","version":"v6.4.0","tagName":"h3"},{"title":"ADR 022: Fault Resolutions","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions","content":"","keywords":"","version":"v6.4.0"},{"title":"Changelog​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#changelog","content":" 17th July 2024: Initial draft  ","version":"v6.4.0","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#status","content":" Proposed  ","version":"v6.4.0","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#context","content":" Partial Set Security (PSS) allows a subset of a provider chain's validator set to secure a consumer chain. While this shared security scheme has many advantages, it comes with a risk known as thesubset problem. This problem arises when a malicious majority of validators from the provider chain collude and misbehave on a consumer chain. This threat is particularly relevant for Opt-in chains, since they might be secured by a relatively small subset of the provider's validator set.  In cases of collusion, various types of misbehaviour can be performed by the validators, such as:  Incorrect executions to break protocol rules in order to steal funds.Liveness attacks to halt the chain or censor transactions.Oracle attacks to falsify information used by the chain logic.  Currently, these types of attacks aren't handled in PSS, leaving the malicious validators unpunished.  A potential solution for the handling of incorrect executions is to use fraud proofs. This technology allows proving incorrect state transitions of a chain without a full node. However, this is a complex technology and there is no framework that works for Cosmos chains to this day.  To address this risk in PSS, a governance-gated slashing solution can be used to handle all types of misbehavior resulting from validator collusion. As fraud proof technology matures, part of the solution could potentially be automated.  This ADR proposes a fault resolution mechanism, which is a type of governance proposal that can be used to vote on the slashing of validators that misbehave on Opt-in consumer chains (see fault resolutions in &quot;Preventing Intersubjective faults in ICS&quot;).  In what follows, we describe the implementation of a fault resolution mechanism for any intersubjective fault. Note that in the first iteration, it is only incorrect executions that are defined as a fault and are therefore dealt with by the mechanism (see Incorrect Executions in &quot;Preventing Intersubjective faults in ICS&quot;).  ","version":"v6.4.0","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#decision","content":" The proposed solution introduces a new consumer-fault-resolution governance proposal type to the provider module, which allows validators to be penalised for committing faults on an Opt-in consumer chain.  If such a proposal passes, the proposal handler tombstones all the validators listed in the proposal and slashes them by a per-consumer chain predefined amount or the default value used for double-sign infractions.  The proposal has the following fields:  Consumer Chain: The consumer chain ID that the fault was related to.Validators: The list of all the validators to be slashed.Evidence: A free text form.Fault Type: The fault definition type.Description: This field is automatically generated by aggregating the fault definition corresponding to the Fault Type and the Evidence fields.  Each fault type is mapped to a fault definition that precisely describes an intersubjective fault, such as an incorrect execution, and explains why it qualifies as a slashable fault. Refer to the fault definitions section in &quot;Preventing Intersubjective faults in ICS&quot; for more details. Note that the text of each fault definition is stored as a string constant in the provider code.  In addition, to prevent spamming, users must pay a default fee of 100ATOM to submit a fault resolution to the provider. This amount is stored in a new consumer-fault-resolution-fee parameter of the provider module.  ","version":"v6.4.0","tagName":"h2"},{"title":"Validations​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#validations","content":" The submission of a fault resolution succeeds only if all of the following conditions are met:  the consumer chain is an Opt-in chainall listed validators were opted-in to the consumer chain in the past unbonding-periodthe 100ATOM fee is provided  ","version":"v6.4.0","tagName":"h3"},{"title":"States​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#states","content":" Additional states are added to the provider modules:  The timestamps that record when validators opts in or opts out of a Opt-in consumer chain. Note that these timestamps can be pruned after an unbonding period elapses following a validator's opts-out.   ConsumerValidatorSubscriptionTimestampPrefix | len(consumerID) | consumerID | valAddr | ProtocolBuffer(ConsumerValSubscriptionTimestamp)    message { // timestamp recording the last time a validator opted in to the consumer chain google.protobuf.Timestamp join_time = 1; // timestamp recording the last time a validator opted out of the consumer chain google.protobuf.Timestamp leave_time = 2; }   Pre-defined slashing factor per-consumer chain for each defined fault (optional).   ConsumerFaultSlashFactorPrefix | len(consumerID) | consumerID | faultType -&gt; SlashFactor   ","version":"v6.4.0","tagName":"h3"},{"title":"Additional considerations​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#additional-considerations","content":" Fault resolution proposals should be expedited to minimize the time given to the listed validators to unbond to avoid punishment (see Expedited Proposals) .  ","version":"v6.4.0","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#consequences","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#positive","content":" Provide the ability to slash and tombstone validators for committing incorrect executions on Opt-in consumer chains.  ","version":"v6.4.0","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#negative","content":" Assuming that malicious validators unbond immediately after misbehaving, a fault resolution has to be submitted within a maximum of two weeks in order to slash the validators.  ","version":"v6.4.0","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#neutral","content":" Fault definitions need to have a clear framework in order to avoid debates about whether an attack has actually taken place.  ","version":"v6.4.0","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/v6.4.0/adrs/adr-022-fault-resolutions#references","content":" Preventing intersubjective faults in ICS Enabling Opt-in and Mesh Security with Fraud Votes CHIPs discussion phase: Partial Set Security Replicated vs. Mesh Security ","version":"v6.4.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/build/modules/overview","content":"Overview ICS consists of two main modules: x/provider Provides to consumer chains updated information of opted in validators.Distributes ICS rewards to opted in validators.Jails and slashes validators that misbehave on consumer chains. x/consumer Sends to the consensus engine the validator sets received from the provider chain.Splits consumer block rewards and sends ICS rewards to the provider chain.Notifies the provider chain of downtime infractions. Note that x/types contains types shared by both modules. In addition, the following modules are added to ICS to extend its functionality: x/democracy","keywords":"","version":"v6.4.0"},{"title":"Developing an ICS consumer chain","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/consumer-development/app-integration","content":"","keywords":"","version":"v6.4.0"},{"title":"Basic consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v6.4.0/consumer-development/app-integration#basic-consumer-chain","content":" The source code for the example app can be found here.  Please note that consumer chains do not implement the staking module - part of the validator set of the provider is replicated over to the consumer, meaning that the consumer uses a subset of provider validator set and the stake of the validators on the provider determines their stake on the consumer. Note that after the introduction of Partial Set Security, not all the provider validators have to validate a consumer chain (e.g., if top_N != 100).  Your chain should import the consumer module from x/consumer and register it in the correct places in your app.go. The x/consumer module will allow your chain to communicate with the provider using the ICS protocol. The module handles all IBC communication with the provider, and it is a simple drop-in. You should not need to manage or override any code from the x/consumer module.  ","version":"v6.4.0","tagName":"h2"},{"title":"Democracy consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v6.4.0/consumer-development/app-integration#democracy-consumer-chain","content":" The source code for the example app can be found here.  This type of consumer chain wraps the basic CosmosSDK x/distribution, x/staking and x/governance modules allowing the consumer chain to perform democratic actions such as participating and voting within the chain's governance system.  This allows the consumer chain to leverage those modules while also using the x/consumer module.  With these modules enabled, the consumer chain can mint its own governance tokens, which can then be delegated to prominent community members which are referred to as &quot;representatives&quot; (as opposed to &quot;validators&quot; in standalone chains). The token may have different use cases besides just voting on governance proposals.  ","version":"v6.4.0","tagName":"h2"},{"title":"Standalone chain to consumer chain changeover​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/v6.4.0/consumer-development/app-integration#standalone-chain-to-consumer-chain-changeover","content":" See the standalone chain to consumer chain changeover guide for more information on how to transition your standalone chain to a consumer chain. ","version":"v6.4.0","tagName":"h2"},{"title":"Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/consumer-development/changeover-procedure","content":"","keywords":"","version":"v6.4.0"},{"title":"Consumers on ICS Version v6.4.0+​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.4.0/consumer-development/changeover-procedure#consumers-on-ics-version-v640","content":" For chains that are using ICS v6.4.0 or newer, the standalone to consumer changeover consists of the following steps.  ","version":"v6.4.0","tagName":"h2"},{"title":"1. Create a new consumer chain on the provider​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.4.0/consumer-development/changeover-procedure#1-create-a-new-consumer-chain-on-the-provider","content":" Submit a MsgCreateConsumer message to the provider chain. This is a &quot;normal&quot; MsgCreateConsumer message as described in the onboarding checklist, but with the following important notes.  chain_id MUST be equal to the standalone chain id. The consumer initialization parameters (i.e., initialization_parameters) must be adapted for the changeover procedure: initial_height is not used as the provider uses an existing client of the standalone chain..spawn_time is the time on the provider when the consumer module genesis state is being generated, which means that at this time the provide creates the initial validator set that will validate the standalone chain once it becomes a consumer chain. Consequently, spawn_time MUST occur before the standalone chain is upgraded and the consumer module is added as the upgrade requires the consumer module genesis state.unbonding_period MUST correspond to the value used on the standalone chain.distribution_transmission_channel SHOULD be set to the canonical IBC token transfer channel between the provider and the standalone chain. This will preserve the ibc denom that may already be in use.connection_id MUST be set to the ID of the connection end on the provider chain on top of which the canonical IBC token transfer channel was created.  ","version":"v6.4.0","tagName":"h3"},{"title":"2. Add consumer module to standalone chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.4.0/consumer-development/changeover-procedure#2-add-consumer-module-to-standalone-chain","content":" The standalone chain MUST go through an upgrade to include the x/ccv/consumer module. Note that adding the x/ccv/consumer module requires the consumer module genesis state which is created by the provider at spawn_time. Consequently, the spawn_time MUST occur before this upgrade.  Note that the consumer module genesis state can be obtained from the provider using the consumer genesis query, i.e.,  interchain-security-pd query provider consumer-genesis [consumer-id] [flags]   The consumer genesis state must be exported to a file and placed in the correct folder on the standalone chain before the upgrade. The file must be placed at the exact specified location, otherwise the upgrade will not be executed correctly. Usually the file is placed in $NODE_HOME/config, but the file name and the exact directory is dictated by the upgrade code on the standalone chain.  After the consumer_genesis.json file has been made available, the process is equivalent to a normal on-chain upgrade. The standalone validator set will sign the next couple of blocks before transferring control to the initial ICS validator set.  Once upgraded, the x/ccv/consumer module will act as the &quot;staking module&quot; for the consumer chain, i.e., it will provide the validator set to the consensus engine. For staking a native token (e.g., for governance), the x/ccv/democracy/staking module allows the cosmos-sdk x/staking module to be used alongside the x/ccv/consumer module. For more details, check out the democracy modules.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consumers on ICS Version < v6.4.0​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.4.0/consumer-development/changeover-procedure#consumers-on-ics-version--v640","content":" Chains that are using older version of ICS (i.e., &lt; v6.4.0), must &quot;force&quot; the provider to create a new client of the standalone chain (on top of which the CCV channel will be created). This is because older versions of the consumer module expects both a client state and a consensus state in order to create a new provider client. Therefore, when creating a new consumer chain on the provider, the following changes are necessary in the consumer initialization parameters:  connection_id MUST be set to an empty string (i.e., &quot;&quot;). As a result, the provider will create a new client of the consumer chain and a new connection on top of it.initial_height will be used by the provider when creating the new consumer client, so it MUST be set according to the following rules: &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. stride-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_height&quot;: 101, },   ","version":"v6.4.0","tagName":"h2"},{"title":"Adapt the consumer module genesis state​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/v6.4.0/consumer-development/changeover-procedure#adapt-the-consumer-module-genesis-state","content":" Before the upgrade of the standalone chain (i.e., adding the x/ccv/consumer module), the consumer module genesis state created by the provider at spawn_time must be adapted to older versions of the consumer module. This consists of two changes.  First, by setting connection_id in the consumer initialization parameters to an empty string, the provider will set the preCCV flag in the ConsumerGenesisState struct to false. This must be changed to true in order to trigger the changeover procedure logic on the x/ccv/consumer module.  Second, the connection_id field of ConsumerGenesisState must be removed to enable older versions of the consumer module to unmarshal the consumer module genesis state obtained from the provider. This can be done using the interchain-security-cd genesis transform CLI command. ","version":"v6.4.0","tagName":"h3"},{"title":"x/ccv/consumer","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/build/modules/consumer","content":"","keywords":"","version":"v6.4.0"},{"title":"Overview​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#overview","content":" The ICS consumer module enables consumer chains to use stake locked on a provider chain as collateral for their own proof-of-stake based block production.  The consumer module established a IBC ordered channel to the provider chain. This channel is used by the provider chain to regularly send validator updates to the consumer chain. The consumer sends these updates to its own consensus engine. This means that the consumer module acts as a staking module of the consumer chain.  Regularly, the consumer module sends a part of the consumer chain's block rewards to the provider chain as ICS rewards.  If one of the validators in the consumer chain's validator set is missing enough blocks (i.e., downtime infraction), the consumer module notifies the provider chain by sending an IBC packet to the provider module. As a result, the misbehaving validator is punished on the provider chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"State​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#state","content":" For clarity, the description of the consumer module state is split into features. For a more accurate description, check out the x/ccv/consumer/types/keys.go file, which contains the definitions of all the keys.  ","version":"v6.4.0","tagName":"h2"},{"title":"Provider Connection​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#provider-connection","content":" ProviderClientID​  ProviderClientID is the ID of the provider client on which the CCV channel is built.  Format: byte(3) -&gt; string  ProviderChannelID​  ProviderChannelID is the ID of the CCV channel.  Format: byte(4) -&gt; string  ","version":"v6.4.0","tagName":"h3"},{"title":"Changeover​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#changeover","content":" PreCCV​  PreCCV is the flag set when the consumer chain is in the process of a standalone to consumer chain changeover.  Format: byte(7) -&gt; uint64  InitialValSet​  InitialValSet is the initial validator set on the consumer chain.  Format: byte(8) -&gt; GenesisState  Note that only the InitialValSet field of the ProviderInfo field of GenesisState is set, i.e.,  message GenesisState { ... ProviderInfo provider = 14 [ (gogoproto.nullable) = false ]; } message ProviderInfo { // InitialValset filled in on new chain and on restart. repeated .tendermint.abci.ValidatorUpdate initial_val_set = 3 [ (gogoproto.nullable) = false ]; }   InitGenesisHeight​  InitGenesisHeight is the height when the consumer module was initialized (i.e., the InitGenesis method was called).  Format: byte(17) -&gt; uint64  PrevStandaloneChain​  PrevStandaloneChain is the flag set when the consumer chain was previously a standalone chain.  Format: byte(19) -&gt; []byte{}  ","version":"v6.4.0","tagName":"h3"},{"title":"Validator Updates​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#validator-updates","content":" PendingChanges​  PendingChanges are the validator updates received from the provider that were not yet sent to the consensus engine.  Format: byte(5) -&gt; ValidatorSetChangePacketData  Note that only the ValidatorUpdates field of ValidatorSetChangePacketData is set.  CrossChainValidator​  CrossChainValidator is the internal state of a consumer validator with consensus address addr.  Format: byte(16) | addr -&gt; CrossChainValidator, where CrossChainValidator is defined as  message CrossChainValidator { bytes address = 1; int64 power = 2; // pubkey is the consensus public key of the validator, as a Protobuf Any. google.protobuf.Any pubkey = 3 [ (cosmos_proto.accepts_interface) = &quot;cosmos.crypto.PubKey&quot;, (gogoproto.moretags) = &quot;yaml:\\&quot;consensus_pubkey\\&quot;&quot; ]; // deprecated bool opted_out = 4 [deprecated = true]; }   HistoricalInfo​  HistoricalInfo is the header and validator information for a given block. For more details, see the Cosmos SDK docs.  Format: byte(11) | height -&gt; HistoricalInfo, where HistoricalInfo is defined in the staking module as  message HistoricalInfo { tendermint.types.Header header = 1 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true]; repeated Validator valset = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true]; }   ","version":"v6.4.0","tagName":"h3"},{"title":"Reward Distribution​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#reward-distribution","content":" LastDistributionTransmission​  LastDistributionTransmission is the block height of the last attempt to send ICS rewards to the provider module.  Format: byte(1) -&gt; LastTransmissionBlockHeight, where LastTransmissionBlockHeight is defined as  message LastTransmissionBlockHeight { int64 height = 1; }   ","version":"v6.4.0","tagName":"h3"},{"title":"Downtime Infractions​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#downtime-infractions","content":" OutstandingDowntime​  OutstandingDowntime is the flag set when a SlashPacket is queued to be sent to the provider for a downtime infraction of a validator with consensus address addr. The flag is unset when receiving from the provider a VSCPacket with a slash acknowledgement (see SlashAcks in ValidatorSetChangePacketData).  Format: byte(14) | addr -&gt; []byte{}  HeightValsetUpdateID​  HeightValsetUpdateID is the validator set update ID associated with a block height.  Format: byte(13) | height -&gt; uint64  PendingPacketsIndex​  PendingPacketsIndex is the next index available to store packet data to be sent to the provider chain (see below).  Format: byte(20) -&gt; uint64  PendingDataPacketsV1​  PendingDataPacketsV1 is the queue of packet data to be sent to the provider chain. In general, packets in this queue will be sent to the provider in the end blocker, unless  the CCV channel is not yet established;the provider client is expired;the last slash packet sent was not yet acknowledged by the provider chain.  Format: byte(15) | index -&gt; ConsumerPacketData, where index is the index of the packet in the queue and ConsumerPacketData is defined as  message ConsumerPacketData { ConsumerPacketDataType type = 1; oneof data { SlashPacketData slashPacketData = 2; VSCMaturedPacketData vscMaturedPacketData = 3; } }   SlashRecord​  SlashRecord is the record storing the state of a SlashPacket sent to the provider chain that was not yet acknowledged. See ADR 008 for more details.  Format: byte(21) -&gt; SlashRecord, where SlashRecord is defined as  message SlashRecord { bool waiting_on_reply = 1; google.protobuf.Timestamp send_time = 2 [ (gogoproto.stdtime) = true, (gogoproto.nullable) = false ]; }   ","version":"v6.4.0","tagName":"h3"},{"title":"State Transitions​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#state-transitions","content":" TBA  ","version":"v6.4.0","tagName":"h2"},{"title":"IBC Callbacks​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#ibc-callbacks","content":" The consumer module is an IBC application that implements the IBC module callback.  ","version":"v6.4.0","tagName":"h2"},{"title":"OnChanOpenInit​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#onchanopeninit","content":" OnChanOpenInit first verifies that the CCV channel was not already created. Then, it validates the channel parameters -- an ordered IBC channel connected on the consumer port and with the counterparty port set to provider -- and asserts that the version matches the expected version (only version 1 is supported).  Finally, it verifies that the underlying client is the expected client of the provider chain (i.e., provided in the consumer module genesis state).  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanOpenTry​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#onchanopentry","content":" OnChanOpenTry returns an error. MsgChannelOpenTry should be sent to the provider.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanOpenAck​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#onchanopenack","content":" OnChanOpenAck first verifies that the CCV channel was not already created. Then it verifies that the counterparty version matches the expected version (only version 1 is supported).  If the verification passes, it stores the ProviderFeePoolAddr in the state.  Finally, if the DistributionTransmissionChannel parameter is not set, it initiates the opening handshake for a token transfer channel over the same connection as the CCV channel by calling the ChannelOpenInit method of the IBC module.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanOpenConfirm​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#onchanopenconfirm","content":" OnChanOpenConfirm returns an error. MsgChanOpenConfirm should be sent to the provider.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanCloseInit​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#onchancloseinit","content":" OnChanCloseInit allows relayers to close duplicate OPEN channels, if the channel handshake is completed.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanCloseConfirm​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#onchancloseconfirm","content":" OnChanCloseConfirm is a no-op.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnRecvPacket​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#onrecvpacket","content":" OnRecvPacket unmarshals the IBC packet data into a ValidatorSetChangePacketData struct (see below) and executes the handling logic.  If it is the first packet received, sets the underlying IBC channel as the canonical CCV channel.Collects validator updates to be sent to the consensus engine at the end of the block.Store in state the block height to VSC id (i.e., valset_update_id) mapping.Removed the outstanding downtime flags from the validator for which the jailing for downtime infractions was acknowledged by the provider chain (see the slash_acks field in ValidatorSetChangePacketData).  message ValidatorSetChangePacketData { repeated .tendermint.abci.ValidatorUpdate validator_updates = 1 [ (gogoproto.nullable) = false, (gogoproto.moretags) = &quot;yaml:\\&quot;validator_updates\\&quot;&quot; ]; uint64 valset_update_id = 2; // consensus address of consumer chain validators // successfully jailed on the provider chain repeated string slash_acks = 3; }   ","version":"v6.4.0","tagName":"h3"},{"title":"OnAcknowledgementPacket​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#onacknowledgementpacket","content":" OnAcknowledgementPacket enables the consumer module to confirm that the provider module received the previously sent SlashPacket and it unblocks the sending of the next SlashPacket. This functionality is needed for throttling jailing on the provider chain. For more details, see ADR-008.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnTimeoutPacket​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#ontimeoutpacket","content":" OnTimeoutPacket is a no-op.  ","version":"v6.4.0","tagName":"h3"},{"title":"Messages​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#messages","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"MsgUpdateParams​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#msgupdateparams","content":" MsgUpdateParams updates the consumer module parameters. The params are updated through a governance proposal where the signer is the gov module account address.  message MsgUpdateParams { option (cosmos.msg.v1.signer) = &quot;authority&quot;; // signer is the address of the governance account. string authority = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // params defines the x/consumer parameters to update. interchain_security.ccv.v1.ConsumerParams params = 2 [(gogoproto.nullable) = false]; }   ","version":"v6.4.0","tagName":"h3"},{"title":"BeginBlock​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#beginblock","content":" In the BeginBlock of the consumer module the following actions are performed:  Store in state the block height to VSC id mapping needed for sending to the provider the height of infractions committed on the consumer chain.Track historical entries. This is the same logic as in the x/staking module.  ","version":"v6.4.0","tagName":"h2"},{"title":"EndBlock​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#endblock","content":" In the EndBlock of the consumer module the following actions are performed:  If PreCCV state is active, i.e., the consumer chain is a previously standalone chain that was just upgraded to include the consumer module, then execute the changeover logic.Otherwise, distribute block rewards internally and once every BlocksPerDistributionTransmission send ICS rewards to the provider chain.Send slash packets to the provider chain reporting infractions validators committed on the consumer chain.Send to the consensus engine validator updates reveived from the provider chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"Hooks​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#hooks","content":" TBA  ","version":"v6.4.0","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#events","content":" TBA  ","version":"v6.4.0","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#parameters","content":" warning The consumer module parameters are set by the provider when creating the consumer genesis (i.e., when launching the consumer chain). As a result, changes of these parameters might result in incompatibilities between different versions of consumers and providers.  The consumer module contains the following parameters.  ","version":"v6.4.0","tagName":"h2"},{"title":"Enabled​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#enabled","content":" Enabled is deprecated.  ","version":"v6.4.0","tagName":"h3"},{"title":"BlocksPerDistributionTransmission​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#blocksperdistributiontransmission","content":" Type\tDefault valueint64\t1000  BlocksPerDistributionTransmission is the number of blocks between rewards transfers from the consumer to the provider.  ","version":"v6.4.0","tagName":"h3"},{"title":"DistributionTransmissionChannel​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#distributiontransmissionchannel","content":" Type\tDefault valuestring\t&quot;&quot;  DistributionTransmissionChannel is the provider chain IBC channel used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  Providing an IBC transfer channel enables a consumer chain to re-use one of the existing channels to the provider for consumer chain rewards distribution. This will preserve the ibc denom that may already be in use. This is especially important for standalone chains transitioning to become consumer chains. For more details, see the changeover procedure.  ","version":"v6.4.0","tagName":"h3"},{"title":"ProviderFeePoolAddrStr​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#providerfeepooladdrstr","content":" Type\tDefault valuestring\t&quot;&quot;  ProviderFeePoolAddrStr is the provider chain fee pool address used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  ","version":"v6.4.0","tagName":"h3"},{"title":"CcvTimeoutPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#ccvtimeoutperiod","content":" Type\tDefault valuetime.Duration\t2419200s (4 weeks)  CcvTimeoutPeriod is the period used to compute the timeout timestamp when sending IBC packets.CcvTimeoutPeriod may have different values on the provider and consumer chains.  ","version":"v6.4.0","tagName":"h3"},{"title":"TransferTimeoutPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#transfertimeoutperiod","content":" Type\tDefault valuetime.Duration\t3600s (1 hour)  TransferTimeoutPeriod is the timeout period for consumer chain reward distribution IBC packets.  ","version":"v6.4.0","tagName":"h3"},{"title":"ConsumerRedistributionFraction​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#consumerredistributionfraction","content":" Type\tDefault valuestring\t&quot;0.75&quot;  ConsumerRedistributionFraction is the fraction of tokens allocated to the consumer redistribution address during distribution events. The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. For example, a consumer with ConsumerRedistributionFraction set to &quot;0.75&quot; would send 75% of its block rewards and accumulated fees to the consumer redistribution address, and the remaining 25% to the provider chain every BlocksPerDistributionTransmission blocks.  ","version":"v6.4.0","tagName":"h3"},{"title":"HistoricalEntries​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#historicalentries","content":" Type\tDefault valueint64\t10000  HistoricalEntries is the number of historical info entries to persist in store (see the staking module parameter with the same name for details).HistoricalEntries is needed since the consumer module acts as a staking module on the consumer chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"UnbondingPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#unbondingperiod","content":" Type\tDefault valuetime.Duration\t1209600s (2 weeks)  UnbondingPeriod is the unbonding period on the consumer chain. It is recommended that every consumer chain set and unbonding period shorter than provider unbonding period, e.g., one week shorter.  ","version":"v6.4.0","tagName":"h3"},{"title":"SoftOptOutThreshold​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#softoptoutthreshold","content":" SoftOptOutThreshold is deprecated.  ","version":"v6.4.0","tagName":"h3"},{"title":"RewardDenoms​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#rewarddenoms","content":" Type\tDefault value[]string\t[]string  RewardDenoms are the denominations which are allowed to be sent to the provider as ICS rewards.  ","version":"v6.4.0","tagName":"h3"},{"title":"ProviderRewardDenoms​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#providerrewarddenoms","content":" Type\tDefault value[]string\t[]string  ProviderRewardDenoms are the denominations coming from the provider which are allowed to be used as ICS rewards. e.g. &quot;uatom&quot;.  ","version":"v6.4.0","tagName":"h3"},{"title":"RetryDelayPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#retrydelayperiod","content":" Type\tDefault valuetime.Duration\t3600s (1 hour)  RetryDelayPeriod is the period at which the consumer retries to send a SlashPacket that was rejected by the provider. For more details, see ADR-008.  ","version":"v6.4.0","tagName":"h3"},{"title":"Client​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#client","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"CLI​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#cli","content":" A user can interact with the consumer module using the CLI.  Query​  The query commands allow users to query consumer state.  interchain-security-cd query ccvconsumer --help   Next Fee Distribution​  The next-fee-distribution command allows to query next fee distribution data.  interchain-security-cd query ccvconsumer next-fee-distribution [flags]   Example interchain-security-cd query ccvconsumer next-fee-distribution Output: data: currentHeight: &quot;967&quot; distribution_fraction: &quot;0.75&quot; lastHeight: &quot;960&quot; nextHeight: &quot;980&quot; toConsumer: &quot;&quot; toProvider: &quot;&quot; total: &quot;&quot;   Provider Info​  The provider-info command allows to query provider info.  interchain-security-cd query ccvconsumer provider-info [flags]   Example interchain-security-cd query ccvconsumer provider-info Output: consumer: chainID: pion-1 channelID: channel-0 clientID: 07-tendermint-0 connectionID: connection-0 provider: chainID: provider channelID: channel-0 clientID: 07-tendermint-0 connectionID: connection-0   Throttle State​  The throttle-state command allows to query on-chain state relevant with slash packet throttling.  interchain-security-cd query ccvconsumer throttle-state [flags]   Example interchain-security-cd query ccvconsumer throttle-state Output: packet_data_queue: - slashPacketData: infraction: INFRACTION_DOWNTIME validator: address: mb06cu8SzQJOdYSzrJAK43Q8at8= power: &quot;500&quot; valset_update_id: &quot;48&quot; type: CONSUMER_PACKET_TYPE_SLASH slash_record: send_time: &quot;2024-10-02T07:58:24.405645924Z&quot; waiting_on_reply: true   Params​  The params command allows to query consumer module parameters.  interchain-security-cd query ccvconsumer params [flags]   Example interchain-security-cd query ccvconsumer params Output: params: blocks_per_distribution_transmission: &quot;1000&quot; ccv_timeout_period: 2419200s consumer_id: &quot;0&quot; consumer_redistribution_fraction: &quot;0.75&quot; distribution_transmission_channel: channel-1 enabled: true historical_entries: &quot;10000&quot; provider_fee_pool_addr_str: cosmos1ap0mh6xzfn8943urr84q6ae7zfnar48am2erhd provider_reward_denoms: [] retry_delay_period: 3600s reward_denoms: [] soft_opt_out_threshold: &quot;0&quot; transfer_timeout_period: 3600s unbonding_period: 1209600s   ","version":"v6.4.0","tagName":"h3"},{"title":"gRPC​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#grpc","content":" A user can query the consumer module using gRPC endpoints.  Next Fee Distribution​  The QueryNextFeeDistribution endpoint queries next fee distribution data.  interchain_security.ccv.consumer.v1.Query/QueryNextFeeDistribution   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryNextFeeDistribution Output: { &quot;data&quot;: { &quot;currentHeight&quot;: &quot;402&quot;, &quot;lastHeight&quot;: &quot;400&quot;, &quot;nextHeight&quot;: &quot;420&quot;, &quot;distributionFraction&quot;: &quot;0.75&quot; } }   Provider Info​  The QueryProviderInfo endpoint queries provider info.  interchain_security.ccv.consumer.v1.Query/QueryProviderInfo   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryProviderInfo Output: { &quot;consumer&quot;: { &quot;chainID&quot;: &quot;pion-1&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; }, &quot;provider&quot;: { &quot;chainID&quot;: &quot;provider&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; } }   Throttle State​  The QueryThrottleState endpoint queries on-chain state relevant with slash packet throttling.  interchain_security.ccv.consumer.v1.Query/QueryThrottleState   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryThrottleState Output: { &quot;slashRecord&quot;: { &quot;waitingOnReply&quot;: true, &quot;sendTime&quot;: &quot;2024-10-02T07:58:24.405645924Z&quot; }, &quot;packetDataQueue&quot;: [ { &quot;type&quot;: &quot;CONSUMER_PACKET_TYPE_SLASH&quot;, &quot;slashPacketData&quot;: { &quot;validator&quot;: { &quot;address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;power&quot;: &quot;500&quot; }, &quot;valsetUpdateId&quot;: &quot;48&quot;, &quot;infraction&quot;: &quot;INFRACTION_DOWNTIME&quot; } } ] }   Params​  The QueryParams endpoint queries consumer module parameters.  interchain_security.ccv.consumer.v1.Query/QueryParams   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryParams Output: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1000&quot;, &quot;distributionTransmissionChannel&quot;: &quot;channel-1&quot;, &quot;providerFeePoolAddrStr&quot;: &quot;cosmos1ap0mh6xzfn8943urr84q6ae7zfnar48am2erhd&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;10000&quot;, &quot;unbondingPeriod&quot;: &quot;1209600s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot;, &quot;consumerId&quot;: &quot;0&quot; } }   ","version":"v6.4.0","tagName":"h3"},{"title":"REST​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/v6.4.0/build/modules/consumer#rest","content":" A user can query the consumer module using REST endpoints.  Next Fee Distribution​  The next-fee-distribution endpoint queries next fee distribution data.  /interchain_security/ccv/consumer/next-fee-distribution   Example curl http://localhost:1317/interchain_security/ccv/consumer/next-fee-distribution Output: { &quot;data&quot;: { &quot;currentHeight&quot;: &quot;402&quot;, &quot;lastHeight&quot;: &quot;400&quot;, &quot;nextHeight&quot;: &quot;420&quot;, &quot;distributionFraction&quot;: &quot;0.75&quot; } }   Provider Info​  The QueryProviderInfo endpoint queries provider info.  /interchain_security/ccv/consumer/provider-info   Example curl http://localhost:1317/interchain_security/ccv/consumer/provider-info Output: { &quot;consumer&quot;: { &quot;chainID&quot;: &quot;pion-1&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; }, &quot;provider&quot;: { &quot;chainID&quot;: &quot;provider&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; } }   Throttle State​  The throttle_state endpoint queries on-chain state relevant with slash packet throttling.  /interchain_security/ccv/consumer/throttle_state   Example curl http://localhost:1317/interchain_security/ccv/consumer/throttle_state Output: { &quot;consumer&quot;: { &quot;chainID&quot;: &quot;pion-1&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; }, &quot;provider&quot;: { &quot;chainID&quot;: &quot;provider&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; } }   Params​  The params endpoint queries consumer module parameters.  /interchain_security/ccv/consumer/params   Example curl http://localhost:1317/interchain_security/ccv/consumer/params Output: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1000&quot;, &quot;distributionTransmissionChannel&quot;: &quot;channel-1&quot;, &quot;providerFeePoolAddrStr&quot;: &quot;cosmos1ap0mh6xzfn8943urr84q6ae7zfnar48am2erhd&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;10000&quot;, &quot;unbondingPeriod&quot;: &quot;1209600s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot;, &quot;consumerId&quot;: &quot;0&quot; } }  ","version":"v6.4.0","tagName":"h3"},{"title":"x/ccv/democracy","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/build/modules/democracy","content":"","keywords":"","version":"v6.4.0"},{"title":"Staking​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.4.0/build/modules/democracy#staking","content":" The x/ccv/democracy/staking module allows the cosmos-sdk x/staking module to be used alongside the interchain security consumer module.  The module uses overrides that allow the full x/staking functionality with one notable difference - the staking module will no longer be used to provide the validator set to the consensus engine.  ","version":"v6.4.0","tagName":"h2"},{"title":"Implications for consumer chains​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.4.0/build/modules/democracy#implications-for-consumer-chains","content":" The x/ccv/democracy/staking allows consumer chains to separate governance from block production. The validator set coming from the provider chain does not need to participate in governance - they only provide infrastructure (create blocks and maintain consensus).  Governators (aka. Governors)​  Validators registered with the x/ccv/democracy/staking module become Governators. Unlike validators, governators are not required to run any chain infrastructure since they are not signing any blocks. However, governators retain a subset of the validator properties:  new governators can be created (via MsgCreateValidator)governators can accept delegationsgovernators can vote on governance proposals (with their self stake and delegations)governators earn block rewards -- the block rewards kept on the consumer (see the ConsumerRedistributionFraction param) are distributed to all governators and their delegators.  With these changes, governators can become community advocates that can specialize in chain governance and they get rewarded for their participation the same way the validators do. Additionally, governators can choose to provide additional infrastructure such as RPC/API access points, archive nodes, indexers and similar software.  Tokenomics​  The consumer chain's token will remain a governance token. The token's parameters (inflation, max supply, burn rate) are completely under the control of the consumer chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.4.0/build/modules/democracy#integration","content":" The x/ccv/democracy/staking module provides these x/staking overrides:   // InitGenesis delegates the InitGenesis call to the underlying x/staking module, // however, it returns no validator updates as validators are tracked via the // consumer chain's x/cvv/consumer module and so this module is not responsible for returning the initial validator set. func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run staking InitGenesis return []abci.ValidatorUpdate{} // do not return validator updates } // EndBlock delegates the EndBlock call to the underlying x/staking module. // However, no validator updates are returned as validators are tracked via the // consumer chain's x/cvv/consumer module. func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates return []abci.ValidatorUpdate{} // do not return validator updates }   To integrate the democracy/staking follow this guide:  1. confirm that no modules are returning validator updates​  warning Only the x/ccv/consumer module should be returning validator updates.  If some of your modules are returning validator updates please disable them while maintaining your business logic:  func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) -\treturn am.keeper.InitGenesis(ctx, &amp;genesisState) + _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run InitGenesis but drop the result +\treturn []abci.ValidatorUpdate{} // return empty validator updates } func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { -\treturn am.keeper.BlockValidatorUpdates(ctx) + _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates +\treturn []abci.ValidatorUpdate{} // return empty validator updates }   2. wire the module in app.go​  You do not need to remove the cosmos-sdk StakingKeeper from your wiring.  import ( ... + ccvstaking &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/staking&quot; ) var ( // replace the staking.AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, - sdkstaking.AppModuleBasic{}, + ccvstaking.AppModuleBasic{}, // replace sdkstaking ... ) ) func NewApp(...) { ... // use sdk StakingKeepeer app.StakingKeeper = stakingkeeper.NewKeeper( appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.MintKeeper = mintkeeper.NewKeeper( appCodec, keys[minttypes.StoreKey], app.StakingKeeper, app.AccountKeeper, app.BankKeeper, authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // no changes required for the distribution keeper app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // keep StakingKeeper! authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) + // pre-initialize ConsumerKeeper to satsfy ibckeeper.NewKeeper +\tapp.ConsumerKeeper = consumerkeeper.NewNonZeroKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), +\t) + +\tapp.IBCKeeper = ibckeeper.NewKeeper( + appCodec, + keys[ibchost.StoreKey], + app.GetSubspace(ibchost.ModuleName), + &amp;app.ConsumerKeeper, + app.UpgradeKeeper, + scopedIBCKeeper, +\t) + +\t// Create CCV consumer and modules +\tapp.ConsumerKeeper = consumerkeeper.NewKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), + scopedIBCConsumerKeeper, + app.IBCKeeper.ChannelKeeper, + &amp;app.IBCKeeper.PortKeeper, + app.IBCKeeper.ConnectionKeeper, + app.IBCKeeper.ClientKeeper, + app.SlashingKeeper, + app.BankKeeper, + app.AccountKeeper, + &amp;app.TransferKeeper, + app.IBCKeeper, + authtypes.FeeCollectorName, +\t) + +\t// Setting the standalone staking keeper is only needed for standalone to consumer changeover chains + // New chains using the democracy/staking do not need to set this +\tapp.ConsumerKeeper.SetStandaloneStakingKeeper(app.StakingKeeper) // change the slashing keeper dependency app.SlashingKeeper = slashingkeeper.NewKeeper( appCodec, legacyAmino, keys[slashingtypes.StoreKey], - app.StakingKeeper, + &amp;app.ConsumerKeeper, // ConsumerKeeper implements StakingKeeper interface authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register slashing module StakingHooks to the consumer keeper +\tapp.ConsumerKeeper = *app.ConsumerKeeper.SetHooks(app.SlashingKeeper.Hooks()) +\tconsumerModule := consumer.NewAppModule(app.ConsumerKeeper, app.GetSubspace(consumertypes.ModuleName)) // register the module with module manager // replace the x/staking module app.MM = module.NewManager( ... - sdkstaking.NewAppModule(appCodec, &amp;app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), + ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }   ","version":"v6.4.0","tagName":"h3"},{"title":"Distribution​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.4.0/build/modules/democracy#distribution","content":" The x/ccv/democracy/distribution module allows the consumer chain to send rewards to the provider chain while retaining the logic of the x/distribution module for internal reward distribution to governators and their delegators.  ","version":"v6.4.0","tagName":"h2"},{"title":"How it works​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.4.0/build/modules/democracy#how-it-works","content":" First, a percentage of the block rewards is sent to the provider chain, where is distributed only to opted-in validators and their delegators. Second, the remaining rewards get distributed to the consumer chain's governators and their delegators. The percentage that is sent to the provider chain corresponds to 1 - ConsumerRedistributionFraction. For example, ConsumerRedistributionFraction = &quot;0.75&quot; means that the consumer chain retains 75% of the rewards, while 25% gets sent to the provider chain  ","version":"v6.4.0","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/v6.4.0/build/modules/democracy#integration-1","content":" Change the wiring in app.go  import ( ... distrkeeper &quot;github.com/cosmos/cosmos-sdk/x/distribution/keeper&quot; distrtypes &quot;github.com/cosmos/cosmos-sdk/x/distribution/types&quot; sdkdistr &quot;github.com/cosmos/cosmos-sdk/x/distribution&quot; + ccvdistr &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/distribution&quot; ) var ( // replace sdk distribution AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, ccvstaking.AppModuleBasic{}, // make sure you first swap the staking keeper mint.AppModuleBasic{}, - sdkdistr.AppModuleBasic{}, + ccvdistr.AppModuleBasic{}, ) ) func NewApp(...) { .... app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // connect to sdk StakingKeeper consumertypes.ConsumerRedistributeName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register with the module manager app.MM = module.NewManager( ... - sdkdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), + ccvdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }  ","version":"v6.4.0","tagName":"h3"},{"title":"Consumer Chain Governance","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/consumer-development/consumer-chain-governance","content":"","keywords":"","version":"v6.4.0"},{"title":"Democracy module​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v6.4.0/consumer-development/consumer-chain-governance#democracy-module","content":" The democracy module provides a governance experience identical to what exists on a standalone Cosmos chain, with one small but important difference. On a standalone Cosmos chain validators can act as representatives for their delegators by voting with their stake, but only if the delegator themselves does not vote. This is a lightweight form of liquid democracy.  Using the democracy module on a consumer chain is the exact same experience, except for the fact that it is not the actual validator set of the chain (since it is a consumer chain, these are the Cosmos Hub validators) acting as representatives. Instead, there is a separate representative role who token holders can delegate to and who can perform the functions that validators do in Cosmos governance, without participating in proof of stake consensus.  For an example, see the Democracy Consumer  ","version":"v6.4.0","tagName":"h2"},{"title":"CosmWasm​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/v6.4.0/consumer-development/consumer-chain-governance#cosmwasm","content":" There are several great DAO and governance frameworks written as CosmWasm contracts. These can be used as the main governance system for a consumer chain. Actions triggered by the CosmWasm governance contracts are able to affect parameters and trigger actions on the consumer chain.  For an example, see Neutron. ","version":"v6.4.0","tagName":"h2"},{"title":"Consumer Genesis Transformation","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/consumer-development/consumer-genesis-transformation","content":"","keywords":"","version":"v6.4.0"},{"title":"1. Prerequisite​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v6.4.0/consumer-development/consumer-genesis-transformation#1-prerequisite","content":" used provider and consumer versions require transformation step as indicated in in the compatibility notesinterchain-security-cd application supports the versions used by the consumer and provider  ","version":"v6.4.0","tagName":"h2"},{"title":"2. Export the CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v6.4.0/consumer-development/consumer-genesis-transformation#2-export-the-ccv-data","content":" Export the CCV data from the provider chain as described in the Onboarding and Changeover your following. As a result the CCV data will be stored in a file in JSON format.  ","version":"v6.4.0","tagName":"h2"},{"title":"3. Transform CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/v6.4.0/consumer-development/consumer-genesis-transformation#3-transform-ccv-data","content":" To transform the CCV data  to the format supported by the current version of the consumer run the following command: interchain-security-cd genesis transform [genesis-file] where 'genesis-file' is the path to the file containing the CCV data exported in step 2. As a result the CCV data in the new format will be written to standard output.a specific target version of a consumer run the following command: interchain-security-cd genesis transform --to &lt;target_version&gt; [genesis-file] where &lt;target_version is the ICS version the consumer chain is running. Use interchain-security-cd genesis transform --help to get more details about supported target versions and more.  Use the new CCV data as described in the procedure you're following. ","version":"v6.4.0","tagName":"h2"},{"title":"Consumer Offboarding","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/consumer-development/offboarding","content":"Consumer Offboarding To offboard a consumer chain, the owner of the chain has to submit a MsgRemoveConsumer message with the chain's consumerId. If the chain is a Top N chain, the MsgRemoveConsumer has to be submitted through a governance proposal. Otherwise, the message can be submitted simply by the owner of the consumer chain. When the MsgRemoveConsumer executes, the provider chain will stop the chain from the ICS protocol (it will stop sending validator set updates) and the chain is considered to be in the stopped phase. At this phase, validators cannot opt in, change keys, etc. and validators stop receiving rewards. After the chain is stopped, and an unbonding period of time passes, part of the state of the chain is deleted and the chain is considered deleted.","keywords":"","version":"v6.4.0"},{"title":"Create an ICS chain with Spawn","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/consumer-development/create-with-spawn","content":"","keywords":"","version":"v6.4.0"},{"title":"Requirements​","type":1,"pageTitle":"Create an ICS chain with Spawn","url":"/interchain-security/v6.4.0/consumer-development/create-with-spawn#requirements","content":" go 1.22+Docker  MacOS + Ubuntu Setup  ","version":"v6.4.0","tagName":"h2"},{"title":"Getting Started​","type":1,"pageTitle":"Create an ICS chain with Spawn","url":"/interchain-security/v6.4.0/consumer-development/create-with-spawn#getting-started","content":" Note: This tutorial focuses on using the Spawn CLI to create an ICS consumer chain. For more complete documentation on Spawn, see the Spawn documentation.  In this tutorial, we'll create and interact with a new Interchain security enabled blockchain called &quot;consumer&quot;, with the token denomination &quot;uconsu&quot;.  Install Spawn  # Install from latest source git clone https://github.com/rollchains/spawn.git --depth 1 --branch v0.50.10 # Change to this directory cd spawn # Clear Go modules cache for a fresh install go clean -modcache # Install Spawn make install # Install Local Interchain (testnet runner) make get-localic # Install docker container builder make get-heighliner # Verify installations were successful spawn local-ic heighliner # If you get &quot;command 'spawn' not found&quot;, run the following # Linux / Windows / Some MacOS echo 'export PATH=$PATH:$(go env GOPATH)/bin' &gt;&gt; ~/.bashrc source ~/.bashrc # MacOS echo 'export PATH=$PATH:$(go env GOPATH)/bin' &gt;&gt; ~/.zshrc source ~/.zshrc # Legacy MacOS Go echo 'export PATH=$PATH:$HOME/go/bin' &gt;&gt; ~/.zshrc source ~/.zshrc # Sometimes it can be good to also clear your cache # especially WSL users go clean -cache   Create your chain using the spawn command and customize it to your needs!  GITHUB_USERNAME=&lt;your github username&gt; spawn new consumer \\ --consensus=interchain-security \\ --bech32=consu \\ --denom=uconsu \\ --bin=consumerd \\ --disabled=tokenfactory,ibc-packetforward,ibc-ratelimit,cosmwasm,wasm-light-client \\ --org=${GITHUB_USERNAME}   NOTE: spawn creates a ready to use repository complete with git and GitHub CI. It can be quickly pushed to a new repository getting you and your team up and running quickly.  Spin up a local testnet for your chain  cd consumer # Starts 2 networks for the IBC testnet at http://127.0.0.1:8080. # - Builds the docker image of your chain # - Launches a testnet with IBC automatically connected and relayed # # Note: you can run a single node, non IBC testnet, with `make sh-testnet`. make testnet   Open a new terminal window and send a transaction on your new chain  # list the keys that have been provisioned with funds in genesis consumerd keys list # send a transaction from one account to another consumerd tx bank send acc0 $(consumerd keys show acc1 -a) 1337uconsu --chain-id=localchain-1 # enter &quot;y&quot; to confirm the transaction # then query your balances tfor proof the transaction executed successfully consumerd q bank balances $(consumerd keys show acc1 -a)   (optional) Send an IBC transaction  # submit a cross chain transfer from acc0 to the other address consumerd tx ibc-transfer transfer transfer channel-0 cosmos1hj5fveer5cjtn4wd6wstzugjfdxzl0xpxvjjvr 7uconsu --from=acc0 --chain-id=localchain-1 --yes # Query the other side to confirm it went through sleep 10 # Interact with the other chain without having to install the cosmos binary # - Endpoints found at: GET http://127.0.0.1:8080/info local-ic interact localcosmos-1 query 'bank balances cosmos1hj5fveer5cjtn4wd6wstzugjfdxzl0xpxvjjvr' --api-endpoint=http://127.0.0.1:8080   Push your new chain to a github repository  # Create a new repository on GitHub from the gh cli gh repo create ics-consumer --source=. --remote=origin --push   You can also push it the old fashioned way with https://github.com/new and git push origin main.  In this tutorial, we configured a new custom chain, launched a testnet for it, tested a simple token transfer, and confirmed it was successful. This tutorial demonstrates just how easy it is to create a brand new custom Cosmos-SDK blockchain from scratch, saving developers time.  ","version":"v6.4.0","tagName":"h2"},{"title":"Modify your chain​","type":1,"pageTitle":"Create an ICS chain with Spawn","url":"/interchain-security/v6.4.0/consumer-development/create-with-spawn#modify-your-chain","content":" New module code is usually added in the x/ directory of your repository. Check out the Cosmos SDK documentation for more information on how to add modules to your chain.  Once you're ready you can preview your chain using the section below.  ","version":"v6.4.0","tagName":"h2"},{"title":"List your chain​","type":1,"pageTitle":"Create an ICS chain with Spawn","url":"/interchain-security/v6.4.0/consumer-development/create-with-spawn#list-your-chain","content":" You can list your chain on Forge, even if it's not finished, in the pre-launch stage. ","version":"v6.4.0","tagName":"h2"},{"title":"Consumer Onboarding Checklist","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/consumer-development/onboarding","content":"","keywords":"","version":"v6.4.0"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.4.0/consumer-development/onboarding#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.10.2) reach out to the ICS team if you are facing issues  ","version":"v6.4.0","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.4.0/consumer-development/onboarding#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json without the consumer module genesis (before the spawn time passes). Make sure the genesis time is within the trusting period (i.e., one day before launch time or shorter). genesis.json with the consumer module genesis (after the spawn time passes). Check if the consumer module genesis needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"v6.4.0","tagName":"h2"},{"title":"3. Submit MsgCreateConsumer (and MsgUpdateConsumer) messages​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.4.0/consumer-development/onboarding#3-submit-msgcreateconsumer-and-msgupdateconsumer-messages","content":" Before you start your chain, you need to submit a MsgCreateConsumer message that generates and returns back theconsumerId that should be used in any upcoming interactions by the consumer chain or the validators that interact with your chain. Additionally, you need to decide whether your chain should be an Opt-In chain or a Top N chain (see Partial Set Security) and act accordingly (see Permissionless ICS).  If you create a Top N chain through, please consider allowing at least a day between your proposal passing and the chain spawn time. This will allow the validators, other node operators and the community to prepare for the chain launch. If possible, please set your spawn time so people from different parts of the globe can be available in case of emergencies. Ideally, you should set your spawn time to be between 12:00 UTC and 20:00 UTC so most validator operators are available and ready to respond to any issues.  Additionally, for a Top N chain, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters take note to include a link to your onboarding repository describe the purpose and benefits of running your chain if desired, decide on power-shaping parameters (see Power Shaping)  Example of initialization parameters:  // ConsumerInitializationParameters provided in MsgCreateConsumer or MsgUpdateConsumer { // Initial height of new consumer chain. // For a completely new chain, this will be {1,1}. &quot;initial_height&quot; : { &quot;revision_height&quot;: 1, &quot;revision_number&quot;: 1, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // It is used for off-chain confirmation of genesis.json validity by validators and other parties. &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on chain initialization. // It is used for off-chain confirmation of binary validity by validators and other parties. &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should be smaller than that of the provider. &quot;unbonding_period&quot;: 1728000000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 2419200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot; }   Example of power-shaping parameters:  // PowerShaping parameters provided in MsgCreateConsumer or MsgUpdateConsumer { // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. &quot;top_N&quot;: 0, // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis. &quot;validators_power_cap&quot;: 0, // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. &quot;validator_set_cap&quot;: 0, // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate // the consumer chain. &quot;allowlist&quot;: [&quot;cosmosvalcons...&quot;], // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. &quot;denylist&quot;: [&quot;cosmosvalcons...&quot;], // Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain. &quot;min_stake&quot;: 0, // Corresponds to whether inactive validators are allowed to validate the consumer chain. &quot;allow_inactive_vals&quot;: false, // Corresponds to a list of provider consensus addresses of validators that have priority &quot;prioritylist&quot;: [], }   Example of allowlisted reward denoms:  // AllowlistedRewardDenoms provided in MsgCreateConsumer or MsgUpdateConsumer { &quot;denoms&quot;: [&quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;, &quot;ibc/054892D6BB43AF8B93AAC28AA5FD7019D2C59A15DAFD6F45C1FA2BF9BDA22454&quot;] }   caution For opt-in consumer chains, make sure that at least one validator opts in before the spawn time elapses. Otherwise the launch process will be aborted and the spawn time needs to be updated by submitting a MsgUpdateConsumer message.  ","version":"v6.4.0","tagName":"h2"},{"title":"4. Launch​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.4.0/consumer-development/onboarding#4-launch","content":" The consumer chain starts after at least 66.67% of its voting power comes online. Note that this means 66.67% of the voting power in the consumer validator set, which will be comprised of all validators that either opted in to the chain or are part of the top N% of the provider chain (and are thus automatically opted in). The consumer chain is considered interchain secured once the appropriate CCV channels are established and the first validator set update is propagated from the provider to the consumer   provide a repo with onboarding instructions for validators genesis.json with the consumer module section populated (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) have a block explorer in place to track chain activity &amp; health  ","version":"v6.4.0","tagName":"h2"},{"title":"Establish CCV channel​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/v6.4.0/consumer-development/onboarding#establish-ccv-channel","content":" Once the consumer chain is launched, the CCV channel needs to be established. The following instructions are setting both the connection and channel using Hermes:  #!/bin/bash # CONSUMER_CLIENT_ID is created on CONSUMER upon genesis CONSUMER_CLIENT_ID=&quot;&lt;consumer-client-id&gt;&quot; CONSUMER_CHAIN_ID=&quot;&lt;consumer-chain-id&gt;&quot; # PROVIDER_CLIENT_ID is created on PROVIDER upon CONSUMER spawn time: gaiad q provider list-consumer-chains PROVIDER_CLIENT_ID=&quot;&lt;provider-client-id&gt;&quot; PROVIDER_CHAIN_ID=&quot;&lt;provider-chain-id&gt;&quot; CONFIG=$1 if [ -z &quot;$CONFIG&quot; ]; then CONFIG=$HOME/.hermes/config.toml fi if [ ! -f &quot;$CONFIG&quot; ]; then echo &quot;no config file found at $CONFIG&quot; exit 1 fi output=$(hermes --json --config $CONFIG create connection --a-chain $CONSUMER_CHAIN_ID --a-client $CONSUMER_CLIENT_ID --b-client $PROVIDER_CLIENT_ID | tee /dev/tty) json_output=$(echo &quot;$output&quot; | grep 'result') a_side_connection_id=$(echo &quot;$json_output&quot; | jq -r '.result.a_side.connection_id') output=$(hermes --json --config $CONFIG create channel --a-chain $CONSUMER_CHAIN_ID --a-port consumer --b-port provider --order ordered --a-connection $a_side_connection_id --channel-version 1 | tee /dev/tty) json_output=$(echo &quot;$output&quot; | grep 'result') echo &quot;---- DONE ----&quot; echo &quot;$json_output&quot; | jq # hermes start  ","version":"v6.4.0","tagName":"h3"},{"title":"Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/features/key-assignment","content":"","keywords":"","version":"v6.4.0"},{"title":"Rules​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.4.0/features/key-assignment#rules","content":" A key can be assigned to any active (i.e., in the registered, initialized, or launched phase) chain.Validator A cannot assign consumer key K to consumer chain X if there is already a validator B (B!=A) using K on the provider.Validator A cannot assign consumer key K to consumer chain X if there is already a validator B using K on X.A new validator on the provider cannot use a consensus key K if K is already used by any validator on any consumer chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"Adding a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.4.0/features/key-assignment#adding-a-key","content":" warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  First, create a new node on the consumer chain using the equivalent:  consumerd init &lt;moniker&gt;   Then query your node for the consensus key.  consumerd tendermint show-validator # {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, make an assign-consensus-key transaction on the provider chain in order to inform the provider chain about the consensus key you will be using for a specific consumer chain.  gaiad tx provider assign-consensus-key &lt;consumer-id&gt; '&lt;pubkey&gt;' --from &lt;tx-signer&gt; --home &lt;home_dir&gt; --gas 900000 -b sync -y -o json   consumer-id is the string identifier of the consumer chain, as assigned on the provider chainconsumer-pub-key has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}  Check that the key was assigned correctly by querying the provider:  gaiad query provider validator-consumer-key &lt;consumer-id&gt; cosmosvalcons1e....3xsj3ayzf4uv6   You must use a valcons address. You can obtain it by querying your node on the provider gaiad tendermint show-address  OR  gaiad query provider validator-provider-key &lt;consumer-id&gt; consumervalcons1e....123asdnoaisdao   You must use a valcons address. You can obtain it by querying your node on the consumer consumerd tendermint show-address  OR  gaiad query provider all-pairs-valconsensus-address &lt;consumer-id&gt;   You just need to use the consumerId of consumer to query all pairs valconsensus address with consumer-pub-key for each of pair  ","version":"v6.4.0","tagName":"h2"},{"title":"Changing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.4.0/features/key-assignment#changing-a-key","content":" To change your key, simply repeat all of the steps listed above. Take note that your old key will be remembered for at least the unbonding period of the consumer chain so any slashes can be correctly applied  ","version":"v6.4.0","tagName":"h2"},{"title":"Removing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/v6.4.0/features/key-assignment#removing-a-key","content":" To remove a key, simply switch it back to the consensus key you have assigned on the provider chain by following steps in the Adding a key section and using your provider consensus key. ","version":"v6.4.0","tagName":"h2"},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/faq","content":"","keywords":"","version":"v6.4.0"},{"title":"General​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#general","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"What is Interchain Security (ICS)?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#what-is-interchain-security-ics","content":" ICS is an IBC protocol that enables a provider chain (e.g., the Cosmos Hub) to provide security to multiple consumer chains. This means that consumer chains will leverage the stake locked on the provider chain for block production (i.e., a cross-chain proof-of-stake system). ICS allows anyone to launch a consumer chain using a subset, or even the entire, validator set from the provider chain. Note that validators need to run separate infrastructure for the provider and consumer chains, resulting in different networks that only share (a subset of) the validator set.  ","version":"v6.4.0","tagName":"h3"},{"title":"What is the difference between ICS and Partial Set Security (PSS)?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#what-is-the-difference-between-ics-and-partial-set-security-pss","content":" ICS is a protocol. PSS is a feature of ICS that allows a provider chain to share only a subset of its validator set with a consumer chain. PSS differentiates between TopN and Opt-In consumer chains. For TopN chains, the validator subset is determined by the top N% provider validators by voting power. For Opt-In chains, the validator subset is determined by validators opting in to validate the consumer chains. PSS allows for flexible tradeoffs between security, decentralization, and the budget a consumer chain spends on rewards to validators.  For more details, see the PSS feature.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consumer Chains​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#consumer-chains","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"What are consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#what-are-consumer-chains","content":" Consumer chains are blockchains operated by (a subset of) the validators of the provider chain. The ICS protocol ensures that consumer chains get information about which validators should validate on them. This information consists of the opted in validators and their power on the consumer chains. Note that the validators' power on the consumer chains is a function of their stake locked on the provider chain.  Consumer chains are run on infrastructure (virtual or physical machines) distinct from the provider chain, have their own configurations and operating requirements.  Consumer chains are free to choose how they wish to operate and which modules to include. For example, they can choose to use CosmWasm either in a permissioned or a permissionless way. Also, consumer chains are free to perform software upgrades at any time without impacting the provider chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"How to become a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#how-to-become-a-consumer-chain","content":" To become a consumer chain use this checklist and check the App integration section.  ","version":"v6.4.0","tagName":"h3"},{"title":"What happens to consumers if the provider is down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#what-happens-to-consumers-if-the-provider-is-down","content":" In case the provider chain halts or experiences difficulties, the consumer chains will keep operating - the provider chain and consumer chains represent different networks that only share (a subset of) the validator set. As the validators run separate infrastructure on these networks, the provider chain liveness does not impact the liveness of consumer chains.  Every consumer chain communicates with the provider chain via a CCV channel -- an IBC ordered channel. If any of the packets sent over the CCV channel timeout (see the CCVTimeoutPeriod param), then the channel is closed and, consequently, the consumer chain transitions to a Proof of Authority (PoA) chain. This means that the validator set on the consumer will no longer be updated with information from the provider.  ","version":"v6.4.0","tagName":"h3"},{"title":"What happens to provider if any of the consumers are down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#what-happens-to-provider-if-any-of-the-consumers-are-down","content":" Consumer chains do not impact the livness of the provider chain.The ICS protocol is concerned only with validator set management, and the only communication that the provider requires from the consumer is information about validator activity (essentially keeping the provider informed about slash events).  ","version":"v6.4.0","tagName":"h3"},{"title":"Can consumer chains have their own token?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#can-consumer-chains-have-their-own-token","content":" As any other Cosmos SDK chains, consumer chains can issue their own token and manage inflation parameters. Note that the ICS protocol does not impact the transaction fee system on the consumer chains. This means consumer chains can use any token (including their own token) to pay gas fees. For more details, see the democracy modules.  ","version":"v6.4.0","tagName":"h3"},{"title":"Can consumer chains have their own governance?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#can-consumer-chains-have-their-own-governance","content":" Yes. ICS allows consumer chains to separate governance from block production. Validator operators (with their stake locked on the provider) are responsible for block production, while representatives (aka governators, governors) are responsible for on-chain governance. For more details, see the democracy modules.  ","version":"v6.4.0","tagName":"h3"},{"title":"Can a consumer chain modify its power shaping parameters?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#can-a-consumer-chain-modify-its-power-shaping-parameters","content":" Yes, by issuing a MsgUpdateConsumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"Can a Top N consumer chain become Opt-In or vice versa?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#can-a-top-n-consumer-chain-become-opt-in-or-vice-versa","content":" Yes, by issuing a MsgUpdateConsumer (see Permissionless ICS)  ","version":"v6.4.0","tagName":"h3"},{"title":"Validators​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#validators","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"How can validators opt in to validate a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#how-can-validators-opt-in-to-validate-a-consumer-chain","content":" Check the validator guide to Partial Set Security.  An important note is that validator the top N% of the provider chain validator set are automatically opted in on Top N consumer chains.  ","version":"v6.4.0","tagName":"h3"},{"title":"Can validators opt in to an Opt-in chain after the spawn time if nobody else opted in?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#can-validators-opt-in-to-an-opt-in-chain-after-the-spawn-time-if-nobody-else-opted-in","content":" No, the consumer chain does not launch if nobody opted in by the spawn time. At least one validator, regardless of its voting power, must opt in before the spawn time in order for the chain can start.  ","version":"v6.4.0","tagName":"h3"},{"title":"How does a validator know which consumers chains it has to validate?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#how-does-a-validator-know-which-consumers-chains-it-has-to-validate","content":" In order for a validator to keep track of all the chains it has to validate, the validator can use thehas-to-validate query.  ","version":"v6.4.0","tagName":"h3"},{"title":"How many chains can a validator opt in to?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#how-many-chains-can-a-validator-opt-in-to","content":" There is no limit in the number of consumers chains a validator can choose to opt in to.  ","version":"v6.4.0","tagName":"h3"},{"title":"How can validators assign consumer keys?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#how-can-validators-assign-consumer-keys","content":" Check the Key Assignment guide for specific instructions.  Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  Also note that validators can assign consensus keys before a consumer chain is launched (e.g., during the voting period for Top N consumer chains).  ","version":"v6.4.0","tagName":"h3"},{"title":"What are the benefits for validators running consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#what-are-the-benefits-for-validators-running-consumer-chains","content":" The consumer chains sends a portion of its block rewards (e.g., transaction fees and inflation) to the provider chain as defined by the ConsumerRedistributionFraction param. These rewards are sent periodically to the provider (via IBC transfers), where they are distributed ONLY to the opted in validators and their delegators. For more details, see the Reward Distribution feature.  ","version":"v6.4.0","tagName":"h3"},{"title":"Can validators set per consumer chain commission rates?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#can-validators-set-per-consumer-chain-commission-rates","content":" Yes. See the validator guide to Partial Set Security.  ","version":"v6.4.0","tagName":"h3"},{"title":"What are the risks for validators running consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#what-are-the-risks-for-validators-running-consumer-chains","content":" Validators that perform an equivocation or a light-client attack on a consumer chain are slashed on the provider chain. This is done by submitting a proof of the equivocation or the light-client attack to the provider chain.  In addition, consumer chains send IBC packets via the CCV channels informing the provider when opted in validators should be jailed for downtime. It is important to notice that validators are not slashed for downtime on consumer chains. The downtime logic is custom to the consumer chain. For example, Cosmos SDK chains can use the slashing module to configure the downtime window.  For more details, see the slashing feature.  ","version":"v6.4.0","tagName":"h3"},{"title":"Can validators run the provider and consumer chains on the same machine?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#can-validators-run-the-provider-and-consumer-chains-on-the-same-machine","content":" In theory yes. In practice, we recommend validators to run the provider and consumer chains in separate environments for fault containment, i.e., failures of one machine do not impact the entire system.  ","version":"v6.4.0","tagName":"h3"},{"title":"Can validators opt out of validating a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#can-validators-opt-out-of-validating-a-consumer-chain","content":" Validators can always opt out from an Opt-In consumer chain. Validators can only opt out from a TopN chain if they do not belong to the top N% validators.  ","version":"v6.4.0","tagName":"h3"},{"title":"Can all validators opt out of an Opt-in chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#can-all-validators-opt-out-of-an-opt-in-chain","content":" Note that if all validators opt out of an Opt-In consumer chain, then the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"v6.4.0","tagName":"h3"},{"title":"How to connect to the testnets?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#how-to-connect-to-the-testnets","content":" Check out the Joining Interchain Security testnet section.  ","version":"v6.4.0","tagName":"h3"},{"title":"Integrators​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#integrators","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Which relayers are supported?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#which-relayers-are-supported","content":" Currently supported versions:  Hermes v1.8.0+  ","version":"v6.4.0","tagName":"h3"},{"title":"How to check when the next validator update will be sent to the consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/v6.4.0/faq#how-to-check-when-the-next-validator-update-will-be-sent-to-the-consumer-chains","content":" Validator updates are sent to consumer chains every BlocksPerEpoch blocks. Depending on the status of relayers between the Hub and the consumer chains, it might take a while for the validator updates to be processed and applied on the consumer chains.  To query how many blocks are left until the next epoch starts, run the following command:  interchain-security-pd query provider blocks-until-next-epoch  ","version":"v6.4.0","tagName":"h3"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/features/partial-set-security","content":"Partial Set Security Partial Set Security (PSS) is a complete revamp of the Hub's security offering. It allows consumer chains to leverage only a subset of validators from the provider chain, which offers more flexibility than the previous Replicated Security model. By introducing the top_N parameter, each consumer chain can choose the extent of security needed: Top N: Requires the top N% validators from the provider chain to secure the consumer chain. This guarantees that the validators with the most power on the provider will validate the consumer chain, while others can voluntarily opt in. Opt-In: If the top_N parameter is set to zero, no validator is mandated to secure the consumer chain. Instead, any validator from the provider chain can opt in using a dedicated transaction. An advantage of Top N chains is that they are guaranteed to receive at least a certain fraction of the market cap of the provider chain in security. In turn, Top N chains need to be approved by governance, since some validators will be forced to validate on them. Thus, Top N chains should typically expect to need to provide a strong case for why they should be added to the provider chain, and they should make sure they offer enough rewards to incentivize validators and delegators to vote for their proposal. Opt-In chains, on the other hand, are more flexible. Validators are never forced to validate these chains and simply opt in if they want to. Because of this, Opt-In chains can be launch completely permissionlessly by sending a transaction to the provider chain. As a trade-off though, Opt-In chains do not get a fixed amount of security as a relation of the market cap of the provider as top N chains do, so Opt-In chains might want to keep an eye on how many validators have opted in to validate their chain and adjust their reward emissions accordingly to incentivize validators. Note that Top N consumer chains can become Opt-In chains or vice versa via a MsgUpdateConsumer message. Partial Set Security is handled only by the provider chain - the consumer chains are simply sent validator sets, and they are not aware that this represents only a subset of the provider chain's validator set.","keywords":"","version":"v6.4.0"},{"title":"Permissionless ICS","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/features/permissionless","content":"","keywords":"","version":"v6.4.0"},{"title":"From chainId to consumerId​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.4.0/features/permissionless#from-chainid-to-consumerid","content":" With Permissionless ICS, anyone can issue a transaction to launch a consumer chain. As a result, the chainId of a consumer chain cannot uniquely identify a consumer chain from the point of view of the provider, because we could have multiple consumer chains with the exact same chainId. Because of this, Permissionless ICS introduces the notion of a consumerId. The provider associates for each consumer chain a unique consumerId. A consumer chain can then interact (e.g., update chain parameters) with its chain by utilizing this consumerId. Additionally, validators can interact (e.g., assign a consumer key, opt in, etc.) with a consumer chain by using the consumer's consumerId.  ","version":"v6.4.0","tagName":"h2"},{"title":"Phases of a Consumer Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.4.0/features/permissionless#phases-of-a-consumer-chain","content":" A consumer chain can reside in one of the phases shown in the table below.  Phase\tDescriptionRegistered\tThe consumer chain was created with MsgCreateConsumer and has received the consumer's associated consumerId. The chain cannot launch yet. Initialized\tThe consumer chain has set all the initialization parameters and is ready to launch at spawnTime. Launched\tThe consumer chain has launched and is running. The provider chain is sending VSCPackets to the consumer. Stopped\tThe consumer chain is stopped and the provider chain is not sending VSCPackets to the consumer. The consumer chain is slated to be deleted. Deleted\tThe majority of the state of the consumer chain on the provider is deleted. Basic metadata of the consumer chain, such as the chainId, etc. are not deleted.  The following diagram shows the phases and the actions that need to take place to move from one phase to another.    ","version":"v6.4.0","tagName":"h2"},{"title":"Owner of a Consumer Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.4.0/features/permissionless#owner-of-a-consumer-chain","content":" A consumer chain (either Opt In or Top N) has an owner. An Opt In chain is owned by the address that initially sent and signed the MsgCreateConsumer message. A Top N chain is owned by the governance module and can only be updated through governance proposals.  Note that the owner of a chain can be changed at any later point in time by providing a new_owner_address message in the MsgUpdateConsumer message. As a result, an Opt In chain can change its owner to be the governance module in order to transform to Top N chain, and a Top N chain can change its owner to something that is not the governance module to become an Opt In chain (see below).  ","version":"v6.4.0","tagName":"h2"},{"title":"Launch an Opt In Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.4.0/features/permissionless#launch-an-opt-in-chain","content":" To launch an Opt In chain, we have to send a MsgCreateConsumer message. This message returns the newly created consumerIdassociated with this consumer. The chain is considered to be in the registered phase at this point and its owner is the one that signed the MsgCreateConsumer message. If the optional initialization_parameters are provided in the MsgCreateConsumer, then the chain is considered to be in the initialized phase and the chain can launch at the spawnTime provided in the initialization_parameters.  If no initialization_parameters are provided in MsgCreateConsumer, the consumer can later set those parameters by issuing a MsgUpdateConsumer. The chain would then move to the initialized phase and be slated to launch.  info An Opt In can only launch at spawnTime if at least one validator is opted in at spawnTime.  ","version":"v6.4.0","tagName":"h2"},{"title":"Launch a Top N Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.4.0/features/permissionless#launch-a-top-n-chain","content":" To launch a Top N chain, we need to issue a MsgCreateConsumer to retrieve the consumerId. At this stage, the chain corresponds to an Opt In chain and the owner of the chain is the one that signed the MsgCreateConsumer. For the chain to become Top N we need to issue a message and a governance proposal:  A MsgUpdateConsumer message to change the owner of the chain to be that of the governance module, that is to cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn.A governance proposal that includes a MsgUpdateConsumer that sets the TopN of the consumer chain.  warning If top_N, validators_power_cap, or some other argument is not included in the power-shaping parameters, then it is considered that the default value is set for this argument. For example, if a Top 50% chain wants to only modify validators_power_capfrom 35 to 40, then the power-shaping parameters in MsgUpdateConsumer still need to include that top_N is 50. Otherwisetop_N would be set to its default value of 0, and the chain would become an Opt-In chain. To be safe, if you include power-shaping parameters in the MsgUpdateConsumer, always include top_N and all the power-shaping parameters. The same applies for the initialization parameters.  ","version":"v6.4.0","tagName":"h2"},{"title":"Transform an Opt In Chain to Top N and Vice Versa​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.4.0/features/permissionless#transform-an-opt-in-chain-to-top-n-and-vice-versa","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"From Opt In to Top N​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.4.0/features/permissionless#from-opt-in-to-top-n","content":" This corresponds to the case of launching a Top N chain. The Opt In chain has to issue a MsgUpdateConsumer to change the owner of the consumer to be that of the governance module and to issue a governance proposal that includes a MsgUpdateConsumer and sets the TopN of the consumer chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"From Top N to Opt In​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/v6.4.0/features/permissionless#from-top-n-to-opt-in","content":" A consumer chain can move from Top N to Opt In by issuing a governance proposal that includes a MsgUpdateConsumerthat sets TopN to 0 and also sets the owner of the chain to not be the governance module anymore. ","version":"v6.4.0","tagName":"h3"},{"title":"Power Shaping","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/features/power-shaping","content":"","keywords":"","version":"v6.4.0"},{"title":"Power Shaping Configuration​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.4.0/features/power-shaping#power-shaping-configuration","content":" Currently, ICS supports the following power shaping parameters.  ","version":"v6.4.0","tagName":"h2"},{"title":"Capping the validator set size​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.4.0/features/power-shaping#capping-the-validator-set-size","content":" The consumer chain can specify a maximum number of validators it wants to have in its validator set. This can be used to limit the number of validators in the set, which can be useful for chains that want to have a smaller validator set for faster blocks or lower overhead. If more validators than the maximum size have opted in on a consumer chain, only the validators with the highest power, up to the specified maximum, will validate the consumer chain.  Note that this parameter only applies to Opt In consumer chains (i.e., with Top N = 0).  ","version":"v6.4.0","tagName":"h3"},{"title":"Capping the validator powers​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.4.0/features/power-shaping#capping-the-validator-powers","content":" The consumer chain can specify a power cap which corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. The validators-power cap is intended as a safeguard against a validator having too much power on the consumer chain and hence &quot;taking over&quot; the consumer chain. For example, if the validators-power cap is set to 32%, then no single validator can have more than 32% of the total voting power on the consumer, and thus no single validator would be able to halt the consumer by going offline.  To respect this power cap, the voting powers of the validators that run the consumer chain are decremented or incremented accordingly. It is important to note that the voting powers of validators on the provider do not change. For example, assume that the provider chain has among others, validators A, B, C, and D with voting powers 100, 1, 1, 1 respectively. Assume that only those 4 validators opt in on a consumer chain. Without a power cap set, validator Awould have 100 / (100 + 1 + 1 + 1) = ~97% of the total voting power on the consumer chain, while validators B, C, and D would have 1 /(100 + 1 + 1 + 1) = ~1% of the total voting power on the consumer chain. If the power cap is set to 30%, then the voting power of A would be reduced from 100 to 30 on the consumer chain, the voting power of B would be increased from 1 to 25, and the power of C and D would be increased from 1 to 24. After those modifications, A would have 30 / (30 + 25 + 24 + 24) = ~29% of the total voting power of the consumer chain, B would have 25 / (30 + 25 + 24 + 24) = ~25%, and C and D would both have 24 / (30 + 25 + 24 + 24) = ~23%. Naturally, there are many ways to change the voting powers of validators to respect the power cap, and ICS chooses one of them.  Note that respecting the power cap might NOT always be possible. For example, if we have a consumer chain with only 5 validators and the power cap is set to 10%, then it is not possible to respect the power cap. If the voting power of each validator is capped to a maximum of 10% of the total consumer chain's voting power, then the total voting power of the consumer chain would add up to 50% which obviously does not make sense (percentages should add up to 100%). In cases where it is not feasible to respect the power cap, all validators on the consumer chain will have equal voting power in order to minimize the power of a single validator. Thus, in the example of 5 validators and a power cap set to 10%, all validators would end up having 20% of the total voting power on the consumer chain. Therefore, power-cap operates on a best-effort basis.  Note that rewards are distributed proportionally to validators with respect to their capped voting power on the consumer and not their voting power on the provider. For more information, read on Reward Distribution.  ","version":"v6.4.0","tagName":"h3"},{"title":"Allowlist and denylist​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.4.0/features/power-shaping#allowlist-and-denylist","content":" The consumer chain can specify a list of validators that are allowed or disallowed from participating in the validator set. If an allowlist is set, all validators not on the allowlist cannot validate the consumer chain. If a validator is on both lists, the denylist takes precedence, that is, they cannot validate the consumer chain. By default, both lists are empty -- there are no restrictions on which validators are eligible to opt in.  warning Note that if denylisting is used in a Top N consumer chain, then the chain might not be secured by N% of the total provider's power. For example, consider that the top validator V on the provider chain has 10% of the voting power, and we have a Top 50% consumer chain, then if V is denylisted, the consumer chain would only be secured by at least 40% of the provider's power.  ","version":"v6.4.0","tagName":"h3"},{"title":"Minimum validator stake​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.4.0/features/power-shaping#minimum-validator-stake","content":" The consumer chains can specify a minimum amount of stake that any validator must have on the provider chain to be eligible to opt in. For example, setting this to 1000 would mean only validators with at least 1000 tokens staked on the provider chain can validate the consumer chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"Allow inactive validators​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.4.0/features/power-shaping#allow-inactive-validators","content":" The consumer chains can specify whether validators outside of the provider's active set are eligible to opt in. This can be useful for chains that want to have a larger validator set than the provider chain, or for chains that want to have a more decentralized validator set. Consumer chains that enable this feature should strongly consider setting a minimum validator stake to ensure that only validators with some reputation/stake can validate the chain. By default, this parameter is set to false, i.e., validators outside of the provider's active set are not eligible to opt in.  ","version":"v6.4.0","tagName":"h3"},{"title":"Prioritylist​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.4.0/features/power-shaping#prioritylist","content":" The consumer chain can specify a priority list of validators for participation in the validator set. Validators on the priority list are considered first when forming the consumer chain's validator set. If a priority list isn't set, the remaining slots are filled based on validator power.  ","version":"v6.4.0","tagName":"h3"},{"title":"Setting Power Shaping Parameters​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/v6.4.0/features/power-shaping#setting-power-shaping-parameters","content":" All the power shaping parameters can be set by the consumer chain in the MsgCreateConsumer or MsgUpdateConsumer messages. They operate solely on the provider chain, meaning the consumer chain simply receives the validator set after these rules have been applied and does not have any knowledge about whether they are applied.  When setting power shaping parameters, please consider the following guidelines:  Do not cap the validator set size too low.Notice that this number is the maximum number of validators that will ever validate the consumer chain. If this number is too low, the chain will be very limited in the amount of stake that secures it. The validator set size cap should only be used if there are strong reasons to prefer fewer validators.Be aware of the interaction between capping the validator powers capping the validator set size.For example, if there are only 3 validators, and the cap is 20%, this will not be possible (since even splitting the power fairly would mean that each validator has 33% of the power, so is above the cap). Also note that the smaller this value is, the more the original voting power gets distorted, which could discourage large validators from deciding to opt in to the chain.Do not have allowlist contain too few validators.If the allowlist is non empty, then only validators on the allowlist can validate the chain. Thus, an allowlist containing too few validators is a security risk, e.g., the validators on the allowlist get jailed on the provider.Do not have denylist contain too many validators.If the denylist is non empty, then the validators on the denylist cannot validate the chain. Thus, a denylist containing too many validators is a security risk, e.g., the validators on the denylist represents a large fraction of the provider's power.  In general, when setting these parameters, consider that the voting power distribution in the future might be very different from the one right now, and that the chain should be secure even if the power distribution changes significantly.  The power shaping parameters of a launched consumer chain can be changed through a MsgUpdateConsumer message.  The power shaping parameters can be seen by querying the list of consumer chains:  interchain-security-pd query provider list-consumer-chains  ","version":"v6.4.0","tagName":"h2"},{"title":"Reward Distribution","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/features/reward-distribution","content":"","keywords":"","version":"v6.4.0"},{"title":"Reward distribution with power capping​","type":1,"pageTitle":"Reward Distribution","url":"/interchain-security/v6.4.0/features/reward-distribution#reward-distribution-with-power-capping","content":" If a consumer chain has set a validators-power cap, then the total received rewards are distributed proportionally to validators with respect to their capped voting power on the consumer and notwith respect to their voting power on the provider.  For example, assume that the provider chain has 4 validators, A, B, C, and D with voting powers 100, 1, 1, 1 respectively. So, validators A, B, C, and D have ~97%, ~1%, ~1%, and ~1% of the total voting power of the provider respectively. Now, assume that all those 4 validators opt in on a consumer chain that has set a validators-power cap set to 30%. As a result, validators A, B, C, and D have their powers modified (only) on the consumer chain to 30, 25, 24, and 24 and now have ~29%, ~25%, ~23%, and ~23% of the total voting power of the consumer. Roughly speaking, when rewards are sent from the consumer to the provider, validator A would get ~29% of the rewards because it has 29% of the total voting power on the consumer, regardless of A's 97% of the total power on the provider. Similarly, validator B would get 25% of the rewards, etc.  ","version":"v6.4.0","tagName":"h2"},{"title":"Whitelisting Reward Denoms​","type":1,"pageTitle":"Reward Distribution","url":"/interchain-security/v6.4.0/features/reward-distribution#whitelisting-reward-denoms","content":" The ICS distribution system works by allowing consumer chains to send rewards to a module address on the provider called the ConsumerRewardsPool. Only whitelisted denoms from the ConsumerRewardsPool are then distributed to validators and their delegators.  The whitelisted denoms can be adjusted through governance by sending a MsgChangeRewardDenoms message.MsgChangeRewardDenoms is used to update the set of denoms accepted by the provider as rewards. Note that a MsgChangeRewardDenoms is only accepted on the provider chain if at least one of the denomsToAdd or denomsToRemove fields is populated with at least one denom. Also, a denom cannot be repeated in both sets.  An example of a MsgChangeRewardDenoms message:  { &quot;@type&quot;: &quot;/interchain_security.ccv.provider.v1.MsgChangeRewardDenoms&quot;, &quot;denoms_to_add&quot;: [ &quot;ibc/42C7464F6415DC7529A8C7581FE0991C7A090D60176BC90998B1DAF75B868635&quot; ], &quot;denoms_to_remove&quot;: [], &quot;authority&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot; }   Besides native provider denoms (e.g., uatom for the Cosmos Hub), please use the ibc/* denom trace format. For example, for untrn transferred over the path transfer/channel-569, the denom trace can be queried using the following command:  &gt; gaiad query ibc-transfer denom-hash transfer/channel-569/untrn hash: 0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5   Then use the resulting hash when adding or removing denoms. For example:   &quot;denoms_to_add&quot;: [ &quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot; ]   To query the list of whitelisted reward denoms on the Cosmos Hub, use the following command:  &gt; gaiad q provider registered-consumer-reward-denoms denoms: - ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 - ibc/6B8A3F5C2AD51CD6171FA41A7E8C35AD594AB69226438DB94450436EA57B3A89 - uatom   tip Use the following command to get a human readable denom from the ibc/* denom trace format: &gt; gaiad query ibc-transfer denom-trace ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 denom_trace: base_denom: untrn path: transfer/channel-569  ","version":"v6.4.0","tagName":"h2"},{"title":"Inactive Validators Integration Guide","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/integrators/integrating_inactive_validators","content":"Inactive Validators Integration Guide With the inactive validators feature of Interchain Security, validators outside of the active set on the provider chain can validate on consumer chains that allow this. Technically, this is achieved by increasing the MaxValidators parameter in the staking module, to let additional validators be part of the set of bonded validators. However, to keep the set of validators participating in consensus on the Cosmos Hub the same, we introduce the MaxProviderConsensusValidators parameter in the provider module, which will restrict the number of validators that actively validate on the provider chain. To clarify the terminology: bonded validators are all validators that are bonded on the Cosmos Hub, and active validators are all validators that actively participate in consensus on the Cosmos Hub. Before the introduction of the feature, these two terms were equivalent: every bonded validator was active, and every active validator was bonded. After the introduction of this feature, it still holds that every active validator is bonded, but not every bonded validator is active. Importantly, only active validators receive inflation rewards from ATOM; only active validators may vote on behalf of their delegators in governance, and only active validators can get slashed for downtime (because only those validators participate in consensus and produce blocks). Apart from these differences, bonded but inactive validators are just like active validators - they can receive delegations, and they can validate on consumer chains (and receive rewards for this) just like active validators. The following queries will change after this upgrade: /cosmos/staking/v1beta1/pool / query staking pool The bonded_tokens will include the stake of all bonded validators. As the number of bonded validators will be increased as part of the upgrade, the number of bonded_tokens is expected to have a sudden increase after the upgrade is applied. All queries in the staking module that return a Validator All bonded validators will show with Status=Bonded. To identify active validators, query the validator set from Tendermint (https://docs.cometbft.com/v0.37/rpc/#/Info/validators or query comet-validator-set [height]), which will return the set of all active validators.","keywords":"","version":"v6.4.0"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/introduction/overview","content":"","keywords":"","version":"v6.4.0"},{"title":"Why Interchain Security?​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/introduction/overview#why-interchain-security","content":" Tailored security.Consumer chains can choose the right level of security based on their needs: Chains can choose to inherit the whole validator set from the provider, or they can launch as an opt-in chain with a subset of the provider validators. Additionally, consumer chains have the power to shape the validator set to their specific requirements by setting allow &amp; deny lists, capping its size, etc. This allows for a wide range of security tradeoffs. For example, it enables emerging projects to deploy on consumer chains that don’t need high level of security.Permissionless deployment.Opt-in consumer chains -- consumers that do not compel any validator to participate -- can be launched permissionlessly. User can create and update opt-in consumer chains by submitting transactions to the provider chain. Provider validators that are eligible can opt in on any consumer they wish to validate.Separation of governance from block production.Consumer chains can separate their governance mechanism from block production. Block production is handled by provider validators, which means it is an extension of the proof-of-state (PoS) mechanism on the provider chain. Governance on the consumer chains can rely on the same PoS mechanism (using the same stake locked on the provider), but it doesn't have to. For example, consumer chains can have a governance system based on proof-of-authority (PoA) or on PoS using the consumer token (which would make the consumer token a governance token). This also allows the governance to be more decentralized without affecting consensus (i.e., increasing the number of validators usually leads to slower block production).Distribution of block rewards.Consumer chains can choose how to distribute the block rewards (i.e., inflation and fees), what percentage to send to the provider as payment for block production, and what percentage to keep on-chain. The rewards kept on-chain can then be distributed to the community DAO (the consumer's governance) or can be used in the protocol in other ways.No validator search.Consumer chains do not have their own validator sets, and so do not need to find validators one by one. Validators from the provider chain validate on the consumer chain with their stake on the provider chain, earning additional rewards. For the consumer chain, this comes with the benefit of exposing their chain to the wider audience of the provider chain.Instant sovereignty.Consumers can run arbitrary app logic similar to standalone chains. At any time in the future, a consumer chain can elect to become a completely standalone chain, with its own validator set.Block-space sharding.Consumer chains are Cosmos appchains, which means that transactions on these chains do not compete with any other applications. As a result, there will be no unexpected congestion, and performance will generally be much better than on a shared smart contract platform such as Ethereum.  ","version":"v6.4.0","tagName":"h2"},{"title":"Core protocol​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/introduction/overview#core-protocol","content":" Validator updates. Once an IBC connection and channel are established between a provider and consumer chain, the provider will continually send validator set updates to the consumer over IBC. Note the provider only sends updates for opted in validators. The consumer uses these validator set updates to update its own validator set in the consensus engine (e.g., CometBFT).  Slashing and jailing.If the opted-in validators misbehave on the consumer chains, then they will be punished on the provider chain. ICS currently differentiates between two types of infractions -- double signing and downtime. Double signing on consumer chains results in the misbehaving validators having their provider stake slashed and being permanently jailed on the provider, while downtime on consumer chains results in the misbehaving validators being temporarily jailed. Note that jailing entails removing the validator from the provider active validator set and, consequently, from any of the consumer validator sets. This entails the validator will miss out on both staking and ICS rewards.  Tokenomics and rewards.Consumer chains are free to create their own native token which can be used for fees, and can be created on the consumer chain in the form of inflationary rewards. These rewards can be used to incentivize user behavior, for example, LPing or staking. A percentage of these fees and rewards will be sent to provider chain to be distributed among the opted in validators and their delegators. The percentage is completely customizable by the developers and subject to governance. ","version":"v6.4.0","tagName":"h2"},{"title":"Consumer Initiated Slashing","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/features/slashing","content":"","keywords":"","version":"v6.4.0"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.4.0/features/slashing#downtime-infractions","content":" Downtime infractions are reported by consumer chains and are acted upon on the provider as soon as they are received. The provider will jail and slash the offending validator. The jailing duration and slashing fraction are determined by the consumer's downtime infraction parameters on the provider chain. By default, validators are only jailed for downtime on consumer chains that they opted in to validate on, or in the case of Top N chains, where they are automatically opted in by being in the Top N% of the validator set on the provider.  For preventing malicious consumer chains from harming the provider, slash throttling (also known as jail throttling) ensures that only a fraction of the provider validator set can be jailed at any given time.  ","version":"v6.4.0","tagName":"h2"},{"title":"Equivocation Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.4.0/features/slashing#equivocation-infractions","content":" Equivocation infractions are reported by external agents (e.g., relayers) that can submit to the provider evidence of light client or double signing attacks observed on a consumer chain. The evidence is submitted by sending MsgSubmitConsumerMisbehaviour or MsgSubmitConsumerDoubleVoting messages to the provider. When valid evidence is received, the malicious validators are slashed, jailed, and tombstoned on the provider. The jailing duration and slashing fraction are determined by the consumer's double sign infraction parameters on the provider chain. This is enabled through the cryptographic verification of equivocation feature. For more details, see ADR-005 and ADR-013.  ","version":"v6.4.0","tagName":"h2"},{"title":"Report equivocation infractions through CLI​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.4.0/features/slashing#report-equivocation-infractions-through-cli","content":" The ICS provider module offers two commands for submitting evidence of misbehavior originating from a consumer chain. Below are two examples illustrating the process on Cosmos Hub.  Use the following command to submit evidence of double signing attacks:  gaiad tx provider submit-consumer-double-voting [consumer-id] [path/to/evidence.json] [path/to/infraction_header.json] --from node0 --home ../node0 --chain-id $CID   Example of evidence.json { &quot;vote_a&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;tBBWTqjECl31S/clZGoxLdDqs93kTvy3qhpPqET/laY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;ai2qCLgVZAFph4FJ4Cqw5QW1GZKR4zjOv0bI/Um5AIc=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.565207Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;signature&quot;: &quot;y9yILm9hmv45BZwAaaq9mS1FpH7QeAIJ5Jkcc3U2/k5uks9cuqr4NTIwaIrqMSMKwxVyqiR56xmCT59a6AngAA==&quot; }, &quot;vote_b&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;3P06pszgPatuIdLTP5fDWiase4SYHIq9YXGSbRk9/50=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;S+SbOMxFRzfeNNpX9/jyFMz94VwBKk7Dpx6ZyvSYyNU=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.599273Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;validator_index&quot;: 0, &quot;signature&quot;: &quot;DGFcn4Um1t2kXW60+JhMk5cj7ZFdE5goKVOGiZkLwnNv43+6aGmOWjoq0SHYVzM4MwSwOwbhgZNbkWX+EHGUBw==&quot; }, &quot;total_voting_power&quot;: 300, &quot;validator_power&quot;: 100, &quot;timestamp&quot;: &quot;2023-11-20T12:57:51.267308Z&quot; }   Example of infraction_header.json { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: 11, &quot;app&quot;: 2 }, &quot;chain_id&quot;: &quot;consumer&quot;, &quot;height&quot;: 22, &quot;time&quot;: &quot;2023-11-20T12:57:40.479686Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;L63hyLJ+y9+fpb7WYKdmmBhPHwbfEGQEuKmvGzyBPiY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 18, &quot;hash&quot;: &quot;euzRQjN7MjGtM6skXM4B8wOgAldWGfZSJRA9JRlO42s=&quot; } }, &quot;last_commit_hash&quot;: &quot;qdDJwVziW3pPqmf8QDGZG+5HVd3OF7fCVh2Z8KQqNVU=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;next_validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;last_results_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: 22, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;PKrS32IEZoFY2q2S3iQ68HQL751ieBhf5Eu/Y5Z/QPg=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;8UuA7Oqw5AH/KOacpmHVSMOIDe4l2eC8VmdH2mzcpiM=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076538Z&quot;, &quot;signature&quot;: &quot;bSOH4+Vg2I37zeJphOguGOD0GK3JzM1ghSgJd0UlW/DHn1u9Hvv4EekHuCu6qwRLZcuS/ZxNlmr9qYNfxX3bDA==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:07:00Z&quot;, &quot;signature&quot;: &quot;7bXSDtlOwGK/gLEsFpTWOzm2TFoaARrWQUpbgWEwKtLlUs7iE06TOvJ3yPPfTfqqN/qYnvxxgjl0M0EhUWu5Bg==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076519Z&quot;, &quot;signature&quot;: &quot;Pb6G4bCg4wafmV89WNnzXxbSCknZUHnSQfSCE5QMFxPtSUIN4A7SK5m7yltqMJF5zkyenlFiEI4J3OZ4KCjCAw==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.057451Z&quot;, &quot;signature&quot;: &quot;j3EasIHNYA6MxW/PiWyruzHsjVsBV9t11W6Qx800WMm/+P+CkfR+UZAp7MPTvKZEZFuh3GUsBtyfb/vA+jJWCw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 }, { &quot;address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;UgN2JsjPy2WLh7dzJRBkUQtdgNoT4/uGj7kbIVqqHT8=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;5svW8261x+cZosp2xIhqzgt2tyuawrSDyHlpbgS3BC4=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } }, &quot;trusted_height&quot;: { &quot;revision_height&quot;: 18 }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 }, { &quot;address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;FCmIw7hSuiAoWk/2f4LuGQ+3zx5101xiqU8DoC5wGkg=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;2DrZF0roNnnvEy4NS2aY811ncKg=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;MI9c6sphsWlx0RAHCYOjMRXMFkTUaEYwOiOKG/0tsMs=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;73aN0uOc5b/Zfq2Xcjl0kH2r+tw=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;gWNcDup4mdnsuqET4QeFRzVb+FnSP4Vz3iNMj5wvWXk=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } } }   Use the following command to submit evidence of light client attacks:  gaiad tx provider submit-consumer-misbehaviour [consumer-id] [path/to/misbehaviour.json] --from node0 --home ../node0 --chain-id $CID   Example of misbehaviour.json { &quot;client_id&quot;: &quot;07-tendermint-0&quot;, &quot;header_1&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;W2xVqzPw03ZQ1kAMpcpht9WohwMzsGnyKKNjPYKDF6U=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;PGTquCtnTNFFY5HfEFz9f9pA7PYqjtQfBwHq6cxF/Ux8OI6nVqyadD9a84Xm7fSm6mqdW+T6YVfqIKmIoRjJDQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;0e39yoBorwORAH/K9qJ7D1N1Yr7CutMiQJ+oiIK39eMhuoK3UWzQyMGRLzDOIDupf8yD99mvGVVAlNIODlV3Dg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;lhc2tkwydag9D1iLQhdDCE8GgrHP94M1LbHFYMoL9tExaEq6RiFW/k71TQH5x96XQ9XYOznMIHKC2BDh4GlnAQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;8xeSBf0nSFs/X/rQ9CZLzwkJJhQBLA2jKdPGP3MlULxm992XxrOsIYq47u1daxvSsn6ql5OVYjzBNU0qbPpvCA==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } }, &quot;header_2&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;IZM8NKS+8FHB7CBmgB8Nz7BRVVXiiyqMQDvHFUvgzxo=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;pLIEZ4WSAtnMsgryujheHSq4+YG3RqTfMn2ZxgEymr0wyi+BNlQAKRtRfesm0vfYxvjzc/jhGqtUqHtSIaCwCQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;XG7iTe/spWyTUkT7XDzfLMpYqrdyqizE4/X4wl/W+1eaQp0WsCHYnvPU3x9NAnYfZzaKdonZiDWs7wacbZTcDg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;TqegK7ORuICSy++wVdPHt8fL2WfPlYsMPv1XW79wUdcjnQkezOM50OSqYaP4ua5frIZsn+sWteDrlqFTdkl3BA==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;dhvp3XlIaCxx5MFDs0TCkAPHSm0PS2EtJzYAx2c/7MWdLwUJFZrAUTeimQE2c9i9ro91cjZn/vI0/oFRXab6Aw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } } }   ","version":"v6.4.0","tagName":"h3"},{"title":"Report equivocation infractions with Hermes​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.4.0/features/slashing#report-equivocation-infractions-with-hermes","content":" Ensure you have a well-configured Hermes v1.7.3+ relayer effectively relaying packets between a consumer chain and a provider chain. The following command demonstrates how to run a Hermes instance in evidence mode to detect misbehaviors on a consumer chain and automatically submit the evidence to the provider chain.  hermes evidence --chain &lt;CONSUMER-CHAIN-ID&gt;   Note that hermes evidence takes a --check-past-blocks option giving the possibility to look for older evidence (default is 100).  ","version":"v6.4.0","tagName":"h3"},{"title":"Infraction parameters​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/v6.4.0/features/slashing#infraction-parameters","content":" Jailing and slashing for misbehavior on a consumer chain are governed by parameters defined on the provider chain for that specific consumer chain. To create or update these infraction parameters, use the MsgCreateConsumer or MsgUpdateConsumer messages. When creating a consumer chain, if custom infraction parameters are not specified, default values from the provider are applied. For updates, parameters can be modified immediately if the chain is in the pre-launch phase. If the chain has already launched, the update will be scheduled to take effect after the unbonding period expires. This ensures that changes are applied seamlessly based on the chain's lifecycle. ","version":"v6.4.0","tagName":"h3"},{"title":"Terminology","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/introduction/terminology","content":"","keywords":"","version":"v6.4.0"},{"title":"Shared Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.4.0/introduction/terminology#shared-security","content":" Shared Security is a family of technologies that include optimistic rollups, zk-rollups, sharding and Interchain Security. Basically, any protocol or technology that can allow one blockchain to lend/share its proof-of-stake security with another blockchain or off-chain process.  ","version":"v6.4.0","tagName":"h2"},{"title":"Interchain Security (ICS)​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.4.0/introduction/terminology#interchain-security-ics","content":" Interchain Security is the Cosmos-specific category of Shared Security that uses IBC (Inter-Blockchain Communication).  ","version":"v6.4.0","tagName":"h2"},{"title":"Consumer Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.4.0/introduction/terminology#consumer-chain","content":" Chain that is secured by the validator set of the provider, instead of its own. Interchain Security allows a subset of the provider chain's validator set to validate blocks on the consumer chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"Replicated Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.4.0/introduction/terminology#replicated-security","content":" A particular protocol/implementation of Interchain Security that fully replicates the security and decentralization of a validator set across multiple blockchains. Replicated security has also been referred to as &quot;Interchain Security V1&quot;, a legacy term for the same protocol. That is, a &quot;provider chain&quot; such as the Cosmos Hub can share its exact validator set with multiple consumer chains by communicating changes in its validator set over IBC. Note that since the introduction of Partial Set Security, a TopN consumer chain with N 100% fully replicates the security and decentralization of the provider chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"Partial Set Security (PSS)​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.4.0/introduction/terminology#partial-set-security-pss","content":" A major feature of Interchain Security (also referred to as &quot;Interchain Security V2&quot;) that allows a provider chain to share only a subset of its validator set with a consumer chain. This subset can be determined by the top N% validators by voting power, or by validators opting in to validate the consumer chain. PSS allows for more flexible security tradeoffs than Replicated Security.  ","version":"v6.4.0","tagName":"h2"},{"title":"Permissionless ICS​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.4.0/introduction/terminology#permissionless-ics","content":" Permissionless ICS is the latest version of ICS that allows to launch Opt In chains in a permissionless way (i.e., without requiring a governance proposal).  ","version":"v6.4.0","tagName":"h2"},{"title":"Standalone Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.4.0/introduction/terminology#standalone-chain","content":" Chain that is secured by its own validator set. This chain does not participate in Interchain Security.  ","version":"v6.4.0","tagName":"h2"},{"title":"Changeover Procedure​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.4.0/introduction/terminology#changeover-procedure","content":" Chains that were not initially launched as consumers of Interchain Security can still participate in the protocol and leverage the economic security of the provider chain. The process where a standalone chain transitions to being a replicated consumer chain is called the changeover procedure and is part of the ICS protocol. After the changeover, the new consumer chain will retain all existing state, including the IBC clients, connections and channels already established by the chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"Mesh Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/v6.4.0/introduction/terminology#mesh-security","content":" A protocol built on IBC that allows delegators on a Cosmos chain to re-delegate their stake to validators in another chain's own validator set, using the original chain's token (which remains bonded on the original chain). For a deeper exploration of Mesh Security, see Replicated vs. Mesh Security on the Informal Blog. ","version":"v6.4.0","tagName":"h2"},{"title":"Validator Instructions for Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/validators/changeover-procedure","content":"","keywords":"","version":"v6.4.0"},{"title":"Timeline​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#timeline","content":" Upgrading standalone chains can be best visualised using a timeline, such as the one available Excalidraw graphic by Stride.  There is some flexibility with regards to how the changeover procedure is executed, so please make sure to follow the guides provided by the team doing the changeover.    ","version":"v6.4.0","tagName":"h2"},{"title":"1. ConsumerAdditionProposal on provider chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#1-consumeradditionproposal-on-provider-chain","content":" This step will add the standalone chain to the list of consumer chains secured by the provider. This step dictates the spawn_time. After spawn_time the CCV state (initial validator set of the provider) will be available to the consumer.  To obtain it from the provider use:  gaiad q provider consumer-genesis stride-1 -o json &gt; ccv-state.json jq -s '.[0].app_state.ccvconsumer = .[1] | .[0]' genesis.json ccv-state.json &gt; ccv.json   Transformation of the exported consumer genesis state to the target version of the consumer might be needed in case the provider and consumer formats are incompatible. Refer to the compatibility notes here to check if data transformation is needed for your case. Instructions on how to transform the exported CCV genesis state (ccv-state.json in the example above) to the required target version can be found here  ","version":"v6.4.0","tagName":"h3"},{"title":"2. SoftwareUpgradeProposal on the standalone/consumer chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#2-softwareupgradeproposal-on-the-standaloneconsumer-chain","content":" This upgrade proposal will introduce ICS to the standalone chain, making it a consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"3. Assigning a consumer key​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#3-assigning-a-consumer-key","content":" After spawn_time, make sure to assign a consumer key if you intend to use one.  Instructions are available here  ","version":"v6.4.0","tagName":"h3"},{"title":"4. Perform the software upgrade on standalone chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#4-perform-the-software-upgrade-on-standalone-chain","content":" Please use instructions provided by the standalone chain team and make sure to reach out if you are facing issues. The upgrade preparation depends on your setup, so please make sure you prepare ahead of time.  danger The ccv.json from step 1. must be made available on the machine running the standalone/consumer chain at standalone chain upgrade_height. This file contains the initial validator set and parameters required for normal ICS operation. Usually, the file is placed in $NODE_HOME/config but this is not a strict requirement. The exact details are available in the upgrade code of the standalone/consumer chain.  Performing this upgrade will transition the standalone chain to be a consumer chain.  After 3 blocks, the standalone chain will stop using the &quot;old&quot; validator set and begin using the provider validator set.  ","version":"v6.4.0","tagName":"h3"},{"title":"FAQ​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#faq","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Can I reuse the same validator key for the consumer chain that I am already using on the standalone chain? Will I need to perform a AssignConsumerKey tx with this key before spawn time?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#can-i-reuse-the-same-validator-key-for-the-consumer-chain-that-i-am-already-using-on-the-standalone-chain-will-i-need-to-perform-a-assignconsumerkey-tx-with-this-key-before-spawn-time","content":" Validators must either assign a key or use the same key as on the provider.  If you are validating both the standalone and the provider, you can use your current standalone key with some caveats:  you must submit an AssignConsumerKey tx with your current standalone validator keyit is best to submit AssignConsumerKey tx before spawn_timeif you do not submit the Tx, it is assumed that you will be re-using your provider key to validate the standalone/consumer chain  ","version":"v6.4.0","tagName":"h3"},{"title":"Can I continue using the same node that was validating the standalone chain?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#can-i-continue-using-the-same-node-that-was-validating-the-standalone-chain","content":" Yes.  Please assign your consensus key as stated above.  ","version":"v6.4.0","tagName":"h3"},{"title":"Can I set up a new node to validate the standalone/consumer chain after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#can-i-set-up-a-new-node-to-validate-the-standaloneconsumer-chain-after-it-transitions-to-interchain-security","content":" Yes.  If you are planning to do this please make sure that the node is synced with standalone network and to submit AssignConsumerKey tx before spawn_time.  ","version":"v6.4.0","tagName":"h3"},{"title":"What happens to the standalone validator set after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#what-happens-to-the-standalone-validator-set-after-it-transitions-to-interchain-security","content":" The standalone chain validators will stop being validators after the first 3 blocks are created while using Interchain Security. The standalone validators will become governors and still can receive delegations if the consumer chain is using the consumer-democracy module.  Governors DO NOT VALIDATE BLOCKS.  Instead, they can participate in the governance process and take on other chain-specific roles.  ","version":"v6.4.0","tagName":"h3"},{"title":"Credits​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/v6.4.0/validators/changeover-procedure#credits","content":" Thank you Stride team for providing detailed instructions about the changeover procedure. ","version":"v6.4.0","tagName":"h2"},{"title":"Joining Stride","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/validators/joining-stride","content":"","keywords":"","version":"v6.4.0"},{"title":"Note​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v6.4.0/validators/joining-stride#note","content":" Stride re-uses an existing transfer channel to send consumer rewards to the provider chain, in order to preserve existing transfer IBC denom between stride-1 and cosmoshub-4.  ","version":"v6.4.0","tagName":"h2"},{"title":"Resources​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/v6.4.0/validators/joining-stride#resources","content":" Stride docsChangeover procedure timelineChangeover upgrade docs ","version":"v6.4.0","tagName":"h2"},{"title":"Joining Neutron","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/validators/joining-neutron","content":"","keywords":"","version":"v6.4.0"},{"title":"Resources​","type":1,"pageTitle":"Joining Neutron","url":"/interchain-security/v6.4.0/validators/joining-neutron#resources","content":" Neutron docs ","version":"v6.4.0","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/validators/overview","content":"","keywords":"","version":"v6.4.0"},{"title":"Startup sequence overview​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#startup-sequence-overview","content":" An Opt In consumer chain cannot start and be secured by the validator set of the provider unless there is at least one validator opted in on the chain at spawn_time. A Top N consumer chain cannot start unless the governance proposal containing the MsgUpdateConsumer has passed.  Each chain defines a spawn_time - the timestamp when the consumer chain genesis is finalized and the consumer chain clients get initialized on the provider.  tip Validators are required to run consumer chain binaries only after spawn_time has passed.  Please note that any additional instructions pertaining to specific consumer chain launches will be available before spawn time. The chain start will be stewarded by the Cosmos Hub team and the teams developing their respective consumer chains.  The image below illustrates the startup sequence  ","version":"v6.4.0","tagName":"h2"},{"title":"1. Consumer Chain init + 2. Genesis generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#1-consumer-chain-init--2-genesis-generation","content":" Consumer chain team initializes the chain genesis.json and prepares binaries which will be listed in the initialization parameters of either MsgCreateConsumer or MsgUpdateConsumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"3. Create the chain on the provider​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#3-create-the-chain-on-the-provider","content":" Consumer chain team (or their advocates) submits a MsgCreateConsumer message (and potentially later a governance proposal with a MsgUpdateConsumer message if it is a Top N chain). The most important parameters for validators are:  spawn_time - the time after which the consumer chain must be startedgenesis_hash - hash of the pre-ccv genesis.json; the file does not contain any validator info -&gt; the information is available only after the proposal is passed and spawn_time is reachedbinary_hash - hash of the consumer chain binary used to validate the software builds  ","version":"v6.4.0","tagName":"h3"},{"title":"4. CCV Genesis state generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#4-ccv-genesis-state-generation","content":" After reaching spawn_time the provider chain will automatically create the CCV validator states that will be used to populate the corresponding fields in the consumer chain genesis.json. The CCV validator set consists of the validator set on the provider at spawn_time.  The state can be queried on the provider chain (in this case the Cosmos Hub):   gaiad query provider consumer-genesis &lt;consumer-id&gt; -o json &gt; ccvconsumer_genesis.json   This is used by the launch coordinator to create the final genesis.json that will be distributed to validators in step 5.  ","version":"v6.4.0","tagName":"h3"},{"title":"5. Updating the genesis file​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#5-updating-the-genesis-file","content":" Upon reaching the spawn_time the initial validator set state will become available on the provider chain. The initial validator set is included in the final genesis.json of the consumer chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"6. Chain start​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#6-chain-start","content":" info The consumer chain will start producing blocks as soon as 66.67% of the provider chain's voting power comes online (on the consumer chain). The relayer should be started after block production commences.  The new genesis.json containing the initial validator set will be distributed to validators by the consumer chain team (launch coordinator). Each validator should use the provided genesis.json to start their consumer chain node.  tip Please pay attention to any onboarding repositories provided by the consumer chain teams. Recommendations are available in Consumer Onboarding Checklist. Another comprehensive guide is available in the Interchain Security testnet repo.  ","version":"v6.4.0","tagName":"h3"},{"title":"7. Creating IBC connections​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#7-creating-ibc-connections","content":" Finally, to fully establish interchain security an IBC relayer is used to establish connections and create the required channels.  warning The relayer can establish the connection only after the consumer chain starts producing blocks.  hermes create connection --a-chain &lt;consumer chain ID&gt; --a-client 07-tendermint-0 --b-client &lt;client assigned by provider chain&gt; hermes create channel --a-chain &lt;consumer chain ID&gt; --a-port consumer --b-port provider --order ordered --a-connection connection-0 --channel-version 1 hermes start   ","version":"v6.4.0","tagName":"h3"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#downtime-infractions","content":" At present, the consumer chain can report evidence about downtime infractions to the provider chain. The min_signed_per_window and signed_blocks_window can be different on each consumer chain and are subject to changes via consumer chain governance.  info Causing a downtime infraction on any consumer chain will not incur a slash penalty. Instead, the offending validator will be jailed on the provider chain and consequently on all consumer chains. To unjail, the validator must wait for the jailing period to elapse on the provider chain and submit an unjail transaction on the provider chain. After unjailing on the provider, the validator will be unjailed on all consumer chains. More information is available in Downtime Slashing documentation  ","version":"v6.4.0","tagName":"h2"},{"title":"Double-signing Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#double-signing-infractions","content":" To learn more about equivocation handling in interchain security check out the Slashing documentation section.  ","version":"v6.4.0","tagName":"h2"},{"title":"Key assignment​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#key-assignment","content":" Validators can use different consensus keys on the provider and each of the consumer chains. The consumer chain consensus key must be registered on the provider before use.  For more information check out the Key assignment overview and guide  ","version":"v6.4.0","tagName":"h2"},{"title":"References:​","type":1,"pageTitle":"Overview","url":"/interchain-security/v6.4.0/validators/overview#references","content":" Cosmos Hub Validators FAQCosmos Hub Running a validatorStartup SequenceSubmit Unjailing Transaction ","version":"v6.4.0","tagName":"h2"},{"title":"Joining Interchain Security testnet","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/validators/joining-testnet","content":"","keywords":"","version":"v6.4.0"},{"title":"Introduction​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.4.0/validators/joining-testnet#introduction","content":" This short guide will teach you how to join the Interchain Security testnet.  The experience gained in the testnet will prepare you for validating interchain secured chains.  tip Provider and consumer chain represent distinct networks and infrastructures operated by the same validator set. For general information about running cosmos-sdk based chains check out the validator basics and Running a Node section of Cosmos SDK docs  ","version":"v6.4.0","tagName":"h2"},{"title":"Joining the provider chain​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.4.0/validators/joining-testnet#joining-the-provider-chain","content":" A comprehensive guide is available here.  ","version":"v6.4.0","tagName":"h2"},{"title":"Initialization​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.4.0/validators/joining-testnet#initialization","content":" First, initialize your $NODE_HOME using the provider chain binary.  NODE_MONIKER=&lt;your_node&gt; CHAIN_ID=provider NODE_HOME=&lt;path_to_your_home&gt; gaiad init $NODE_MONIKER --chain-id $CHAIN_ID --home $NODE_HOME   Add your key to the keyring - more details available here.  In this example we will use the test keyring-backend. This option is not safe to use in production.  gaiad keys add &lt;key_moniker&gt; --keyring-backend test # save the address as variable for later use MY_VALIDATOR_ADDRESS=$(gaiad keys show my_validator -a --keyring-backend test)   Before issuing any transactions, use the provider testnet faucet to add funds to your address.  curl https://faucet.rs-testnet.polypore.xyz/request?address=$MY_VALIDATOR_ADDRESS&amp;chain=provider # example output: { &quot;address&quot;: &quot;cosmos17p3erf5gv2436fd4vyjwmudakts563a497syuz&quot;, &quot;amount&quot;: &quot;10000000uatom&quot;, &quot;chain&quot;: &quot;provider&quot;, &quot;hash&quot;: &quot;10BFEC53C80C9B649B66549FD88A0B6BCF09E8FCE468A73B4C4243422E724985&quot;, &quot;status&quot;: &quot;success&quot; }   Then, use the account associated with the keyring to issue a create-validator transaction which will register your validator on chain.  gaiad tx staking create-validator \\ --amount=1000000uatom \\ --pubkey=$(gaiad tendermint show-validator) \\ --moniker=&quot;choose a moniker&quot; \\ --chain-id=$CHAIN_ID&quot; \\ --commission-rate=&quot;0.10&quot; \\ --commission-max-rate=&quot;0.20&quot; \\ --commission-max-change-rate=&quot;0.01&quot; \\ --min-self-delegation=&quot;1000000&quot; \\ --gas=&quot;auto&quot; \\ --gas-prices=&quot;0.0025uatom&quot; \\ --from=&lt;key_moniker&gt;   tip Check this guide to edit your validator.  After this step, your validator is created and you can start your node and catch up to the rest of the network. It is recommended that you use statesync to catch up to the rest of the network.  You can use this script to modify your config.toml with the required statesync parameters.  # create the statesync script $: cd $NODE_HOME $: touch statesync.sh $ chmod 700 statesync.sh # make executable   Paste the following instructions into the statesync.sh:  #!/bin/bash SNAP_RPC=&quot;https://rpc.provider-state-sync-01.rs-testnet.polypore.xyz:443&quot; LATEST_HEIGHT=$(curl -s $SNAP_RPC/block | jq -r .result.block.header.height); \\ BLOCK_HEIGHT=$((LATEST_HEIGHT - 2000)); \\ TRUST_HASH=$(curl -s &quot;$SNAP_RPC/block?height=$BLOCK_HEIGHT&quot; | jq -r .result.block_id.hash) sed -i.bak -E &quot;s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1true| ; \\ s|^(rpc_servers[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$SNAP_RPC,$SNAP_RPC\\&quot;| ; \\ s|^(trust_height[[:space:]]+=[[:space:]]+).*$|\\1$BLOCK_HEIGHT| ; \\ s|^(trust_hash[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$TRUST_HASH\\&quot;|&quot; $NODE_HOME/config/config.toml   Then, you can execute the script:  $: ./statesync.sh # setup config.toml for statesync   Finally, copy the provider genesis and start your node:  $: GENESIS_URL=https://github.com/cosmos/testnets/raw/master/interchain-security/provider/provider-genesis.json $: wget $GENESIS_URL -O genesis.json $: genesis.json $NODE_HOME/config/genesis.json # start the service $: gaiad start --x-crisis-skip-assert-invariants --home $NODE_HOME --p2p.seeds=&quot;08ec17e86dac67b9da70deb20177655495a55407@provider-seed-01.rs-testnet.polypore.xyz:26656,4ea6e56300a2f37b90e58de5ee27d1c9065cf871@provider-seed-02.rs-testnet.polypore.xyz:26656&quot;   Additional scripts to setup your nodes are available here and here. The scripts will configure your node and create the required services - the scripts only work in linux environments.  ","version":"v6.4.0","tagName":"h2"},{"title":"Joining consumer chains​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.4.0/validators/joining-testnet#joining-consumer-chains","content":" tip We strongly recommend that you assign a separate key for each consumer chain. Check out this guide to learn more about key assignment in interchain security.  To join consumer chains, simply replicate the steps above for each consumer using the correct consumer chain binaries.  info When running the provider chain and consumers on the same machine please update the PORT numbers for each of them and make sure they do not overlap (otherwise the binaries will not start). Important ports to re-configure: --rpc.laddr--p2p.laddr--api.address--grpc.address--grpc-web.address  ","version":"v6.4.0","tagName":"h2"},{"title":"Re-using consensus key​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.4.0/validators/joining-testnet#re-using-consensus-key","content":" To reuse the key on the provider and consumer chains, simply initialize your consumer chain and place the priv_validator_key.json into the home directory of your consumer chain (&lt;consumer_home&gt;/config/priv_validator_key.json).  When you start the chain, the consensus key will be the same on the provider and the consumer chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"Assigning consensus keys​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/v6.4.0/validators/joining-testnet#assigning-consensus-keys","content":" Whenever you initialize a new node, it will be configured with a consensus key you can use.  # machine running consumer chain consumerd init &lt;node_moniker&gt; --home &lt;home_path&gt; --chain-id consumer-1 # use the output of this command to get the consumer chain consensus key consumerd tendermint show-validator # output: {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, let the provider know which key you will be using for the consumer chain:  # machine running the provider chain gaiad tx provider assign-consensus-key consumer-id '&lt;consumer_pubkey&gt;' --from &lt;key_moniker&gt; --home $NODE_HOME --gas 900000 -b sync -y -o json   After this step, you are ready to copy the consumer genesis into your nodes's /config folder, start your consumer chain node and catch up to the network. ","version":"v6.4.0","tagName":"h2"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators","content":"","keywords":"","version":"v6.4.0"},{"title":"Messages​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#messages","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"How to opt in to a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#how-to-opt-in-to-a-consumer-chain","content":" warning A validator is automatically opted in to a Top N chain if the validator belongs to the top N% of the validators on the provider chain.  In a Top N chain, a validator that does not belong to the top N% of the validators on the provider can still choose to opt in to a consumer chain. In other words, validators can opt in, in both Opt-In and Top N chains.  A validator can opt in to a consumer chain by issuing the following message:  interchain-security-pd tx provider opt-in &lt;consumer-id&gt; &lt;optional consumer-pub-key&gt;   where  consumer-id is the consumer id identifier of the consumer chain the validator wants to opt in to;consumer-pub-key corresponds to the public key the validator wants to use on the consumer chain, and it has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}.  A validator can opt in to any active consumer chain, so a validator can opt in to a chain even before it launches. A validator can use the following command to retrieve the currently existing consumer chains:  interchain-security-pd query provider list-consumer-chains   By setting the consumer-pub-key, a validator can both opt in to a chain and assign a public key on a consumer chain. Note that a validator can always assigna new consumer key at a later stage. The key-assignment rulesstill apply when setting consumer-pub-key when opting in.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  Note that a validator is only eligible for consumer rewards from a consumer chain if the validator is opted into that chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"How to opt out from a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#how-to-opt-out-from-a-consumer-chain","content":" A validator can opt out from a consumer by issuing the following message:  interchain-security-pd tx provider opt-out &lt;consumer-chain-id&gt;   where  consumer-id is the consumer identifier of the consumer chain.  The opting out mechanism has the following rules:  A validator cannot opt out from a Top N chain if it belongs to the top N% validators of the provider.If a validator moves from the Top N to outside of the top N% of the validators on the provider, it will notbe automatically opted-out. The validator has to manually opt out.A validator should stop its node on a consumer chain only after opting out and confirming through the has-to-validatequery (see below) that it does not have to validate the consumer chain any longer. Otherwise, the validator risks getting jailed for downtime.  warning If all validators opt out from an Opt-In chain, the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"v6.4.0","tagName":"h3"},{"title":"How to set specific per consumer chain commission rate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#how-to-set-specific-per-consumer-chain-commission-rate","content":" A validator can choose to set a different commission rate on each of the consumer chains. This can be done with the following command:  interchain-security-pd tx provider set-consumer-commission-rate &lt;consumer-id&gt; &lt;commission-rate&gt;   where  consumer-id is the consumer identifier of the consumer chain;comission-rate decimal in [minRate, 1] where minRate corresponds to the minimum commission rate set on the provider chain (see min_commission_rate in interchain-security-pd query staking params).  If a validator does not set a commission rate on a consumer chain, the commission rate defaults to their commission rate on the provider chain.  Validators can set their commission rate even for consumer chains that they are not currently opted in on, and the commission rate will be applied when they opt in. This is particularly useful for Top N chains, where validators might be opted in automatically, so validators can set the commission rate in advance.  If a validator opts out and then back in, this will not reset their commission rate back to the default. Instead, their set commission rate still applies.  ","version":"v6.4.0","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#queries","content":" PSS introduces a number of queries to assist validators in determining which consumer chains they have to validate, their commission rate per chain, etc.  ","version":"v6.4.0","tagName":"h2"},{"title":"Which chains does a validator have to validate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#which-chains-does-a-validator-have-to-validate","content":" Naturally, a validator is aware of the Opt-In chains it has to validate because in order to validate an Opt-In chain, a validator has to manually opt in to the chain. This is not the case for Top N chains where a validator might be required to validate such a chain without explicitly opting in if it belongs to the top N% of the validators on the provider.  We introduce the following query:  interchain-security-pd query provider has-to-validate &lt;provider-validator-address&gt;   that can be used by validator with provider-validator-address address to retrieve the list of chains that it has to validate.  warning For a validator, the list of chains returned by has-to-validate is the list of chains the validator should be validating to avoid getting jailed for downtime.  ","version":"v6.4.0","tagName":"h3"},{"title":"How do you know how much voting power you need to have to be in the top N for a chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#how-do-you-know-how-much-voting-power-you-need-to-have-to-be-in-the-top-n-for-a-chain","content":" This can be seen as part of the list-consumer-chains query:  interchain-security-pd query provider list-consumer-chains   where the min_power_in_top_N field shows the minimum voting power required to be automatically opted in to the chain.  Note that list-consumer-chains shows the minimal voting power right now, but the automatic opt-in happens only when epochs end on the provider. In consequence, a validators power might be large enough to be automatically opted in during an epoch, but if their power is sufficiently decreased before the epoch ends, they will not be opted in automatically.  ","version":"v6.4.0","tagName":"h3"},{"title":"How to retrieve all the opted-in validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-opted-in-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-opted-in-validators &lt;consumer-id&gt;   we can see all the opted-in validators on consumer-id that were manually or automatically opted in.  ","version":"v6.4.0","tagName":"h3"},{"title":"How to retrieve all the consumer validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#how-to-retrieve-all-the-consumer-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-validators &lt;consumer-id&gt;   we can see all the consumer validators (i.e., validator set) of consumer-id. The consumer validators are the ones that are currently (or in the future, see warning) validating the consumer chain. A consumer validator is an opted-in validator but not vice versa. For example, an opted-in validator V might not be a consumer validator because V is denylisted or because V is removed due to a validator-set cap.  Note that the returned consumer validators from this query do not necessarily correspond to the validator set that is validating the consumer chain at this exact moment. This is because the VSCPacket sent to a consumer chain might be delayed and hence this query might return the validator set that the consumer chain would have at some future point in time.  ","version":"v6.4.0","tagName":"h3"},{"title":"How can we see the commission rate a validator has set on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/v6.4.0/validators/partial-set-security-for-validators#how-can-we-see-the-commission-rate-a-validator-has-set-on-a-consumer-chain","content":" Using the following query:  interchain-security-pd query provider validator-consumer-commission-rate &lt;consumer-id&gt; &lt;provider-validator-address&gt;   we retrieve the commission rate set by validator with provider-validator-address address on consumer-id. ","version":"v6.4.0","tagName":"h3"},{"title":"Consumer chain validator rewards","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/validators/withdraw_rewards","content":"","keywords":"","version":"v6.4.0"},{"title":"Withdrawing rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.4.0/validators/withdraw_rewards#withdrawing-rewards","content":" Here are example steps for withdrawing rewards from consumer chains in the provider chain  info The examples used are from rs-testnet, the Interchain Security persistent testnet. Validator operator address: cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6Self-delegation address: cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf  Prior to withdrawing rewards, query balances for self-delegation address:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;1000000000000&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;   ","version":"v6.4.0","tagName":"h2"},{"title":"Querying validator rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.4.0/validators/withdraw_rewards#querying-validator-rewards","content":" Query rewards for the validator address:  gaiad q distribution rewards cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 rewards: - amount: &quot;158.069895000000000000&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;841842390516.072526500000000000&quot; denom: uatom   The ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD denom represents rewards from a consumer chain.  ","version":"v6.4.0","tagName":"h2"},{"title":"Withdrawing rewards and commission​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.4.0/validators/withdraw_rewards#withdrawing-rewards-and-commission","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"1. Withdraw rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.4.0/validators/withdraw_rewards#1-withdraw-rewards","content":" gaiad tx distribution withdraw-rewards cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 --from cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf --commission --chain-id provider --gas auto --fees 500uatom -b block -y txhash: A7E384FB1958211B43B7C06527FC7D4471FB6B491EE56FDEA9C5634D76FF1B9A   ","version":"v6.4.0","tagName":"h3"},{"title":"2. Confirm withdrawal​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/v6.4.0/validators/withdraw_rewards#2-confirm-withdrawal","content":" After withdrawing rewards self-delegation address balance to confirm rewards were withdrawn:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;216&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;2233766225342&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;  ","version":"v6.4.0","tagName":"h3"},{"title":"ADR 001: Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-001-key-assignment","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#changelog","content":" 2022-12-01: Initial Draft2024-03-01: Updated to take into account they key-assigment-replacement deprecation.  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#context","content":" KeyAssignment is the name of the feature that allows validator operators to use different consensus keys for each consumer chain validator node that they operate.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#decision","content":" It is possible to change the keys at any time by submitting a transaction (i.e., MsgAssignConsumerKey).  ","version":"Next","tagName":"h2"},{"title":"State required​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#state-required","content":" ValidatorConsumerPubKey - Stores the validator assigned keys for every consumer chain.  ConsumerValidatorsBytePrefix | len(chainID) | chainID | providerConsAddress -&gt; consumerKey   ValidatorByConsumerAddr - Stores the mapping from validator addresses on consumer chains to validator addresses on the provider chain. Needed for the consumer initiated slashing sub-protocol.  ValidatorsByConsumerAddrBytePrefix | len(chainID) | chainID | consumerConsAddress -&gt; providerConsAddress   ConsumerAddrsToPrune - Stores the mapping from VSC ids to consumer validators addresses. Needed for pruning ValidatorByConsumerAddr.  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; []consumerConsAddresses   ","version":"Next","tagName":"h3"},{"title":"Protocol overview​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#protocol-overview","content":" On receiving a MsgAssignConsumerKey(chainID, providerAddr, consumerKey) message:  // get validator from staking module validator, found := stakingKeeper.GetValidator(providerAddr) if !found { return ErrNoValidatorFound } providerConsAddr := validator.GetConsAddr() // make sure consumer key is not in use consumerAddr := utils.TMCryptoPublicKeyToConsAddr(consumerKey) if _, found := GetValidatorByConsumerAddr(ChainID, consumerAddr); found { return ErrInvalidConsumerConsensusPubKey } // check whether the consumer chain is already registered // i.e., a client to the consumer was already created if _, consumerRegistered := GetConsumerClientId(chainID); consumerRegistered { // get the previous key assigned for this validator on this consumer chain oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr) if found { // mark this old consumer key as prunable once the VSCMaturedPacket // for the current VSC ID is received oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) vscID := GetValidatorSetUpdateId() AppendConsumerAddrsToPrune(chainID, vscID, oldConsumerAddr) } } else { // if the consumer chain is not registered, then remove the previous reverse mapping if oldConsumerKey, found := GetValidatorConsumerPubKey(chainID, providerConsAddr); found { oldConsumerAddr := utils.TMCryptoPublicKeyToConsAddr(oldConsumerKey) DeleteValidatorByConsumerAddr(chainID, oldConsumerAddr) } } // set the mapping from this validator's provider address to the new consumer key SetValidatorConsumerPubKey(chainID, providerConsAddr, consumerKey) // set the reverse mapping: from this validator's new consensus address // on the consumer to its consensus address on the provider SetValidatorByConsumerAddr(chainID, consumerAddr, providerConsAddr)   When a new consumer chain is registered, i.e., a client to the consumer chain is created, the provider constructs the consumer CCV module part of the genesis state (see MakeConsumerGenesis).  func (k Keeper) MakeConsumerGenesis(chainID string) (gen consumertypes.GenesisState, nextValidatorsHash []byte, err error) { // ... // get initial valset from the staking module var updates []abci.ValidatorUpdate{} stakingKeeper.IterateLastValidatorPowers(func(providerAddr sdk.ValAddress, power int64) (stop bool) { validator := stakingKeeper.GetValidator(providerAddr) providerKey := validator.TmConsPublicKey() updates = append(updates, abci.ValidatorUpdate{PubKey: providerKey, Power: power}) return false }) // applies the key assignment to the initial validator for i, update := range updates { providerAddr := utils.TMCryptoPublicKeyToConsAddr(update.PubKey) if consumerKey, found := GetValidatorConsumerPubKey(chainID, providerAddr); found { updates[i].PubKey = consumerKey } } gen.InitialValSet = updates // get a hash of the consumer validator set from the update updatesAsValSet := tendermint.PB2TM.ValidatorUpdates(updates) hash := tendermint.NewValidatorSet(updatesAsValSet).Hash() return gen, hash, nil }   Note that key assignment works hand-in-hand with epochs. For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. Specifically, for each validator in the set we store among others, the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacketwith all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   where DiffValidators internally checks if the consumer public key for a validator has changed since the last epoch and if so generates a validator update. This way, a validator can change its consumer public key for a consumer chain an arbitrary amount of times and only the last set consumer public key would be taken into account.  On receiving a SlashPacket from a consumer chain with id chainID for a infraction of a validator data.Validator:  func HandleSlashPacket(chainID string, data ccv.SlashPacketData) (success bool, err error) { // ... // the slash packet validator address may be known only on the consumer chain; // in this case, it must be mapped back to the consensus address on the provider chain consumerAddr := sdk.ConsAddress(data.Validator.Address) providerAddr, found := GetValidatorByConsumerAddr(chainID, consumerAddr) if !found { // the validator has the same key on the consumer as on the provider providerAddr = consumerAddr } // ... }   On receiving a VSCMatured:  func OnRecvVSCMaturedPacket(packet channeltypes.Packet, data ccv.VSCMaturedPacketData) exported.Acknowledgement { // ... // prune previous consumer validator address that are no longer needed consumerAddrs := GetConsumerAddrsToPrune(chainID, data.ValsetUpdateId) for _, addr := range consumerAddrs { DeleteValidatorByConsumerAddr(chainID, addr) } DeleteConsumerAddrsToPrune(chainID, data.ValsetUpdateId) // ... }   On stopping a consumer chain:  func (k Keeper) StopConsumerChain(ctx sdk.Context, chainID string, closeChan bool) (err error) { // ... // deletes all the state needed for key assignments on this consumer chain // ... }   ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#positive","content":" Validators can use different consensus keys on the consumer chains.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#negative","content":" None  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#neutral","content":" The consensus state necessary to create a client to the consumer chain must use the hash returned by the MakeConsumerGenesis method as the nextValsHash.The consumer chain can no longer check the initial validator set against the consensus state on InitGenesis.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 001: Key Assignment","url":"/interchain-security/adrs/adr-001-key-assignment#references","content":" Key assignment issue ","version":"Next","tagName":"h2"},{"title":"ADR 003: Equivocation governance proposal","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal#changelog","content":" 2023-02-06: Initial draft2023-11-30: Change status to deprecated  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal#status","content":" Deprecated  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal#context","content":" Note: ADR deprecated as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  We want to limit the possibilities of a consumer chain to execute actions on the provider chain to maintain and ensure optimum security of the provider chain.  For instance, a malicious consumer consumer chain can send slash packet to the provider chain, which will slash a validator without the need of providing an evidence.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal#decision","content":" To protect against a malicious consumer chain, slash packets unrelated to downtime are ignored by the provider chain. Thus, an other mechanism is required to punish validators that have committed a double-sign on a consumer chain.  A new kind of governance proposal is added to the provider module, allowing to slash and tombstone a validator for double-signing in case of any harmful action on the consumer chain.  If such proposal passes, the proposal handler delegates to the evidence module to process the equivocation. This module ensures the evidence isn’t too old, or else ignores it (see code). Too old is determined by 2 consensus params :  evidence.max_age_duration number of nanoseconds before an evidence is considered too oldevidence.max_age_numblocks number of blocks before an evidence is considered too old.  On the hub, those parameters are equals to  // From https://cosmos-rpc.polkachu.com/consensus_params?height=13909682 (...) &quot;evidence&quot;: { &quot;max_age_num_blocks&quot;: &quot;1000000&quot;, &quot;max_age_duration&quot;: &quot;172800000000000&quot;, (...) }, (...)   A governance proposal takes 14 days, so those parameters must be big enough so the evidence provided in the proposal is not ignored by the evidence module when the proposal passes and is handled by the hub.  For max_age_num_blocks=1M, the parameter is big enough if we consider the hub produces 12k blocks per day (blocks_per_year/365 = 436,0000/365). The evidence can be up to 83 days old (1,000,000/12,000) and not be ignored.  For max_age_duration=172,800,000,000,000, the parameter is too low, because the value is in nanoseconds so it’s 2 days. Fortunately the condition that checks those 2 parameters uses a AND, so if max_age_num_blocks condition passes, the evidence won’t be ignored.  ","version":"Next","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal#positive","content":" Remove the possibility from a malicious consumer chain to “attack” the provider chain by slashing/jailing validators.Provide a more acceptable implementation for the validator community.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal#negative","content":" Punishment action of double-signing isn’t “automated”, a governance proposal is required which takes more time.You need to pay 250ATOM to submit an equivocation evidence.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal#neutral","content":" ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 003: Equivocation governance proposal","url":"/interchain-security/adrs/adr-003-equivocation-gov-proposal#references","content":" PR that ignores non downtime slash packet : https://github.com/cosmos/interchain-security/pull/692PR that adds the governance slash proposal: https://github.com/cosmos/interchain-security/pull/703 ","version":"Next","tagName":"h2"},{"title":"ADR 004: Denom DOS fixes","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-004-denom-dos-fixes","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/adrs/adr-004-denom-dos-fixes#changelog","content":" 5/9/2023: ADR created  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/adrs/adr-004-denom-dos-fixes#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/adrs/adr-004-denom-dos-fixes#context","content":" The provider and consumer modules are vulnerable to similar issues involving an attacker sending millions of denoms to certain addresses and causing the chain to halt. This ADR outlines both fixes since they are similar. Both fixes involve processing only denoms that are on a whitelist to avoid iterating over millions of junk denoms but have different requirements and are implemented in different ways.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/adrs/adr-004-denom-dos-fixes#decision","content":" ","version":"Next","tagName":"h2"},{"title":"Provider​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/adrs/adr-004-denom-dos-fixes#provider","content":" Put the distribution module's FeePoolAddress back on the blocklist so that it cannot receive funds from users.Create a new address called ConsumerRewardPool and unblock it, allowing funds to be sent to it.Create a set of strings in the store for allowed ConsumerRewardDenoms.Create an endpoint called RegisterConsumerRewardDenom which deducts a fee from the sender's account, sends it to the community pool and adds a string to the ConsumerRewardDenoms set.Create a parameter called ConsumerRewardDenomRegistrationFee which determines the fee which is charged to register a consumer reward denom in the step above.Create a function called TransferRewardsToFeeCollector which gets the entire ConsumerRewardDenoms set from the store, iterates over it, and for each entry: Gets the balance of this denom for the ConsumerRewardPool accountSends the entire balance out to the FeePoolAddress using SendCoinsFromModuleToModule which is not affected by the blocklist. Run TransferRewardsToFeeCollector in the endblock  Now, nobody can send millions of junk denoms to the FeePoolAddress because it is on the block list. If they send millions of junk denoms to the ConsumerRewardPool, this does not matter because all balances are not iterated over, only those which are in the ConsumerRewardDenoms set.  We also add a new tx: register-consumer-reward-denom, and a new query: registered-consumer-reward-denoms  ","version":"Next","tagName":"h3"},{"title":"Consumer​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/adrs/adr-004-denom-dos-fixes#consumer","content":" Create a new param RewardDenoms with a list of stringsCreate a new param ProviderRewardDenoms with a list of stringsCreate a function AllowedRewardDenoms which iterates over ProviderRewardDenoms and converts each denom to its ibc-prefixed denom using the provider chain's ibc channel information, then concatenates the RewardDenoms list and returns the combined list of allowed denoms.In SendRewardsToProvider, instead of iterating over the balances of all denoms in the ToSendToProvider address, iterate over AllowedRewardDenoms  Now, if somebody sends millions of junk denoms to ToSendToProvider, they will not be iterated over. Only the RewardDenoms and ProviderRewardDenoms will be iterated over. Since we do not require this feature to be permissionless on the consumer, the registration fee process is not needed.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/adrs/adr-004-denom-dos-fixes#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/adrs/adr-004-denom-dos-fixes#positive","content":" Denom DOS is no longer possible on either provider or consumer.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 004: Denom DOS fixes","url":"/interchain-security/adrs/adr-004-denom-dos-fixes#negative","content":" Consumer chain teams must pay a fee to register a denom for distribution on the provider, and add some extra parameters in their genesis file. ","version":"Next","tagName":"h3"},{"title":"ADR 002: Jail Throttling","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-002-throttle","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#changelog","content":" 2023-01-26: Initial Draft2023-02-07: Property refined, ADR ready to review/merge2023-11-22: Refactor for better understanding  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#context","content":" The CCV spec is based around the assumption that the provider binary and all consumers binaries are non-malicious, and follow the defined protocols. In practice, this assumption may not hold. A malicious consumer binary could potentially include code which is able to send many slash/jail packets at once to the provider.  Before the throttling feature was implemented, the following attack was possible. Attacker(s) would create provider validators just below the provider's active set. Using a malicious consumer binary, slash packets would be relayed to the provider, that would slash/jail a significant portion (or all) of honest validator at once. Control of the provider would then pass over to the attackers' validators. This enables the attacker(s) to halt the provider. Or even worse, commit arbitrary state on the provider, potentially stealing all tokens bridged to the provider over IBC.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#decision","content":" The throttling feature was designed to slow down the mentioned attack from above, allowing validators and the community to appropriately respond to the attack, i.e., this feature limits (enforced by on-chain params) the rate that the provider validator set can be jailed over time.  ","version":"Next","tagName":"h2"},{"title":"Required State​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#required-state","content":" Slash meter: There exists one slash meter on the provider which stores an amount of voting power (integer), corresponding to an allowance of validators that can be jailed over time. This meter is initialized to a certain value on genesis, decremented by the amount of voting power jailed whenever a slash packet is handled, and periodically replenished as decided by on-chain params.  Global entry queue: There exists a single queue which stores &quot;global slash entries&quot;. These entries allow the provider to appropriately handle slash packets sent from any consumer in FIFO ordering. This queue is responsible for coordinating the order that slash packets (from multiple chains) are handled over time.  Per-chain data queue: For each established consumer, there exists a queue which stores &quot;throttled packet data&quot;, i.e.,pending slash packet data is queued together with pending VSC matured packet data in FIFO ordering. Order is enforced by IBC sequence number. These &quot;per-chain&quot; queues are responsible for coordinating the order that slash packets are handled in relation to VSC matured packets from the same chain.  Note: The reason for a multiple-queue design is the VSC Maturity and Slashing Order property (see spec). There are other ways to ensure such a property (like a queue of linked lists, etc.), but the proposed approach seemed to be the most understandable and easiest to implement with a KV store.  ","version":"Next","tagName":"h3"},{"title":"Params​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#params","content":" SlashMeterReplenishPeriod -- the period after which the slash meter is replenished.  SlashMeterReplenishFraction -- the portion (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs. This param also serves as a maximum fraction of total voting power that the slash meter can hold.  MaxThrottledPackets -- the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value. This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness.  ","version":"Next","tagName":"h3"},{"title":"Protocol Overview​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#protocol-overview","content":" OnRecvSlashPacket​  Upon the provider receiving a slash packet from any of the established consumers during block execution, two things occur:  A global slash entry is queued.The data of such a packet is added to the per-chain queue.  OnRecvVSCMaturedPacket​  Upon the provider receiving a VSCMatured packet from any of the established consumers during block execution, the VSCMatured packet data is added to the per-chain queue.  Endblocker​  In the EndBlock of the provider CCV module, there are three actions performed:  replenish the slash meter;handle the leading VSCMaturedPackets;and handle the throttle queues.  Slash Meter Replenishment​  Once the slash meter becomes not full, it'll be replenished after SlashMeterReplenishPeriod by incrementing the meter with its allowance for the replenishment block, where allowance = SlashMeterReplenishFraction * currentTotalVotingPower. The slash meter will never exceed its current allowance (function of the total voting power for the block) in value.  Note a few things:  The slash meter can go negative in value, and will do so when handling a single slash packet that jails a validator with significant voting power. In such a scenario, the slash meter may take multiple replenishment periods to once again reach a positive value (or 0), meaning no other slash packets may be handled for multiple replenishment periods.Total voting power of a chain changes over time, especially as validators are jailed. As validators are jailed, total voting power decreases, and so does the jailing allowance. See below for more detailed throttling property discussion.The voting power allowance added to the slash meter during replenishment will always be greater than or equal to 1. If the SlashMeterReplenishFraction is set too low, integer rounding will put this minimum value into effect. That is, if SlashMeterReplenishFraction * currentTotalVotingPower &lt; 1, then the effective allowance would be 1. This min value of allowance ensures that there's some packets handled over time, even if that is a very long time. It's a crude solution to an edge case caused by too small of a replenishment fraction.  The behavior described above is achieved by executing CheckForSlashMeterReplenishment() every EndBlock, BEFORE HandleThrottleQueues() is executed.  Handle Leading VSCMaturedPackets​  In every block, it is possible that VSCMaturedPacket data was queued before any slash packet data. Since this &quot;leading&quot; VSCMatured packet data does not have to be throttled (see VSC Maturity and Slashing Order), we can handle all VSCMatured packet data at the head of the queue, before the any throttling or packet data handling logic executes.  Handle Throttle Queues​  In every EndBlock, the following logic is executed to handle data from the throttle queues.  meter := getSlashMeter() // Keep iterating as long as the meter has a positive (or 0) value, and global slash entries exist while meter.IsPositiveOrZero() &amp;&amp; entriesExist() { // Get next entry in queue entry := getNextGlobalSlashEntry() // Decrement slash meter by the voting power that will be removed from the valset from handling this slash packet valPower := entry.getValPower() meter = meter - valPower // Using the per-chain queue, handle the single slash packet using its queued data, // then handle all trailing VSCMatured packets for this consumer handleSlashPacketAndTrailingVSCMaturedPackets(entry) // Delete entry in global queue, delete handled data entry.Delete() deleteThrottledSlashPacketData() deleteTrailingVSCMaturedPacketData() }   ","version":"Next","tagName":"h3"},{"title":"System Properties​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#system-properties","content":" All CCV system properties should be maintained by implementing this feature, see CCV spec - Consumer Initiated Slashing.  One implementation-specific property introduced is that if any of the chain-specific packet data queues become larger than MaxThrottledPackets, then the provider binary will panic, and the provider chain will halt. Therefore this param should be set carefully. See SetThrottledPacketDataSize. This behavior ensures that if the provider binaries are queuing up more packet data than machines can handle, the provider chain halts deterministically between validators.  ","version":"Next","tagName":"h3"},{"title":"Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#main-throttling-property","content":" Using on-chain params and the sub protocol defined, slash packet throttling is implemented such that the following property holds under some conditions.  First, we introduce the following definitions:  A consumer initiated slash attack &quot;starts&quot; when the first slash packet from such an attack is received by the provider.The &quot;initial validator set&quot; for the attack is the validator set that existed on the provider when the attack started.There is a list of honest validators such that if they are jailed, X% of the initial validator set will be jailed.  For the Throttling Property to hold, the following assumptions must be true:  We assume the total voting power of the chain (as a function of delegations) does not increase over the course of the attack.No validator has more than SlashMeterReplenishFraction of total voting power on the provider.SlashMeterReplenishFraction is large enough that SlashMeterReplenishFraction * currentTotalVotingPower &gt; 1, i.e., the replenish fraction is set high enough that we can ignore the effects of rounding.SlashMeterReplenishPeriod is sufficiently longer than the time it takes to produce a block.  Note if these assumptions do not hold, throttling will still slow down the described attack in most cases, just not in a way that can be succinctly described. It's possible that more complex properties can be defined.  Throttling Property: The time it takes to jail/tombstone X% of the initial validator set will be greater than or equal toSlashMeterReplenishPeriod⋅XSlashMeterReplenishFraction−2⋅SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod} \\cdot \\frac{X}{\\mathit{SlashMeterReplenishFraction}} - 2 \\cdot \\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriod⋅SlashMeterReplenishFractionX​−2⋅SlashMeterReplenishPeriod.  Intuition Let's use the following notation: CCC: Number of replenishment cyclesPPP: SlashMeterReplenishPeriod\\mathit{SlashMeterReplenishPeriod}SlashMeterReplenishPeriodFFF: SlashMeterReplenishFraction\\mathit{SlashMeterReplenishFraction}SlashMeterReplenishFractionVmaxV_{\\mathit{max}}Vmax​: Max power of a validator as a fraction of total voting power In CCC number of replenishment cycles, the fraction of total voting power that can be removed, aaa, is a≤F⋅C+Vmaxa \\leq F \\cdot C + V_{\\mathit{max}}a≤F⋅C+Vmax​ (where VmaxV_{\\mathit{max}}Vmax​ is there to account for the power fraction of the last validator removed, one which pushes the meter to the negative value). So, we need at least C≥a−VmaxFC \\geq \\frac{a - V_{\\mathit{max}}}{F}C≥Fa−Vmax​​ cycles to remove aaa fraction of the total voting power. Since we defined the start of the attack to be the moment when the first slash request arrives, then FFF fraction of the initial validator set can be jailed immediately. For the remaining X−FX - FX−F fraction of the initial validator set to be jailed, it takes at least C≥(X−F)−VmaxFC \\geq \\frac{(X - F) - V_{\\mathit{max}}}{F}C≥F(X−F)−Vmax​​ cycles. Using the assumption that Vmax≤FV_{\\mathit{max}} \\leq FVmax​≤F (assumption 2), we get C≥X−2FFC \\geq \\frac{X - 2F}{F}C≥FX−2F​ cycles. In order to execute CCC cycles, we need C⋅PC \\cdot PC⋅P time. Thus, jailing the remaining X−FX - FX−F fraction of the initial validator set corresponds to P⋅(X−2F)F\\frac{P \\cdot (X - 2F)}{F}FP⋅(X−2F)​ time. In other words, the attack must take at least P⋅XF−2P\\frac{P \\cdot X}{F} - 2PFP⋅X​−2P time (in the units of replenish period PPP).  This property is useful because it allows us to reason about the time it takes to jail a certain percentage of the initial provider validator set from consumer initiated slash requests. For example, if SlashMeterReplenishFraction is set to 0.06, then it takes no less than 4 replenishment periods to jail 33% of the initial provider validator set on the Cosmos Hub. Note that as of writing this on 11/29/22, the Cosmos Hub does not have a validator with more than 6% of total voting power.  Note also that 4 replenishment period is a worst case scenario that depends on well crafted attack timings.  ","version":"Next","tagName":"h3"},{"title":"How Unjailing Affects the Main Throttling Property​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#how-unjailing-affects-the-main-throttling-property","content":" Note that the jailing allowance is directly proportional to the current total voting power of the provider chain. Therefore, if honest validators don't unjail themselves during the attack, the total voting power of the provider chain will decrease over the course of the attack, and the attack will be slowed down, main throttling property is maintained.  If honest validators do unjail themselves, the total voting power of the provider chain will still not become higher than when the attack started (unless new token delegations happen), therefore the main property is still maintained. Moreover, honest validators unjailing themselves helps prevent the attacking validators from gaining control of the provider.  In summary, the throttling mechanism as designed has desirable properties whether or not honest validators unjail themselves over the course of the attack.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#positive","content":" The described attack is slowed down in seemingly all cases.If certain assumptions hold, the described attack is slowed down in a way that can be precisely time-bounded.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#negative","content":" Throttling introduces a vector for a malicious consumer chain to halt the provider, see issue below. However, this is sacrificing liveness in a edge case scenario for the sake of security. As an improvement, using retries would fully prevent this attack vector.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#neutral","content":" Additional state is introduced to the provider chain.VSCMatured and slash packet data is not always handled in the same block that it is received.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 002: Jail Throttling","url":"/interchain-security/adrs/adr-002-throttle#references","content":" Original issue inspiring throttling featureIssue on DOS vectorConsideration of another attack vector ","version":"Next","tagName":"h2"},{"title":"ADR 005: Cryptographic verification of equivocation evidence","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#changelog","content":" 5/1/2023: First draft7/23/2023: Add light client attacks handling9/6/2023: Add double signing attacks handling11/3/2023: Update limitations to clarify amnesia attacks are ignored  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#context","content":" Currently, we use a governance proposal to slash validators for equivocation (double signing and light client attacks). Every proposal needs to go through a (two weeks) voting period before it can be approved. Given a three-week unbonding period, this means that an equivocation proposal needs to be submitted within one week since the infraction occurred.  This ADR proposes a system to slash validators automatically for equivocation, immediately upon the provider chain's receipt of the evidence. Another thing to note is that we intend to introduce this system in stages, since even the partial ability to slash and/or tombstone is a strict improvement in security. The feature is implemented in two parts, each with its dedicated endpoint. One endpoint handles light client attacks, while the other handles double signing attacks.  ","version":"Next","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack","content":" In a nutshell, the light client is a process that solely verifies a specific state machine's consensus without executing the transactions. The light clients get new headers by querying multiple nodes, called primary and witness nodes.  Light clients download new headers committed on chain from a primary. Headers can be verified in two ways: sequentially, where the block height of headers is serial, or using skipping. This second verification method allows light clients to download headers with nonconsecutive block height, where some intermediate headers are skipped (see Tendermint Light Client, Figure 1 and Figure 3). Additionally, light clients are cross-checking new headers obtained from a primary with witnesses to ensure all nodes share the same state.  A light client attack occurs when a Byzantine validator sends invalid headers to a light client. As the light client doesn't execute transactions, it can be deceived into trusting corrupted application state transitions. For instance, if a light client receives header A from the primary and header B from a witness for the same block height H, and both headers are successfully verified, it indicates a light client attack. Note that in this case, either the primary or the witness or both are malicious.  The types of light client attacks are defined by analyzing the differences between the conflicting headers. There are three types of light client attacks: lunatic attack, equivocation attack, and amnesia attack. For details, see the CometBFT specification.  When a light client agent detects two conflicting headers, it will initially verify their traces (see cometBFT detector) using its primary and witness nodes. If these headers pass successful verification, the Byzantine validators will be identified based on the header's commit signatures and the type of light client attack. The agent will then transmit this information to its nodes using a LightClientAttackEvidence evidence to be eventually voted on and added to a block. Note that from a light client agent perspective, it is not possible to establish whether a primary or a witness node, or both, are malicious. Therefore, it will create and send two evidences: one against the primary (sent to the witness), and one against the witness (sent to the primary). Both nodes will then verify it before broadcasting it and adding it to the evidence pool. If an evidence is finally committed to a block, the chain's evidence module will execute it, resulting in the jailing and the slashing of the validators responsible for the light client attack.  Light clients are a core component of IBC. In the event of a light client attack, IBC relayers notify the affected chains by submitting an IBC misbehavior message. A misbehavior message includes the conflicting headers that constitute a light client attack evidence. Upon receiving such a message, a chain will first verify whether these headers would have convinced its light client. This verification is achieved by checking the header states against the light client consensus states (see IBC misbehaviour handler). If the misbehaviour is successfully verified, the chain will then &quot;freeze&quot; the light client, halting any further trust in or updating of its states.  ","version":"Next","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack","content":" A double signing attack, also known as equivocation, occurs when a validator votes for two different blocks in the same round of the CometBFT consensus. This consensus mechanism operates with multiple voting rounds at each block height, and it strictly prohibits sending two votes of the same type during a round (see CometBFT State Machine Overview).  When a node observes two votes from the same peer, it will use these two votes to create a DuplicateVoteEvidenceevidence and gossip it to the other nodes in the network (see CometBFT equivocation detection). Each node will then verify the evidence according to the CometBFT rules that define a valid double signing infraction, and based on this verification, they will decide whether to add the evidence to a block. During the evidence verification process, the signatures of the conflicting votes must be verified successfully. Note that this is achieved using the public key of the misbehaving validator, along with the chain ID of the chain where the infraction occurred (see CometBFT equivocation verification).  Once a double signing evidence is committed to a block, the consensus layer will report the equivocation to the evidence module of the Cosmos SDK application layer. The application will, in turn, punish the malicious validator through jailing, tombstoning and slashing (see handleEquivocationEvidence).  ","version":"Next","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#decision","content":" ","version":"Next","tagName":"h2"},{"title":"Light Client Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#light-client-attack-1","content":" In the first part of the feature, we introduce a new endpoint: HandleConsumerMisbehaviour(ctx sdk.Context, misbehaviour ibctmtypes.Misbehaviour). The main idea is to leverage the current IBC misbehaviour handling and update it to solely jail and slash the validators that performed a light client attack. Note that in this context, we assume that chains connected via a light client share a subset of the validator set of the provider.  This endpoint reuses the IBC client libraries to verify that the misbehaviour headers would have fooled the light client. Additionally, it’s crucial that the endpoint logic results in the slashing and jailing of validators under the same conditions as a light client agent detector. Therefore, the endpoint ensures that the two conditions are met: the headers in the misbehaviour message have the same block height, and the light client isn’t expired.  After having successfully verified a misbehaviour, the endpoint executes the jailing and slashing of the malicious validators similarly as in the evidence module.  ","version":"Next","tagName":"h3"},{"title":"Double Signing Attack​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#double-signing-attack-1","content":" In the second part of the feature, we introduce a new endpoint HandleConsumerDoubleVoting( ctx sdk.Context, evidence *tmtypes.DuplicateVoteEvidence, chainID string, pubkey cryptotypes.PubKey). Simply put, the handling logic verifies a double signing evidence against a provided public key and chain ID and, if successful, executes the jailing of the malicious validator who double voted.  We define a newMsgSubmitConsumerDoubleVoting message to report a double voting evidence observed on a consumer chain to the endpoint of the provider chain. This message contains two fields: a double signing evidenceduplicate_vote_evidence and a light client header for the infraction block height, referred to as infraction_block_header. The latter provides the malicious validator's public key and the chain ID required to verify the signature of the votes contained in the evidence.  Note that double signing evidence is not verified using the same conditions as in the implementation CometBFT (seeverify(evidence types.Evidence) method). Specifically, we do not check that the evidence hasn't expired. More details can be found in the &quot;Current limitations&quot; section below.  Upon a successful equivocation verification, the misbehaving validator is jailed for the maximum time (see DoubleSignJailEndTimein the SDK evidence module).  ","version":"Next","tagName":"h3"},{"title":"Current limitations:​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#current-limitations","content":" We cannot derive an infraction height from the evidence, so it is only possible to jail validators, not actually slash them. To explain the technical reasons behind this limitation, let's recap the initial consumer initiated slashing logic. In a nutshell, consumer heights are mapped to provider heights through VSCPackets, namely through the so called vscIDs. When an infraction occurs on the consumer, a SlashPacket containing the vscID obtained from mapping the consumer infraction height is sent to the provider. Upon receiving the packet, the provider maps the consumer infraction height to a local infraction height, which is used to slash the misbehaving validator. In the context of untrusted consumer chains, all their states, including vscIDs, could be corrupted and therefore cannot be used for slashing purposes. For the same reasons explained above, the age of a consumer double signing evidence can't be verified, either using its infraction height or its unsigned timestamp. Note that changes the jailing behaviour, potentially leading to a validator's jailing based on some &quot;old&quot; evidence from a consumer, which wouldn't occur if the consumer were a standalone chain. In the first stage of this feature, validators are jailed indefinitely without being tombstoned. The underlying reason is that a malicious validator could take advantage of getting tombstoned to avoid being slashed on the provider (see comment). Currently, the endpoint can only handle equivocation light client attacks. This is because the lunatic attacks require the endpoint to possess the ability to dissociate which header is conflicted or trusted upon receiving a misbehavior message. Without this information, it's not possible to extract the Byzantine validators from the conflicting headers (see comment). In addition, &quot;amnesia&quot; attacks are ignored, similar to CometBFT (see ADR-056).  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#positive","content":" It is now possible for the provider chain to jail validators who committed light client or double signing attacks on a consumer chain.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#negative","content":" N/A  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 005: Cryptographic verification of equivocation evidence","url":"/interchain-security/adrs/adr-005-cryptographic-equivocation-verification#references","content":" ICS misbehaviour handling PRConsumer double voting handler PRArchitectural diagramsADR on equivocation slashing ","version":"Next","tagName":"h2"},{"title":"ADR 007: Pause validator unbonding during equivocation proposal","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#changelog","content":" 2023-05-16: Initial Draft2023-11-30: Change the status to rejected  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#status","content":" Rejected  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#context","content":" Note: ADR rejected as the equivocation proposal was removed by the cryptographic verification of equivocation feature (see ADR-005 andADR-013).  Currently, if an equivocation slashing proposal is created after more than one week has passed since the equivocation, it is possible that the validator in question could unbond and get away without being slashed, since the unbonding period is 3 weeks, and the voting period is 2 weeks. For this reason, it might be good to pause unbondings for validators named in an equivocation slashing proposal until the proposal's voting period is over.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#decision","content":" ","version":"Next","tagName":"h2"},{"title":"How​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#how","content":" Pausing the unbonding period is already possible thanks to the changes in thestaking module of the cosmos-sdk:  stakingKeeper.PutUnbondingOnHold pauses an unbonding periodstakingKeeper.UnbondingCanComplete unpauses an unbonding period  These methods use a reference counter under the hood, that gets incremented every time PutUnbondingOnHold is called, and decreased whenUnbondingCanComplete is called instead. A specific unbonding is considered fully unpaused when its underlying reference counter reaches 0. Therefore, as long as we safeguard consistency - i.e. we make sure we eventually decrement the reference counter for each time we have incremented it - we can safely use this existing mechanism without conflicts with the Completion of Unbonding Operations system.  ","version":"Next","tagName":"h3"},{"title":"When pause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#when-pause","content":" The unbonding period (if there is any unbonding) should be paused once an equivocation proposal enters the voting period. For that, the gov module's hook AfterProposalDeposit can be used.  If the hook is triggered with a an equivocation proposal in voting period, then for each equivocation of the proposal, the unbonding operations of the related validator that were initiated after the equivocation block time must be paused  i.e. the underlying reference counter has to be increased.  Note that even after the voting period has started, a proposal can receive additional deposits. The hook is triggered however at arrival of a deposit, so a check to verify that the proposal is not already in voting period is required.  ","version":"Next","tagName":"h3"},{"title":"When unpause​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#when-unpause","content":" We can use a gov module's hook also here and it isAfterProposalVotingPeriodEnded.  If the hook is triggered with an equivocation proposal, then for each associated equivocation, the unbonding operations of the related validator that were initiated between the equivocation block time and the start of the proposal voting period must be unpaused - i.e. decrease the underlying reference counter - regardless of the proposal outcome.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#positive","content":" Validators subject to an equivocation proposal cannot finish unbonding their tokens before the end of the voting period.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#negative","content":" A malicious consumer chain could forge slash packets enabling submission of an equivocation proposal on the provider chain, resulting in the freezing of validator's unbondings for an undeterminated amount of time.Misbehavior on a consumer chain can potentially go unpunished, if no one submits an equivocation proposal in time, or if the proposal doesn't pass.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#neutral","content":" This feature can't be used for social slashing, because an equivocation proposal is only accepted if there's a slash log for the related validator(s), meaning the consumer chain has reported the equivocation to the provider chain.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 007: Pause validator unbonding during equivocation proposal","url":"/interchain-security/adrs/adr-007-pause-unbonding-on-eqv-prop#references","content":" https://github.com/cosmos/interchain-security/issues/747https://github.com/cosmos/interchain-security/pull/791 ","version":"Next","tagName":"h2"},{"title":"x/ccv/provider","type":0,"sectionRef":"#","url":"/interchain-security/v6.4.0/build/modules/provider","content":"","keywords":"","version":"v6.4.0"},{"title":"Overview​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#overview","content":" The ICS provider module enables a proof-of-stake chain (known as the provider chain) to share (parts of) its security with other chains (known as consumer chains). This basically means that consumer chains can run as proof-of-stake chains using (parts of) the stake locked on the provider as collateral.  The provider module has the following functionalities:  The permissionless creation of consumer chains.The customization of the consumer chains validator sets.The option for validators to opt in to validate the consumer chains they want.The distribution of rewards from consumer chains to the opted in validators.The slashing and jailing of validators committing infractions on consumer chains based on cryptographic evidence.  ","version":"v6.4.0","tagName":"h2"},{"title":"State​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#state","content":" For clarity, the description of the provider module state is split into features. For a more accurate description, check out the x/ccv/provider/types/keys.go file, which contains the definitions of all the keys.  ","version":"v6.4.0","tagName":"h2"},{"title":"Consumer Lifecycle​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#consumer-lifecycle","content":" ConsumerId​  ConsumerId is the consumer ID of the next consumer chain to be created.  Format: byte(43) -&gt; uint64  ConsumerIdToChainId​  ConsumerIdToChainId is the chain ID of a given consumer chain.  Format: byte(44) | len(consumerId) | []byte(consumerId) -&gt; string  ConsumerIdToOwnerAddress​  ConsumerIdToOwnerAddress is the account address of the owner of a given consumer chain.  Format: byte(45) | len(consumerId) | []byte(consumerId) -&gt; string  ConsumerIdToMetadataKey​  ConsumerIdToMetadataKey is the metadata of a given consumer chain.  Format: byte(46) | len(consumerId) | []byte(consumerId) -&gt; ConsumerMetadata  ConsumerIdToPhase​  ConsumerIdToPhase is the phase of a given consumer chain.  Format: byte(49) | len(consumerId) | []byte(consumerId) -&gt; ConsumerPhase, where ConsumerPhase is defined as  enum ConsumerPhase { option (gogoproto.goproto_enum_prefix) = false; // UNSPECIFIED defines an empty phase. CONSUMER_PHASE_UNSPECIFIED = 0; // REGISTERED defines the phase in which a consumer chain has been assigned a unique consumer id. // A chain in this phase cannot yet launch. CONSUMER_PHASE_REGISTERED = 1; // INITIALIZED defines the phase in which a consumer chain has set all the needed parameters to launch but // has not yet launched (e.g., because the `spawnTime` of the consumer chain has not yet been reached). CONSUMER_PHASE_INITIALIZED = 2; // LAUNCHED defines the phase in which a consumer chain is running and consuming a subset of the validator // set of the provider. CONSUMER_PHASE_LAUNCHED = 3; // STOPPED defines the phase in which a previously-launched chain has stopped. CONSUMER_PHASE_STOPPED = 4; // DELETED defines the phase in which the state of a stopped chain has been deleted. CONSUMER_PHASE_DELETED = 5; }   ConsumerIdToRemovalTime​  ConsumerIdToRemovalTime is the removal time of a given consumer chain in the stopped phase.  Format: byte(50) | len(consumerId) | []byte(consumerId) -&gt; time.Time  SpawnTimeToConsumerIds​  SpawnTimeToConsumerIds are the IDs of initialized consumer chains ready to be launched at a timestamp ts.  Format: byte(51) | ts -&gt; ConsumerIds, where ConsumerIds is defined as  message ConsumerIds { repeated string ids = 1; }   RemovalTimeToConsumerIds​  RemovalTimeToConsumerIds are the IDs of stopped consumer chains ready to be removed at a timestamp ts.  Format: byte(52) | ts -&gt; ConsumerIds, where ConsumerIds is defined as  ","version":"v6.4.0","tagName":"h3"},{"title":"Consumer Launch​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#consumer-launch","content":" ConsumerIdToInitializationParameters​  ConsumerIdToInitializationParameters are the initialization parameters of a given consumer chain.  Format: byte(47) | len(consumerId) | []byte(consumerId) -&gt; ConsumerInitializationParameters  ConsumerIdToChannelId​  ConsumerIdToChannelId is the ID of the CCV channel associated with a consumer chain.  Format: byte(5) | []byte(consumerId) -&gt; string  ChannelIdToConsumerId​  ChannelIdToConsumerId is the consumer ID associated with a CCV channel.  Format: byte(6) | []byte(channelId) -&gt; string  ConsumerIdToClientId​  ConsumerIdToClientId is the ID of the client associated with a consumer chain. This is the underlying client of the corresponding CCV channel.  Format: byte(7) | []byte(consumerId) -&gt; string  ClientIdToConsumerId​  ClientIdToConsumerId is the consumer ID associated with an IBC client (i.e., the underlying client of the corresponding CCV channel).  Format: byte(53) | len(clientId) | []byte(clientId) -&gt; string  ConsumerGenesis​  ConsumerGenesis is the genesis state of the consumer module associated with a consumer chain.  Format: byte(14) | []byte(consumerId) -&gt; ConsumerGenesisState  ","version":"v6.4.0","tagName":"h3"},{"title":"Key Assignment​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#key-assignment","content":" ConsumerValidators​  TODO: ConsumerValidators and ConsumerValidator are too similar.  ConsumerValidators is the public key assigned by a given validator with addr as its provider consensus address (i.e., sdk.ConsAddress) on a given consumer chain.  Format: byte(22) | len(consumerId) | []byte(consumerId) | addr -&gt; crypto.PublicKey, where crypto is &quot;github.com/cometbft/cometbft/proto/tendermint/crypto&quot;.  ValidatorsByConsumerAddr​  ValidatorsByConsumerAddr is the consensus address on the provider chain of a validator with addr as its consensus address on a given consumer chain.  Format: byte(23) | len(consumerId) | []byte(consumerId) | addr -&gt; sdk.ConsAddress.  ConsumerAddrsToPruneV2​  ConsumerAddrsToPruneV2 stores the list of consumer consensus addresses that can be pruned at a timestamp ts as they are no longer needed.  Format: byte(40) | len(consumerId) | []byte(consumerId) | ts -&gt; AddressList, where AddressList is defined as  message AddressList { repeated bytes addresses = 1; }   ","version":"v6.4.0","tagName":"h3"},{"title":"Power Shaping​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#power-shaping","content":" ConsumerIdToPowerShapingParameters​  ConsumerIdToPowerShapingParameters are the power-shaping parameters of a given consumer chain.  Format: byte(48) | len(consumerId) | []byte(consumerId) -&gt; PowerShapingParameters  ConsumerValidator​  ConsumerValidator is the ConsensusValidator record of a provider validator on a given consumer chain, i.e.,  message ConsensusValidator { // validator's consensus address on the provider chain bytes provider_cons_addr = 1; // voting power the validator has during this epoch int64 power = 2; // public key the validator uses on the consumer chain during this epoch tendermint.crypto.PublicKey public_key = 3; // height the validator had when it FIRST became a consumer validator int64 join_height = 4; }   Format: byte(31) | len(consumerId) | []byte(consumerId) | addr -&gt; ConsensusValidator, with addr the validator's consensus address on the provider chain.  OptedIn​  OptedIn is the list of provider validators that opted in to validate on a given consumer chain. Note that opting in doesn't guarantee a spot in the consumer validator set.  Format: byte(32) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  Allowlist​  Allowlist is the list of provider validators that are eligible to validate a given consumer chain.  Format: byte(36) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  Denylist​  Denylist is the list of provider validators that are not eligible to validate a given consumer chain. Note that validators can opt in regardless of whether they are eligible or not.  Format: byte(37) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  MinimumPowerInTopN​  MinimumPowerInTopN is the minimum voting power a provider validator must have to be required to validate a given TopN consumer chain.  Format: byte(40) | len(consumerId) | []byte(consumerId) -&gt; uint64  Prioritylist​  Prioritylist is the list of provider validators that have priority to validate a given consumer chain.  Format: byte(56) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  ","version":"v6.4.0","tagName":"h3"},{"title":"Validator Set Updates​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#validator-set-updates","content":" ValidatorSetUpdateId​  ValidatorSetUpdateId is an incrementing sequence number that is used as a unique identifier for validator set updates sent to the consumer chains. The validator set update ID is incremented every epoch.  Format: byte(2) -&gt; uint64  PendingVSCs​  PendingVSCs is the list of VSCPackets that are queued to be sent to a given consumer chain.  Format: byte(17) | []byte(consumerId) -&gt; ValidatorSetChangePackets, where ValidatorSetChangePackets is defined as  message ValidatorSetChangePackets { repeated ValidatorSetChangePacketData list = 1 [ (gogoproto.nullable) = false ]; }   LastProviderConsensusVals​  LastProviderConsensusVals is the last validator set sent to the consensus engine of the provider chain.  Format: byte(42) | addr -&gt; ConsensusValidator, with addr the validator's consensus address on the provider chain and ConsensusValidator defined as  message ConsensusValidator { // validator's consensus address on the provider chain bytes provider_cons_addr = 1; // voting power the validator has during this epoch int64 power = 2; // public key the validator uses on the consumer chain during this epoch tendermint.crypto.PublicKey public_key = 3; // height the validator had when it FIRST became a consumer validator int64 join_height = 4; }   ","version":"v6.4.0","tagName":"h3"},{"title":"Reward Distribution​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#reward-distribution","content":" ConsumerRewardDenoms​  ConsumerRewardDenoms is storing the list of whitelisted denoms that are accepted as ICS rewards. Note that denoms that are not whitelisted can still be transferred to the consumer_rewards_pool account on the provider module, but they will not be distributed to validators and their delegators.  Format: byte(27) | []byte(denom) -&gt; []byte{}  ConsumerRewardsAllocation​  ConsumerRewardsAllocation is the allocation of ICS rewards for a given consumer chain. This is used to distribute ICS rewards only to the validators that are part of the consumer chain validator set.  Format: byte(38) | []byte(consumerId) -&gt; ConsumerRewardsAllocation, where ConsumerRewardsAllocation is defined as  message ConsumerRewardsAllocation { repeated cosmos.base.v1beta1.DecCoin rewards = 1 [ (gogoproto.nullable) = false, (amino.dont_omitempty) = true, (gogoproto.castrepeated) = &quot;github.com/cosmos/cosmos-sdk/types.DecCoins&quot; ]; }   ConsumerCommissionRate​  ConsumerCommissionRate is the commission rate set by a provider validator for a given consumer chain.  Format: byte(39) | len(consumerId) | []byte(consumerId) | addr -&gt; math.LegacyDec, with addr the validator's consensus address on the provider chain and math is &quot;cosmossdk.io/math&quot;.  ","version":"v6.4.0","tagName":"h3"},{"title":"Consumer Infractions​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#consumer-infractions","content":" SlashMeter​  SlashMeter is the meter used for the throttling mechanism as the allowance of voting power that can be jailed over time. It is decremented by the amount of voting power jailed whenever a validator is jailed for downtime, and periodically replenished as decided by on-chain params. See ADR 002 for more details.  Format: byte(3) -&gt; math.Int  SlashMeterReplenishTimeCandidate​  SlashMeterReplenishTimeCandidate is the next UTC time the SlashMeter could potentially be replenished. Note that this value is the next time the SlashMeter will be replenished if and only if the SlashMeter is not full. Otherwise this value will be updated in every future block until the slash meter becomes not full.  Format: byte(4) -&gt; time.Time  ValsetUpdateBlockHeight​  ValsetUpdateBlockHeight is the block height associated with a validator set update ID vscId. This is used for mapping infraction heights on consumer chains to heights on the provider chain via the validator set update IDs (together with InitChainHeight).  Format: byte(13) | vscId -&gt; uint64  InitChainHeight​  InitChainHeight is the block height on the provider when the CCV channel of a given consumer chain was established (i.e., the channel opening handshake was completed). This is used for mapping infraction heights on consumer chains to heights on the provider chain (together with ValsetUpdateBlockHeight).  Format: byte(16) | []byte(consumerId) -&gt; uint64  SlashAcks​  SlashAcks are addresses of validators for which SlashPackets for downtime infractions received from a given consumer chain were handled. These addresses are sent together with the validator updates to the consumer chain as confirmation that the downtime infractions were dealt with.  Format: byte(15) | []byte(consumerId) -&gt; SlashAcks, where SlashAcks is defined as  message SlashAcks { repeated string addresses = 1; }   EquivocationEvidenceMinHeight​  EquivocationEvidenceMinHeight is the minimum height of a valid evidence of equivocation on a given consumer chain.  Format: byte(29) | []byte(consumerId) -&gt; uint64  ","version":"v6.4.0","tagName":"h3"},{"title":"State Transitions​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#state-transitions","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"Consumer chain phases​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#consumer-chain-phases","content":" The following diagram describes the phases of a consumer chain from the perspective of the provider module:    ","version":"v6.4.0","tagName":"h3"},{"title":"IBC Callbacks​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#ibc-callbacks","content":" The consumer module is an IBC application that implements the IBC module callback.  ","version":"v6.4.0","tagName":"h2"},{"title":"OnChanOpenInit​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#onchanopeninit","content":" OnChanOpenInit returns an error. MsgChannelOpenInit should be sent to the consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanOpenTry​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#onchanopentry","content":" OnChanOpenTry validates the parameters of the CCV channel -- an ordered IBC channel connected on the provider port and with the counterparty port set to consumer -- and asserts that the counterparty version matches the expected version (only version 1 is supported).  If the validation passes, the provider module verifies that the underlying client is the expected client of the consumer chain (i.e., the client created during the consumer chain launch) and that no other CCV channel exists for this consumer chain.  Finally, it sets the ProviderFeePoolAddr as part of the metadata.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanOpenAck​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#onchanopenack","content":" OnChanOpenAck returns an error. MsgChannelOpenAck should be sent to the consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanOpenConfirm​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#onchanopenconfirm","content":" OnChanOpenConfirm first verifies that no other CCV channel exists for this consumer chain. Note that this is a sanity check. Then, it sets the channel mapping in the state.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanCloseInit​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#onchancloseinit","content":" OnChanCloseInit returns an error. MsgChannelCloseInit should be sent to the consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnChanCloseConfirm​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#onchancloseconfirm","content":" OnChanCloseConfirm is a no-op.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnRecvPacket​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#onrecvpacket","content":" OnRecvPacket unmarshals the IBC packet data into a SlashPacketData struct (see below) and executes the handling logic.  Validate the fields in SlashPacketData: validator has a valid address and a non-zero power;infraction is either downtime or double-singing;the provider has in state a mapping from valset_update_id to a block height. If it is a double-signing infraction, then just log it and return.Verify that the consumer chain is launched and the validator is opted in.Update the meter used for jail throttling.Jail the validator on the provider chain.Store in state the ACK that the downtime infraction was handled. This will be sent to the consumer with the next validator updates to enable it to send other downtime infractions for this validator.  message SlashPacketData { tendermint.abci.Validator validator = 1 [ (gogoproto.nullable) = false, (gogoproto.moretags) = &quot;yaml:\\&quot;validator\\&quot;&quot; ]; // map to the infraction block height on the provider uint64 valset_update_id = 2; // tell if the slashing is for a downtime or a double-signing infraction cosmos.staking.v1beta1.Infraction infraction = 3; }   Note that IBC packets with VSCMaturedPacketData data are dropped. For more details, check out ADR 018.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnAcknowledgementPacket​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#onacknowledgementpacket","content":" OnAcknowledgementPacket stops and eventually removes the consumer chain associated with the channel on which the MsgAcknowledgement message was received.  ","version":"v6.4.0","tagName":"h3"},{"title":"OnTimeoutPacket​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#ontimeoutpacket","content":" OnTimeoutPacket stops and eventually removes the consumer chain associated with the channel on which the MsgTimeout message was received.  ","version":"v6.4.0","tagName":"h3"},{"title":"Messages​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#messages","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"MsgUpdateParams​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgupdateparams","content":" MsgUpdateParams updates the provider module parameters. The params are updated through a governance proposal where the signer is the gov module account address.  message MsgUpdateParams { option (cosmos.msg.v1.signer) = &quot;authority&quot;; // authority is the address of the governance account. string authority = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // params defines the x/provider parameters to update. Params params = 2 [(gogoproto.nullable) = false]; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgChangeRewardDenoms​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgchangerewarddenoms","content":" MsgChangeRewardDenoms updates the list of whitelisted denoms accepted by the provider as ICS rewards. The list of accepted denoms is updated through a governance proposal where the signer is the gov module account address.  Note that this message replaces ChangeRewardDenomsProposal, which is deprecated.  message MsgChangeRewardDenoms { option (cosmos.msg.v1.signer) = &quot;authority&quot;; // the list of consumer reward denoms to add repeated string denoms_to_add = 1; // the list of consumer reward denoms to remove repeated string denoms_to_remove = 2; // signer address string authority = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgCreateConsumer​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgcreateconsumer","content":" MsgCreateConsumer enables a user to create a consumer chain.  Both the chain_id and metadata fields are mandatory. The initialization_parameters, power_shaping_parameters, infraction_parameters and allowlisted_reward_denoms fields are optional. The parameters not provided are set to their zero value. If infraction_parameters are not set, the default values currently configured on the provider are used.  The owner of the created consumer chain is the submitter of the message. This message cannot be submitted as part of a governance proposal, i.e., the submitter cannot be the gov module account address. As a result, if the power_shaping_parameters are provided, then power_shaping_parameters.top_N must be set to zero (i.e., opt-in consumer chain).  To create a top-n consumer chain, the following steps are required:  Create an opt-in consumer chain (via MsgCreateConsumer).Change the ownership of the consumer chain to the gov module account address (via MsgUpdateConsumer).Change power_shaping_parameters.top_N to a value in [50, 100] through a governance proposal with a MsgUpdateConsumer message.  If the initialization_parameters field is set and initialization_parameters.spawn_time &gt; 0, then the consumer chain will be scheduled to launch at spawn_time.  message MsgCreateConsumer { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; // Submitter address. If the message is successfully handled, the ownership of // the consumer chain will given to this address. string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the chain id of the new consumer chain string chain_id = 2; ConsumerMetadata metadata = 3 [ (gogoproto.nullable) = false ]; ConsumerInitializationParameters initialization_parameters = 4; PowerShapingParameters power_shaping_parameters = 5; // allowlisted reward denoms by the consumer chain AllowlistedRewardDenoms allowlisted_reward_denoms = 6; // infraction parameters for slashing and jailing InfractionParameters infraction_parameters = 7; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgUpdateConsumer​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgupdateconsumer","content":" MsgUpdateConsumer enables the owner of a consumer chain to update its parameters (e.g., set a new owner).  Note that only the owner (i.e., signer) and consumer_id fields are mandatory. The others fields are optional. Not providing one of them will leave the existing values unchanged. Providing one of metadata, initialization_parameters, power_shaping_parameters, or allowlisted_reward_denomswill update all the containing fields. If one of the containing fields is missing, it will be set to its zero value. For example, updating the initialization_parameters without specifying the spawn_time, will set the spawn_time to zero.  If the initialization_parameters field is set and initialization_parameters.spawn_time &gt; 0, then the consumer chain will be scheduled to launch at spawn_time. Updating the spawn_time from a positive value to zero will remove the consumer chain from the list of scheduled to launch chains. If the consumer chain is already launched, updating the initialization_parameters is no longer possible.  If the power_shaping_parameters field is set and power_shaping_parameters.top_N is positive, then the owner needs to be the gov module account address.  If the new_owner_address field is set to a value different than the gov module account address, then top_N needs to be zero.  We can also update the chain_id of a consumer chain by using the optional new_chain_id field. Note that the chain id of a consumer chain can only be updated if the chain has not yet launched. After launch, the chain id of a consumer chain cannot be updated anymore.  message MsgUpdateConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the address of the owner of the consumer chain to be updated string owner = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to be updated string consumer_id = 2; // the new owner of the consumer when updated string new_owner_address = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the metadata of the consumer when updated ConsumerMetadata metadata = 4; // initialization parameters can only be updated before a chain has launched ConsumerInitializationParameters initialization_parameters = 5; // the power-shaping parameters of the consumer when updated PowerShapingParameters power_shaping_parameters = 6; // allowlisted reward denoms by the consumer chain AllowlistedRewardDenoms allowlisted_reward_denoms = 7; // to update the chain id of the chain (can only be updated if the chain has not yet launched) string new_chain_id = 8; // infraction parameters for slashing and jailing InfractionParameters infraction_parameters = 9; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgRemoveConsumer​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgremoveconsumer","content":" MsgRemoveConsumer enables the owner of a launched consumer chain to remove it from the provider chain. The message will first stop the consumer chain, which means the provider will stop sending it validator updates over IBC. Then, once the unbonding period elapses, the consumer chain is removed from the provider state.  message MsgRemoveConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the consumer id of the consumer chain to be stopped string consumer_id = 1; // the address of the owner of the consumer chain to be stopped string owner = 2 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgOptIn​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgoptin","content":" MsgOptIn enables a validator to opt in to validate a consumer chain. Note that validators can opt in to validate consumer chains that are not launched yet. The signer of the message needs to match the validator address on the provider.  Note that opting in doesn't guarantee a spot in the consumer chain's validator set. Use the has-to-validate query to check if the validator is part of the consumer chain's validator set. For more details, check out the validator guide to Partial Set Security.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  The consumer_key field is optional. It enables the validator to set the consensus public key to use on the consumer chain. The validator can assign (or re-assign) this key also later via MsgAssignConsumerKey.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons. This is especially important since the introduction of thePermissionless ICS featurethat allows multiple consumer chains to have the same chain ID. A validator using the same consensus key to validate on two chains with the same chain ID might get slashed for double signing.  message MsgOptIn { option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; option (cosmos.msg.v1.signer) = &quot;signer&quot;; // [DEPRECATED] use `consumer_id` instead string chain_id = 1 [deprecated = true]; // the validator address on the provider string provider_addr = 2 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // (optional) The consensus public key to use on the consumer in json string format corresponding to proto-any, // for example `{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}`. // This field is optional and can remain empty (i.e., `consumer_key = &quot;&quot;`). A validator can always change the // consumer public key at a later stage by issuing a `MsgAssignConsumerKey` message. string consumer_key = 3; // submitter address string signer = 4 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to opt in to string consumer_id = 5; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgAssignConsumerKey​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgassignconsumerkey","content":" MsgAssignConsumerKey enables a validator to assign the consensus public key to use on a consumer chain. Without assigning a specific key, the validator will need to use the same key as on the provider chain.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons. This is especially important since the introduction of thePermissionless ICS featurethat allows multiple consumer chains to have the same chain ID. A validator using the same consensus key to validate on two chains with the same chain ID might get slashed for double signing.  The signer of the message needs to match the validator address on the provider.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details, check out the description of the Key Assignment feature.  message MsgAssignConsumerKey { option (cosmos.msg.v1.signer) = &quot;signer&quot;; option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; // [DEPRECATED] use `consumer_id` instead string chain_id = 1 [deprecated = true]; // The validator address on the provider string provider_addr = 2 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // The consensus public key to use on the consumer. // in json string format corresponding to proto-any, ex: // `{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}` string consumer_key = 3; string signer = 4 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to assign a consensus public key to string consumer_id = 5; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgOptOut​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgoptout","content":" MsgOptOut enables a validator to opt out from validating a launched consumer chain. The signer of the message needs to match the validator address on the provider.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on optin out, check out the validator guide to Partial Set Security.  message MsgOptOut { option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; option (cosmos.msg.v1.signer) = &quot;signer&quot;; // [DEPRECATED] use `consumer_id` instead string chain_id = 1 [deprecated = true]; // the validator address on the provider string provider_addr = 2 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // submitter address string signer = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to opt out from string consumer_id = 4; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgSetConsumerCommissionRate​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgsetconsumercommissionrate","content":" MsgSetConsumerCommissionRate enables validators to set a per-consumer chain commission rate. The rate is a decimal in [minRate, 1], with minRate corresponding to the minimum commission rate set on the provider chain (see min_commission_rate in interchain-security-pd query staking params).  The signer of the message needs to match the validator address on the provider.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on setting per-consumer chain commission rates, check out the validator guide to Partial Set Security.  message MsgSetConsumerCommissionRate { option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; option (cosmos.msg.v1.signer) = &quot;signer&quot;; // The validator address on the provider string provider_addr = 1 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // [DEPRECATED] use `consumer_id` instead string chain_id = 2 [deprecated = true]; // The rate to charge delegators on the consumer chain, as a fraction string rate = 3 [ (cosmos_proto.scalar) = &quot;cosmos.Dec&quot;, (gogoproto.customtype) = &quot;cosmossdk.io/math.LegacyDec&quot;, (gogoproto.nullable) = false ]; // submitter address string signer = 4 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to set the commission rate string consumer_id = 5; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgSubmitConsumerMisbehaviour​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgsubmitconsumermisbehaviour","content":" MsgSubmitConsumerMisbehaviour enables users to submit to the provider evidence of a light client attack that occurred on a consumer chain. This message can be submitted directly by users, e.g., via the CLI command tx provider submit-consumer-misbehaviour, or by a relayer that can be set to automatically detect consumer chain misbehaviors, e.g., Hermes.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on reporting light client attacks that occurred on consumer chains, check out the guide on equivocation infractions.  message MsgSubmitConsumerMisbehaviour { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // The Misbehaviour of the consumer chain wrapping // two conflicting IBC headers ibc.lightclients.tendermint.v1.Misbehaviour misbehaviour = 2; // the consumer id of the consumer chain where the misbehaviour occurred string consumer_id = 3; }   ","version":"v6.4.0","tagName":"h3"},{"title":"MsgSubmitConsumerDoubleVoting​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#msgsubmitconsumerdoublevoting","content":" MsgSubmitConsumerDoubleVoting enables users to submit to the provider evidence of a double signing infraction that occurred on a consumer chain. This message can be submitted directly by users, e.g., via the CLI command tx provider submit-consumer-double-voting, or by a relayer that can be set to automatically detect consumer chain misbehaviors, e.g., Hermes.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on reporting double signing infractions that occurred on consumer chains, check out the guide on equivocation infractions.  message MsgSubmitConsumerDoubleVoting { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // The equivocation of the consumer chain wrapping // an evidence of a validator that signed two conflicting votes tendermint.types.DuplicateVoteEvidence duplicate_vote_evidence = 2; // The light client header of the infraction block ibc.lightclients.tendermint.v1.Header infraction_block_header = 3; // the consumer id of the consumer chain where the double-voting took place string consumer_id = 4; }   ","version":"v6.4.0","tagName":"h3"},{"title":"BeginBlock​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#beginblock","content":" In the BeginBlock of the provider module the following actions are performed:  Launch every consumer chain that has a spawn time that already passed. Compute the initial validator set.Create the genesis state for the consumer module. Note that the genesis state contains the consumer module parameters and both the client state and consensus state needed for creating a provider client on the consumer chain.Create a consumer client. Remove every stopped consumer chain for which the removal time has passed.Replenish the throttling meter if necessary.Distribute ICS rewards to the opted in validators.Update consumer infraction parameters with the queued infraction parameters that were added to the queue before a time period greater than the unbonding time.  Note that for every consumer chain, the computation of its initial validator set is based on the consumer's power shaping parametersand the validators that opted in on that consumer.  ","version":"v6.4.0","tagName":"h2"},{"title":"EndBlock​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#endblock","content":" In the EndBlock of the provider module the following actions are performed:  Store in state the VSC id to block height mapping needed for determining the height of infractions on consumer chains.Prune the no-longer needed public keys assigned by validators to use when validating on consumer chains.Send validator updates to the consensus engine. The maximum number of validators is set through the MaxProviderConsensusValidators param.At the beginning of every epoch, for every launched consumer chain, compute the next consumer validator set and send it to the consumer chain via an IBC packet;increment the VSC id.  Note that for every consumer chain, the computation of its validator set is based on the consumer's power shaping parametersand the validators that opted in on that consumer.  ","version":"v6.4.0","tagName":"h2"},{"title":"Hooks​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#hooks","content":" TBA  ","version":"v6.4.0","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#events","content":" TBA  ","version":"v6.4.0","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#parameters","content":" The provider module contains the following parameters.  ","version":"v6.4.0","tagName":"h2"},{"title":"TemplateClient​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#templateclient","content":" TemplateClient is a template of an IBC ClientState used for launching consumer chains.  ","version":"v6.4.0","tagName":"h3"},{"title":"TrustingPeriodFraction​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#trustingperiodfraction","content":" Type\tDefault valuestring\t&quot;0.66&quot;  TrustingPeriodFraction is used to used to compute the trusting period of IBC clients (for both provider and consumer chains) as UnbondingPeriod / TrustingPeriodFraction. Note that a light client must be updated within the trusting period in order to avoid being frozen.  The param is set as a string, and converted to a sdk.Dec when used.  ","version":"v6.4.0","tagName":"h3"},{"title":"CcvTimeoutPeriod​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#ccvtimeoutperiod","content":" Type\tDefault valuetime.Duration\t2419200s (4 weeks)  CcvTimeoutPeriod is the period used to compute the timeout timestamp when sending IBC packets. For more details, see the IBC specification of Channel &amp; Packet Semantics.  warning If a sent packet is not relayed within this period, then the packet times out. The CCV channel used by the interchain security protocol is closed, and the corresponding consumer is removed.  CcvTimeoutPeriod may have different values on the provider and consumer chains.CcvTimeoutPeriod on the provider must be larger than consumer unbonding period.  ","version":"v6.4.0","tagName":"h3"},{"title":"SlashMeterReplenishPeriod​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#slashmeterreplenishperiod","content":" Type\tDefault valuetime.Duration\t3600s (1 hour)  SlashMeterReplenishPeriod is the time interval at which the meter for jail throttling is replenished. The meter is replenished to an amount equal to the allowance for that block, or SlashMeterReplenishFraction * CurrentTotalVotingPower.  ","version":"v6.4.0","tagName":"h3"},{"title":"SlashMeterReplenishFraction​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#slashmeterreplenishfraction","content":" Type\tDefault valuestring\t&quot;0.05&quot;  SlashMeterReplenishFraction is the fraction (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs. This param also serves as a maximum fraction of total voting power that the slash meter can hold.  The param is set as a string, and converted to a sdk.Dec when used.  ","version":"v6.4.0","tagName":"h3"},{"title":"ConsumerRewardDenomRegistrationFee​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#consumerrewarddenomregistrationfee","content":" ConsumerRewardDenomRegistrationFee is deprecated.  ","version":"v6.4.0","tagName":"h3"},{"title":"BlocksPerEpoch​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#blocksperepoch","content":" Type\tDefault valueint64\t600  BlocksPerEpoch is the number of blocks in an ICS epoch. The provider sends validator updates to the consumer chains only once per epoch.  warning It is recommended for the length of an ICS epoch to not exceed a day. Large epochs would lead to delays in validator updates sent to the consumer chains, which might impact the security of the consumer chains.  ","version":"v6.4.0","tagName":"h3"},{"title":"NumberOfEpochsToStartReceivingRewards​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#numberofepochstostartreceivingrewards","content":" Type\tDefault valueint64\t24  NumberOfEpochsToStartReceivingRewards is the number of ICS epochs that a validator needs to wait after opting in on a consumer chain before being eligible to ICS rewards from that consumer.  ","version":"v6.4.0","tagName":"h3"},{"title":"MaxProviderConsensusValidators​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#maxproviderconsensusvalidators","content":" Type\tDefault valueint64\t180  MaxProviderConsensusValidators is the maximum number of validators sent to the provider consensus engine. This was introduced with the Inactive Provider Validators featureand it replaces the MaxValidators staking module parameter. As a result, the provider chain can differentiate betweenbonded validators, i.e., validators that have stake locked on the provider chain, and active validator, i.e., validators that participate actively in the provider chain's consensus.  ","version":"v6.4.0","tagName":"h3"},{"title":"Client​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#client","content":" ","version":"v6.4.0","tagName":"h2"},{"title":"CLI​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#cli","content":" A user can interact with the provider module using the CLI.  Query​  The query commands allow users to query provider state.  interchain-security-pd query provider --help   Consumer Genesis​  The consumer-genesis command allows to query for consumer chain genesis state by consumer id.  interchain-security-pd query provider consumer-genesis [consumer-id] [flags]   Example interchain-security-pd query provider consumer-genesis 0 Output: new_chain: true params: blocks_per_distribution_transmission: &quot;1000&quot; ccv_timeout_period: 2419200s consumer_id: &quot;0&quot; consumer_redistribution_fraction: &quot;0.75&quot; distribution_transmission_channel: &quot;&quot; enabled: true historical_entries: &quot;10000&quot; provider_fee_pool_addr_str: &quot;&quot; provider_reward_denoms: [] retry_delay_period: 3600s reward_denoms: [] soft_opt_out_threshold: &quot;0&quot; transfer_timeout_period: 3600s unbonding_period: 1209600s provider: client_state: allow_update_after_expiry: false allow_update_after_misbehaviour: false chain_id: provider frozen_height: revision_height: &quot;0&quot; revision_number: &quot;0&quot; latest_height: revision_height: &quot;25&quot; revision_number: &quot;0&quot; max_clock_drift: 10s proof_specs: - inner_spec: child_order: - 0 - 1 child_size: 33 empty_child: null hash: SHA256 max_prefix_length: 12 min_prefix_length: 4 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false - inner_spec: child_order: - 0 - 1 child_size: 32 empty_child: null hash: SHA256 max_prefix_length: 1 min_prefix_length: 1 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false trust_level: denominator: &quot;3&quot; numerator: &quot;1&quot; trusting_period: 1197504s unbonding_period: 1814400s upgrade_path: - upgrade - upgradedIBCState consensus_state: next_validators_hash: 632730A03DEF630F77B61DF4092629007AE020B789713158FABCB104962FA54F root: hash: Jcck4b/HHJOcjcVjTdMi8qHB4SeCpWpfLiN9DtB99oA= timestamp: &quot;2024-09-25T09:18:40.262655625Z&quot; initial_val_set: - power: &quot;500&quot; pub_key: ed25519: RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10= - power: &quot;500&quot; pub_key: ed25519: Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is= - power: &quot;500&quot; pub_key: ed25519: mAN6RXYxSM4MNGSIriYiS7pHuwAcOHDQAy9/wnlSzOI=   List Consumer Chains​  The list-consumer-chains command allows to query consumer chains supported by the provider chain. An optional integer parameter can be passed for phase filtering of consumer chains, (Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5).`  interchain-security-pd query provider list-consumer-chains [phase] [limit] [flags]   Example interchain-security-pd query provider list-consumer-chains 3 Output: chains: - allow_inactive_vals: true allowlist: [] prioritylist: [] chain_id: pion-1 client_id: 07-tendermint-0 consumer_id: &quot;0&quot; denylist: [&quot;cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6&quot;] metadata: description: description of your chain and all other relevant information metadata: some metadata about your chain name: pion-1 min_power_in_top_N: &quot;500&quot; min_stake: &quot;0&quot; phase: CONSUMER_PHASE_LAUNCHED top_N: 60 validator_set_cap: 0 validators_power_cap: 0 pagination: next_key: null total: &quot;1&quot;   Validator Consumer Key Assignment​  The validator-consumer-key command allows to query assigned validator consensus public key for a consumer chain.  interchain-security-pd query provider validator-consumer-key [consumer-id] [provider-validator-address] [flags]   Example interchain-security-pd query provider validator-consumer-key 0 cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6 Output: consumer_address: cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk   Validator Provider Key​  The validator-provider-key command allows to query validator consensus public key for the provider chain.  interchain-security-pd query provider validator-provider-key [consumer-id] [consumer-validator-address] [flags]   Example interchain-security-pd query provider validator-provider-key 0 cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk Output: provider_address: cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj   Throttle State​  The throttle-state command allows to query on-chain state relevant to slash packet throttling.  interchain-security-pd query provider throttle-state [flags]   Example interchain-security-pd query provider throttle-state Output: next_replenish_candidate: &quot;2024-09-26T07:59:51.336971970Z&quot; slash_meter: &quot;1500&quot; slash_meter_allowance: &quot;1511&quot;   Registered Consumer Reward Denoms​  The registered-consumer-reward-denoms command allows to query registered consumer reward denoms.  interchain-security-pd query provider registered-consumer-reward-denoms [flags]   Example interchain-security-pd query provider registered-consumer-reward-denoms Output: denoms: - ibc/3C3D7B3BE4ECC85A0E5B52A3AEC3B7DFC2AA9CA47C37821E57020D6807043BE9 - ibc/D549749C93524DA1831A4B3C850DFC1BA9060261BEDFB224B3B0B4744CD77A70   All Pairs Valconsensus Address​  The all-pairs-valconsensus-address command allows to query all pairs of valconsensus address by consumer id.  interchain-security-pd query provider all-pairs-valconsensus-address [consumer-id] [flags]   Example interchain-security-pd query provider all-pairs-valconsensus-address 0 Output: pair_val_con_addr: - consumer_address: cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk consumer_key: ed25519: Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is= provider_address: cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6   Provider Parameters​  The params command allows to query provider parameters information.  interchain-security-pd query provider params [flags]   Example interchain-security-pd query provider params Output: blocks_per_epoch: &quot;3&quot; ccv_timeout_period: 2419200s consumer_reward_denom_registration_fee: amount: &quot;10000000&quot; denom: stake max_provider_consensus_validators: &quot;180&quot; number_of_epochs_to_start_receiving_rewards: &quot;24&quot; slash_meter_replenish_fraction: &quot;1.0&quot; slash_meter_replenish_period: 3600s template_client: allow_update_after_expiry: false allow_update_after_misbehaviour: false chain_id: &quot;&quot; frozen_height: revision_height: &quot;0&quot; revision_number: &quot;0&quot; latest_height: revision_height: &quot;0&quot; revision_number: &quot;0&quot; max_clock_drift: 10s proof_specs: - inner_spec: child_order: - 0 - 1 child_size: 33 empty_child: null hash: SHA256 max_prefix_length: 12 min_prefix_length: 4 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false - inner_spec: child_order: - 0 - 1 child_size: 32 empty_child: null hash: SHA256 max_prefix_length: 1 min_prefix_length: 1 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false trust_level: denominator: &quot;3&quot; numerator: &quot;1&quot; trusting_period: 0s unbonding_period: 0s upgrade_path: - upgrade - upgradedIBCState trusting_period_fraction: &quot;0.66&quot;   Consumer Opted In Validators​  The consumer-opted-in-validators command allows to query opted-in validators for a given consumer chain.  interchain-security-pd query provider consumer-opted-in-validators [consumer-id] [flags]   Example interchain-security-pd query provider consumer-opted-in-validators 0 Output: validators_provider_addresses: - cosmosvalcons1qmq08eruchr5sf5s3rwz7djpr5a25f7xw4mceq - cosmosvalcons1nx7n5uh0ztxsynn4sje6eyq2ud6rc6klc96w39 - cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6   Consumer Validators​  The consumer-validators command allows to query the last set consumer-validator set for a given consumer chain.  interchain-security-pd query provider consumer-validators [consumer-id] [flags]   Example interchain-security-pd query provider consumer-validators 0 Output: validators: - consumer_commission_rate: &quot;0.100000000000000000&quot; consumer_key: ed25519: RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10= consumer_power: &quot;511&quot; description: details: &quot;&quot; identity: &quot;&quot; moniker: validatoralice security_contact: &quot;&quot; website: &quot;&quot; jailed: false power: &quot;0&quot; provider_address: cosmosvalcons1qmq08eruchr5sf5s3rwz7djpr5a25f7xw4mceq provider_commission_rate: &quot;0.100000000000000000&quot; provider_operator_address: cosmosvaloper19pe9pg5dv9k5fzgzmsrgnw9rl9asf7ddtrgtng provider_power: &quot;511&quot; provider_tokens: &quot;511000000&quot; rate: &quot;0.000000000000000000&quot; status: BOND_STATUS_BONDED validates_current_epoch: true - consumer_commission_rate: &quot;0.100000000000000000&quot; consumer_key: ed25519: mAN6RXYxSM4MNGSIriYiS7pHuwAcOHDQAy9/wnlSzOI= consumer_power: &quot;500&quot; description: details: &quot;&quot; identity: &quot;&quot; moniker: validatorbob security_contact: &quot;&quot; website: &quot;&quot; jailed: false power: &quot;0&quot; provider_address: cosmosvalcons1nx7n5uh0ztxsynn4sje6eyq2ud6rc6klc96w39 provider_commission_rate: &quot;0.100000000000000000&quot; provider_operator_address: cosmosvaloper1dkas8mu4kyhl5jrh4nzvm65qz588hy9qakmjnw provider_power: &quot;500&quot; provider_tokens: &quot;500000000&quot; rate: &quot;0.000000000000000000&quot; status: BOND_STATUS_BONDED validates_current_epoch: true   Has to Validate​  The has-to-validate command allows to query the consumer chains list a given validator has to validate.  interchain-security-pd query provider has-to-validate [provider-validator-address] [flags]   Example interchain-security-pd query provider has-to-validate cosmoscons1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj Output: consumer_ids: - &quot;0&quot; - &quot;2&quot;   Validator Consumer Commission Rate​  The validator-consumer-commission-rate command allows to query the consumer commission rate a validator charges on a consumer chain.  interchain-security-pd query provider validator-consumer-commission-rate [consumer-id] [provider-validator-address] [flags]   Example interchain-security-pd query provider validator-consumer-commission-rate 0 cosmoscons1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj Output: rate: &quot;0.750000000000000000&quot;   Blocks Until Next Epoch​  The blocks-until-next-epoch command allows to query the number of blocks until the next epoch begins and validator updates are sent to consumer chains  interchain-security-pd query provider blocks-until-next-epoch [flags]   Example interchain-security-pd query provider blocks-until-next-epoch Output: blocks_until_next_epoch: &quot;286&quot;   Consumer Id From Client Id​  The consumer-id-from-client-id command allows to query the consumer id of the chain associated with the provided client id.  interchain-security-pd query provider consumer-id-from-client-id [client-id] [flags]   Example interchain-security-pd query provider consumer-id-from-client-id 07-tendermint-0 Output: consumer_id: &quot;0&quot;   Consumer Chain​  The consumer-chain command allows to query the consumer chain associated with the consumer id.  interchain-security-pd query provider consumer-chain [consumer-id] [flags]   Example interchain-security-pd query provider consumer-chain 0 Output: chain_id: pion-1 consumer_id: &quot;0&quot; init_params: binary_hash: YmluX2hhc2g= blocks_per_distribution_transmission: &quot;1000&quot; ccv_timeout_period: 2419200s consumer_redistribution_fraction: &quot;0.75&quot; distribution_transmission_channel: &quot;&quot; genesis_hash: Z2VuX2hhc2g= historical_entries: &quot;10000&quot; initial_height: revision_height: &quot;1&quot; revision_number: &quot;0&quot; spawn_time: &quot;2024-09-26T06:55:14.616054Z&quot; transfer_timeout_period: 3600s unbonding_period: 1209600s connection_id: &quot;&quot; metadata: description: description of your chain and all other relevant information metadata: some metadata about your chain name: pion-1 owner_address: cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn phase: CONSUMER_PHASE_LAUNCHED power_shaping_params: allow_inactive_vals: false allowlist: [] denylist: [] min_stake: 0 top_N: 100 validator_set_cap: 0 validators_power_cap: 0 prioritylist: []   Consumer Genesis Time​  The consumer-genesis-time command allows to query the genesis time of the consumer chain associated with the consumer id.  interchain-security-pd query provider consumer-genesis-time [consumer-id] [flags]   Example interchain-security-pd query provider consumer-genesis-time 0 Output: genesis_time: &quot;2024-10-18T08:13:23.507178095Z&quot;   Transactions​  The tx commands allows users to interact with the provider module.  interchain-security-pd tx provider --help   Assign Consumer Key​  The assign-consensus-key command allows to assign a consensus public key to use for a consumer chain.  interchain-security-pd tx provider assign-consensus-key [consumer-id] [consumer-pubkey] [flags]   Example interchain-security-pd tx provider assign-consensus-key 0 \\ '{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}' \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Note that the consumer pubkey can be obtained by using interchain-security-cd tendermint show-validator command.  Create Consumer​  The create-consumer command allows to create a consumer chain.  interchain-security-pd tx provider create-consumer [consumer-parameters] [flags]   Example interchain-security-pd tx provider create-consumer path/to/create-consumer-msg.json \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where create-consumer-msg.json contains: { &quot;chain_id&quot; : &quot;pion-1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;{\\&quot;forge_json_url\\&quot;: \\&quot;...\\&quot;, \\&quot;stage\\&quot;: \\&quot;mainnet\\&quot;}&quot; } }   Update Consumer​  The update-consumer command allows to update a consumer chain.  interchain-security-pd tx provider update-consumer [consumer-parameters] [flags]   Example interchain-security-pd tx provider update-consumer path/to/update-consumer.json \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where update-consumer-msg.json contains: { &quot;consumer_id&quot; : &quot;0&quot;, &quot;owner_address&quot;: &quot;cosmos1p3ucd3ptpw902fluyjzhq3ffgq4ntddac9sa3s&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;{\\&quot;forge_json_url\\&quot;: \\&quot;...\\&quot;, \\&quot;stage\\&quot;: \\&quot;mainnet\\&quot;}&quot; }, &quot;initialization_parameters&quot;:{ &quot;initial_height&quot;:{ &quot;revision_number&quot;: 1, &quot;revision_height&quot;: 1 }, &quot;genesis_hash&quot;: &quot;&quot;, &quot;binary_hash&quot;: &quot;&quot;, &quot;spawn_time&quot;: &quot;2024-09-29T12:57:43Z&quot;, &quot;unbonding_period&quot;: 1728000000000000, &quot;ccv_timeout_period&quot;: 2419200000000000, &quot;transfer_timeout_period&quot;: 1800000000000, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;blocks_per_distribution_transmission&quot;: &quot;1500&quot;, &quot;historical_entries&quot;: &quot;1000&quot;, &quot;distribution_transmission_channel&quot;: &quot;&quot;, &quot;connection_id&quot;: &quot;&quot; }, &quot;power_shaping_parameters&quot;:{ &quot;top_N&quot;: 0, &quot;validators_power_cap&quot;: 10, &quot;validator_set_cap&quot;: 50, &quot;allowlist&quot;:[&quot;cosmosvalcons1l9qq4m300z8c5ez86ak2mp8znftewkwgjlxh88&quot;], &quot;denylist&quot;:[], &quot;min_stake&quot;: &quot;1000&quot;, &quot;allow_inactive_vals&quot;:true, &quot;prioritylist&quot;:[] }, &quot;allowlisted_reward_denoms&quot;: { &quot;denoms&quot;: [&quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;] } }   Remove Consumer​  The remove-consumer command allows to remove a consumer chain.  interchain-security-pd tx provider remove-consumer [consumer-id] [flags]   Example interchain-security-pd tx provider remove-consumer 0   Opt In​  The opt-in command allows a validator to opt in to a consumer chain and optionally set a consensus public key.  interchain-security-pd tx provider opt-in [consumer-id] [consumer-pubkey] [flags]   Example interchain-security-pd tx provider opt-in 0 \\ '{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}' \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Opt Out​  The opt-out command allows validators to opt out from consumer chains.  interchain-security-pd tx provider opt-out [consumer-id] [flags]   Example interchain-security-pd tx provider opt-out 0 \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Set Consumer Commission Rate​  The set-consumer-commission-rate command allows to set a per-consumer chain commission rate.  interchain-security-pd tx provider set-consumer-commission-rate [consumer-id] [commission-rate] [flags]   Example interchain-security-pd tx provider set-consumer-commission-rate 0 0.5 \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Submit Consumer Double Voting​  The submit-consumer-double-voting command allows to submit a double voting evidence for a consumer chain.  interchain-security-pd tx provider submit-consumer-double-voting [consumer-id] [evidence] [infraction_header] [flags]   Example interchain-security-pd tx provider submit-consumer-double-voting 0 path/to/evidence.json path/to/infraction_header.json \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where evidence.json contains: { &quot;vote_a&quot;: { &quot;type&quot;: &quot;SIGNED_MSG_TYPE_PREVOTE&quot;, &quot;height&quot;: &quot;59&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;paTPgLrLCZmw5ctQWlaMLJhXLckafakKN9skJbTiCHA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;pVOTT8MO00rk0HAeVQgzdP3wjIOzN5X5tfPLTtXIn2g=&quot; } }, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.146234009Z&quot;, &quot;validator_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;validator_index&quot;: 1, &quot;signature&quot;: &quot;Z9C1oU5AEyFqXVmQ0LKNlaVa+tGh++95EB5HYe0i61PlREOmo/OTLlWedr8kuAThBu/1CpaLz446hYjISAKqBQ==&quot;, &quot;extension&quot;: null, &quot;extension_signature&quot;: null }, &quot;vote_b&quot;: { &quot;type&quot;: &quot;SIGNED_MSG_TYPE_PREVOTE&quot;, &quot;height&quot;: &quot;59&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;07tksQsQ0gVBphgP4eeyGII9tEaLUuCauQcmwar9ktk=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;nND/ClxCtoSJ9fC7Jyy884ab+nDh+PnHwI28T2fELCE=&quot; } }, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.051976301Z&quot;, &quot;validator_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;validator_index&quot;: 1, &quot;signature&quot;: &quot;QscqC9ilH4gL7+3GPqLMWly+UkO+p0JgcinDZtfHOM4fYosZhx+TzhLrrXNExYpwX3D8qQHmJlLCcXLqbo7aCA==&quot;, &quot;extension&quot;: null, &quot;extension_signature&quot;: null }, &quot;total_voting_power&quot;: &quot;1500&quot;, &quot;validator_power&quot;: &quot;500&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:45.945436342Z&quot; } and infraction_header.json contains: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;0&quot; }, &quot;chain_id&quot;: &quot;pion-1&quot;, &quot;height&quot;: &quot;59&quot;, &quot;time&quot;: &quot;2024-09-26T09:34:45.945436342Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;t8HcmkQbchpGE1CxqdhcogoT+yD5VIm+cRGLcosTtxE=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;fTediSh8XttUUoxWJLPIxO6iWecqdMMsegD2svBtR5E=&quot; } }, &quot;last_commit_hash&quot;: &quot;2U4mFcB6+FffQeFPUaHkd+eBtEV5/5d3Zy0Lk58dwIs=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;D26N3CL1zQt7yn+JUQ8Dcb2vCYG7QmHMiMfY+nGxhts=&quot;, &quot;next_validators_hash&quot;: &quot;D26N3CL1zQt7yn+JUQ8Dcb2vCYG7QmHMiMfY+nGxhts=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;k/RW/WMOYCS89VBhKMHIRYb30a30JkZ+puyp9ESTBiA=&quot;, &quot;last_results_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;59&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;07tksQsQ0gVBphgP4eeyGII9tEaLUuCauQcmwar9ktk=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;nND/ClxCtoSJ9fC7Jyy884ab+nDh+PnHwI28T2fELCE=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;BsDz5HzFx0gmkIjcLzZBHTqqJ8Y=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.271500717Z&quot;, &quot;signature&quot;: &quot;bXA2WgQVVlHAkn9mGIfoUvgn3C+EJCzNGTAjnhoQJwLkh1Okg3oYmwZRz+UGbc95kXyVO7kQSXhavt0ZPcJ4AA==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.305955426Z&quot;, &quot;signature&quot;: &quot;YG1OcUhpTKFz+Uo8halNmkw0s6n333+m53laZvyQSHM5gqOG4h8jzij2u9sU4H404OJMgdj+1GTxuHmQ8jWFBg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;tBw6QBQpY6pbEt3RxOWJDAs5JrE=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.255694467Z&quot;, &quot;signature&quot;: &quot;EYOC/yo+RaosEVhwBy0bZFjVwHCR7rRZo/FmTRWpAIXZHBVrIiX3iVzRUwn78lsfbaoT97TsqRX61bAiJDM6BA==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;BsDz5HzFx0gmkIjcLzZBHTqqJ8Y=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;-1000&quot; }, { &quot;address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;mAN6RXYxSM4MNGSIriYiS7pHuwAcOHDQAy9/wnlSzOI=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;500&quot; }, { &quot;address&quot;: &quot;tBw6QBQpY6pbEt3RxOWJDAs5JrE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;500&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;BsDz5HzFx0gmkIjcLzZBHTqqJ8Y=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;-1000&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;0&quot; }, &quot;trusted_validators&quot;: null }   Submit Consumer Misbehaviour​  The submit-consumer-misbehaviour command allows to submit an IBC misbehaviour for a consumer chain.  interchain-security-pd tx provider submit-consumer-misbehaviour [consumer-id] [misbehaviour] [flags]   Example interchain-security-pd tx provider submit-consumer-misbehaviour 0 path/to/consumer-misbehaviour.json --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where consumer-misbehaviour.json contains: { &quot;client_id&quot;: &quot;07-tendermint-0&quot;, &quot;header_1&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;0&quot; }, &quot;chain_id&quot;: &quot;pion-1&quot;, &quot;height&quot;: &quot;95&quot;, &quot;time&quot;: &quot;2024-09-26T09:15:52.845591095Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;PUph0B9N9X+LdrstqOoGf+W+OS6oHetQUa+0fpcRnF8=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;SlVkAlM1uq3DjgTk0NbZftLlFwOEJrau1Wnhg3jEH3A=&quot; } }, &quot;last_commit_hash&quot;: &quot;Hxe4aLTULJ7qxJ10XsQfluKyU1Rn+d+cgDeTm2AATqU=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;next_validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;uGHlqLiNp+ZCjE889JDFKnrNkRpZ5xZ5OOamXrCNcOc=&quot;, &quot;last_results_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;95&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;hkUUob+4UVRE4uJW53fY9UYViGTs2v6P5Sb/hUFYyak=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;0tx9pRIzYJ3vwrYyOgMC8zxf/sSJUtNVm9DBKM8Yxo0=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:15:53.852414554Z&quot;, &quot;signature&quot;: &quot;iiQCCxsCOoNVb2smAVmDO62o9HLf+I4rWk8o86uA1ZoFun/lk1bwrocaMp1It1SjVo/szYsX6Hp5rP1IwcAjDg==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;20&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } }, &quot;header_2&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;0&quot; }, &quot;chain_id&quot;: &quot;consu&quot;, &quot;height&quot;: &quot;95&quot;, &quot;time&quot;: &quot;2024-09-26T09:15:54.044450012Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;MG9B1h4R9Xb4GRjvaNydD5NSqT37OOjGDcatCZpBlco=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;3jQh26/9EuNAAEL6v2tRuGhKtkotoyTqGtduOOn++vk=&quot; } }, &quot;last_commit_hash&quot;: &quot;s1hUy5e7i+GrH5IGW1ck4YHK2CDTY4fjnSiNMInJBWc=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;next_validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;bWRmShMthwEAB3lIVMgB673gH5vTdoqfn223M3Xrk6Q=&quot;, &quot;last_results_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;95&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;z3MJTCXppRYoIEPOrneYzw/U0CSiYF3zsUv67ynxM6Q=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;BFSlw7bqXxBHl9O5O9sCUB01nbe0T0KGOmv7yyr8KYU=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:15:55.054809888Z&quot;, &quot;signature&quot;: &quot;oi+TQ0yoDEeXyBchFIql9AGxbufnx3FzDKsCp4B8tx42ropD8tyotKOjk0OMuZQC5aMMRndRfKiYYsWiOrcpAg==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;20&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } } }   ","version":"v6.4.0","tagName":"h3"},{"title":"gRPC​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#grpc","content":" A user can query the provider module using gRPC endpoints.  Consumer Genesis​  The QueryConsumerGenesis endpoint queries a consumer chain genesis state by consumer id.  interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 \\ interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis Output: { &quot;genesisState&quot;: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;1000&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot; }, &quot;provider&quot;: { &quot;clientState&quot;: { &quot;chainId&quot;: &quot;provider&quot;, &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;57024s&quot;, &quot;unbondingPeriod&quot;: &quot;86400s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: { &quot;revisionHeight&quot;: &quot;10&quot; }, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;consensusState&quot;: { &quot;timestamp&quot;: &quot;2024-09-26T08:19:42.708111Z&quot;, &quot;root&quot;: { &quot;hash&quot;: &quot;xbZV/9QyM3PYzY/HyJAsNogaaJVJtyAGROTcXuqxHas=&quot; }, &quot;nextValidatorsHash&quot;: &quot;/zLB6RSu9omrO5L0tnDK03hCOUibwl/7eeVC3hTP7so=&quot; }, &quot;initialValSet&quot;: [ { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;E9bJ6bi7X9MG9s3djQ4MmBxshis9W15y7UzXCxp2Yuk=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;power&quot;: &quot;100&quot; } ] }, &quot;newChain&quot;: true } }   List Consumer Chains​  The QueryConsumerChains endpoint queries consumer chains supported by the provider chain and supports pagination for managing a large number of chains. An optional integer parameter can be passed for phase filtering of consumer chains, (Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5).`  interchain_security.ccv.provider.v1.Query/QueryConsumerChains   Example grpcurl -plaintext -d '{&quot;phase&quot;: &quot;1&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChains Output: { &quot;chains&quot;: [ { &quot;chainId&quot;: &quot;pion-1&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;2&quot; }, { &quot;chainId&quot;: &quot;dash-2&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;dash-2&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;4&quot; }, ], &quot;pagination&quot;: { &quot;total&quot;: &quot;6&quot; } }   Validator Consumer Key Assignment​  The QueryValidatorConsumerAddr endpoint queries the address assigned by a validator for a consumer chain.  interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;, &quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr Output: { &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot; }   Validator Provider Key​  The QueryValidatorProviderAddr endpoint queries the provider chain address given a consumer chain validator address.  interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;, &quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr Output: { &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot; }   Throttle State​  The QueryThrottleState endpoint queries the main on-chain state relevant to slash packet throttling.  interchain_security.ccv.provider.v1.Query/QueryThrottleState   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryThrottleState Output: { &quot;slashMeter&quot;: &quot;15&quot;, &quot;slashMeterAllowance&quot;: &quot;15&quot;, &quot;nextReplenishCandidate&quot;: &quot;2024-09-26T14:27:38.066958Z&quot; }   Registered Consumer Reward Denoms​  The QueryRegisteredConsumerRewardDenoms command allows to query registered consumer reward denoms  interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms Output: { &quot;denoms&quot;: [ &quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;, &quot;ibc/054892D6BB43AF8B93AAC28AA5FD7019D2C59A15DAFD6F45C1FA2BF9BDA22454&quot;, &quot;uatom&quot; ] }   All Pairs Valconsensus Address​  The QueryAllPairsValConsAddrByConsumer endpoint queries the list of pair valconsensus address between provider and consumer chain.  interchain_security.ccv.provider.v1.Query/QueryAllPairsValConsAddrByConsumer   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryAllPairsValConsAddrByConsumer Output: { &quot;pairValConAddr&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6&quot;, &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; } } ] }   Provider Parameters​  The QueryParams endpoint queries all current values of provider parameters.  interchain_security.ccv.provider.v1.Query/QueryParams   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryParams Output: { &quot;params&quot;: { &quot;templateClient&quot;: { &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;0s&quot;, &quot;unbondingPeriod&quot;: &quot;0s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: {}, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;trustingPeriodFraction&quot;: &quot;0.66&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;slashMeterReplenishPeriod&quot;: &quot;3600s&quot;, &quot;slashMeterReplenishFraction&quot;: &quot;0.05&quot;, &quot;consumerRewardDenomRegistrationFee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocksPerEpoch&quot;: &quot;5&quot;, &quot;numberOfEpochsToStartReceivingRewards&quot;: &quot;24&quot;, &quot;maxProviderConsensusValidators&quot;: &quot;180&quot; } }   Consumer Opted In Validators​  The QueryConsumerChainOptedInValidators endpoint queries opted-in validators for a given consumer chain.  interchain_security.ccv.provider.v1.Query/QueryConsumerChainOptedInValidators   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChainOptedInValidators Output: { &quot;validatorsProviderAddresses&quot;: [ &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot; ] }   Consumer Validators​  The QueryConsumerValidators endpoint queries the latest set consumer-validator set for a given consumer ID. Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment because a VSCPacket could be delayed to be delivered on the consumer chain.  interchain_security.ccv.provider.v1.Query/QueryConsumerValidators   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerValidators Output: { &quot;validators&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;101&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;bob&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1a7u5k6f54ua3tptl9yn6u82yrvayet6sxn9ywn&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;101000000&quot;, &quot;providerPower&quot;: &quot;101&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;coordinator&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1jk2pp655zxy2gazhxj50s8jk3750y8np6wz4lm&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;alice&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper19vfen9jn3uk3e6rrkt3pxansunujnlm40wpdvg&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true } ] }   Has to Validate​  The QueryConsumerChainsValidatorHasToValidate endpoint queries a list of consumer chains that a given validator must validate.  interchain_security.ccv.provider.v1.Query/QueryConsumerChainsValidatorHasToValidate   Example grpcurl -plaintext -d '{&quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChainsValidatorHasToValidate Output: { &quot;consumerIds&quot;: [ &quot;0&quot;, &quot;2&quot; ] }   Validator Consumer Commission Rate​  The QueryValidatorConsumerCommissionRate endpoint queries the consumer commission rate a validator charges on a consumer chain.  interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerCommissionRate   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;, &quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerCommissionRate Output: { &quot;rate&quot;: &quot;750000000000000000&quot; }   Blocks Until Next Epoch​  The QueryBlocksUntilNextEpoch endpoint allows to query the number of blocks until the next epoch begins and validator updates are sent to consumer chains.  interchain_security.ccv.provider.v1.Query/QueryBlocksUntilNextEpoch   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryBlocksUntilNextEpoch Output: { &quot;blocks_until_next_epoch&quot;:&quot;4&quot; }   Consumer Id From Client Id​  The QueryConsumerIdFromClientId endpoint allows to query the consumer id of the chain associated with the provided client id.  interchain_security.ccv.provider.v1.Query/QueryConsumerIdFromClientId   Example grpcurl -plaintext -d '{&quot;client_id&quot;:&quot;07-tendermint-0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerIdFromClientId Output: { &quot;consumerId&quot;: &quot;0&quot; }   Consumer Chain​  The QueryConsumerChain endpoint allows to query the consumer chain associated with the consumer id.  interchain_security.ccv.provider.v1.Query/QueryConsumerChain   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChain { &quot;consumerId&quot;: &quot;0&quot;, &quot;chainId&quot;: &quot;pion-1&quot;, &quot;ownerAddress&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_LAUNCHED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;description of your chain and all other relevant information&quot;, &quot;description&quot;: &quot;some metadata about your chain&quot;, &quot;metadata&quot;: &quot;pion-1&quot; }, &quot;initParams&quot;: { &quot;initialHeight&quot;: { &quot;revisionHeight&quot;: &quot;1&quot; }, &quot;genesisHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;binaryHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;spawnTime&quot;: &quot;2023-03-11T17:02:14.718477Z&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;historicalEntries&quot;: &quot;1000&quot; }, &quot;powerShapingParams&quot;: { &quot;topN&quot;: 100, &quot;validatorSetCap&quot;: 50, &quot;minStake&quot;: &quot;1000&quot;, &quot;allowInactiveVals&quot;: true }, &quot;infraction_parameters&quot;:{ &quot;double_sign&quot;:{ &quot;slash_fraction&quot;:&quot;0.050000000000000000&quot;, &quot;jail_duration&quot;:&quot;9223372036.854775807s&quot;, &quot;tombstone&quot;: true }, &quot;downtime&quot;:{ &quot;slash_fraction&quot;:&quot;0.000000000000000000&quot;, &quot;jail_duration&quot;:&quot;600s&quot;, &quot;tombstone&quot;: false } }, &quot;clientId&quot;: &quot;07-tendermint-28&quot; }   Consumer Genesis Time​  The QueryConsumerGenesisTime endpoint allows to query the genesis time of the consumer chain associated with the consumer id.  interchain_security.ccv.provider.v1.Query/QueryConsumerGenesisTime   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerGenesisTime { &quot;genesisTime&quot;: &quot;2024-10-18T08:13:23.507178095Z&quot; }   ","version":"v6.4.0","tagName":"h3"},{"title":"REST​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/v6.4.0/build/modules/provider#rest","content":" A user can query the provider module using REST endpoints.  Consumer Genesis​  The consumer_genesis endpoint queries a consumer chain genesis state by consumer id.  interchain_security/ccv/provider/consumer_genesis/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_genesis/0 Output: { &quot;genesisState&quot;: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;1000&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot; }, &quot;provider&quot;: { &quot;clientState&quot;: { &quot;chainId&quot;: &quot;provider&quot;, &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;57024s&quot;, &quot;unbondingPeriod&quot;: &quot;86400s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: { &quot;revisionHeight&quot;: &quot;10&quot; }, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;consensusState&quot;: { &quot;timestamp&quot;: &quot;2024-09-26T08:19:42.708111Z&quot;, &quot;root&quot;: { &quot;hash&quot;: &quot;xbZV/9QyM3PYzY/HyJAsNogaaJVJtyAGROTcXuqxHas=&quot; }, &quot;nextValidatorsHash&quot;: &quot;/zLB6RSu9omrO5L0tnDK03hCOUibwl/7eeVC3hTP7so=&quot; }, &quot;initialValSet&quot;: [ { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;E9bJ6bi7X9MG9s3djQ4MmBxshis9W15y7UzXCxp2Yuk=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;power&quot;: &quot;100&quot; } ] }, &quot;newChain&quot;: true } }   List Consumer Chains​  The consumer_chains endpoint queries consumer chains supported by the provider chain. An optional integer parameter can be passed for phase filtering of consumer chains, (Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5).`  interchain_security/ccv/provider/consumer_chains/{phase}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_chains/3 Output: { &quot;chains&quot;: [ { &quot;chainId&quot;: &quot;pion-1&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;2&quot; }, { &quot;chainId&quot;: &quot;dash-2&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;dash-2&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;4&quot; }, ], &quot;pagination&quot;: { &quot;total&quot;: &quot;6&quot; } }   Validator Consumer Key Assignment​  The validator_consumer_addr endpoint queries the address assigned by a validator for a consumer chain.  /interchain_security/ccv/provider/validator_consumer_addr/{consumer_id}/{provider_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/validator_consumer_addr/0/cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj Output: { &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot; }   Validator Provider Key​  The validator_provider_addr endpoint queries the provider chain address given a consumer chain validator address.  /interchain_security/ccv/provider/validator_provider_addr/{consumer_id}/{consumer_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/validator_provider_addr/0/cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk Output: { &quot;providerAddress&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot; }   Throttle State​  The throttle_state queries the main on-chain state relevant to slash packet throttling.  &quot;/interchain_security/ccv/provider/throttle_state&quot;   Example curl http://localhost:1317/interchain_security/ccv/provider/throttle_state Output: { &quot;slashMeter&quot;: &quot;15&quot;, &quot;slashMeterAllowance&quot;: &quot;15&quot;, &quot;nextReplenishCandidate&quot;: &quot;2024-09-26T14:27:38.066958Z&quot; }   Registered Consumer Reward Denoms​  The registered_consumer_reward_denoms endpoint allows to query registered consumer reward denoms  interchain_security/ccv/provider/registered_consumer_reward_denoms   Example curl http://localhost:1317/interchain_security/ccv/provider/registered_consumer_reward_denoms Output: { &quot;denoms&quot;: [ &quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;, &quot;ibc/054892D6BB43AF8B93AAC28AA5FD7019D2C59A15DAFD6F45C1FA2BF9BDA22454&quot;, &quot;uatom&quot; ] }   All Pairs Valconsensus Address​  The address_pairs endpoint queries the list of pair valconsensus address between provider and consumer chain.  interchain_security/ccv/provider/address_pairs/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/address_pairs/0 Output: { &quot;pairValConAddr&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6&quot;, &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; } } ] }   Provider Parameters​  The params endpoint queries all current values of provider parameters  interchain_security/ccv/provider/params   Example curl http://localhost:1317/interchain_security/ccv/provider/params Output: { &quot;params&quot;: { &quot;templateClient&quot;: { &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;0s&quot;, &quot;unbondingPeriod&quot;: &quot;0s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: {}, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;trustingPeriodFraction&quot;: &quot;0.66&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;slashMeterReplenishPeriod&quot;: &quot;3600s&quot;, &quot;slashMeterReplenishFraction&quot;: &quot;0.05&quot;, &quot;consumerRewardDenomRegistrationFee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocksPerEpoch&quot;: &quot;5&quot;, &quot;numberOfEpochsToStartReceivingRewards&quot;: &quot;24&quot;, &quot;maxProviderConsensusValidators&quot;: &quot;180&quot; } }   Consumer Opted In Validators​  The opted_in_validators endpoint queries opted-in validators for a given consumer chain  /interchain_security/ccv/provider/opted_in_validators/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/opted_in_validators/0 Output: { &quot;validatorsProviderAddresses&quot;: [ &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot; ] }   Consumer Validators​  The consumer_validators endpoint queries the latest set consumer-validator set for a given consumer ID Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment because a VSCPacket could be delayed to be delivered on the consumer chain.  /interchain_security/ccv/provider/consumer_validators/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_validators/0 Output: { &quot;validators&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;101&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;bob&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1a7u5k6f54ua3tptl9yn6u82yrvayet6sxn9ywn&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;101000000&quot;, &quot;providerPower&quot;: &quot;101&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;coordinator&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1jk2pp655zxy2gazhxj50s8jk3750y8np6wz4lm&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;alice&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper19vfen9jn3uk3e6rrkt3pxansunujnlm40wpdvg&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true } ] }   Has to Validate​  The consumer_chains_per_validator endpoint queries a list of consumer chains that a given validator must validate.  interchain_security/ccv/provider/consumer_chains_per_validator/{provider_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_chains_per_validator/cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph Output: { &quot;consumerIds&quot;: [ &quot;0&quot;, &quot;2&quot; ] }   Validator Consumer Commission Rate​  The consumer_commission_rate endpoint queries the consumer commission rate a validator charges on a consumer chain.  /interchain_security/ccv/provider/consumer_commission_rate/{consumer_id}/{provider_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_commission_rate/0/cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph Output: { &quot;rate&quot;: &quot;0.100000000000000000&quot; }   Blocks Until Next Epoch​  The blocks_until_next_epoch endpoint allows to query the number of blocks until the next epoch begins and validator updates are sent to consumer chains  interchain_security/ccv/provider/blocks_until_next_epoch   Example curl http://localhost:1317/interchain_security/ccv/provider/blocks_until_next_epoch Output: { &quot;blocks_until_next_epoch&quot;:&quot;3&quot; }   Consumer Id From Client Id​  The consumer_id endpoint allows to query the consumer id of the chain associated with the provided client id  /interchain_security/ccv/provider/consumer_id/{client_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_id/07-tendermint-0 Output: { &quot;consumer_id&quot;:&quot;0&quot; }   Consumer Chain​  The consumer_chain endpoint allows to query the consumer chain associated with the consumer id.  interchain_security/ccv/provider/consumer_chain/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_chain/0 Output: { &quot;consumerId&quot;: &quot;0&quot;, &quot;chainId&quot;: &quot;pion-1&quot;, &quot;ownerAddress&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_LAUNCHED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;description of your chain and all other relevant information&quot;, &quot;description&quot;: &quot;some metadata about your chain&quot;, &quot;metadata&quot;: &quot;pion-1&quot; }, &quot;initParams&quot;: { &quot;initialHeight&quot;: { &quot;revisionHeight&quot;: &quot;1&quot; }, &quot;genesisHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;binaryHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;spawnTime&quot;: &quot;2023-03-11T17:02:14.718477Z&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;historicalEntries&quot;: &quot;1000&quot; }, &quot;powerShapingParams&quot;: { &quot;topN&quot;: 100, &quot;validatorSetCap&quot;: 50, &quot;minStake&quot;: &quot;1000&quot;, &quot;allowInactiveVals&quot;: true } , &quot;infraction_parameters&quot;:{ &quot;double_sign&quot;:{ &quot;slash_fraction&quot;:&quot;0.050000000000000000&quot;, &quot;jail_duration&quot;:&quot;9223372036.854775807s&quot;, &quot;tombstone&quot;: true }, &quot;downtime&quot;:{ &quot;slash_fraction&quot;:&quot;0.000000000000000000&quot;, &quot;jail_duration&quot;:&quot;600s&quot;, &quot;tombstone&quot;: false } } }   Consumer Genesis Time​  The consumer_genesis_time endpoint allows to query the genesis time of the consumer chain associated with the consumer id.  interchain_security/ccv/provider/consumer_genesis_time/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_genesis_time/0 Output: { &quot;genesis_time&quot;:&quot;2024-10-18T08:29:46.153234Z&quot; }  ","version":"v6.4.0","tagName":"h3"},{"title":"Throttle with retries","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-008-throttle-retries","content":"","keywords":"","version":"Next"},{"title":"ADR 008: Throttle with retries​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#adr-008-throttle-with-retries","content":" ","version":"Next","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#changelog","content":" 6/9/23: Initial draft6/22/23: added note on consumer pending packets storage optimization7/14/23: Added note on upgrade order  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#context","content":" For context on why the throttling mechanism exists, see ADR 002.  Note the terms slash throttling and jail throttling are synonymous, since in Interchain Security a SlashPacket simply jails a validator for downtime infractions.  Currently the throttling mechanism is designed so that provider logic (slash meter, etc.) dictates how many SlashPackets can be handled over time. Throttled SlashPackets are persisted on the provider, leading to multiple possible issues. Namely:  If SlashPackets or VSCMaturedPackets are actually throttled/queued on the provider, state can grow and potentially lead to a DoS attack. We have short term solutions around this, but overall they come with their own weaknesses. See #594.If a jailing attack described in ADR 002 were actually to be carried out with the current throttling design, we'd likely have to halt the provider, and perform an emergency upgrade and/or migration to clear the queues of SlashPackets that were deemed to be malicious. Alternatively, validators would just have to tough it out and wait for the queues to clear, during which all/most validators would be jailed. Right after being jailed, validators would have to unjail themselves promptly to ensure safety. The coordination required to maintain safety in such a scenario is not ideal.  As a solution, we can improve the throttling mechanism to instead queue/persist relevant data on each consumer, and have consumers retry slash requests as needed.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#decision","content":" ","version":"Next","tagName":"h2"},{"title":"Consumer changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#consumer-changes","content":" Note the consumer already queues up both SlashPackets and VSCMaturedPackets via AppendPendingPacket. Those packets are dequeued in every EndBlock in SendPackets and sent to the provider.  Instead, we will now introduce the following logic on EndBlock:  Slash packets will always be sent to the provider once they're at the head of the queue. However, once sent, the consumer will not send any subsequent VSCMaturedPackets from the queue until the provider responds with an acknowledgement that the sent SlashPacket has been handled, i.e., validator was jailed. That is, SlashPackets block the sending of subsequent VSCMaturedPackets in the consumer queue.If two SlashPackets are at the head of the queue, the consumer will send the first SlashPacket, and then wait for a success acknowledgement from the provider before sending the second SlashPacket. This seems like it'd simplify implementation.VSCMaturedPackets at the head of the queue (i.e., NOT following a SlashPacket) can be sent immediately, and do not block any other packets in the queue, since the provider always handles them immediately.  To prevent the provider from having to keep track of what SlashPackets have been rejected, the consumer will have to retry the sending of SlashPackets over some period of time. This can be achieved with an on-chain consumer param, i.e., RetryDelayPeriod. To reduce the amount of redundant re-sends, we recommend setting RetryDelayPeriod ~ SlashMeterReplenishmentPeriod, i.e., waiting for the provider slash meter to be replenished before resending the rejected SlashPacket.  Note to prevent weird edge case behavior, a retry would not be attempted until either a success or failure acknowledgement has been received from the provider.  With the behavior described, we maintain very similar behavior to the previous throttling mechanism regarding the timing that SlashPackets and VSCMaturedPackets are handled on the provider. Obviously the queueing and blocking logic is moved, and the two chains would have to send more messages between one another (only in the case the throttling mechanism is triggered).  In the normal case, when no or a few SlashPackets are being sent, the VSCMaturedPackets will not be delayed, and hence unbonding will not be delayed.  For the implementation of this design, see throttle_retry.go.  Consumer pending packets storage optimization​  In addition to the mentioned consumer changes, an optimization will need to be made to the consumer's pending packets storage to properly implement the feature from this ADR.  The consumer ccv module previously queued &quot;pending packets&quot; to be sent in each EndBlock in SendPackets. These packets are queued in state with a protobuf list of ConsumerPacketData. For a single append operation, the entire list is deserialized, then a packet is appended to that list, and the list is serialized again. See older version of AppendPendingPacket. That is, a single append operation has O(N) complexity, where N is the size of the list.  This poor append performance isn't a problem when the pending packets list is small. But with this ADR being implemented, the pending packets list could potentially grow to the order of thousands of entries when SlashPackets need to be resent.  We can improve the append time for this queue by converting it from a protobuf-esq list, to a queue implemented with sdk-esq code. The idea is to persist a uint64 index that will be incremented each time you queue up a packet. You can think of this as storing the tail of the queue. Then, packet data will be keyed by that index, making the data naturally ordered byte-wise for sdk's iterator. The index will also be stored in the packet data value bytes, so that the index can later be used to delete certain packets from the queue.  Two things are achieved with this approach:  More efficient packet append/enqueue timesThe ability to delete select packets from the queue (previously all packets were deleted at once)  ","version":"Next","tagName":"h3"},{"title":"Provider changes​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#provider-changes","content":" The main change needed for the provider is the removal of queuing logic for SlashPackets and VSCMaturedPackets upon being received.  Instead, the provider will consult the slash meter to determine if a SlashPacket can be handled immediately. If not, the provider will return an acknowledgement message to the consumer communicating that the SlashPacket could not be handled, and needs to be sent again in the future (retried).  VSCMaturedPackets will always be handled immediately upon being received by the provider.  Note spec. Specifically the section on VSC Maturity and Slashing Order. Previously the onus was on the provider to maintain this property via queuing packets and handling them FIFO.  Now this property will be maintained by the consumer sending packets in the correct order, and blocking the sending of VSCMaturedPackets as needed. Then, the ordered IBC channel will ensure that SlashPackets and VSCMaturedPackets are received in the correct order on the provider.  The provider's main responsibility regarding throttling will now be to determine if a received SlashPacket can be handled via slash meter etc., and appropriately acknowledge to the sending consumer.  Handling VSCMaturedPackets immediately​  Why the provider can handle VSCMatured packets immediately​  A VSCMaturedPacket communicates to the provider that sufficient time passed on the consumer since the corresponding VSCPacket has been applied (on the consumer) such that infractions committed on the consumer could have been submitted.  If the consumer is following the queuing/blocking protocol described, then no bad behavior occurs and the VSC Maturity and Slashing Order property is maintained.  If a consumer sends VSCMaturedPackets too leniently -- the consumer is malicious and sends duplicate VSCMaturedPackets, or sends the packets sooner than the CCV protocol specifies -- then the provider needs to handle VSCMaturedPackets immediately to prevent DOS, state bloat, or other issues. The only possible negative outcome is that the malicious consumer may not be able to jail a validator who should have been jailed. The malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  If a consumer blocks the sending of VSCMaturedPackets, then unbonding operations on the provider will be delayed, but only until the VSC timeout period has elapsed. At that time, the consumer is removed. Again the malicious behavior only creates a negative outcome for the consumer chain that is being malicious.  ","version":"Next","tagName":"h3"},{"title":"Splitting of PRs and Upgrade Order​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#splitting-of-prs-and-upgrade-order","content":" This feature will implement consumer changes in #1024.  ❗These changes should be deployed to production for all consumers before the provider changes are deployed to production.  In other words, the consumer changes in #1024 are compatible with the current (&quot;v1&quot;) provider implementation of throttling that's running on the Cosmos Hub as of July 2023.  Once all consumers have deployed the changes in #1024, the provider changes from #1321 can be deployed to production, fully enabling v2 throttling.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#consequences","content":" Consumers will now have to manage their own queues, and retry logic.Consumers still aren't trustless, but the provider is now less susceptible to mismanaged or malicious consumers.Recovering from the &quot;jailing attack&quot; is more elegant.Some issues like #1001 will now be handled implicitly by the improved throttling mechanism.SlashPackets and VSCMaturedPackets can be handled immediately once received by the provider if the slash meter allows.In general, we reduce the amount of computation that happens in the provider EndBlock.  ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#positive","content":" We no longer have to reason about a &quot;global queue&quot; and a &quot;chain specific queue&quot;, and keeping those all in-sync. Now SlashPackets and VSCMaturedPackets queuing is handled on each consumer individually.Due to the above, the throttling protocol becomes less complex overall.We no longer have to worry about throttle related DoS attack on the provider, since no queuing exists on the provider.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#negative","content":" Increased number of IBC packets being relayed anytime throttling logic is triggered.Consumer complexity increases, since consumers now have manage queuing themselves, and implement packet retry logic.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#neutral","content":" Core throttling logic on the provider remains unchanged, i.e., slash meter, replenishment cycles, etc.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Throttle with retries","url":"/interchain-security/adrs/adr-008-throttle-retries#references","content":" EPIC tracking the changes proposed by this ADRADR 002: Jail Throttling#594 ","version":"Next","tagName":"h2"},{"title":"Soft Opt-Out","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-009-soft-opt-out","content":"","keywords":"","version":"Next"},{"title":"ADR 009: Soft Opt-Out​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#adr-009-soft-opt-out","content":" ","version":"Next","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#changelog","content":" 6/13/23: Initial draft of ADR. Feature already implemented and in production.6/19/24: Change status to deprecated  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#status","content":" Deprecated Deprecated by Partial Set Security  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#context","content":" Some small validators may not have the resources needed to validate all consumer chains. Therefore a need exists to allow the bottom x% of validators to opt-out of validating a consumer chain. Meaning downtime infractions for these validators are dropped without ever reaching the provider.  This document specifies a modification to the ccv protocol which allows the bottom x% of the validator set by power to opt out of validating consumer chains without being jailed or otherwise punished for it. The feature is implemented with entirely consumer-side code.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#decision","content":" A consumer param exists, known as SoftOptOutThreshold, which is a string decimal in the range of [0, 0.2], that determines the portion of validators which are allowed to opt out of validating that specific consumer.  In every consumer beginblocker, a function is ran which determines the so called smallest non opt-out voting power. Validators with voting power greater than or equal to this value must validate the consumer chain, while validators below this value may opt out of validating the consumer chain.  The smallest non opt-out voting power is recomputed every beginblocker in UpdateSmallestNonOptOutPower(). In a nutshell, the method obtains the total voting power of the consumer, iterates through the full valset (ordered power ascending) keeping track of a power sum, and when powerSum / totalPower &gt; SoftOptOutThreshold, the SmallestNonOptOutPower is found and persisted.  Then, whenever the Slash() interface is executed on the consumer, if the voting power of the relevant validator being slashed is less than SmallestNonOptOutPower for that block, the slash request is dropped and never sent to the provider.  ","version":"Next","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#positive","content":" Small validators can opt out of validating specific consumers without being punished for it.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#negative","content":" The bottom x% is still part of the total voting power of the consumer chain. This means that if the soft opt-out threshold is set to 10% for example, and every validator in the bottom 10% opts out from validating the consumer, then a 24% downtime of the remaining voting power would halt the chain. This may be especially problematic during consumer upgrades.In nominal scenarios, consumers with soft opt out enabled will be constructing slash packets for small vals, which may be dropped. This is wasted computation, but necessary to keep implementation simple. Note that the sdk's full downtime logic is always executed on the consumer, which can be computationally expensive and slow down certain blocks.In a consumer chain, when a validator that has opted out becomes the proposer, there will naturally be no proposal made and validators would need to move to the next consensus round for the same height to reach a decision. As a result, we would need more time to finalize blocks on a consumer chain.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#neutral","content":" Validators in the bottom of the valset who don't have to validate, may receive large delegation(s) which suddenly boost the validator to the subset that has to validate. This may catch the validator off guard.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Soft Opt-Out","url":"/interchain-security/adrs/adr-009-soft-opt-out#references","content":" Original issue with some napkin math #784 ","version":"Next","tagName":"h2"},{"title":"Standalone to Consumer Changeover","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-010-standalone-changeover","content":"","keywords":"","version":"Next"},{"title":"ADR 010: Standalone to Consumer Changeover​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#adr-010-standalone-to-consumer-changeover","content":" ","version":"Next","tagName":"h2"},{"title":"Changelog​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#changelog","content":" 6/30/23: Feature completed, first draft of ADR.  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#status","content":" Implemented  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#context","content":" Stride will be the first consumer to &quot;changeover&quot; from a standalone cosmos blockchain, to a consumer chain secured by the Cosmos Hub. This document outlines the changes made to support this changeover process.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#decision","content":" ","version":"Next","tagName":"h2"},{"title":"Process​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#process","content":" Prior to the changeover, the consumer chain will have an existing staking keeper and validator set, these may be referred to as the &quot;standalone staking keeper&quot; and &quot;standalone validator set&quot; respectively.  The first step in the changeover process is to submit a ConsumerAdditionProposal. If the proposal passes, the provider will create a new IBC client for the consumer at spawn time, with the provider's validator set. A consumer genesis will also be constructed by the provider for validators to query. Within this consumer genesis contains the initial validator set for the consumer to apply after the changeover.  Next, the standalone consumer chain runs an upgrade which adds the CCV module, and is properly setup to execute changeover logic.  The consumer upgrade height must be reached after the provider has created the new IBC client. Any Interchain Security validators who will run the consumer, but are not a part of the sovereign validator set, must sync up a full node before the consumer upgrade height is reached. The disk state of said full node will be used to run the consumer chain after the changeover has completed.  The meat of the changeover logic is that the consumer chain validator set is updated to that which was specified by the provider via the queried consumer genesis. Validators which were a part of the old set, but not the new set, are given zero voting power. Once these validator updates are given to Comet, the set is committed, and in effect 2 blocks later (see FirstConsumerHeight).  A relayer then establishes the new IBC connection between the provider and consumer. The CCV channel handshake is started on top of this connection. Once the CCV channel is established and VSC packets are being relayed, the consumer chain is secured by the provider.  ","version":"Next","tagName":"h3"},{"title":"Changes to CCV Protocol​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#changes-to-ccv-protocol","content":" Consumer Genesis state is updated to include a PreCCV boolean. When this boolean is set true in the consumer genesis JSON, special logic is executed on InitGenesis to trigger the changeover process on the consumer's first endblocker after the upgrade which adds the CCV module. Note that InitGenesis is not automatically called during chain upgrades, so the consumer must manually call the consumer's InitGenesis method in an upgrade handler.The ConsumerAdditionProposal type is updated to include a DistributionTransmissionChannel field. This field allows the consumer to use an existing IBC transfer channel to send rewards as a part of the CCV protocol. Consumers that're not changing over from a standalone chain will leave this field blank, indicating that a new transfer channel should be created on top of the same connection as the CCV channel.The CCV consumer keeper is updated to contain an optional reference to the standalone staking keeper. The standalone staking keeper is used to slash for infractions that happened before the changeover was completed. Ie. any infraction from a block height before the changeover, that is submitted after the changeover, will call the standalone staking keeper's slash method. Note that a changeover consumer's standalone staking keeper becomes a democracy module keeper, so it is possible for a governance token to be slashed.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#positive","content":" Existing cosmos chains are now able to onboard over to a consumer chain secured by a provider.The previous staking keepers for such chains can be transitioned to democracy staking module keepers.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#negative","content":" The delineation between different types of consumers in this repo becomes less clear. Ie. there is code in the democracy consumer's app.go that only applies to a previously standalone chain, but that file also serves as the base for a normal democracy consumer launched with RS from genesis.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Standalone to Consumer Changeover","url":"/interchain-security/adrs/adr-010-standalone-changeover#references","content":" EPIC: Standalone to Consumer Changeover #756Changeover diagram from Stride ","version":"Next","tagName":"h2"},{"title":"ADR 011: Improving testing and increasing confidence","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-011-improving-test-confidence","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#changelog","content":" 2023-08-11: Proposed, first draft of ADR.  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#status","content":" Proposed  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#context","content":" Testing, QA, and maintenance of interchain-security libraries is an ever-evolving area of software engineering we have to keep incrementally improving. The purpose of the QA process is to catch bugs as early as possible. In an ideal development workflow a bug should never reach production. A bug found in the specification stage is a lot cheaper to resolve than a bug discovered in production (or even in testnet). Ideally, all bugs should be found during the CI execution, and we hope that no bugs will ever even reach the testnet (although nothing can replace actual system stress test under load interacting with users).  During development and testnet operation the following types of bugs were the most commonly found:  improper iterator usageunbounded array access/iterationimproper input handling and validationimproper cached context usagenon-determinism check (improper use of maps in go, relying on random values)KV store management and/or how keys are defineddeserialization issues arising from consumer/provider versioning mismatch  Such bugs can be discovered earlier with better tooling. Some of these bugs can induce increases in block times, chain halts, state corruption, or introduce an attack surface which is difficult to remove if other systems have started depending on that behavior.  Current state of testing​  Our testing suites consist of multiple parts, each with their own trade-offs and benefits with regards to code coverage, complexity and confidence they provide.  ","version":"Next","tagName":"h2"},{"title":"Unit testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#unit-testing","content":" Unit testing is employed mostly for testing single-module functionality. It is the first step in testing and often the most practical. While highly important, unit tests often test a single piece of code and don't test relationships between different moving parts, this makes them less valuable when dealing with multi-module interactions.  Unit tests often employ mocks to abstract parts of the system that are not under test. Mocks are not equivalent to actual models and should not be treated as such.  Out of all the approaches used, unit testing has the most tools available and the coverage can simply be displayed as % of code lines tested. Although this is a very nice and very easy to understand metric, it does not speak about the quality of the test coverage.  Since distributed systems testing is a lot more involved, unit tests are oftentimes not sufficient to cover complex interactions. Unit tests are still necessary and helpful, but in cases where unit tests are not helpful e2e or integration tests should be favored.  ","version":"Next","tagName":"h3"},{"title":"Integration testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#integration-testing","content":" With integration testing we test the multi-module interactions while isolating them from the remainder of the system. Integration tests can uncover bugs that are often missed by unit tests.  It is very difficult to gauge the actual test coverage imparted by integration tests and the available tooling is limited. In interchain-security we employ the ibc-go/testing framework to test interactions in-memory.  At present, integration testing does not involve the consensus layer - it is only concerned with application level state and logic.  ","version":"Next","tagName":"h3"},{"title":"End-to-end testing​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#end-to-end-testing","content":" In our context end-to-end testing comprises of tests that use the actual application binaries in an isolated environment (e.g. docker container). During test execution the inputs are meant to simulate actual user interaction, either by submitting transactions/queries using the command line or using gRPC/REST APIs and checking for state changes after an action has been performed. With this testing strategy we also include the consensus layer in all of our runs. This is the closest we can get to testing user interactions without starting a full testnet.  End-to-end testing strategies vary between different teams and projects and we strive to unify our approach to the best of our ability (at least for ICS and gaia).  The available tooling does not give us significant (or relevant) line of code coverage information since most of the tools are geared towards analyzing unit tests and simple code branch evaluation.  We aim to adapt our best practices by learning from other similar systems and projects such as cosmos-sdk, ibc-go and CometBFT.  ","version":"Next","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#decision","content":" ","version":"Next","tagName":"h2"},{"title":"1. Connect specifications to code and tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#1-connect-specifications-to-code-and-tooling","content":" Oftentimes, specifications are disconnected from the development and QA processes. This gives rise to problems where the specification does not reflect the actual state of the system and vice-versa. Usually specifications are just text files that are rarely used and go unmaintained after a while, resulting in consistency issues and misleading instructions/expectations about system behavior.  Decision context and hypothesis​  Specifications written in a dedicated and executable specification language are easier to maintain than the ones written entirely in text. Additionally, we can create models based on the specification OR make the model equivalent to a specification.  Models do not care about the intricacies of implementation and neither do specifications. Since both models and specifications care about concisely and accurately describing a system (such as a finite state machine), we see a benefit of adding model based tools (such as quint) to our testing and development workflows.  Main benefit​  MBT tooling can be used to generate test traces that can be executed by multiple different testing setups.  ","version":"Next","tagName":"h3"},{"title":"2. Improve e2e tooling​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#2-improve-e2e-tooling","content":" Matrix tests​  Instead of only running tests against current main branch we should adopt an approach where we also:  run regression tests against different released software versions (ICS v1 vs v2 vs v3)run non-determinism tests to uncover issues quickly  Matrix tests can be implemented using CometMock and refactoring our current e2e CI setup.  Introducing e2e regression testing​  This e2e test suite would execute using a cronjob in our CI (nightly, multiple times a day etc.)  Briefly, the same set of traces is run against different maintained versions of the software and the main branch. This would allow us to discover potential issues during development instead of in a testnet scenarios.  The most valuable issues that can be discovered in this way are state breaking changes, regressions and version incompatibilities.  The setup is illustrated by the image below.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  USES: ICS v1 PROVIDER\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv1 consumer (sdk45,ibc4.3)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v2 consumer (sdk45, ibc4.4)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ v3 consumer (sdk47, ibc7)\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main consumer\t❌\t❌\t❌\t❌\t❌\t❌\t❌\t❌ neutron\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌ stride\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t❌  Introducing e2e CometMock tests​  CometMock is a mock implementation of the CometBFT consensus engine. It supports most operations performed by CometBFT while also being lightweight and relatively easy to use.  CometMock tests allow more nuanced control of test scenarios because CometMock can &quot;fool&quot; the blockchain app into thinking that a certain number of blocks had passed.This allows us to test very nuanced scenarios, difficult edge cases and long-running operations (such as unbonding operations).  Examples of tests made easier with CometMock are listed below:  regression testsnon-determinism testsupgrade testsstate-breaking changes  With CometMock, the matrix test approach can also be used. The image below illustrates a CometMock setup that can be used to discover non-deterministic behavior and state-breaking changes.  This table explains which versions are tested against each other for the same set of test traces:  ✅ marks a passing test❌ marks a failing test  SCENARIO\tstart chain\tadd key\tdelegate\tundelegate\tredelegate\tdowntime\tequivocation\tstop chainv3 provi + v3 consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ main provi + main consu\t✅\t✅\t✅\t✅\t✅\t✅\t✅\t✅ commit provi + commit consu\t✅\t❌\t✅\t❌\t✅\t✅\t❌\t❌  Briefly; multiple versions of the application are run against the same CometMock instance and any deviations in app behavior would result in app hash errors (the apps would be in different states after performing the same set of actions).  ","version":"Next","tagName":"h3"},{"title":"3. Introduce innovative testing approaches​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#3-introduce-innovative-testing-approaches","content":" When discussing e2e testing, some very important patterns emerge - especially if test traces are used instead of ad-hoc tests written by hand.  We see a unique opportunity to clearly identify concerns and modularize the testing architecture.  The e2e testing frameworks can be split into a pipeline consisting of 3 parts: model, driver and harness.  Model​  Model is the part of the system that can emulate the behavior of the system under test. Ideally, it is very close to the specification and is written in a specification language such as quint, TLA+ or similar. One of the purposes of the model is that it can be used to generate test traces.  Driver​  The purpose of the driver is to accept test traces (generated by the model or written by hand), process them and provide inputs to the next part of the pipeline.  Basically, the driver sits between the model and the actual infrastructure on which the test traces are being executed on.  Harness​  Harness is the infrastructure layer of the pipeline that accepts inputs from the driver.  There can be multiple harnesses as long as they can perform four things:  bootstrap a test execution environment (local, docker, k8s…)accept inputs from driversperform the action specified by the driverreport results after performing actions  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#consequences","content":" The procedure outlined in this ADR is not an all-or-nothing approach. Concepts introduced here do not rely on each other, so this ADR may only be applied partially without negative impact on test coverage and code confidence.  ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#positive","content":" introduction of maintainable MBT solutions  improvement over the current &quot;difftest&quot; setup that relies on an opinionated typescript model and go driver  increased code coverage and confidence  using CometMock allows us to run more tests in less timeadding matrix e2e tests allows us to quickly pinpoint differences between code versions  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#negative","content":" It might be easier to forgo the MBT tooling and instead focus on pure property based testing  PBT proof of conceptproperty based testing in go  The solutions are potentially expensive if we increase usage of the CI pipeline - this is fixed by running &quot;expensive&quot; tests using a cronjob, instead of running them on every commit.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#neutral","content":" The process of changing development and testing process is not something that can be thought of and delivered quickly. Luckily, the changes can be rolled out incrementally without impacting existing workflows.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 011: Improving testing and increasing confidence","url":"/interchain-security/adrs/adr-011-improving-test-confidence#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  https://github.com/cosmos/gaia/issues/2427https://github.com/cosmos/gaia/issues/2420ibc-go e2e tests ","version":"Next","tagName":"h2"},{"title":"ADR 012: Separate Releasing","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-012-separate-releasing","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#changelog","content":" 0.0202020202020202: Initial draft of idea in #8010.01652892561983471: Put idea in this ADR0.05: Reject this ADR  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#status","content":" Rejected  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#context","content":" ","version":"Next","tagName":"h2"},{"title":"Spike results​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#spike-results","content":" I explored the idea of #801 with this spike branch. Here's my conclusions:  Splitting this repo to have multiple go.mods is possible. However there are various intricacies involved in decoupling the package hierarchy to have x/ccv/types as the lowest level dep, with x/ccv/consumer and x/ccv/provider being one dep layer above, with high-level tests depending on all three of the mentioned packages. I'd estimate this decoupling would take 2-5 workdays to finish, and require significant review effort.  ","version":"Next","tagName":"h3"},{"title":"Why go.mod split is not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#why-gomod-split-is-not-the-way-to-go","content":" Let's take a step back and remember the issue we're trying to solve - We need a clean way to decouple semver/releasing for the consumer and provider modules. After more consideration, splitting up go.mods gives us little benefit in achieving this. Reasons:  The go.mod dependency system is tied to git tags for the entire repo (ex: require github.com/cometbft/cometbft v0.37.2 refers to a historical tag for the entire cometbft repo).It'd be an odd dev experience to allow modules to reference past releases of other modules in the same repo. When would we ever want the consumer module to reference a past release of the types module for example?If we allow for go.mod replace statements to build from local source code, why split up the package deps at all?Splitting go.mods adds a bunch of complexity with go.work files and all that shiz. VSCode does not play well with multiple module repos either.  ","version":"Next","tagName":"h3"},{"title":"Why separate repos is cool but also not the way to go​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#why-separate-repos-is-cool-but-also-not-the-way-to-go","content":" All this considered, the cleanest solution to decoupling semver/releasing for the consumer and provider modules would be to have multiple repos, each with their own go.mod (3-4 repos total including high level tests). With this scheme we could separately tag each repo as changes are merged, they could share some code from types being an external dep, etc.  I don't think any of us want to split up the monorepo, that's a lot of work and seems like bikeshedding. There's another solution that's very simple..  ","version":"Next","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#decision","content":" Slightly adapting the current semver ruleset:  A library API breaking change to EITHER the provider or consumer module will result in an increase of the MAJOR version number for BOTH modules (X.y.z-provider AND X.y.z-consumer).A state breaking change (change requiring coordinated upgrade and/or state migration) will result in an increase of the MINOR version number for the AFFECTED module(s) (x.Y.z-provider AND/OR x.Y.z-consumer).Any other changes (including node API breaking changes) will result in an increase of the PATCH version number for the AFFECTED module(s) (x.y.Z-provider AND/OR x.y.Z-consumer).  ","version":"Next","tagName":"h2"},{"title":"Example release flow​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#example-release-flow","content":" We upgrade main to use a new version of SDK. This is a major version bump, triggering a new release for both the provider and consumer modules, v5.0.0-provider and v5.0.0-consumer.  A state breaking change is merged to main for the provider module. We release only a v5.1.0-provider off main.Another state breaking change is merged to main for the provider module. We release only a v5.2.0-provider off main.At this point, the latest consumer version is still v5.0.0-consumer. We now merge a state breaking change for the consumer module to main, and consequently release v5.1.0-consumer. Note that v5.1.0-consumer is tagged off a LATER commit from main than v5.2.0-provider. This is fine, as the consumer module should not be affected by the provider module's state breaking changes.Once either module sees a library API breaking change, we bump the major version for both modules. For example, we merge a library API breaking change to main for the provider module. We release v6.0.0-provider and v6.0.0-consumer off main. Note that most often, a library API breaking change will affect both modules simultaneously (example being bumping sdk version).  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#positive","content":" Consumer repos have clear communication of what tagged versions are relevant to them. Consumer devs should know to never reference an ICS version that starts with provider, even if it'd technically build.Consumer and provider modules do not deviate as long as we continually release off a shared main branch. Backporting remains relatively unchanged besides being explicit about what module(s) your changes should affect.No code changes, just changes in process. Very simple.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#negative","content":" ~~Slightly more complexity.~~Considerably more complex to manage the ICS library. This is because ICS needs to support multiple versions of SDK (e.g., 0.45, 0.47, 0.50). In addition, ICS needs to support a special fork of SDK (with LSM included) for the Cosmos Hub. This means that instead of focusing on main the development team needs to manage multiple release branches with different dependency trees.This solution does not allow having provider and consumer on separate versions of e.g. the Cosmos SDK.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#neutral","content":" ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 012: Separate Releasing","url":"/interchain-security/adrs/adr-012-separate-releasing#references","content":" Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!  #801#801 comment ","version":"Next","tagName":"h2"},{"title":"ADR 013: Slashing on the provider for consumer equivocation","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-013-equivocation-slashing","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#changelog","content":" 1st Sept. 2023: Initial draft  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#context","content":" This ADR presents some approaches on how to slash on the provider chain validators that performed equivocations on consumer chains. Currently, the provider chain can receive and verify evidence of equivocation, but it cannot slash the misbehaving validator.  In the remainder of this section, we explain how slashing is performed on a single chain and show why slashing on the provider for equivocation on the consumer is challenging.  Note that future versions of the Cosmos SDK, CometBFT, and ibc-go could modify the way we slash, etc. Therefore, a future reader of this ADR, should note that when we refer to Cosmos SDK, CometBFT, and ibc-go we specifically refer to their v0.47, v0.37 and v7.3.0 versions respectively.  ","version":"Next","tagName":"h2"},{"title":"Single-chain slashing​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#single-chain-slashing","content":" Slashing is implemented across the slashingand staking modules. The slashing module's keeper calls the staking module's Slash() method, passing among others, the infractionHeight (i.e., the height when the equivocation occurred), the validator's power at the infraction height, and the slashFactor (currently set to 5% in case of equivocation on the Cosmos Hub).  Slashing undelegations and redelegations​  To slash undelegations, Slash goes through all undelegations and checks whether they started before or after the infraction occurred. If an undelegation started before the infractionHeight, then it is not slashed, otherwise it is slashed by slashFactor.  The slashing of redelegations happens in a similar way, meaning that Slash goes through all redelegations and checks whether the redelegations started before or after the infractionHeight.  Slashing delegations​  Besides undelegations and redelegations, the validator's delegations need to also be slashed. This is performed by deducting the appropriate amount of tokens from the validator. Note that this deduction is computed based on the voting power the misbehaving validator had at the height of the equivocation. As a result of the tokens deduction, the tokens per sharereduce and hence later on, when delegators undelegate or redelegate, the delegators retrieve back less tokens, effectively having their tokens slashed. The rationale behind this slashing mechanism, as mentioned in the Cosmos SDK documentation  [...] is to simplify the accounting around slashing. Rather than iteratively slashing the tokens of every delegation entry, instead the Validators total bonded tokens can be slashed, effectively reducing the value of each issued delegator share.  This approach of slashing delegations does not utilize theinfractionHeight in any way and hence the following scenario could occur:  a validator V performs an equivocation at a height Hia new delegator D delegates to V after height Hievidence of the equivocation by validator V is receivedthe tokens of delegator D are slashed  In the above scenario, delegator D is slashed, even though D's voting power did not contribute to the infraction.  Old evidence​  In the single-chain case, old evidence (e.g., from 3 years ago) is ignored. This is achieved throughCometBFT that ignores old evidence based on the parameters MaxAgeNumBlocks and MaxAgeDuration (see here). Additionally, note that when the evidence is sent by CometBFT to the application, the evidence is rechecked in the evidence module of Cosmos SDK and if it is old, the evidence is ignored. In Cosmos Hub, the MaxAgeNumBlocks is set to 1000000 (i.e., ~70 days if we assume we need ~6 sec per block) and MaxAgeDuration is set to 172800000000000 ns (i.e., 2 days). Because of this check, we can easily exclude old evidence.  ","version":"Next","tagName":"h3"},{"title":"Slashing for equivocation on the consumer​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#slashing-for-equivocation-on-the-consumer","content":" In the single-chain case, slashing requires both the infractionHeight and the voting power. In order to slash on the provider for an equivocation on a consumer, we need to have both the provider's infractionHeight and voting power. Note that the infractionHeight on the consumer chain must be mapped to a height on the provider chain. Unless we have a way to find the corresponding infractionHeight and power on the provider chain, we cannot slash for equivocation on the consumer in the same way as we would slash in the single-chain case.  The challenge of figuring out the corresponding infractionHeight and power values on the provider chain is due to the following trust assumption:  We trust the consensus layer and validator set of the consumer chains, but we do not trust the application layer.  As a result, we cannot trust anything that stems from the application state of a consumer chain.  Note that when a relayer or a user sends evidence through a MsgSubmitConsumerDoubleVoting message, the provider gets access to DuplicateVoteEvidence:  type DuplicateVoteEvidence struct { VoteA *Vote `json:&quot;vote_a&quot;` VoteB *Vote `json:&quot;vote_b&quot;` // abci specific information TotalVotingPower int64 ValidatorPower int64 Timestamp time.Time }   The &quot;abci specific information&quot; fields cannot be trusted because they are not signed. Therefore, we can use neither ValidatorPower for slashing on the provider chain, nor the Timestamp to check the evidence age. We can get the infractionHeight from the votes, but this infractionHeight corresponds to the infraction height on the consumer and not on the provider chain. Similarly, when a relayer or a user sends evidence through a MsgSubmitConsumerMisbehaviour message, the provider gets access to Misbehaviour that we cannot use to extract the infraction height, power, or the time on the provider chain.  ","version":"Next","tagName":"h3"},{"title":"Proposed solution​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#proposed-solution","content":" As a first iteration, we propose the following approach. At the moment the provider receives evidence of equivocation on a consumer:  slash all the undelegations and redelegations using slashFactor;slash all delegations using as voting power the sum of the voting power of the misbehaving validator and the power of all the ongoing undelegations and redelegations.  Evidence expiration: Additionally, because we cannot infer the actual time of the evidence (i.e., the timestamp of the evidence cannot be trusted), we do not consider evidence expiration and hence old evidence is never ignored (e.g., the provider would act on 3 year-old evidence of equivocation on a consumer). Additionally, we do not need to store equivocation evidence to avoid slashing a validator more than once, because we do not slash tombstoned validators and we tombstone a validator when slashed.  We do not act on evidence that was signed by a validator consensus key that is pruned when we receive the evidence. We prune a validator's consensus key if the validator has assigned a new consumer key (using MsgAssignConsumerKey) and an unbonding period on the consumer chain has elapsed (see key assignment ADR). Note that the provider chain is informed that the unbonding period has elapsed on the consumer when the provider receives a VSCMaturedPacket and because of this, if the consumer delays the sending of a VSCMaturedPacket, we would delay the pruning of the key as well.  ","version":"Next","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#implementation","content":" The following logic needs to be added to the HandleConsumerDoubleVoting and HandleConsumerMisbehaviour methods:  undelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetUnbondingDelegationsFromValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // undelegation no longer eligible for slashing, skip it continue } undelegationsInTokens = undelegationsInTokens.Add(entry.InitialBalance) } } redelegationsInTokens := sdk.NewInt(0) for _, v := range k.stakingKeeper.GetRedelegationsFromSrcValidator(ctx, validatorAddress) { for _, entry := range v.Entries { if entry.IsMature(now) &amp;&amp; !entry.OnHold() { // redelegation no longer eligible for slashing, skip it continue } redelegationsInTokens = redelegationsInTokens.Add(entry.InitialBalance) } } infractionHeight := 0 undelegationsAndRedelegationsInPower = sdk.TokensToConsensusPower(undelegationsInTokens.Add(redelegationsInTokens)) totalPower := validator's voting power + undelegationsAndRedelegationsInPower slashFraction := k.slashingKeeper.SlashFractionDoubleSign(ctx) k.stakingKeeper.Slash(ctx, validatorConsAddress, infractionHeight, totalPower, slashFraction, DoubleSign)   Infraction height: We provide a zero infractionHeight to the Slash method in order to slash all ongoing undelegations and redelegations (see checks in Slash, SlashUnbondingDelegation, and SlashRedelegation).  Power: We pass the sum of the voting power of the misbehaving validator when the evidence was received (i.e., at evidence height) and the power of all the ongoing undelegations and redelegations. If we assume that the slashFactor is 5%, then the voting power we pass is power + totalPower(undelegations) + totalPower(redelegations). Hence, when the Slash method slashes all the undelegations and redelegations it would end up with 0.05 * power + 0.05 * totalPower(undelegations) + 0.05 * totalPower(redelegations) - 0.05 * totalPower(undelegations) - 0.05 * totalPower(redelegations) = 0.05 * power and hence it would slash 5% of the validator's power when the evidence is received.  ","version":"Next","tagName":"h3"},{"title":"Positive​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#positive","content":" With the proposed approach we can quickly implement slashing functionality on the provider chain for consumer chain equivocations. This approach does not need to change the staking module and therefore does not change in any way how slashing is performed today for a single chain.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#negative","content":" We definitely slash more when it comes to undelegations and redelegations because we slash for all of them without considering an infractionHeight.We potentially slash more than what we would have slashed if we knew the voting power at the corresponding infractionHeight in the provider chain.We slash on old evidence of equivocation on a consumer.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 013: Slashing on the provider for consumer equivocation","url":"/interchain-security/adrs/adr-013-equivocation-slashing#references","content":" ADR 005: Cryptographic verification of equivocation evidenceEPIC tracking cryptographic equivocation featureCosmos Hub Forum discussion on cryptographic equivocation slashing ","version":"Next","tagName":"h2"},{"title":"ADR 014: Epochs","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-014-epochs","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/adrs/adr-014-epochs#changelog","content":" 2024-01-05: Proposed, first draft of ADR.2024-02-29: Updated so that it describes the implementation where we store the whole consumer validator set.  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/adrs/adr-014-epochs#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/adrs/adr-014-epochs#context","content":" In every block that the provider valset changes, a VSCPacket must be sent to every consumer and a corresponding VSCMaturedPacket sent back. Given that the validator powers may change very often on the provider chain (e.g., the Cosmos Hub), this approach results in a large workload for the relayers. Although the validator powers may change very often, these changes are usually small and have an insignificant impact on the chain's security. In other words, the valset on the consumers can be slightly outdated without affecting security. As a matter of fact, this already happens due to relaying delays.  As a solution, this ADR introduces the concept of epochs. An epoch consists of multiple blocks. The provider sends VSCPackets once per epoch. A VSCPacket contains all the validator updates that are needed by a consumer chain.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/adrs/adr-014-epochs#decision","content":" The implementation of epochs requires the following changes:  For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the consumer chain. For each validator in the set we store i) its voting power, and ii) the public key that it is using on the consumer chain during the current (i.e., ongoing) epoch. The initial consumer validator set for a chain is set during the creation of the consumer genesis.We introduce the BlocksPerEpoch param that sets the number of blocks in an epoch. By default, BlocksPerEpoch is set to be 600 which corresponds to 1 hour, assuming 6 seconds per block. This param can be changed through a governance proposal. In the provider EndBlock we check BlockHeight() % BlocksPerEpoch() == 0to decide when an epoch has ended.At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we construct a VSCPacket with all the validator updates and add it to the list of PendingVSCPackets. We compute the validator updates needed by a consumer chain by comparing the stored list of consumer validators with the current bonded validators on the provider, with something similar to this:  // get the valset that has been validating the consumer chain during this epoch currentValidators := GetConsumerValSet(consumerChain) // generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators // in the epoch with the latest bonded validators valUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators()) // update the current validators set for the upcoming epoch to be the latest bonded validators instead SetConsumerValSet(stakingmodule.GetBondedValidators())   Note that a validator can change its consumer public key for a specific consumer chain an arbitrary amount of times during a block and during an epoch. Then, when we generate the validator updates in DiffValidators, we have to check whether the current consumer public key (retrieved by calling GetValidatorConsumerPubKey) is different from the consumer public key the validator was using in the current epoch.  ","version":"Next","tagName":"h2"},{"title":"Consequences​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/adrs/adr-014-epochs#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/adrs/adr-014-epochs#positive","content":" Reduce the cost of relaying.Reduce the amount of IBC packets needed for ICS.Simplifies key-assignment code because we only need to check if the consumer_public_key has been modified since the last epoch to generate an update.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/adrs/adr-014-epochs#negative","content":" Increase the delay in the propagation of validator set changes (but for reasonable epoch lengths on the order of ~hours or less, this is unlikely to be significant).  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/adrs/adr-014-epochs#neutral","content":" N/A  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 014: Epochs","url":"/interchain-security/adrs/adr-014-epochs#references","content":" EPIC ","version":"Next","tagName":"h2"},{"title":"ADR 015: Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-015-partial-set-security","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#changelog","content":" 2024-01-22: Proposed, first draft of ADR.  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#context","content":" Currently, in Replicated Security, the entire validator set of the provider chain is used to secure consumer chains. There are at least three concerns with this approach. First, a large number of validators might be forced to validate consumer chains they are not interested in securing. Second, it is costly for small validators to secure additional chains. This concern is only partially addressed through soft opt-out that allows small validators to opt out from validating consumer chains. Third and for the above reasons, it is challenging for a new consumer chain to join Replicated Security.  As a solution, we present Partial Set Security (PSS). As the name suggests, PSS allows for every consumer chain to be secured by only a subset of the provider validator set. In what follows we propose the exact steps we need to take to implement PSS. This is a first iteration of PSS, and therefore we present the most minimal solution that make PSS possible.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#decision","content":" In Replicated Security, all the provider validators have to secure every consumer chain (with the exception of those validators allowed to opt out through the soft opt-out feature).  In PSS, we allow validators to opt in and out of validating any given consumer chain. This has one exception: we introduce a parameter N for each consumer chain and require that the validators in top N% of the provider's voting power have to secure the consumer chain. Validators outside of the top N% can dynamically opt in if they want to validate on the consumer chain.  For example, if a consumer chain has N = 95%, then it ultimately receives the same security it receives today with Replicated Security (with a default SoftOptOutThreshold of 5%). On the other hand, if a consumer chain has N = 0%, then no validator is forced to validate the chain, but validators can opt in to do so instead.  For the remainder of this ADR, we call a consumer chain Top N if it has joined as a Top N chain with N &gt; 0 and Opt In chain otherwise. An Opt In consumer chain is secured only by the validators that have opted in to secure that chain.  We intend to implement PSS using a feature branch off v4.0.0 interchain security.  ","version":"Next","tagName":"h2"},{"title":"How do consumer chains join?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#how-do-consumer-chains-join","content":" As a simplification and to avoid chain id squatting, a consumer chain can only join PSS through a governance proposal and not in a permissionless way.  However, this proposal type will be modified so that it requires a lower quorum percentage than normal proposal, and every validator who voted &quot;YES&quot; on the proposal will form the consumer chain's initial validator set.  Consumer chains join PSS the same way chains now join Replicated Security, namely through a ConsumerAdditionProposal proposal. We extend ConsumerAdditionProposal with one optional field:  uint32 top_N: Corresponds to the percentage of validators that join under the Top N case. For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators have to validate the proposed consumer chain.top_N can be 0 or include any value in [50, 100]. A chain can join with top_N == 0 as an Opt In, or with top_N ∈ [50, 100] as a Top N chain.  In case of a Top N chain, we restrict the possible values of top_N from (0, 100] to [50, 100]. By having top_N &gt;= 50 we can guarantee that we cannot have a successful attack, assuming that at most 1/3 of provider validators can be malicious. This is because, a Top N chain with N &gt;= 50% would have at least 1/3 honest validators, which is sufficient to stop attacks. Additionally, by having N &gt;= 50% (and hence N &gt; (VetoThreshold = 33.4%)) we enable the top N validators to Veto any ConsumerAdditionProposal for consumer chains they do not want to validate.  If a proposal has the top_N argument wrongly set, it should get rejected in [ValidateBasic] (https://github.com/cosmos/interchain-security/blob/v4.0.0/x/ccv/provider/types/proposal.go#L86).  In the code, we distinguish whether a chain is Top N or Opt In by checking whether top_N is zero or not.  In a future version of PSS, we intend to introduce a ConsumerModificationProposal so that we can modify the parameters of a consumer chain, e.g, a chain that is Opt In to become Top N, etc.  State &amp; Query​  We augment the provider module’s state to keep track of the top_N value for each consumer chain. The key to store this information would be:  topNBytePrefix | len(chainID) | chainID   To create the above key, we can use ChainIdWithLenKey.  Then in the keeper we introduce methods as follows:  func (k Keeper) SetTopN(ctx sdk.Context, chainID string, topN uint32) func (k Keeper) IsTopN(ctx sdk.Context, chainID string) bool func (k Keeper) IsOptIn(ctx sdk.Context, chainID string) bool // returns the N if Top N chain, otherwise an error func (k Keeper) GetTopN(ctx sdk.Context, chainID string) (uint32, error)   We also extend the interchain-security-pd query provider list-consumer-chains query to return information on whether a consumer chain is an Opt In or a Top N chain and with what N. This way, block explorers can present informative messages such as &quot;This chain is secured by N% of the provider chain&quot; for consumer chains.  ","version":"Next","tagName":"h3"},{"title":"How do validators opt in?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#how-do-validators-opt-in","content":" A validator can opt in by sending a new type of message that we introduce in tx.proto.  message MsgOptIn { // the chain id of the consumer chain to opt in to string chainID = 1; // the provider address of the validator string providerAddr = 2; // (optional) the consensus public key to use on the consumer optional string consumerKey = 3; }   Note that in a Top N consumer chain, the top N% provider validators have to validate the consumer chain. Nevertheless, validators in the bottom (100 - N)% can opt in to validate as well. Provider validators that belong or enter the top N% validators are automatically opted in to validate a Top N consumer chain. This means that if a validator V belongs to the top N% validators but later falls (e.g., due to undelegations) to the bottom (100 - N)%, V is still considered opted in and has to validate unless V sends a MsgOptOut message (see below). By automatically opting in validators when they enter the top N% validators and by forcing top N% validators to explicitly opt out in case they fall to the (100 - N)% bottom validators we simplify the design of PSS.  Note that a validator can send a MsgOptIn message even if the consumer chain is not yet running. To do this we reuse the IsConsumerProposedOrRegistered. If the chainID does not exist, the MsgOptIn should fail, as well as if the provider address does not exist.  Optionally, a validator that opts in can provide a consumerKey so that it assigns a different consumer key (from the provider) to the consumer chain. Naturally, a validator can always change the consumer key on a consumer chain by sending a MsgAssignConsumerKey message at a later point in time, as is done in Replicated Security.  State &amp; Query​  For each validator, we store a pair (blockHeight, isOptedIn) that contains the block height the validator opted in and whether the validator is currently opted in or not, under the key:  optedInBytePrefix | len(chainID) | chainID | addr   By using a prefix iterator on optedInBytePrefix | len(chainID) | chainID we retrieve all the opted in validators.  We introduce the following Keeper methods.  // returns all the validators that have opted in on chain `chainID` func (k Keeper) GetOptedInValidators(ctx sdk.Context, chainID string) []Validators func (k Keeper) IsValidatorOptedIn(ctx sdk.Context, chainID string, val Validator) bool   We introduce the following two queries:  interchain-security-pd query provider optedInValidators $chainID interchain-security-pd query provider hasToValidate $providerAddr   One query to retrieve the validators that are opted in and hence the validators that need to validate the consumer chain and one query that given a validator's address returns all the chains this validator has to validate.  When do validators opt in?​  As described earlier, validators can manually opt in by sending a MsgOptIn message. Additionally, in a Top N chain, a validator is automatically opted in when it moves from the bottom (100 - N)% to the top N% validators.  Lastly, validators can also opt in if they vote Yes during the ConsumerAdditionProposal that introduces a consumer chain. This simplifies validators operations because they do not have to send an additional message to opt in.  Because the Tally method deletes the votes after reading them, we cannot check the votes of the validators after the votes have been tallied. To circumvent this, we introduce a hook for AfterProposalVote and keep track of all the votes cast by a validator. If a validator casts more than one vote, we only consider the latest vote. Finally, we only consider a validator has opted in if it casts a 100% Yes vote in case of a weighted vote.  ","version":"Next","tagName":"h3"},{"title":"How do validators opt out?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#how-do-validators-opt-out","content":" Validators that have opted in on a chain can opt out by sending the following message:  message MsgOptOut { // the chain id of the consumer chain to opt out from string chainID = 1; // the provider address of the validator string providerAddr = 2; }   Validators can only opt out after a consumer chain has started and hence the above message returns an error if the chain with chainID is not running. Additionally, a validator that belongs to the top N% validators cannot opt out from a Top N chain and hence a MsgOptOut would error in such a case.  State &amp; Query​  We also update the state of the opted-in validators when a validator has opted out by removing the opted-out validator.  Note that only opted-in validators can be punished for downtime on a consumer chain. For this, we use historical info of all the validators that have opted in; We can examine the blockHeight stored under the key optedInBytePrefix | len(chainID) | chainID | addr to see if a validator was opted in. This way we can jail validators for downtime knowing that indeed the validators have opted in at some point in the past. Otherwise, we can think of a scenario where a validator V is down for a period of time, but before V gets punished for downtime, validator V opts out, and then we do not know whether V should be punished or not.  ","version":"Next","tagName":"h3"},{"title":"When does a consumer chain start?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#when-does-a-consumer-chain-start","content":" A Top N consumer chain always starts at the specified date (spawn_time) if the ConsumerAdditionProposal has passed. An Opt In consumer chain only starts if at least one validator has opted in. We check this in BeginBlockInit:  func (k Keeper) BeginBlockInit(ctx sdk.Context) { propsToExecute := k.GetConsumerAdditionPropsToExecute(ctx) for _, prop := range propsToExecute { chainID := prop.ChainId if !k.IsTopN(ctx, chainID) &amp;&amp; len(k.GetOptedInValidators(ctx, chainID)) == 0 { // drop the proposal ctx.Logger().Info(&quot;could not start chain because no validator has opted in&quot;) continue } ...   ","version":"Next","tagName":"h3"},{"title":"How do we send the partial validator sets to the consumer chains?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#how-do-we-send-the-partial-validator-sets-to-the-consumer-chains","content":" A consumer chain should only be validated by opted in validators. We introduce logic to do this when we queue the VSCPackets. The logic behind this, is not as straightforward as it seems because CometBFT does not receive the validator set that has to validate a chain, but rather a delta of validator updates. For example, to remove an opted-out validator from a consumer chain, we have to send a validator update with a power of 0, similarly to what is done in the assignment of consumer keys. We intend to update this ADR at a later stage on how exactly we intend to implement this logic.  ","version":"Next","tagName":"h3"},{"title":"How do we distribute rewards?​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#how-do-we-distribute-rewards","content":" Currently, rewards are distributed as follows: The consumer periodically sends rewards on the provider ConsumerRewardsPool address. The provider then transfers those rewards to the fee collector address and those transferred rewards are distributed to validators and delegators.  In PSS, we distribute rewards only to validators that actually validate the consumer chain. To do this, we have a pool associated with each consumer chain and consumers IBC transfer the rewards to this pool. We then extract the rewards from each consumer pool and distribute them to the opted in validators.  Note that we only distribute rewards to validators that have been opted in for some time (e.g., 10000 blocks) to avoid cases where validators opt in just to receive rewards and then opt out immediately afterward.  ","version":"Next","tagName":"h3"},{"title":"Misbehaviour​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#misbehaviour","content":" Fraud votes​  In an Opt In chain, a set of validators might attempt to perform an attack. To deter such potential attacks, PSS allows for the use of fraud votes. A fraud vote is a governance proposal that enables the slashing of validators that performed an attack. Due to their inherent complexity, we intend to introduce fraud votes in a different ADR and at a future iteration of PSS.  Double signing​  We do not change the way slashing for double signing and light client attacks functions. If a validator misbehaves on a consumer, then we slash that validator on the provider.  Downtime​  We do not change the way downtime jailing functions. If a validator is down on a consumer chain for an adequate amount of time, we jail this validator on the provider but only if the validator was opted in on this consumer chain in the recent past.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#positive","content":" Easier for new consumer chains to consume the provider's chain economic security because proposals are more likely to pass if not everyone is forced to validate. Smaller validators are not forced to validate chains anymore if they do not want to. We can deprecate the soft opt-out implementation.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#negative","content":" A consumer chain does not receive the same economic security as with Replicated Security (assuming the value of SoftOptOutThreshold is 5%), unless it is a Top N chain with N &gt;= 95%.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 015: Partial Set Security","url":"/interchain-security/adrs/adr-015-partial-set-security#references","content":" PSS: Permissionless vs premissioned-lite opt-in consumer chainsCHIPs discussion phase: Partial Set Security (updated)PSS: Exclusive vs Inclusive Top-NInitial PSS ADR and notes #1518Replicated vs. Mesh Security ","version":"Next","tagName":"h2"},{"title":"ADR 016: Security aggregation","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-016-securityaggregation","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#changelog","content":" 2024-04-24: Initial draft of ADR  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#status","content":" Proposed  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#context","content":" Security Aggregation enables staking of tokens from external sources such as Ethereum or Bitcoin to Cosmos blockchains. By integrating Security Aggregation, a Cosmos blockchain can be secured by both native tokens and external tokens (e.g. ETH, BTC).  Security Aggregation consists of the following parts:  A mechanism for delegating external tokens to Cosmos validators, such as Babylon or EigenLayer AVS contract.An oracle that tracks how much external stake has been delegated to each Cosmos validator and provides price feeds for external tokens.Power mixing: a mechanism to combine external and native stake to derive the power of each validator.A reward distribution protocol that enables sending back rewards to the external source.  External staking information is received from an oracle together with price information of related stakes. The CosmosLayer derives validator powers based on external and native staking information and initiates rewarding of external depositors.  This ADR describes the Cosmos modules of the solution.  ","version":"Next","tagName":"h2"},{"title":"Alternative Approaches​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#alternative-approaches","content":" ","version":"Next","tagName":"h2"},{"title":"Rewards​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#rewards","content":" As an alternative to sending rewards back to the external chains, stakers could be rewarded on the Cosmos chain. This would require a mapping of external addresses to addresses on Cosmos chain for each staker on external source. In addition detailed external staking information such as staking addresses, amount of stakes per staker and validator, etc. have to be provided by the oracle.  ","version":"Next","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#decision","content":" ","version":"Next","tagName":"h2"},{"title":"Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#rewards-will-be-sent-back-to-external-chains-instead-of-paying-rewards-for-external-stakers-on-cosmos-chain","content":" Rewards will be sent back to external chains instead of paying rewards for external stakers on Cosmos chain  due to amount of additional staking information to be sent and tracked by the oracledue to the additional complexity of managing external and Cosmos addresses  ","version":"Next","tagName":"h3"},{"title":"Detailed Design​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#detailed-design","content":" The Power Mixing feature and Reward Distribution protocol are an integral part of the Security Aggregation solution. The Power Mixing module provides the capability of deriving validator power based on stake originated from external sources such as Ethereum/Bitcoin and the native staking module. The Reward Distribution manages the process of sending rewards to external stakers.  ","version":"Next","tagName":"h2"},{"title":"Power Mixing​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#power-mixing","content":" Power Mixing provides the final validator powers based on staking information of the native chain and the external stakes. The information about external staking and related price feeds are received from an oracle. Once the final validator powers are determined the result is submitted to the underlying CometBFT consensus layer by updating the validator set.  Requirements:  validator updates are performed on each EndBlocka validator's power is determined based on its native on-chain stakes and external stakesprice information of staked tokens is used to determine a validator’s power, e.g. price ratio (price of native on-chain token / price of external stake)price information of native/external tokens are received from an oraclestaking information from external sources received from the oraclenative staking information are received from the Cosmos SDK Staking Moduleset of validator stakes from oracle always have the current price, full set of validators, and current stakes  The Power Mixing implementation  queries current validators and their powers from x/stakingand from oracle (see below).calculates power updates by mixing power values of external and internal sources Following pseudocode snippet shows a possible implementation of how power mixing feature works.  // PowerSource is an abstract entity providing validator powers which // are used by the mixer. This can be an oracle, staking module or an // IBC connected bridge. type PowerSource interface { GetValidatorUpdates() []abci.ValidatorUpdate } // MixPowers calculates power updates by mixing validator powers from different sources func (k *Keeper) MixPowers(source ...PowerSource) []abci.ValidatorUpdate { var valUpdate []abci.ValidatorUpdate for _, ps := range source { // mix powers from two sets of validator updates an return set of validator updates // with aggregated powers valUpdate = mixPower(valUpdate, ps.GetValidatorUpdates()) } return valUpdate } func (k *keeper) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { // GetPowerSources (including local staking module) registeredPowerSource := GetPowerSources() return k.MixPowers(registeredPowerSource...) }   Integration with ICS provider​  The provider module updates the validator set on CometBFT instead of the SDK staking module (x/staking). The provider implementation will intervene in this behavior and ensure that the validator updates are taken from the Power Mixing feature.  External power sources are managed by the provider module. Only registered power sources can provide input to the Power Mixing feature. Power sources will be assigned a unique identifier which will be used by the oracle, provider module and the power mixing and rewarding feature.  Updates with the next validator set are sent to consumer chains on each epoch (see EndBlockVSU()). When collecting the validator updates for each consumer chain (see QueueVSCPackets()), the validator powers of the bonded validators will be updated with the validator powers from the external sources using the Power Mixing module. These updates are sent as part of the VSC packets to all registered consumer chains.  Integration with ICS consumer​  Consumer chains receive validator updates as part of VSC packets from the provider. These packets contain validator powers which were already mixed with external staked powers.  ","version":"Next","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#queries","content":" // GetValidatorUpdates returns the power mixed validator results from the provided sources service Query { rpc GetValidatorUpdates(PowerMixedValUpdateRequest) PowerMixedValUpdateResponse {}; } // PowerMixedValUpdateRequest contains the list of power sources on which the // power mixing should be based on message PowerMixedValUpdateRequest { repeated PowerSource sources; } // PowerMixedValUpdateResponse returns the validator set with the updated powers // from the power mixing feature message PowerMixedValUpdateResponse { repeated abci.ValidatorUpdate val_set }   The following queries will be provided by the oracle  service Query { rpc GetExtValidators(GetExtValidatorRequest) returns (ExtValidatorsResponse) { option (google.api.http).get = &quot;oracle/v1/get_validators&quot;; }; } message GetExtValidatorRequest {} // ExtValidatorsResponse is the response from GetExtValidators queries message ExtValidatorsResponse { repeated ExtValPower powers; } // ExtValPower represents a validator with its staking and token information, // where: // `power_source_identifier` is the identifier of the registered power source // `validator_address` is the address of the validator // `stakes` is the total amount of stakes for a validator // `denom` is the source token of the stake e.g. ETH,BTC // `price_ratio` is the ratio of price of the external token to the price of the 'local' token message ExtValPower { string power_source_identifier; string validator_address; uint64 stakes; string denom; float price_ratio; } // GetPrice returns a price feed for a given token service Query { rpc GetPrice(GetPriceRequest) returns (GetPriceResponse) { option (google.api.http).get = &quot;/oracle/v1/get_price&quot;; }; }   For security reasons the amount of external stakes needs to be limited. Limitation of external staking could be driven by governance and is not subject of this version of the ADR.  ","version":"Next","tagName":"h3"},{"title":"Reward Handler​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#reward-handler","content":" For native staked tokens the Distribution Module of the Cosmos SDK is taking care of sending the rewards to stakers. For stakes originated from external chains (Ethereum/Bitcoin) the Reward Handler module sends rewards to EigenLayer/Babylon. The transfer of rewards is done using a bridge between the Cosmos chain and the external provider chain.  Note: currently there's no support paying rewards on EigenLayer (see here)  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#positive","content":" Allow external depositors to stake their tokens to secure a Cosmos chain  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#negative","content":" Dependency to external sources e.g (price feeds) for validator power calculationSecurity impact  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#neutral","content":" Additional complexity for staking  ","version":"Next","tagName":"h3"},{"title":"Questions:​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#questions","content":" Slashing: subject of this ADR? (Defined but not activated currently on EigenLayer).  ","version":"Next","tagName":"h2"},{"title":"References​","type":1,"pageTitle":"ADR 016: Security aggregation","url":"/interchain-security/adrs/adr-016-securityaggregation#references","content":" EigenLayerBabylon ","version":"Next","tagName":"h2"},{"title":"ADR 017: ICS with Inactive Provider Validators","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#changelog","content":" 15th May 2024: Initial draft  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#context","content":" Currently, only validators in the active set on the provider can validate on consumer chains, which limits the number of validators that can participate in Interchain Security (ICS). Validators outside of the active set might be willing to validate on consumer chains, but we might not want to make the provider validator set larger, e.g. to not put more strain on the consensus engine. This runs the risk of leaving consumer chains with too few validators.  The purpose of this ADR is to allow validators that are not part of the consensus process on the provider chain (because they are inactive) to validate on consumer chains.  In the context of this ADR, &quot;consensus validator set&quot; is the set of validators participating in the consensus protocol, and &quot;staking validator set&quot; is the set of validators viewed as active by the staking module.  Currently, the staking module, provider module, and CometBFT interact in this way:    The staking module keeps a list of validators. The MaxValidators validators with the largest amount of stake are &quot;active&quot; validators. MaxValidators is a parameter of the staking module. The staking module sends these validators to CometBFT to inform which validators make up the next consensus validators, that is, the set of validators participating in the consensus process. Separately, the provider module reads the list of bonded validators and sends this to the consumer chain, after shaping it according to which validators are opted in and the parameters set by the consumer chain for allowlist, denylist, etc.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#decision","content":" The proposed solution to allow validators that are not participating in the consensus process on the provider (inactive validators) is to change 3 main things:  a) increase the MaxValidators parameter of the staking module  b) do not take the updates for CometBFT directly from the bonded validators in the staking module, by wrapping the staking modules EndBlocker with a dummy EndBlocker that doesn't return any validator updates. Instead, we adjust the provider module to return validator updates on its EndBlocker. These validator updates are obtained by filtering the bonded validators to send only the first MaxProviderConsensusValidators (sorted by largest amount of stake first) many validators to CometBFT  c) use the enlarged list of bonded validators from the staking module as basis for the validator set that the provider module sends to consumer chains (again after applying power shaping and filtering out validators that are not opted in).  In consequence, the provider chain can keep a reasonably-sized consensus validator set, while giving consumer chains a much larger pool of potential validators.    Some additional considerations:  Migration: In the migration, the last consensus validator set will be set to the last active validator set from the view of the staking module. Existing consumer chains are migrated to have a validator set size cap (otherwise, they could end up with a huge validator set including all the staking-but-not-consensus-active validators from the provider chain)Slashing: Validators that are not part of the active set on the provider chain can still be jailed for downtime on a consumer chain (via an Interchain Security SlashPacket sent to the provider, who will then jail the validator), but they are not slashed for downtime on the provider chain. This is achieved without any additional changes to the slashing module, because the slashing module checks for downtime by looking at the consensus participants reported by CometBFT, and thus with the proposed solution, validators that are not part of the consensus validators on the provider chain are not considered for downtime slashing (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/slashing/abci.go#L22).Rewards: Validators that are not part of the active set on the provider chain can still receive rewards on the consumer chain, but they do not receive rewards from the provider chain. This change is achieved without further changes to staking or reward distributions, because similar to downtime, rewards are based on the consensus validator set (see https://github.com/cosmos/cosmos-sdk/blob/v0.47.11/x/distribution/abci.go#L28)  ","version":"Next","tagName":"h2"},{"title":"Changes to the state​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#changes-to-the-state","content":" The following changes to the state are required:  Introduce the MaxProviderConsensusValidators parameter to the provider module, which is the number of validators that the provider module will send to the consensus engine.Store the provider consensus validator set in the provider module state under the LastProviderConsensusValsPrefix key. This is the last set of validators that the provider sent to the consensus engine. This is needed to compute the ValUpdates to send to the consensus engine (by diffing the current set with this last sent set).Increase the MaxValidators parameter of the staking module to the desired size of the potential validator set of consumer chains.Introduce extra per-consumer-chain parameters: MinStake: is the minimum amount of stake a validator must have to be considered for validation on the consumer chain.AllowInactiveVals: is a boolean that determines whether validators that are not part of the active set on the provider chain can validate on the consumer chain. If this is set to true, validators outside the active set on the provider chain can validate on the consumer chain. If this is set to true, validators outside the active set on the provider chain cannot validate on the consumer chain.  ","version":"Next","tagName":"h3"},{"title":"Risk Mitigations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#risk-mitigations","content":" To mitigate risks from validators with little stake, we introduce a minimum stake requirement for validators to be able to validate on consumer chains, which can be set by each consumer chain independently, with a default value set by the provider chain.  Additional risk mitigations are to increase the active set size slowly, and to monitor the effects on the network closely. For the first iteration, we propose to increase the active set size to 200 validators (while keeping the consensus validators to 180), thus letting the 20 validators with the most stake outside of the active set validate on consumer chains.  ","version":"Next","tagName":"h2"},{"title":"Testing Scenarios​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#testing-scenarios","content":" In the following,  bonded validators refers to all validators that have bonded stake,active validators refers to the validators that take part in consensus,inactive validators refers to bonded validators that are not active validators.  ","version":"Next","tagName":"h2"},{"title":"Scenario 1: Inactive validators should not be considered by governance​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#scenario-1-inactive-validators-should-not-be-considered-by-governance","content":" Inactive validators should not be considered for the purpose of governance. In particular, the quorum should depend only on active validators.  We test this by:  creating a provider chain (either with 3 active validators, or with only 1 active validator), a quorum of 50%, and 3 validators with alice=300, bob=299, charlie=299 stakewe create a governance proposalalice votes for the proposalwe check that the proposal has the right status: in the scenario where we have 3 active validators, the proposal should not have passed, because alice alone is not enough to fulfill the quorumin the scenario where we have 1 active validator, the proposal should have passed, because alice is the only active validator, and thus fulfills the quorum  Tested by the e2e tests inactive-provider-validators-governance (scenario with 1 active val) and inactive-provider-validators-governance-basecase (scenario with 3 active vals).  ","version":"Next","tagName":"h3"},{"title":"Scenario 2: Inactive validators should not get rewards from the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#scenario-2-inactive-validators-should-not-get-rewards-from-the-provider-chain","content":" Inactive validators should not get rewards from the provider chain.  This can be tested by starting a provider chain with inactive validators and checking the rewards of inactive validators.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"Next","tagName":"h3"},{"title":"Scenario 3: Inactive validators should get rewards from consumer chains​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#scenario-3-inactive-validators-should-get-rewards-from-consumer-chains","content":" An inactive validator that is validating on a consumer chain should receive rewards in the consumer chain token.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"Next","tagName":"h3"},{"title":"Scenario 4: Inactive validators should not get slashed/jailed for downtime on the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#scenario-4-inactive-validators-should-not-get-slashedjailed-for-downtime-on-the-provider-chain","content":" This can be tested by having an inactive validator go offline on the provider chain for long enough to accrue downtime. The validator should be neither slashed nor jailed for downtime.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"Next","tagName":"h3"},{"title":"Scenario 5: Inactive validators should get jailed for consumer downtime on the provider chain​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#scenario-5-inactive-validators-should-get-jailed-for-consumer-downtime-on-the-provider-chain","content":" This can be tested by having an inactive validator go offline on a consumer chain for long enough to accrue downtime. The consumer chain should send a SlashPacket to the provider chain, which should jail the validator.  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"Next","tagName":"h3"},{"title":"Scenario 6: Inactive validators should not be counted when computing the minimum power in the top N​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#scenario-6-inactive-validators-should-not-be-counted-when-computing-the-minimum-power-in-the-top-n","content":" This can be tested like this:  Start a provider chain with validator powers alice=300, bob=200, charlie=100 and 2 max provider consensus validators So alice and bob will validate on the provider Start a consumer chain with top N = 51%. Without inactive validators, this means both alice and bob have to validate. But since charlie is inactive, this means bob is not in the top N Verify that alice is in the top N, but bob is not  Checked as part of the e2e test inactive-vals-topN.  ","version":"Next","tagName":"h3"},{"title":"Scenario 7: Mint does not consider inactive validators​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#scenario-7-mint-does-not-consider-inactive-validators","content":" To compute the inflation rate, only the active validators should be considered.  We can check this by querying the inflation rate change over subsequent blocks.  We start a provider chain with these arguments  3 validators with powers alice=290, bob=280, charlie=270either 1 or 3 active validatorsa bonded goal of 300 tokens (this is given in percent, but we simplify here)  If we have 3 validators active, then the inflation rate should decrease between blocks, because the bonded goal is exceeded as all validators are bonded. If we have only 1 validator active, then the inflation rate should increase between blocks, because the bonded goal is not met.  Checked as part of the e2e tests inactive-vals-mint (scenario with 1 active val) and mint-basecase (scenario with 3 active vals).  ","version":"Next","tagName":"h3"},{"title":"Scenarios 8: Inactive validators can validate on consumer chains​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#scenarios-8-inactive-validators-can-validate-on-consumer-chains","content":" An inactive validator can opt in and validate on consumer chains (if min stake allows it)  Checked as part of the e2e test inactive-provider-validators-on-consumer.  ","version":"Next","tagName":"h3"},{"title":"Scenario 9: MinStake parameters is respected​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#scenario-9-minstake-parameters-is-respected","content":" Validators that don't meet the criteria for a consumer chain cannot validate on it.  Checked in the e2e tests min-stake.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#positive","content":" Validators outside of the active set can validate on consumer chains without having an impact on the consensus engine of the provider chainConsumer chains can have a much larger validator set than the provider chain if they prefer this e.g. for decentralization reasonsConsumer chain teams can, with much less cost than today, start up their own consumer chain node to keep the chain running (in a centralized manner) even if no hub validators have opted in to validate on the chain. This is useful to stop the chain from ending up with an empty validator set and becoming recoverable only with a hardfork  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#negative","content":" Allowing validators from the inactive set brings with it some additional risks. In general, consumer chains will now face some of the problems also faced by standalone chains. It’s reasonable to assume that the validator set on the hub has a minimum amount of operational quality due to being battle tested and decentralized, and consumer chains with validators from outside the hub active set cannot rely on this as much anymore.  Sybil attacks​  With the restricted size of the active set today, it’s clear that the set is at least minimally competitive and it is not trivial to spin up multiple nodes as a validator.  When we make the “potential validator set” much larger, we should assume that it becomes much less competitive to be part of that set, and thus trivial for single entities to control many of those validators.  Reputational damage is not a deterrent​  For validators in the active set, we typically assume that if they would misbehave, they pay a large reputational cost. This represents delegators deciding to switch validators (potentially even on chains other than the one the misbehaviour happened on), and loss of credibility in the ecosystem. With the much larger active set, it seems prudent to assume that reputational damage is not a deterrent for many validators. They might only have minimal amounts of delegated stake and control most of it themselves, so they might not be deterred from performing actions that would usually bring reputational damage.  Additional negative consequences​  The provider keeper will need to implement the staking keeper interface, and modules need to be wired up to either the staking or provider keeper, depending on whether they need the consensus or staking validator setThis will impact how future modules are integrated, since we will need to consider whether those modules should consider the consensus validators or the bonded validators (which other modules might assume to be the same)  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#neutral","content":" There might be validators that are bonded, but not validating on any chain at all. This is not a problem, but it might be a bit confusing.  ","version":"Next","tagName":"h3"},{"title":"Alternative considerations​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#alternative-considerations","content":" ","version":"Next","tagName":"h2"},{"title":"Modifying the staking module​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#modifying-the-staking-module","content":" We could instead adapt the staking module with a similar change. This might be better if it turns out that the staking module active set is used in many other places.  ","version":"Next","tagName":"h3"},{"title":"Allowing unbonding validators to validate​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#allowing-unbonding-validators-to-validate","content":" Instead of increasing the active set size, we could allow validators that are unbonded (but still exist on the provider) to validate consumer chains. For this, we would need to:  Modify the VSC updates to consider the set of all validators, even unbonded ones, instead of just active onesAdjust our downtime jailing/equivocation slashing logic to work correctly with unbonded validators. This is very hard, because redelegations are not usually tracked for unbonded validators.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 017: ICS with Inactive Provider Validators","url":"/interchain-security/adrs/adr-017-allowing-inactive-validators#references","content":" Security Aggregation has similar concerns where the staking validator set will differ from the consensus validator set ","version":"Next","tagName":"h2"},{"title":"ADR 018: Remove VSCMatured Packets","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-018-remove-vscmatured","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#changelog","content":" 19/06/2024: Create initial draft  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#context","content":" The idea of removing VSCMatured packets was first suggested by Jae Kwon over a conversation in 2022. As a result of that conversation, an ADR was proposed to halt consumer chain if VSC packets are no longer received. The ADR was not accepted due to other considerations regarding the safety of consumer chains. See this blog post for more details.  The consumer module on the consumer chains is a representation of the Hub’s staking module, i.e., it provides an asynchronous view of the voting powers and indirectly of the locked collateral. The key word here is asynchronous, which means that (in theory) there is no bound on the lag between the Hub’s view of stake and the consumer’s view of stake. The reasons for this asynchrony are relaying delays and chain liveness (e.g., a consumer could be down for a long period of time without affecting the liveness of the staking module on the Hub).  The current version of ICS uses VSCMaturedPackets to create on the consumers a partially synchronous view of the Hub’s staking module. Partially synchronous means that the lag between the Hub’s view of stake and the consumer’s view of stake is bounded, because consumers that exceed this lag are forcibly removed from the protocol. Basically, unlocking collateral from the Hub is being delayed until the consumers’ UnbondingPeriod elapses. The reason the view is only partially synchronous is that eventually the collateral is unlocked, i.e., if VSCMaturedPackets are not received from a consumer for VscTimeoutPeriod (default: 5 weeks), then the consumer is removed from ICS and the collateral is unlocked. Note that keeping the stake locked “forever” would affect the Hub’s liveness, so it’s not a viable option.  The issue is that whatever attack is possible with an asynchronous view of the staking module, it is eventually possible with the partially synchronous view as well. For example, an attacker could wait for VscTimeoutPeriod for the collateral to be unlocked and then send invalid headers to third-party chains that are not aware the consumer's collateral is no longer locked on the Hub (i.e., the consumer is no longer part of ICS).  Moreover, with the introduction of PSS, a consumer’s validator set could “lie” about its UnbondingPeriod elapsing by sending VSCMaturedPackets earlier. This would result in a discrepancy between a light client’s view of the UnbondingPeriod and the actual Hub’s UnbondingPeriod.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#decision","content":" This ADR proposes the removal of VSCMaturedPackets. The reason is twofold. First, VSCMaturedPackets provide a &quot;false&quot; sense of correctness as the attack described above is still possible. Second, VSCMaturedPackets add considerable complexity to the ICS protocol -- an extra message plus the pausing of unbonding operations that can affect the UX.  To simplify the upgrading process, removing VSCMaturedPackets can be done in two releases:  (R1) Update the provider to drop VSCMaturedPackets.(R2) Update the consumer to stop sending VSCMaturedPackets.  As a result, once the provider chain runs R1, the consumers can start upgrading to R2.  ","version":"Next","tagName":"h2"},{"title":"Provider Changes (R1)​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#provider-changes-r1","content":" Parameters​  Deprecate the InitTimeoutPeriod and VscTimeoutPeriod parameters.  State​  Add the following key prefix to the state:  ConsumerAddrsToPruneV2BytePrefix -- the byte prefix for storing consumer validators addresses that need to be pruned. These are stored as ConsumerAddrsToPruneV2BytePrefix | len(chainID) | chainID | ts -&gt; (consumer_address1, consumer_address2, ...) where ts is the timestamp at which the consumer validators addresses can be pruned.  Migrate the consumer validator addresses stored under the ConsumerAddrsToPruneBytePrefix to the new prefix ConsumerAddrsToPruneV2BytePrefix. Note that these consumer validators addresses are stored as  ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -&gt; (consumer_address1, consumer_address2, ...)   where vscID is the ID of the first VSCPacket sent after these consumer validator addresses were changed. These means that we can use the VscSendTimestamps to compute the timestamps when these consumer validator addresses can be pruned, i.e.,  func MigrateConsumerAddrsToPrune() iterator := sdk.KVStorePrefixIterator(store, []byte{providertypes.ConsumerAddrsToPruneBytePrefix}) for ; iterator.Valid(); iterator.Next() { chainID, vscID, _ := providertypes.ParseChainIdAndUintIdKey(providertypes.ConsumerAddrsToPruneBytePrefix, iterator.Key()) // use the VscSendTimestamp index to compute the timestamp at which this consumer addresses can be pruned vscSendTimestampKey := providertypes.ChainIdAndUintIdKey(providertypes.VscSendTimestampBytePrefix, chainID, vscID) timeBz := store.Get(vscSendTimestampKey) sentTime, _ := sdk.ParseTimeBytes(timeBz) pruneTs := sentTime.Add(sk.UnbondingTime(ctx)) var addrs providertypes.AddressList addrs.Unmarshal(iterator.Value()) for _, addr := range addrs.Addresses { consumerAddr := providertypes.NewConsumerConsAddress(addr) pk.AppendConsumerAddrsToPrune(ctx, chainID, pruneTs, consumerAddr) } } }   Remove the following key prefixes from the state. Note that these removals require state migration.  MaturedUnbondingOpsByteKey -- the byte key that stores the list of all unbonding operations ids that have matured from a consumer chain perspective.UnbondingOpBytePrefix -- the byte prefix that stores a record of all the ids of consumer chains that need to unbond before a given unbonding operation can unbond on this chain.UnbondingOpIndexBytePrefix -- the byte prefix of the index for looking up which unbonding operations are waiting for a given consumer chain to unbond.InitTimeoutTimestampBytePrefix -- the byte prefix for storing the init timeout timestamp for a given consumer chainID.VscSendTimestampBytePrefix -- the byte prefix for storing the list of VSC sending timestamps for a given consumer chainID.ConsumerAddrsToPruneBytePrefix -- the byte prefix for storing the mapping from VSC IDs to consumer validators addresses that need to be pruned.  State Transitions​  Removing VSCMaturedPackets affects three ICS sub-protocols (see HandleVSCMaturedPacket): unbonding operations pausing, VSCPackets timeout, and key assignment pruning. The first two are no longer needed, while the third (key assignment pruning) needs to be redesigned to not depend on VSCMaturedPackets.  Removing unbonding operations pausing:  Make the AfterUnbondingInitiated hook a no-op. As a result, unbonding operations are no longer paused.Stop calling the UnbondingCanComplete method from the staking keeper. This entails, it is no longer necessary to append MaturedUnbondingOps and the completeMaturedUnbondingOps method can be removed.Note, that during the upgrade, all unbonding operations stored under the UnbondingOpBytePrefix prefix need to be completed (via the UnbondingCanComplete method from the staking keeper).Remove the init timeout timestamp logic from the following methods: CreateConsumerClient, SetConsumerChain, and EndBlockCCR.  Removing VSCPackets timeout:  Stop setting VSC send timestamps when sending VSCPackets.Stop removing the VSC send timestamps when receiving VSCMaturedPackets.Remove the logic from EndBlockCCR that checks if the first VSC send timestamp in iterator plus VscTimeoutPeriod exceeds the current block time.  Redesign key assignment pruning. The reason for keeping &quot;old&quot; consumer addresses is to enable slashing / jailing validators that misbehave on consumer chains, i.e., the slashing logic uses the GetProviderAddrFromConsumerAddr method that accesses the mapping from validator addresses on consumer chains to validator addresses on the provider chain (ValidatorsByConsumerAddrBytePrefix). Thus, &quot;old&quot; consumer addresses are no longer needed after the provider's UnbondingPeriod elapses. This means that once a validator changes its key on a consumer, we can prune the address corresponding to the &quot;old&quot; key after UnbondingPeriod. This requires the following changes:  Adapt the AppendConsumerAddrsToPrune() method to use the timestamp at which it is safe to prune the consumer validator address (instead of the current vscID).Add a new method ConsumeConsumerAddrsToPrune(ts) that returns the list of consumer addresses that can be pruned at timestamp ts.Adapt the PruneKeyAssignments() method to call ConsumeConsumerAddrsToPrune(ctx.BlockTime()).Call the PruneKeyAssignments() method from every EndBlock() instead of calling it from HandleVSCMaturedPacket().  Queries​  Remove the oldest_unconfirmed_vsc query.  ","version":"Next","tagName":"h3"},{"title":"Consumer Changes (R2)​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#consumer-changes-r2","content":" Parameters​  Given that currently relayers use the consumer UnbondingPeriod (see ConsumerParams), this param cannot be deprecated. Note that Hermes queries the UnbondingPeriod for sanity checks and to set the default trusting period when it is not specified. As a result, the UnbondingTime method from the staking interface will continue to be used to retrieve the consumer's UnbondingPeriod.  State​  Remove the following key prefixes from the state:  PacketMaturityTimeBytePrefix -- the byte prefix that will store maturity time for each received VSC packet  Note that these removals require state migration.  State Transitions​  To stop the consumer chains from sending VSCMaturedPackets, it is sufficient to not store the maturity time of VSCPackets when receiving them, i.e., do not call SetPacketMaturityTime from the OnRecvVSCPacket() method. Note that eventually, no additional VSCMaturedPackets will be added to the sending queue as QueueVSCMaturedPackets iterates over elapsed maturity times. In addition, to clean up the code, the QueueVSCMaturedPackets must be removed.  Messages​  VSCMaturedPacketData is deprecated. Note that this is a wire-breaking change -- older consumer versions will send VSCMaturedPackets and older provider versions will expect to receive VSCMaturedPackets.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#positive","content":" Remove feature that provides a &quot;false&quot; sense of correctness.Remove unnecessary complexity, from both ICS and Cosmos SDK.Remove one IBC packet and, thus, reduce relaying cost.Remove unbonding pausing logic that could affect the UX.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#negative","content":" Large refactor that might introduce unexpected bugs.Consumer chains are no longer removed if the duration between creating a client and creating the CCV channel exceeds InitTimeoutPeriod. This means that if the CCV channel is not created on time, the client expires and the consumer chain can no longer start without a ClientUpdate proposal or re-submitting a ConsumerAdditionProposal.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#neutral","content":" Consumer chains are no longer removed after a VscTimeoutPeriod of inactivity. Note that consumers are still removed if their CCV channel expires, which usually happens after two weeks instead of five weeks (the default value for VscTimeoutPeriod).  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 018: Remove VSCMatured Packets","url":"/interchain-security/adrs/adr-018-remove-vscmatured#references","content":" PR #712 -- Proposal to set an expiration date on the consumer chain updated on each VSCPacket received to ensure the chain is up-to-date.Learning to Live with “Unbonding Pausing” blog post. ","version":"Next","tagName":"h2"},{"title":"ADR 020: Customizable Slashing and Jailing","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#changelog","content":" 2024-07-19: Initial draft of ADR2024-08-23: Generalize ADR to make slashing and jailing customizable  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#context","content":" Interchain Security (ICS) is a cross-chain staking protocol -- it uses the stake on the provider chain as collateral for the Proof of Stake (PoS) on the consumer chains. This means that the voting power of validators validating (aka producing blocks) on the consumer chains is a function of their stake on the provider. Moreover, if these validators misbehave on the consumer chains, they get punished on the provider chain. ICS is currently differentiating between two types of infractions -- equivocation and downtime. Depending on the infraction type, the misbehaving validators might be jailed (i.e., removed from the provider validator set) and / or slashed (i.e., a portion of their stake on the provider is being burned). For example, validators double signing on consumer chains get slashed and are permanently jailed, while validators not validating sufficient blocks are temporarily jailed.  This means that ICS consumer chains get their economical security from the provider. However, this might come at a high cost.  ","version":"Next","tagName":"h2"},{"title":"The Cost of PoS​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#the-cost-of-pos","content":" One of the cost of validating on the consumer chains is operational -- validators need to run and monitor full nodes of every consumer chain they opt in for. Although this cost varies from validator team to validator team (depending on how efficiently they can run their infrastructure), it doesn't depend on the total stake (or voting power) of the validators, so we can think of it as constant. The other cost of validating comes from the risk of getting slashed or jailed.  Most chains in Cosmos (including the Cosmos Hub) use delegated PoS -- users delegate their tokens to validators, which stake them in return for voting power. Therefore, validators act as representatives chosen by their delegators to represent their interests. However, delegators share the risk of their validators getting slashed or jailed:  When validators get slashed, a portion of their stake is being burned, including a portion of the tokens delegated by users. As validators don't need to have their own stake, it is possible that delegators take all the risk of validators misbehaving.When validators get jailed, they no longer receive block rewards (neither from the provider nor from the consumer chains). This also applies to their delegators. As a result, delegators might choose to restake their tokens with another validator. The longer the validators are jailed, the more likely is that delegators will restake. Thus, by getting jailed, validators risk damaging their reputation.  Misbehaviors don't need to be malicious, e.g., most cases of double signing infractions are due to misconfiguration. This means that, by opting in on multiple consumer chains, validators and their delegators incur a higher risk. As a result, validators and their delegators want to be compensated for this additional risk, which makes the current design of ICS expensive.  This ADR addresses the high cost of ICS by allowing consumer chains to customize the slashing and jailing conditions. Basically, every consumer chain can decide the punishment for every type of infraction. This enables consumer chains to tradeoff economical security against cost.  ","version":"Next","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#decision","content":" To reduce the cost of ICS, consumer chains will be able to customize the slashing and jailing for every type of infraction. As a result, consumer chains can decide on the amount of economic security they want and validators (and their delegators) can decide on the amount of additional risk they want to incur.  For every consumer chain, we introduce the following slashing and jailing parameters:  message InfractionParameters { SlashJailParameters double_sign = 1; SlashJailParameters downtime = 2; } message SlashJailParameters { bytes slash_fraction = 1 [ (cosmos_proto.scalar) = &quot;cosmos.Dec&quot;, (gogoproto.customtype) = &quot;cosmossdk.io/math.LegacyDec&quot;, (gogoproto.nullable) = false, (amino.dont_omitempty) = true ]; // use time.Unix(253402300799, 0) for permanent jailing google.protobuf.Duration jail_duration = 2; }   Currently, we consider only two infraction types -- double signing and downtime.  By default, every consumer chain will have the following slashing and jailing parameters:  double_sign.slash_fraction: 0.05 // same as on the provider double_sign.jail_duration: time.Unix(253402300799, 0) // permanent jailing, same as on the provider downtime.slash_fraction: 0 // no slashing for downtime on the consumer downtime.jail_duration: 600s // same as on the provider   These parameters can be updated by the consumer chain owner at any given time (via MsgCreateConsumer or MsgUpdateConsumer). However, the changes will come into effect after a period equal to the staking module's unbonding period elapses. This will allow validators that don't agree with the changes to opt out and not be affected by them. Also, to avoid malicious chains attacking the provider validator set, these params will be bounded by the values on the provider chain:  double_sign.slash_fraction &lt;= 0.05 // 5% downtime.slash_fraction &lt;= 0.0001 // 0.1% downtime.jail_duration &lt;= 600s // 10 minutes   Although consumer chains can set any values to these parameters (within the allowed bounds), we recommend the following settings, depending on the type of consumer chain.  Proof-of-Stake (PoS) Consumer Chains. These are chains that have the full economical security of the provider validators that opted in. This means that all slashing and jailing parameters are the same as on the provider. double_sign.slash_fraction: 0.05 double_sign.jail_duration: time.Unix(253402300799, 0) downtime.slash_fraction: 0.0001 downtime.jail_duration: 600s Proof-of-Reputation (PoR) Consumer Chains. double_sign.slash_fraction: 0 // no slashing double_sign.jail_duration: time.Unix(253402300799, 0) downtime.slash_fraction: 0 // no slashing downtime.jail_duration: 600s This means that when validators that opt in misbehave on PoR consumer chains, their stake on the provider is not being slashed, instead they are just jailed on the provider. As a result, delegators incur (almost) no risk if their validators opt in on multiple PoR consumer chains. If their validators are jailed, then the delegators can redelegate to other validators. Note though that delegators cannot redelegate multiple times, which means that if the new validators also get permanently jailed, the delegators need to wait for the unbonding period to elapse. Testnet Consumer Chains. double_sign.slash_fraction: 0 // no slashing double_sign.jail_duration: 0 // no jailing downtime.slash_fraction: 0 // no slashing downtime.jail_duration: 0 // no jailing This means that validators are not punished for infractions on consumer chains. This setting is ideal for testing consumer chains before going in production, as neither validators nor their delegators incur any risk from the validators opting in on these consumer chains.  This means that both PoR and testnet consumer chains need only to cover the operational costs of the validators that opt in. For example, if we take $600 as the cost of running a validator node, a budget of $3000 will be sufficient to cover the cost of four validators running such a consumer chain and have $150 profit per validator as incentive. In practice, this can be implemented via the per-consumer-chain commission rate that allows validators to have different commission rates on different consumer chains.  ","version":"Next","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#implementation","content":" The implementation of this feature involves the following steps:  Add the InfractionParameters to MsgCreateConsumer.On slashing events (for either downtime or double signing infractions), use the corresponding slash_fraction set by the consumer chain.On jailing events (for either downtime or double signing infractions), use the corresponding jail_duration set by the consumer chain.Cryptographic equivocation evidence received for PoR chains results in the misbehaving validators only being tombstoned and not slashed.(Optional) Add the InfractionParameters to MsgUpdateConsumer, i.e., allow consumer chains to update the slashing and jailing parameters, but the changes will come into effect after a period equal to the staking module's unbonding period elapses to allow for validators to opt out.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#positive","content":" Reduce the cost of ICS by removing the risk of slashing delegators.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#negative","content":" Reduce the economical security of consumer chains with weaker slashing conditions.  Economic Security Model without Slashing​  The economic security model of most Cosmos chains relies on the following properties:  validators are not anonymous, which means that they could be legally liable if they are malicious;the delegated PoS mechanism creates a reputation-based network of validators;most validators have most of their stake coming from delegations (i.e., nothing at stake, besides reputation);it is relatively difficult to enter the active validator set and even more so to climb the voting power ladder.  These properties enable us to make the following assumption:  Being permanently removed from the provider validator set is strong enough of a deterrent to misbehaving on consumer chains.  The additional economical security a consumer gets from slashing is limited: Since most of the stake is delegated, slashing punishes delegators more than validators.  One benefit of slashing is that it acts as a deterrent for someone buying a large amount of staking tokens in order to attack a consumer chain. For example, an attacker could get $15,000,000 worth of ATOM, which would give them around 1% voting power on the Cosmos Hub (at the time of this writing). On a consumer chain, this voting power could be amplified depending on the other validators that opt in. However, by having the right power shaping settings, the voting power of validators can be capped. This means that even if the attacker manages to double sign without getting slashed, as long as they don't have 1/3+ of the voting power, they cannot benefit from the attack. Moreover, the attacker might lose due to other factors, such as token toxicity.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#neutral","content":" NA  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 020: Customizable Slashing and Jailing","url":"/interchain-security/adrs/adr-020-cutomizable_slashing_and_jailing#references","content":"","version":"Next","tagName":"h2"},{"title":"ADR 021: Consumer Chain Clients","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-021-consumer-chain-clients","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#changelog","content":" 2024-08-14: Initial draft of ADR  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#status","content":" Proposed  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#context","content":" In this document, host chain and remote chain are used in the following context: a light client of a remote chain is in the state of a host chain.  ","version":"Next","tagName":"h2"},{"title":"IBC Client Updates​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#ibc-client-updates","content":" IBC Client Updates require two pieces of information:  A header (and a validator set) that originates from the consensus engine of the remote chain, i.e., message Header { .tendermint.types.SignedHeader signed_header = 1 .tendermint.types.ValidatorSet validator_set = 2 ibc.core.client.v1.Height trusted_height = 3 .tendermint.types.ValidatorSet trusted_validators = 4 } Note that the header also contain Commit information, i.e., the signatures that got the block committed. The client state, that is initialized when the client is created and then maintained through client updates. Two important fields of the client state are the UnbondingPeriod (i.e., duration of the staking unbonding period) and the TrustingPeriod, which must be smaller than the UnbondingPeriod (see the Tendermint Security Model in the Tendermint Light Client paper). The TrustingPeriod is the duration, since the timestamp of the latest header the client got updated to, during which new headers are accepted for updating the client. The UnbondingPeriod originates from the application of the remote chain (i.e., a staking module param), which means the TrustingPeriod originates from the remote application as well. if HeaderExpired(trustedHeader, trustingPeriod, now) { return ErrOldHeaderExpired{trustedHeader.Time.Add(trustingPeriod), now} } // HeaderExpired return true if the given header expired. func HeaderExpired(h *types.SignedHeader, trustingPeriod time.Duration, now time.Time) bool { expirationTime := h.Time.Add(trustingPeriod) return !expirationTime.After(now) } In other words, a new header received at timestamp ts is rejected if the following inequality holds for any trusted header h: // h is a header of the remote chain // h.T is a timestamp on the remote chain // ts is a timestamp on the host chain h.T + TrustingPeriod &lt;= ts The following figure describes the algorithm used by the host chain to reject headers outside of the TrustingPeriod. Details Intuition behind the trusting period.The trusting period is there to make sure that the validators that signed for the trusted header have their collateral still locked so that in case they misbehave (i.e., light client attack), this collateral can be slashed. Note that the validators that signed the trusted header are responsible for the untrusted header (for both Sequential Verification and Skipping Verification). For more details, see Figure 1 and 3 in the Tendermint Light Client paper:  ","version":"Next","tagName":"h3"},{"title":"Updating Consumers' IBC Clients​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#updating-consumers-ibc-clients","content":" In the context of ICS, the provider is one of the host chains and the consumers are the remote chains. Note that other third-party chains could be host chains as well.  Consumer chains have their own consensus engine — validators that opt in need to run full nodes of the consumer chains, which consist of both consensus and application layer. This means that consumers produce headers and a relayer could use those headers to update the consumer’s IBC clients on other chains (the provider included). However, consumer chains don’t have their own staking module.  In ICS, the provider is the “staking module” of the consumer chains — validators lock collateral on the provider and as a result can produce blocks on consumer chains. The consumer module on the consumer chains is just a representation of the provider’s staking module, i.e., it provides an asynchronous view of the voting powers and indirectly of the locked collateral. The key word here is asynchronous, which means that (in theory) there is no bound on the lag between the provider’s view of stake and the consumer’s view of stake. The reasons for this asynchrony are relaying delays and chain liveness (e.g., a consumer could be down for a long period of time without affecting the liveness of the staking module on the provider).  The following figure describes the problem of using the same condition (based on the trusting period), i.e.,  // hc is a header of the consumer chain // hc.T is a timestamp on the consumer chain // ts is a timestamp on the host chain hc.T + TrustingPeriod &lt;= ts   to reject consumer headers outside of the TrustingPeriod. The issue is that the time period hc.T and T (the time at which the validator set V was locked on the provider) depends on the consumer chain, i.e., the consumer chain can choose an arbitrary time when to send V to CometBFT. As a result, even if hc.T + TrustingPeriod &gt; ts (i.e., the header is received within the trusting period), if hc.T - T is large enough, then the stake of V could be already unlocked on the provider.    Note that before the removal of VSCMaturedPackets, the consumers had a partially synchronous view of the provider’s staking module. Partially synchronous means that the lag between the provider’s view of stake and the consumer’s view of stake is bounded, because consumers that exceeded this lag were forcibly removed from the protocol. The issue was that whatever attack is possible with an asynchronous view of the staking module, it is eventually possible with the partially synchronous view as well. For more details on this, please check out ADR 018.  This ADR proposes a solution to this synchrony issue -- it uses IBC conditional clients to create a synchronous view of the provider’s staking module.  ","version":"Next","tagName":"h3"},{"title":"Decision​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#decision","content":" The idea is to extend the IBC light clients for ICS consumer chains to accept a new header received at timestamp ts only if, given any trusted header h, h.ProviderTime + TrustingPeriod &gt; ts, where h.ProviderTime is the timestamp on the provider when h.Valset locked its stake.  The implementation of this feature consists of three parts:  Store h.ProviderTime (the timestamps when the consumer validator sets locked their stake) in the provider state. Note that this state can be pruned once the provider unbonding period elapses.Extend the IBC light client logic on the host chains to reject headers received at timestamp ts if, given any trusted header h,h.ProviderTime + TrustingPeriod &lt;= ts. Note that this logic must existing both on the provider chain and on third party chains (including other consumer chains).For cases when the host chain is different than the provider chain, enable relayers to work with IBC conditional clients.  The remainder of this section is addressing the first part and the second part for the case when the host chain is the provider chain. The second part for the case when the host chain is different than the provider chain and the third part are outside the scope of this ADR.  ","version":"Next","tagName":"h2"},{"title":"Store Provider Timestamps​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#store-provider-timestamps","content":" Currently, the provider module stores the validator set for every consumer chain. This is done by calling SetConsumerValSet() at the end of every epoch when queueing new VSCPackets. This is the timestamp when the validator set locked its stake (i.e., h.ProviderTime). For consumer chain clients, the provider needs to store these timestamps.  State​  ConsumerValidatorTimestampKey - Stores the latest timestamp when the validator set V of a consumer chain with consumerID locked its stake on the provider chain.  ConsumerValidatorTimestampBytePrefix | len(consumerID) | consumerID | valsetHash -&gt; V.lockTs   where valsetHash is the hash of V. Note that this hash is the same as the one in the headers produced by the consumer chain validated by V. Also, note that V.lockTs is the same as h.ProviderTime above.  The guarantee provided by the provider chain is that the stake of V will be locked until V.lockTs + UnbondingPeriod. This is sufficient information for consumer chain clients to decide whether new headers are outside the trusting period. This guarantee has two consequences. First, it is sufficient to store the latest timestamp: If a consumer chain has the same validator set V over multiple epochs, the only relevant information is the timestamp until when V's stake will be locked on the provider and this can be derived from V.lockTs. Second, this state can be pruned once the unbonding period elapses, i.e., once the provider block time exceeds V.lockTs + UnbondingPeriod.  Query​  To query the timestamps when consumer validator sets are locked on the provider, the following query is introduced:  interchain-security-pd query provider valsetLockTs $consumerID $valsetHash   ","version":"Next","tagName":"h3"},{"title":"ICS Conditional Clients on the Provider​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#ics-conditional-clients-on-the-provider","content":" If the host chain is different than the provider chain, then it needs to use IBC conditional clients to connect to consumer chains. These conditional clients would need to query the provider chain before they can accept a new header from the consumer chains. In practice, a relayer would send all the information needed (i.e., the new header and the timestamp when the provider locked the stake corresponding to the validator set that signed the trusted header) and the conditional client will verify this information using the existing light client of the provider chain. Note that this is also the case for consumer chains acting as host chain and connecting to other consumer chains.  This section focuses though on the case when the host chain is the provider chain. As the additional information needed is already on the host chain, there is no need for a conditional client. Instead, the provider module needs to act as a &quot;middleware&quot; for all IBC ClientUpdate messages coming from consumer chains and reject headers that were signed by validators outside of the trusting period.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#positive","content":" Improve the security of IBC communication with consumer chains.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#negative","content":" The liveness of consumer chains IBC channels depends on the liveness of the provider. Note though that as long as the provider client on the third-party chain is not expiring, the IBC channels of the consumer chains will remain live.For IBC to work, third-party chains need to have conditional clients of the consumer chains. This includes also other consumer chains.Additional state is needed on the provider chain to store previous consumer validator sets. This state can be pruned once the unbonding period elapses.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#neutral","content":" N/A  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 021: Consumer Chain Clients","url":"/interchain-security/adrs/adr-021-consumer-chain-clients#references","content":" ADR 018: Remove VSCMatured PacketsIBC conditional clientsQuerier Approach for Conditional ClientsOriginal conditional client idea in the IBC specs ","version":"Next","tagName":"h2"},{"title":"ADR 022: Fault Resolutions","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-022-fault-resolutions","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#changelog","content":" 17th July 2024: Initial draft  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#status","content":" Proposed  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#context","content":" Partial Set Security (PSS) allows a subset of a provider chain's validator set to secure a consumer chain. While this shared security scheme has many advantages, it comes with a risk known as thesubset problem. This problem arises when a malicious majority of validators from the provider chain collude and misbehave on a consumer chain. This threat is particularly relevant for Opt-in chains, since they might be secured by a relatively small subset of the provider's validator set.  In cases of collusion, various types of misbehaviour can be performed by the validators, such as:  Incorrect executions to break protocol rules in order to steal funds.Liveness attacks to halt the chain or censor transactions.Oracle attacks to falsify information used by the chain logic.  Currently, these types of attacks aren't handled in PSS, leaving the malicious validators unpunished.  A potential solution for the handling of incorrect executions is to use fraud proofs. This technology allows proving incorrect state transitions of a chain without a full node. However, this is a complex technology and there is no framework that works for Cosmos chains to this day.  To address this risk in PSS, a governance-gated slashing solution can be used to handle all types of misbehavior resulting from validator collusion. As fraud proof technology matures, part of the solution could potentially be automated.  This ADR proposes a fault resolution mechanism, which is a type of governance proposal that can be used to vote on the slashing of validators that misbehave on Opt-in consumer chains (see fault resolutions in &quot;Preventing Intersubjective faults in ICS&quot;).  In what follows, we describe the implementation of a fault resolution mechanism for any intersubjective fault. Note that in the first iteration, it is only incorrect executions that are defined as a fault and are therefore dealt with by the mechanism (see Incorrect Executions in &quot;Preventing Intersubjective faults in ICS&quot;).  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#decision","content":" The proposed solution introduces a new consumer-fault-resolution governance proposal type to the provider module, which allows validators to be penalised for committing faults on an Opt-in consumer chain.  If such a proposal passes, the proposal handler tombstones all the validators listed in the proposal and slashes them by a per-consumer chain predefined amount or the default value used for double-sign infractions.  The proposal has the following fields:  Consumer Chain: The consumer chain ID that the fault was related to.Validators: The list of all the validators to be slashed.Evidence: A free text form.Fault Type: The fault definition type.Description: This field is automatically generated by aggregating the fault definition corresponding to the Fault Type and the Evidence fields.  Each fault type is mapped to a fault definition that precisely describes an intersubjective fault, such as an incorrect execution, and explains why it qualifies as a slashable fault. Refer to the fault definitions section in &quot;Preventing Intersubjective faults in ICS&quot; for more details. Note that the text of each fault definition is stored as a string constant in the provider code.  In addition, to prevent spamming, users must pay a default fee of 100ATOM to submit a fault resolution to the provider. This amount is stored in a new consumer-fault-resolution-fee parameter of the provider module.  ","version":"Next","tagName":"h2"},{"title":"Validations​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#validations","content":" The submission of a fault resolution succeeds only if all of the following conditions are met:  the consumer chain is an Opt-in chainall listed validators were opted-in to the consumer chain in the past unbonding-periodthe 100ATOM fee is provided  ","version":"Next","tagName":"h3"},{"title":"States​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#states","content":" Additional states are added to the provider modules:  The timestamps that record when validators opts in or opts out of a Opt-in consumer chain. Note that these timestamps can be pruned after an unbonding period elapses following a validator's opts-out.   ConsumerValidatorSubscriptionTimestampPrefix | len(consumerID) | consumerID | valAddr | ProtocolBuffer(ConsumerValSubscriptionTimestamp)    message { // timestamp recording the last time a validator opted in to the consumer chain google.protobuf.Timestamp join_time = 1; // timestamp recording the last time a validator opted out of the consumer chain google.protobuf.Timestamp leave_time = 2; }   Pre-defined slashing factor per-consumer chain for each defined fault (optional).   ConsumerFaultSlashFactorPrefix | len(consumerID) | consumerID | faultType -&gt; SlashFactor   ","version":"Next","tagName":"h3"},{"title":"Additional considerations​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#additional-considerations","content":" Fault resolution proposals should be expedited to minimize the time given to the listed validators to unbond to avoid punishment (see Expedited Proposals) .  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#positive","content":" Provide the ability to slash and tombstone validators for committing incorrect executions on Opt-in consumer chains.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#negative","content":" Assuming that malicious validators unbond immediately after misbehaving, a fault resolution has to be submitted within a maximum of two weeks in order to slash the validators.  ","version":"Next","tagName":"h3"},{"title":"Neutral​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#neutral","content":" Fault definitions need to have a clear framework in order to avoid debates about whether an attack has actually taken place.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 022: Fault Resolutions","url":"/interchain-security/adrs/adr-022-fault-resolutions#references","content":" Preventing intersubjective faults in ICS Enabling Opt-in and Mesh Security with Fraud Votes CHIPs discussion phase: Partial Set Security Replicated vs. Mesh Security ","version":"Next","tagName":"h2"},{"title":"ADR 019: Permissionless Interchain Security","type":0,"sectionRef":"#","url":"/interchain-security/adrs/adr-019-permissionless-ics","content":"","keywords":"","version":"Next"},{"title":"Changelog​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#changelog","content":" 27th of June, 2024: Initial draft12th of September, 2024: Updated to take into account message changes, etc.  ","version":"Next","tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#status","content":" Accepted  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#context","content":" Currently, a consumer chain can join Interchain Security (ICS) only through a governance proposal. A governance proposal was needed before the introduction of Partial Set Security (PSS) because validators were required to validate a consumer chain. However, after the introduction of PSS, a consumer chain can be either Top N or Opt In. If a chain is an Opt In chain, then no validator is required to validate this chain unless they choose to. Because of this, we can launch an Opt In consumer chain without going through a governance proposal.  This ADR presents Permissionless ICS, a way in which an Opt In consumer chain can join ICS without needing a governance proposal but by simply issuing a transaction.  ","version":"Next","tagName":"h2"},{"title":"Decision​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#decision","content":" In Permissionless ICS, launching an Opt In chain can be done by issuing a transaction. Naturally, Permissionless ICS does not eliminate governance proposals, as proposals are still necessary for Top N chains. Nevertheless, a Top N chain can transform to an Opt In chain through a gov proposal and vice versa.  ","version":"Next","tagName":"h2"},{"title":"The Phases of a Consumer Chain​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#the-phases-of-a-consumer-chain","content":" We first present the notion of an owner of a consumer chain before showing the specific phases of a consumer chain.  Owner. A consumer chain has an owner, which is simply an address. Only the owner can interact (i.e., launch, update, or stop) with the chain. The owner of an Opt In chain is the one who signed the initial transaction to register a consumer chain (more on this later). Naturally, an Opt In chain can change its owner at any point. The owner of a Top N chain is the account of the governance module. Therefore, any changes on a Top N chain have to go through governance proposals.  A consumer chain can reside in five phases: i) registered, ii) initialized, iii) launched, iv) stopped, and v) deleted phase as seen in the diagram below:  Registered phase. In the registered phase, a consumer chain has an assigned a unique identifier, that of consumerId (more on this later) that identifies a consumer chain that is used to interact with the chain (e.g., when a validator opts in on a chain, etc.). A chain is created and resides at the registered phase through the use of a MsgCreateConsumer which response contains the consumerId.MsgCreateConsumer is the first step in creating either a Top N or an Opt In consumer chain.  If all the optional initialization parameters are provided in MsgCreateConsumer, then an Opt In chain can immediately move to the initialized phase (see below) and get scheduled to launch. Note, however that a Top N chain needs at least two more MsgUpdateConsumer messages and one gov proposal to be able to launch.  In the registered phase, it is not yet known if the consumer chain would end up being a Top N or an Opt In chain and hence the owner of the consumer chain at this phase is the one that signed the MsgCreateConsumer.  Initialized phase. The initialized phase means that the chain has set all the needed initialization parameters to launch but has not yet launched. If a chain in the registered phase has not yet set the initialization parameters, it can issue a MsgUpdateConsumermessage to set those parameters. Additionally, MsgUpdateConsumer can be used to set up other parameters, such as the power-shaping parameters. If a chain is in the initialized phase and MsgUpdateConsumer is issued with spawn time being zero, the chain moves back to the registered phase.  In order to move a Top N chain to the initialized phase, we need to issue at least two MsgUpdateConsumer messages:  one to change the owner of the chain to be the account of the governance module;another as part of a governance proposal to set the Top N.  Launched phase. In the launched phase the consumer chain is running and is consuming a subset of the validator set of the provider. When the spawnTimepasses and at least one validator has opted inthe chain can launch and moves to the launched phase. Note that a Top N chain can launch if and only if the spawnTime has passed and the proposal with the MsgUpdateConsumer has successfully passed. While in launched phase, a consumer chain can choose to modify its parameters through MsgUpdateConsumer. Naturally, only the owner of the chain can issue MsgUpdateConsumer, thus for Top N chains, the chain can be updated only through a governance proposal that contains a MsgUpdateConsumer. Additionally, note that after the chain moves to the launched phase, the initialization parameters cannot be updated anymore, but general metadata and power-shaping parameters of the chain can still be updated.  Stopped phase. In the stopped phase the consumer chain stops receiving VSCPackets. A chain moves to the stopped phase, when the owner of the chain sends the MsgRemoveConsumer message.  Deleted phase. In the deleted phase the majority of the state in relation to this consumer chain is deleted from the provider. A chain moves to the deleted phase after the chain has been stopped for an unbonding period. We keep track of the state of the consumer chain for an unbonding period, so that we are able to punish validators for misbehaviors that occurred before the consumer chain stopped. Additionally, we do not fully delete the whole state of this chain, so that we can still query parameters a deleted chain used to have. This is useful for front-ends, etc.  Note that everything described so far and everything that follows applies to consumer chains that transition from standalone chains as well.  ","version":"Next","tagName":"h3"},{"title":"From chainId to consumerId​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#from-chainid-to-consumerid","content":" A hindrance in moving to Permissionless ICS is chain-id squatting. In a permissionless setting, anyone could issue a transaction to launch a consumer chain with a chainId that might already be used by some other consumer chain. This is a problem because in the current design the majority of stored state for a consumer chain is indexed using the chainId as the key (e.g., see key used to store client ids). To tackle this problem, in Permissionless ICS, we introduce the consumerId that defines a consumer chain and is simply an increasing counter (i.e., counter), thus we can support multiple consumer chains with the same chainId. Another way to understand this is with an analogy between consumer chains and IBC clients: Imagine having multiple IBC clients that each point to different consumer chains, but all share the exact same chainId. It is then up to the user to select the appropriate client (i.e., clientId) based on the actual chain they want to communicate with. Similarly, there can be multiple consumer chains with the exact same chainId, and it is the responsibility of the validators to choose the one they wish to interact with by providing the right consumerId.  Note that with Permissionless ICS, all interactions on a consumer chain have to use the consumerId instead of the chainId. For example, if a validator opts in on a chain using MsgOptIn, the validator has to provide the consumerId. Specifically, for the equivocation evidence, we update the MsgSubmitConsumerMisbehaviour and MsgSubmitConsumerDoubleVotingmessages to include the consumerId, and modify Hermesto include consumerId in those constructed messages as well. Hermes can find out the consumerId by querying the provider's clientId for some consumer chain (i.e., query ccvconsumer provider-info) and then asking the provider chain for the consumerId that corresponds to this clientId. To do this, we store the clientId to consumerId association on the provider and introduce a query to retrieve the clientId given the consumerId.  State​  As a result of using consumerId, we have to migrate a substantial chunk of state to re-index it using consumerId as the key. Currently, in ICS we have state that is indexed by a multitude of keys. In the table below, we see the ones that are associated with a chainId and how often state under those keys gets updated. Additionally, for each key, the table shows whose action can lead to the setting or deletion of the state associated with that key. An action can stem either from: i) a consumer chain (e.g., through a MsgUpdateConsumer message, an IBC packet sent over to the provider, etc.), ii) a provider chain (e.g., at the end of a block some action is taken), or by iii) a validator (e.g., through a MsgAssignConsumerKey message) or a combination of them.  Key\tDescription\tWho can set this?\tWho can delete this?\tHow often are chainId-associated keys updated?ChainToChannelBytePrefix\tStores the CCV channelID for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) ChannelToChainBytePrefix\tStores chainId for a specific channel\tconsumer chain\tconsumer chain\tOnly once (during set up) ChainToClientBytePrefix\tStores the clientID for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) PendingCAPBytePrefix\tStores pending consumer addition proposals\tconsumer chain\tprovider chain\tOnly once (for successful proposal) PendingCRPBytePrefix\tStores pending consumer removal proposals\tconsumer chain\tprovider chain\tOnly once (for successful proposal) ConsumerGenesisBytePrefix\tStores the consumer genesis for a specific chain\tconsumer chain\tconsumer chain\tOnly once (during set up) SlashAcksBytePrefix\tStores slash acks for a specific consumer chain\tconsumer chain\tprovider chain\tEvery time we receive a Slash packet PendingVSCsBytePrefix\tStores VSCPackets for a specific consumer chain\tprovider chain\tprovider chain\tEvery epoch ConsumerValidatorsBytePrefix\tStores consumer key per validator per consumer chain\tvalidator\tconsumer chain\tEvery MsgAssignConsumerKey or MsgOptIn ValidatorsByConsumerAddrBytePrefix\tStores consumer to provider validator address\tvalidator\tconsumer or provider chain\tEvery MsgAssignConsumerKey or MsgOptIn EquivocationEvidenceMinHeightBytePrefix\tStores min height for a consumer chain\tconsumer chain\tconsumer chain\tOnly once (during set up) ProposedConsumerChainByteKey\tStores proposalIDs for consumer chains with proposals in the voting period\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tCreated when the proposal is submitted and deleted when the proposal's voting period ends ConsumerValidatorBytePrefix\tStores consumer validators for a specific chain\tvalidator\tvalidator or consumer chain\tPotentially at every epoch OptedInBytePrefix\tStores opted-in validators for a specific chain\tvalidator\tvalidator or consumer chain\tPotentially at every block TopNBytePrefix\tStores whether a consumer chain is Top N or not\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tEvery parameter update ValidatorsPowerCapPrefix\tStores the power cap of a chain\tconsumer chain\tconsumer chain\tEvery parameter update ValidatorSetCapPrefix\tStores the set cap of a chain\tconsumer chain\tconsumer chain\tEvery parameter update AllowlistPrefix\tStores the allowlist of a chain\tconsumer chain\tconsumer chain\tEvery parameter update DenylistPrefix\tStores the denylist of a chain\tconsumer chain\tconsumer chain\tEvery parameter update ConsumerRewardsAllocationBytePrefix\tStores the ICS rewards per chain\tconsumer or provider chain\tprovider chain\tEvery IBC transfer packet that sends rewards to the provider ConsumerCommissionRatePrefix\tCommission rate per chain per validator\tvalidator\tconsumer chain\tEvery MsgSetConsumerCommissionRate message MinimumPowerInTopNBytePrefix\tStores the minimum power needed to opt in for a chain\tnot applicable for Opt In chains\tnot applicable for Opt In chains\tEvery epoch ConsumerAddrsToPruneV2BytePrefix\tStores consumer addresses to be pruned (as part of VSCMaturedPackets deprecation)\tvalidator or provider chain\tprovider chain\tEvery MsgAssignConsumerKey or MsgOptIn and later during actual pruning  Everything stored under one of the above keys is associated with a chainId and has to be migrated to new state under a consumerId.  ","version":"Next","tagName":"h3"},{"title":"New Messages​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#new-messages","content":" In this section, we describe the new messages (i.e., MsgCreateConsumer, MsgUpdateConsumer, and MsgRemoveConsumer) that Permissionless ICS introduces.  Create a Consumer Chain​  We first have to create a chain before launching it, irrespectively of whether it is Top N or Opt In. This is done through the following message:  message MsgCreateConsumer { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; // Submitter address. If the message is successfully handled, the ownership of // the consumer chain will given to this address. string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the chain id of the new consumer chain string chain_id = 2; ConsumerMetadata metadata = 3 [ (gogoproto.nullable) = false ]; ConsumerInitializationParameters initialization_parameters = 4; PowerShapingParameters power_shaping_parameters = 5; }   Note that metadata is a required field, while the initialization_parameters and power_shaping_parameters are optional and can later be set using MsgUpdateConsumer.  metadata is of the following type:  message ConsumerMetadata { // the name of the chain string name = 1; // the description of the chain string description = 2; // the metadata (e.g., GitHub repository URL) of the chain string metadata = 3; }   initialization_parameters is of the following type and if all are provided the chain is scheduled to launch:  // ConsumerInitializationParameters are the parameters needed to launch a chain message ConsumerInitializationParameters { // ---------- ---------- ---------- // Following fields are used when the consumer chain launches and are not needed by the provider afterwards. // ---------- ---------- ---------- // the proposed initial height of new consumer chain. // For a completely new chain, this will be {0,1}. However, it may be // different if this is a chain that is converting to a consumer chain. ibc.core.client.v1.Height initial_height = 1 [ (gogoproto.nullable) = false ]; // The hash of the consumer chain genesis state without the consumer CCV // module genesis params. It is used for off-chain confirmation of // genesis.json validity by validators and other parties. bytes genesis_hash = 2; // The hash of the consumer chain binary that should be run by validators on // chain initialization. It is used for off-chain confirmation of binary // validity by validators and other parties. bytes binary_hash = 3; // spawn time is the time on the provider chain at which the consumer chain // genesis is finalized and all validators will be responsible for starting // their consumer chain validator node. google.protobuf.Timestamp spawn_time = 4 [ (gogoproto.nullable) = false, (gogoproto.stdtime) = true ]; // Unbonding period for the consumer, // which should be smaller than that of the provider in general. google.protobuf.Duration unbonding_period = 5 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // ---------- ---------- ---------- // Following fields are used to construct the consumer genesis of the to-be-launched consumer chain // and are set up as params on the consumer chain. Those params can then be directly modified by the consumer chain. // ---------- ---------- ---------- // Sent CCV related IBC packets will timeout after this duration google.protobuf.Duration ccv_timeout_period = 6 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // Sent transfer related IBC packets will timeout after this duration google.protobuf.Duration transfer_timeout_period = 7 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ]; // The fraction of tokens allocated to the consumer redistribution address // during distribution events. The fraction is a string representing a // decimal number. For example &quot;0.75&quot; would represent 75%. string consumer_redistribution_fraction = 8; // BlocksPerDistributionTransmission is the number of blocks between // ibc-token-transfers from the consumer chain to the provider chain. On // sending transmission event, `consumer_redistribution_fraction` of the // accumulated tokens are sent to the consumer redistribution address. int64 blocks_per_distribution_transmission = 9; // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. int64 historical_entries = 10; // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer // chain. it is most relevant for chains performing a sovereign to consumer // changeover in order to maintain the existing ibc transfer channel string distribution_transmission_channel = 11; }   power_shaping_parameters is of the following type:  // PowerShapingParameters contains parameters that shape the validator set that we send to the consumer chain message PowerShapingParameters { // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. uint32 top_N = 1; // `validators_power_cap` corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. // For instance, if `validators_power_cap` is set to 32, no validator can have more than 32% of the total voting power of the // consumer chain. The power cap is intended as a safeguard against a validator having too much power on the consumer // chain and hence &quot;taking over&quot; the consumer chain. uint32 validators_power_cap = 2; // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. uint32 validator_set_cap = 3; // corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate the consumer chain repeated string allowlist = 4; // corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain repeated string denylist = 5; // Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain. uint64 min_stake = 6; // Corresponds to whether inactive validators are allowed to validate the consumer chain. bool allow_inactive_vals = 7; }   This MsgCreateConsumerResponse response contains a single string that is the consumerId for this registered consumer chain  Update a Consumer Chain​  We can issue a MsgUpdateConsumer at any point during the registered, initialized, or launched phase of a chain to update parameters of the consumer chain.  The MsgUpdateConsumer message is as follows:  message MsgUpdateConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the address of the owner of the consumer chain to be updated string owner = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to be updated string consumer_id = 2; // the new owner of the consumer when updated string new_owner_address = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the metadata of the consumer when updated ConsumerMetadata metadata = 4; // initialization parameters can only be updated before a chain has launched ConsumerInitializationParameters initialization_parameters = 5; // the power-shaping parameters of the consumer when updated PowerShapingParameters power_shaping_parameters = 6; }   Note that we need to extensively check the fields of the provided ConsumerInitializationParameters to guarantee that no consumer chain launches with problematic parameters.  For all consumer chains, irrespectively of their phase (even in the deleted phase), we keep a mapping between consumerIdand the underlying ConsumerMetadata, ConsumerInitializationParameters and PowerShapingParameters. This way, we can respond to queries that ask for all the consumer chain's parameters. For example, retrieving the spawn_time of consumer chain with a given consumerId.  MsgUpdateConsumer can be executed multiple times for the same Opt In consumer chain during its initialized phase to potentially change its to-be-launched parameters (e.g., spawnTime).  Remove (Stop) a Consumer Chain​  We introduce the MsgRemoveConsumer message so that we can stop any Opt In chain at any point in time. Note that all relevant state for this consumer chain remains on the provider's state before getting removed after the time of an unbonding period (of the provider) has passed. This is to enable potential slashing for any infraction that might have been incurred until now. Note however that we never recycle previously-used consumerIds. Naturally, this message can only be issued by the owner of the consumer chain.  message MsgRemoveConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the consumer id of the consumer chain to be stopped string consumer_id = 1; // the address of the owner of the consumer chain to be stopped string owner = 2 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   Examples of Launching a Consumer Chain​  The figures below depict some examples of some of the phases a consumer chain resides before launching.    ","version":"Next","tagName":"h3"},{"title":"Additional Modifications​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#additional-modifications","content":" We need to perform multiple migrations. All state needs to be reindexed based on a consumerId instead of the chainId. Because we only have two consumer chains (i.e., Neutron and Stride) at the moment, this is not going to be an expensive migration even if we have some live consumer chains that are being voted upon. Similarly, all the messages, queries, etc. would need to be changed to operate on a consumerId instead of a chainId.  It is important to migrate any live proposals, such as ConsumerAdditionProposals and MsgConsumerAdditions, etc. when we upgrade before we actually deprecate ConsumerAdditionProposals, MsgConsumerAdditions, etc.  ","version":"Next","tagName":"h3"},{"title":"Consequences​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#consequences","content":" ","version":"Next","tagName":"h2"},{"title":"Positive​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#positive","content":" Easier to launch an Opt In consumer chain because no governance is required.  ","version":"Next","tagName":"h3"},{"title":"Negative​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#negative","content":" Extensive migration and overhaul of existing code base (as part of API-breaking changes) that could lead to bugs.  ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"ADR 019: Permissionless Interchain Security","url":"/interchain-security/adrs/adr-019-permissionless-ics#references","content":" CHIPs Discussion phase: Permissionless ICSChain-id squatting ","version":"Next","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/adrs/intro","content":"","keywords":"","version":"Next"},{"title":"Table of Contents​","type":1,"pageTitle":"Overview","url":"/interchain-security/adrs/intro#table-of-contents","content":" ","version":"Next","tagName":"h2"},{"title":"Accepted​","type":1,"pageTitle":"Overview","url":"/interchain-security/adrs/intro#accepted","content":" ADR 001: Key AssignmentADR 002: Jail ThrottlingADR 004: Denom DOS fixesADR 005: Cryptographic verification of equivocation evidenceADR 008: Throttle with retriesADR 010: Standalone to Consumer ChangeoverADR 013: Slashing on the provider for consumer equivocationADR 014: EpochsADR 015: Partial Set SecurityADR 017: ICS with Inactive Provider ValidatorsADR 018: Remove VSCMatured PacketsADR 019: Permissionless Interchain SecurityADR 020: Customizable Slashing and Jailing  ","version":"Next","tagName":"h3"},{"title":"Proposed​","type":1,"pageTitle":"Overview","url":"/interchain-security/adrs/intro#proposed","content":" ADR 011: Improving testing and increasing confidenceADR 016: Security aggregationADR 021: Consumer Chain ClientsADR 022: Fault Resolutions  ","version":"Next","tagName":"h3"},{"title":"Rejected​","type":1,"pageTitle":"Overview","url":"/interchain-security/adrs/intro#rejected","content":" ADR 007: Pause validator unbonding during equivocation proposalADR 012: Separate Releasing  ","version":"Next","tagName":"h3"},{"title":"Deprecated​","type":1,"pageTitle":"Overview","url":"/interchain-security/adrs/intro#deprecated","content":" ADR 003: Equivocation governance proposalADR 009: Soft Opt-Out ","version":"Next","tagName":"h3"},{"title":"x/ccv/democracy","type":0,"sectionRef":"#","url":"/interchain-security/build/modules/democracy","content":"","keywords":"","version":"Next"},{"title":"Staking​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/build/modules/democracy#staking","content":" The x/ccv/democracy/staking module allows the cosmos-sdk x/staking module to be used alongside the interchain security consumer module.  The module uses overrides that allow the full x/staking functionality with one notable difference - the staking module will no longer be used to provide the validator set to the consensus engine.  ","version":"Next","tagName":"h2"},{"title":"Implications for consumer chains​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/build/modules/democracy#implications-for-consumer-chains","content":" The x/ccv/democracy/staking allows consumer chains to separate governance from block production. The validator set coming from the provider chain does not need to participate in governance - they only provide infrastructure (create blocks and maintain consensus).  Governators (aka. Governors)​  Validators registered with the x/ccv/democracy/staking module become Governators. Unlike validators, governators are not required to run any chain infrastructure since they are not signing any blocks. However, governators retain a subset of the validator properties:  new governators can be created (via MsgCreateValidator)governators can accept delegationsgovernators can vote on governance proposals (with their self stake and delegations)governators earn block rewards -- the block rewards kept on the consumer (see the ConsumerRedistributionFraction param) are distributed to all governators and their delegators.  With these changes, governators can become community advocates that can specialize in chain governance and they get rewarded for their participation the same way the validators do. Additionally, governators can choose to provide additional infrastructure such as RPC/API access points, archive nodes, indexers and similar software.  Tokenomics​  The consumer chain's token will remain a governance token. The token's parameters (inflation, max supply, burn rate) are completely under the control of the consumer chain.  ","version":"Next","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/build/modules/democracy#integration","content":" The x/ccv/democracy/staking module provides these x/staking overrides:   // InitGenesis delegates the InitGenesis call to the underlying x/staking module, // however, it returns no validator updates as validators are tracked via the // consumer chain's x/cvv/consumer module and so this module is not responsible for returning the initial validator set. func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run staking InitGenesis return []abci.ValidatorUpdate{} // do not return validator updates } // EndBlock delegates the EndBlock call to the underlying x/staking module. // However, no validator updates are returned as validators are tracked via the // consumer chain's x/cvv/consumer module. func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates return []abci.ValidatorUpdate{} // do not return validator updates }   To integrate the democracy/staking follow this guide:  1. confirm that no modules are returning validator updates​  warning Only the x/ccv/consumer module should be returning validator updates.  If some of your modules are returning validator updates please disable them while maintaining your business logic:  func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate { var genesisState types.GenesisState cdc.MustUnmarshalJSON(data, &amp;genesisState) -\treturn am.keeper.InitGenesis(ctx, &amp;genesisState) + _ = am.keeper.InitGenesis(ctx, &amp;genesisState) // run InitGenesis but drop the result +\treturn []abci.ValidatorUpdate{} // return empty validator updates } func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate { -\treturn am.keeper.BlockValidatorUpdates(ctx) + _ = am.keeper.BlockValidatorUpdates(ctx) // perform staking BlockValidatorUpdates +\treturn []abci.ValidatorUpdate{} // return empty validator updates }   2. wire the module in app.go​  You do not need to remove the cosmos-sdk StakingKeeper from your wiring.  import ( ... + ccvstaking &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/staking&quot; ) var ( // replace the staking.AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, - sdkstaking.AppModuleBasic{}, + ccvstaking.AppModuleBasic{}, // replace sdkstaking ... ) ) func NewApp(...) { ... // use sdk StakingKeepeer app.StakingKeeper = stakingkeeper.NewKeeper( appCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) app.MintKeeper = mintkeeper.NewKeeper( appCodec, keys[minttypes.StoreKey], app.StakingKeeper, app.AccountKeeper, app.BankKeeper, authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // no changes required for the distribution keeper app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // keep StakingKeeper! authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) + // pre-initialize ConsumerKeeper to satsfy ibckeeper.NewKeeper +\tapp.ConsumerKeeper = consumerkeeper.NewNonZeroKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), +\t) + +\tapp.IBCKeeper = ibckeeper.NewKeeper( + appCodec, + keys[ibchost.StoreKey], + app.GetSubspace(ibchost.ModuleName), + &amp;app.ConsumerKeeper, + app.UpgradeKeeper, + scopedIBCKeeper, +\t) + +\t// Create CCV consumer and modules +\tapp.ConsumerKeeper = consumerkeeper.NewKeeper( + appCodec, + keys[consumertypes.StoreKey], + app.GetSubspace(consumertypes.ModuleName), + scopedIBCConsumerKeeper, + app.IBCKeeper.ChannelKeeper, + &amp;app.IBCKeeper.PortKeeper, + app.IBCKeeper.ConnectionKeeper, + app.IBCKeeper.ClientKeeper, + app.SlashingKeeper, + app.BankKeeper, + app.AccountKeeper, + &amp;app.TransferKeeper, + app.IBCKeeper, + authtypes.FeeCollectorName, +\t) + +\t// Setting the standalone staking keeper is only needed for standalone to consumer changeover chains + // New chains using the democracy/staking do not need to set this +\tapp.ConsumerKeeper.SetStandaloneStakingKeeper(app.StakingKeeper) // change the slashing keeper dependency app.SlashingKeeper = slashingkeeper.NewKeeper( appCodec, legacyAmino, keys[slashingtypes.StoreKey], - app.StakingKeeper, + &amp;app.ConsumerKeeper, // ConsumerKeeper implements StakingKeeper interface authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register slashing module StakingHooks to the consumer keeper +\tapp.ConsumerKeeper = *app.ConsumerKeeper.SetHooks(app.SlashingKeeper.Hooks()) +\tconsumerModule := consumer.NewAppModule(app.ConsumerKeeper, app.GetSubspace(consumertypes.ModuleName)) // register the module with module manager // replace the x/staking module app.MM = module.NewManager( ... - sdkstaking.NewAppModule(appCodec, &amp;app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), + ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }   ","version":"Next","tagName":"h3"},{"title":"Distribution​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/build/modules/democracy#distribution","content":" The x/ccv/democracy/distribution module allows the consumer chain to send rewards to the provider chain while retaining the logic of the x/distribution module for internal reward distribution to governators and their delegators.  ","version":"Next","tagName":"h2"},{"title":"How it works​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/build/modules/democracy#how-it-works","content":" First, a percentage of the block rewards is sent to the provider chain, where is distributed only to opted-in validators and their delegators. Second, the remaining rewards get distributed to the consumer chain's governators and their delegators. The percentage that is sent to the provider chain corresponds to 1 - ConsumerRedistributionFraction. For example, ConsumerRedistributionFraction = &quot;0.75&quot; means that the consumer chain retains 75% of the rewards, while 25% gets sent to the provider chain  ","version":"Next","tagName":"h3"},{"title":"Integration​","type":1,"pageTitle":"x/ccv/democracy","url":"/interchain-security/build/modules/democracy#integration-1","content":" Change the wiring in app.go  import ( ... distrkeeper &quot;github.com/cosmos/cosmos-sdk/x/distribution/keeper&quot; distrtypes &quot;github.com/cosmos/cosmos-sdk/x/distribution/types&quot; sdkdistr &quot;github.com/cosmos/cosmos-sdk/x/distribution&quot; + ccvdistr &quot;github.com/cosmos/interchain-security/v4/x/ccv/democracy/distribution&quot; ) var ( // replace sdk distribution AppModuleBasic ModuleBasics = module.NewBasicManager( auth.AppModuleBasic{}, genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator), bank.AppModuleBasic{}, capability.AppModuleBasic{}, ccvstaking.AppModuleBasic{}, // make sure you first swap the staking keeper mint.AppModuleBasic{}, - sdkdistr.AppModuleBasic{}, + ccvdistr.AppModuleBasic{}, ) ) func NewApp(...) { .... app.DistrKeeper = distrkeeper.NewKeeper( appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, // connect to sdk StakingKeeper consumertypes.ConsumerRedistributeName, authtypes.NewModuleAddress(govtypes.ModuleName).String(), ) // register with the module manager app.MM = module.NewManager( ... - sdkdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), + ccvdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper, authtypes.FeeCollectorName, app.GetSubspace(distrtypes.ModuleName)), ccvstaking.NewAppModule(appCodec, *app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)), ... ) }  ","version":"Next","tagName":"h3"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/build/modules/overview","content":"Overview ICS consists of two main modules: x/provider Provides to consumer chains updated information of opted in validators.Distributes ICS rewards to opted in validators.Jails and slashes validators that misbehave on consumer chains. x/consumer Sends to the consensus engine the validator sets received from the provider chain.Splits consumer block rewards and sends ICS rewards to the provider chain.Notifies the provider chain of downtime infractions. Note that x/types contains types shared by both modules. In addition, the following modules are added to ICS to extend its functionality: x/democracy","keywords":"","version":"Next"},{"title":"Developing an ICS consumer chain","type":0,"sectionRef":"#","url":"/interchain-security/consumer-development/app-integration","content":"","keywords":"","version":"Next"},{"title":"Basic consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/consumer-development/app-integration#basic-consumer-chain","content":" The source code for the example app can be found here.  Please note that consumer chains do not implement the staking module - part of the validator set of the provider is replicated over to the consumer, meaning that the consumer uses a subset of provider validator set and the stake of the validators on the provider determines their stake on the consumer. Note that after the introduction of Partial Set Security, not all the provider validators have to validate a consumer chain (e.g., if top_N != 100).  Your chain should import the consumer module from x/consumer and register it in the correct places in your app.go. The x/consumer module will allow your chain to communicate with the provider using the ICS protocol. The module handles all IBC communication with the provider, and it is a simple drop-in. You should not need to manage or override any code from the x/consumer module.  ","version":"Next","tagName":"h2"},{"title":"Democracy consumer chain​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/consumer-development/app-integration#democracy-consumer-chain","content":" The source code for the example app can be found here.  This type of consumer chain wraps the basic CosmosSDK x/distribution, x/staking and x/governance modules allowing the consumer chain to perform democratic actions such as participating and voting within the chain's governance system.  This allows the consumer chain to leverage those modules while also using the x/consumer module.  With these modules enabled, the consumer chain can mint its own governance tokens, which can then be delegated to prominent community members which are referred to as &quot;representatives&quot; (as opposed to &quot;validators&quot; in standalone chains). The token may have different use cases besides just voting on governance proposals.  ","version":"Next","tagName":"h2"},{"title":"Standalone chain to consumer chain changeover​","type":1,"pageTitle":"Developing an ICS consumer chain","url":"/interchain-security/consumer-development/app-integration#standalone-chain-to-consumer-chain-changeover","content":" See the standalone chain to consumer chain changeover guide for more information on how to transition your standalone chain to a consumer chain. ","version":"Next","tagName":"h2"},{"title":"Consumer Chain Governance","type":0,"sectionRef":"#","url":"/interchain-security/consumer-development/consumer-chain-governance","content":"","keywords":"","version":"Next"},{"title":"Democracy module​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/consumer-development/consumer-chain-governance#democracy-module","content":" The democracy module provides a governance experience identical to what exists on a standalone Cosmos chain, with one small but important difference. On a standalone Cosmos chain validators can act as representatives for their delegators by voting with their stake, but only if the delegator themselves does not vote. This is a lightweight form of liquid democracy.  Using the democracy module on a consumer chain is the exact same experience, except for the fact that it is not the actual validator set of the chain (since it is a consumer chain, these are the Cosmos Hub validators) acting as representatives. Instead, there is a separate representative role who token holders can delegate to and who can perform the functions that validators do in Cosmos governance, without participating in proof of stake consensus.  For an example, see the Democracy Consumer  ","version":"Next","tagName":"h2"},{"title":"Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/consumer-development/changeover-procedure","content":"","keywords":"","version":"Next"},{"title":"Consumers on ICS Version v6.4.0+​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/consumer-development/changeover-procedure#consumers-on-ics-version-v640","content":" For chains that are using ICS v6.4.0 or newer, the standalone to consumer changeover consists of the following steps.  ","version":"Next","tagName":"h2"},{"title":"1. Create a new consumer chain on the provider​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/consumer-development/changeover-procedure#1-create-a-new-consumer-chain-on-the-provider","content":" Submit a MsgCreateConsumer message to the provider chain. This is a &quot;normal&quot; MsgCreateConsumer message as described in the onboarding checklist, but with the following important notes.  chain_id MUST be equal to the standalone chain id. The consumer initialization parameters (i.e., initialization_parameters) must be adapted for the changeover procedure: initial_height is not used as the provider uses an existing client of the standalone chain..spawn_time is the time on the provider when the consumer module genesis state is being generated, which means that at this time the provide creates the initial validator set that will validate the standalone chain once it becomes a consumer chain. Consequently, spawn_time MUST occur before the standalone chain is upgraded and the consumer module is added as the upgrade requires the consumer module genesis state.unbonding_period MUST correspond to the value used on the standalone chain.distribution_transmission_channel SHOULD be set to the canonical IBC token transfer channel between the provider and the standalone chain. This will preserve the ibc denom that may already be in use.connection_id MUST be set to the ID of the connection end on the provider chain on top of which the canonical IBC token transfer channel was created.  ","version":"Next","tagName":"h3"},{"title":"2. Add consumer module to standalone chain​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/consumer-development/changeover-procedure#2-add-consumer-module-to-standalone-chain","content":" The standalone chain MUST go through an upgrade to include the x/ccv/consumer module. Note that adding the x/ccv/consumer module requires the consumer module genesis state which is created by the provider at spawn_time. Consequently, the spawn_time MUST occur before this upgrade.  Note that the consumer module genesis state can be obtained from the provider using the consumer genesis query, i.e.,  interchain-security-pd query provider consumer-genesis [consumer-id] [flags]   The consumer genesis state must be exported to a file and placed in the correct folder on the standalone chain before the upgrade. The file must be placed at the exact specified location, otherwise the upgrade will not be executed correctly. Usually the file is placed in $NODE_HOME/config, but the file name and the exact directory is dictated by the upgrade code on the standalone chain.  After the consumer_genesis.json file has been made available, the process is equivalent to a normal on-chain upgrade. The standalone validator set will sign the next couple of blocks before transferring control to the initial ICS validator set.  Once upgraded, the x/ccv/consumer module will act as the &quot;staking module&quot; for the consumer chain, i.e., it will provide the validator set to the consensus engine. For staking a native token (e.g., for governance), the x/ccv/democracy/staking module allows the cosmos-sdk x/staking module to be used alongside the x/ccv/consumer module. For more details, check out the democracy modules.  ","version":"Next","tagName":"h3"},{"title":"Consumers on ICS Version < v6.4.0​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/consumer-development/changeover-procedure#consumers-on-ics-version--v640","content":" Chains that are using older version of ICS (i.e., &lt; v6.4.0), must &quot;force&quot; the provider to create a new client of the standalone chain (on top of which the CCV channel will be created). This is because older versions of the consumer module expects both a client state and a consensus state in order to create a new provider client. Therefore, when creating a new consumer chain on the provider, the following changes are necessary in the consumer initialization parameters:  connection_id MUST be set to an empty string (i.e., &quot;&quot;). As a result, the provider will create a new client of the consumer chain and a new connection on top of it.initial_height will be used by the provider when creating the new consumer client, so it MUST be set according to the following rules: &quot;initial_height&quot; : { // must correspond to current revision number of standalone chain // e.g. stride-1 =&gt; &quot;revision_number&quot;: 1 &quot;revision_number&quot;: 1, // must correspond to a height that is at least 1 block after the upgrade // that will add the `consumer` module to the standalone chain // e.g. &quot;upgrade_height&quot;: 100 =&gt; &quot;revision_height&quot;: 101 &quot;revision_height&quot;: 101, },   ","version":"Next","tagName":"h2"},{"title":"Adapt the consumer module genesis state​","type":1,"pageTitle":"Changeover Procedure","url":"/interchain-security/consumer-development/changeover-procedure#adapt-the-consumer-module-genesis-state","content":" Before the upgrade of the standalone chain (i.e., adding the x/ccv/consumer module), the consumer module genesis state created by the provider at spawn_time must be adapted to older versions of the consumer module. This consists of two changes.  First, by setting connection_id in the consumer initialization parameters to an empty string, the provider will set the preCCV flag in the ConsumerGenesisState struct to false. This must be changed to true in order to trigger the changeover procedure logic on the x/ccv/consumer module.  Second, the connection_id field of ConsumerGenesisState must be removed to enable older versions of the consumer module to unmarshal the consumer module genesis state obtained from the provider. This can be done using the interchain-security-cd genesis transform CLI command. ","version":"Next","tagName":"h3"},{"title":"x/ccv/consumer","type":0,"sectionRef":"#","url":"/interchain-security/build/modules/consumer","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#overview","content":" The ICS consumer module enables consumer chains to use stake locked on a provider chain as collateral for their own proof-of-stake based block production.  The consumer module established a IBC ordered channel to the provider chain. This channel is used by the provider chain to regularly send validator updates to the consumer chain. The consumer sends these updates to its own consensus engine. This means that the consumer module acts as a staking module of the consumer chain.  Regularly, the consumer module sends a part of the consumer chain's block rewards to the provider chain as ICS rewards.  If one of the validators in the consumer chain's validator set is missing enough blocks (i.e., downtime infraction), the consumer module notifies the provider chain by sending an IBC packet to the provider module. As a result, the misbehaving validator is punished on the provider chain.  ","version":"Next","tagName":"h2"},{"title":"State​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#state","content":" For clarity, the description of the consumer module state is split into features. For a more accurate description, check out the x/ccv/consumer/types/keys.go file, which contains the definitions of all the keys.  ","version":"Next","tagName":"h2"},{"title":"Provider Connection​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#provider-connection","content":" ProviderClientID​  ProviderClientID is the ID of the provider client on which the CCV channel is built.  Format: byte(3) -&gt; string  ProviderChannelID​  ProviderChannelID is the ID of the CCV channel.  Format: byte(4) -&gt; string  ","version":"Next","tagName":"h3"},{"title":"Changeover​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#changeover","content":" PreCCV​  PreCCV is the flag set when the consumer chain is in the process of a standalone to consumer chain changeover.  Format: byte(7) -&gt; uint64  InitialValSet​  InitialValSet is the initial validator set on the consumer chain.  Format: byte(8) -&gt; GenesisState  Note that only the InitialValSet field of the ProviderInfo field of GenesisState is set, i.e.,  message GenesisState { ... ProviderInfo provider = 14 [ (gogoproto.nullable) = false ]; } message ProviderInfo { // InitialValset filled in on new chain and on restart. repeated .tendermint.abci.ValidatorUpdate initial_val_set = 3 [ (gogoproto.nullable) = false ]; }   InitGenesisHeight​  InitGenesisHeight is the height when the consumer module was initialized (i.e., the InitGenesis method was called).  Format: byte(17) -&gt; uint64  PrevStandaloneChain​  PrevStandaloneChain is the flag set when the consumer chain was previously a standalone chain.  Format: byte(19) -&gt; []byte{}  ","version":"Next","tagName":"h3"},{"title":"Validator Updates​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#validator-updates","content":" PendingChanges​  PendingChanges are the validator updates received from the provider that were not yet sent to the consensus engine.  Format: byte(5) -&gt; ValidatorSetChangePacketData  Note that only the ValidatorUpdates field of ValidatorSetChangePacketData is set.  CrossChainValidator​  CrossChainValidator is the internal state of a consumer validator with consensus address addr.  Format: byte(16) | addr -&gt; CrossChainValidator, where CrossChainValidator is defined as  message CrossChainValidator { bytes address = 1; int64 power = 2; // pubkey is the consensus public key of the validator, as a Protobuf Any. google.protobuf.Any pubkey = 3 [ (cosmos_proto.accepts_interface) = &quot;cosmos.crypto.PubKey&quot;, (gogoproto.moretags) = &quot;yaml:\\&quot;consensus_pubkey\\&quot;&quot; ]; // deprecated bool opted_out = 4 [deprecated = true]; }   HistoricalInfo​  HistoricalInfo is the header and validator information for a given block. For more details, see the Cosmos SDK docs.  Format: byte(11) | height -&gt; HistoricalInfo, where HistoricalInfo is defined in the staking module as  message HistoricalInfo { tendermint.types.Header header = 1 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true]; repeated Validator valset = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true]; }   ","version":"Next","tagName":"h3"},{"title":"Reward Distribution​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#reward-distribution","content":" LastDistributionTransmission​  LastDistributionTransmission is the block height of the last attempt to send ICS rewards to the provider module.  Format: byte(1) -&gt; LastTransmissionBlockHeight, where LastTransmissionBlockHeight is defined as  message LastTransmissionBlockHeight { int64 height = 1; }   ","version":"Next","tagName":"h3"},{"title":"Downtime Infractions​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#downtime-infractions","content":" OutstandingDowntime​  OutstandingDowntime is the flag set when a SlashPacket is queued to be sent to the provider for a downtime infraction of a validator with consensus address addr. The flag is unset when receiving from the provider a VSCPacket with a slash acknowledgement (see SlashAcks in ValidatorSetChangePacketData).  Format: byte(14) | addr -&gt; []byte{}  HeightValsetUpdateID​  HeightValsetUpdateID is the validator set update ID associated with a block height.  Format: byte(13) | height -&gt; uint64  PendingPacketsIndex​  PendingPacketsIndex is the next index available to store packet data to be sent to the provider chain (see below).  Format: byte(20) -&gt; uint64  PendingDataPacketsV1​  PendingDataPacketsV1 is the queue of packet data to be sent to the provider chain. In general, packets in this queue will be sent to the provider in the end blocker, unless  the CCV channel is not yet established;the provider client is expired;the last slash packet sent was not yet acknowledged by the provider chain.  Format: byte(15) | index -&gt; ConsumerPacketData, where index is the index of the packet in the queue and ConsumerPacketData is defined as  message ConsumerPacketData { ConsumerPacketDataType type = 1; oneof data { SlashPacketData slashPacketData = 2; VSCMaturedPacketData vscMaturedPacketData = 3; } }   SlashRecord​  SlashRecord is the record storing the state of a SlashPacket sent to the provider chain that was not yet acknowledged. See ADR 008 for more details.  Format: byte(21) -&gt; SlashRecord, where SlashRecord is defined as  message SlashRecord { bool waiting_on_reply = 1; google.protobuf.Timestamp send_time = 2 [ (gogoproto.stdtime) = true, (gogoproto.nullable) = false ]; }   ","version":"Next","tagName":"h3"},{"title":"State Transitions​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#state-transitions","content":" TBA  ","version":"Next","tagName":"h2"},{"title":"IBC Callbacks​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#ibc-callbacks","content":" The consumer module is an IBC application that implements the IBC module callback.  ","version":"Next","tagName":"h2"},{"title":"OnChanOpenInit​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#onchanopeninit","content":" OnChanOpenInit first verifies that the CCV channel was not already created. Then, it validates the channel parameters -- an ordered IBC channel connected on the consumer port and with the counterparty port set to provider -- and asserts that the version matches the expected version (only version 1 is supported).  Finally, it verifies that the underlying client is the expected client of the provider chain (i.e., provided in the consumer module genesis state).  ","version":"Next","tagName":"h3"},{"title":"OnChanOpenTry​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#onchanopentry","content":" OnChanOpenTry returns an error. MsgChannelOpenTry should be sent to the provider.  ","version":"Next","tagName":"h3"},{"title":"OnChanOpenAck​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#onchanopenack","content":" OnChanOpenAck first verifies that the CCV channel was not already created. Then it verifies that the counterparty version matches the expected version (only version 1 is supported).  If the verification passes, it stores the ProviderFeePoolAddr in the state.  Finally, if the DistributionTransmissionChannel parameter is not set, it initiates the opening handshake for a token transfer channel over the same connection as the CCV channel by calling the ChannelOpenInit method of the IBC module.  ","version":"Next","tagName":"h3"},{"title":"OnChanOpenConfirm​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#onchanopenconfirm","content":" OnChanOpenConfirm returns an error. MsgChanOpenConfirm should be sent to the provider.  ","version":"Next","tagName":"h3"},{"title":"OnChanCloseInit​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#onchancloseinit","content":" OnChanCloseInit allows relayers to close duplicate OPEN channels, if the channel handshake is completed.  ","version":"Next","tagName":"h3"},{"title":"OnChanCloseConfirm​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#onchancloseconfirm","content":" OnChanCloseConfirm is a no-op.  ","version":"Next","tagName":"h3"},{"title":"OnRecvPacket​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#onrecvpacket","content":" OnRecvPacket unmarshals the IBC packet data into a ValidatorSetChangePacketData struct (see below) and executes the handling logic.  If it is the first packet received, sets the underlying IBC channel as the canonical CCV channel.Collects validator updates to be sent to the consensus engine at the end of the block.Store in state the block height to VSC id (i.e., valset_update_id) mapping.Removed the outstanding downtime flags from the validator for which the jailing for downtime infractions was acknowledged by the provider chain (see the slash_acks field in ValidatorSetChangePacketData).  message ValidatorSetChangePacketData { repeated .tendermint.abci.ValidatorUpdate validator_updates = 1 [ (gogoproto.nullable) = false, (gogoproto.moretags) = &quot;yaml:\\&quot;validator_updates\\&quot;&quot; ]; uint64 valset_update_id = 2; // consensus address of consumer chain validators // successfully jailed on the provider chain repeated string slash_acks = 3; }   ","version":"Next","tagName":"h3"},{"title":"OnAcknowledgementPacket​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#onacknowledgementpacket","content":" OnAcknowledgementPacket enables the consumer module to confirm that the provider module received the previously sent SlashPacket and it unblocks the sending of the next SlashPacket. This functionality is needed for throttling jailing on the provider chain. For more details, see ADR-008.  ","version":"Next","tagName":"h3"},{"title":"OnTimeoutPacket​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#ontimeoutpacket","content":" OnTimeoutPacket is a no-op.  ","version":"Next","tagName":"h3"},{"title":"Messages​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#messages","content":" ","version":"Next","tagName":"h2"},{"title":"MsgUpdateParams​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#msgupdateparams","content":" MsgUpdateParams updates the consumer module parameters. The params are updated through a governance proposal where the signer is the gov module account address.  message MsgUpdateParams { option (cosmos.msg.v1.signer) = &quot;authority&quot;; // signer is the address of the governance account. string authority = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // params defines the x/consumer parameters to update. interchain_security.ccv.v1.ConsumerParams params = 2 [(gogoproto.nullable) = false]; }   ","version":"Next","tagName":"h3"},{"title":"BeginBlock​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#beginblock","content":" In the BeginBlock of the consumer module the following actions are performed:  Store in state the block height to VSC id mapping needed for sending to the provider the height of infractions committed on the consumer chain.Track historical entries. This is the same logic as in the x/staking module.  ","version":"Next","tagName":"h2"},{"title":"EndBlock​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#endblock","content":" In the EndBlock of the consumer module the following actions are performed:  If PreCCV state is active, i.e., the consumer chain is a previously standalone chain that was just upgraded to include the consumer module, then execute the changeover logic.Otherwise, distribute block rewards internally and once every BlocksPerDistributionTransmission send ICS rewards to the provider chain.Send slash packets to the provider chain reporting infractions validators committed on the consumer chain.Send to the consensus engine validator updates reveived from the provider chain.  ","version":"Next","tagName":"h2"},{"title":"Hooks​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#hooks","content":" TBA  ","version":"Next","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#events","content":" TBA  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#parameters","content":" warning The consumer module parameters are set by the provider when creating the consumer genesis (i.e., when launching the consumer chain). As a result, changes of these parameters might result in incompatibilities between different versions of consumers and providers.  The consumer module contains the following parameters.  ","version":"Next","tagName":"h2"},{"title":"Enabled​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#enabled","content":" Enabled is deprecated.  ","version":"Next","tagName":"h3"},{"title":"BlocksPerDistributionTransmission​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#blocksperdistributiontransmission","content":" Type\tDefault valueint64\t1000  BlocksPerDistributionTransmission is the number of blocks between rewards transfers from the consumer to the provider.  ","version":"Next","tagName":"h3"},{"title":"DistributionTransmissionChannel​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#distributiontransmissionchannel","content":" Type\tDefault valuestring\t&quot;&quot;  DistributionTransmissionChannel is the provider chain IBC channel used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  Providing an IBC transfer channel enables a consumer chain to reuse one of the existing channels to the provider for consumer chain rewards distribution. This will preserve the ibc denom that may already be in use. This is especially important for standalone chains transitioning to become consumer chains. For more details, see the changeover procedure.  ","version":"Next","tagName":"h3"},{"title":"ProviderFeePoolAddrStr​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#providerfeepooladdrstr","content":" Type\tDefault valuestring\t&quot;&quot;  ProviderFeePoolAddrStr is the provider chain fee pool address used for receiving consumer chain reward distribution token transfers. This is automatically set during the consumer-provider handshake procedure.  ","version":"Next","tagName":"h3"},{"title":"CcvTimeoutPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#ccvtimeoutperiod","content":" Type\tDefault valuetime.Duration\t2419200s (4 weeks)  CcvTimeoutPeriod is the period used to compute the timeout timestamp when sending IBC packets.CcvTimeoutPeriod may have different values on the provider and consumer chains.  ","version":"Next","tagName":"h3"},{"title":"TransferTimeoutPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#transfertimeoutperiod","content":" Type\tDefault valuetime.Duration\t3600s (1 hour)  TransferTimeoutPeriod is the timeout period for consumer chain reward distribution IBC packets.  ","version":"Next","tagName":"h3"},{"title":"ConsumerRedistributionFraction​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#consumerredistributionfraction","content":" Type\tDefault valuestring\t&quot;0.75&quot;  ConsumerRedistributionFraction is the fraction of tokens allocated to the consumer redistribution address during distribution events. The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. For example, a consumer with ConsumerRedistributionFraction set to &quot;0.75&quot; would send 75% of its block rewards and accumulated fees to the consumer redistribution address, and the remaining 25% to the provider chain every BlocksPerDistributionTransmission blocks.  ","version":"Next","tagName":"h3"},{"title":"HistoricalEntries​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#historicalentries","content":" Type\tDefault valueint64\t10000  HistoricalEntries is the number of historical info entries to persist in store (see the staking module parameter with the same name for details).HistoricalEntries is needed since the consumer module acts as a staking module on the consumer chain.  ","version":"Next","tagName":"h3"},{"title":"UnbondingPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#unbondingperiod","content":" Type\tDefault valuetime.Duration\t1209600s (2 weeks)  UnbondingPeriod is the unbonding period on the consumer chain. It is recommended that every consumer chain set and unbonding period shorter than provider unbonding period, e.g., one week shorter.  ","version":"Next","tagName":"h3"},{"title":"SoftOptOutThreshold​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#softoptoutthreshold","content":" SoftOptOutThreshold is deprecated.  ","version":"Next","tagName":"h3"},{"title":"RewardDenoms​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#rewarddenoms","content":" Type\tDefault value[]string\t[]string  RewardDenoms are the denominations which are allowed to be sent to the provider as ICS rewards.  ","version":"Next","tagName":"h3"},{"title":"ProviderRewardDenoms​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#providerrewarddenoms","content":" Type\tDefault value[]string\t[]string  ProviderRewardDenoms are the denominations coming from the provider which are allowed to be used as ICS rewards. e.g. &quot;uatom&quot;.  ","version":"Next","tagName":"h3"},{"title":"RetryDelayPeriod​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#retrydelayperiod","content":" Type\tDefault valuetime.Duration\t3600s (1 hour)  RetryDelayPeriod is the period at which the consumer retries to send a SlashPacket that was rejected by the provider. For more details, see ADR-008.  ","version":"Next","tagName":"h3"},{"title":"Client​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#client","content":" ","version":"Next","tagName":"h2"},{"title":"CLI​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#cli","content":" A user can interact with the consumer module using the CLI.  Query​  The query commands allow users to query consumer state.  interchain-security-cd query ccvconsumer --help   Next Fee Distribution​  The next-fee-distribution command allows to query next fee distribution data.  interchain-security-cd query ccvconsumer next-fee-distribution [flags]   Example interchain-security-cd query ccvconsumer next-fee-distribution Output: data: currentHeight: &quot;967&quot; distribution_fraction: &quot;0.75&quot; lastHeight: &quot;960&quot; nextHeight: &quot;980&quot; toConsumer: &quot;&quot; toProvider: &quot;&quot; total: &quot;&quot;   Provider Info​  The provider-info command allows to query provider info.  interchain-security-cd query ccvconsumer provider-info [flags]   Example interchain-security-cd query ccvconsumer provider-info Output: consumer: chainID: pion-1 channelID: channel-0 clientID: 07-tendermint-0 connectionID: connection-0 provider: chainID: provider channelID: channel-0 clientID: 07-tendermint-0 connectionID: connection-0   Throttle State​  The throttle-state command allows to query on-chain state relevant with slash packet throttling.  interchain-security-cd query ccvconsumer throttle-state [flags]   Example interchain-security-cd query ccvconsumer throttle-state Output: packet_data_queue: - slashPacketData: infraction: INFRACTION_DOWNTIME validator: address: mb06cu8SzQJOdYSzrJAK43Q8at8= power: &quot;500&quot; valset_update_id: &quot;48&quot; type: CONSUMER_PACKET_TYPE_SLASH slash_record: send_time: &quot;2024-10-02T07:58:24.405645924Z&quot; waiting_on_reply: true   Params​  The params command allows to query consumer module parameters.  interchain-security-cd query ccvconsumer params [flags]   Example interchain-security-cd query ccvconsumer params Output: params: blocks_per_distribution_transmission: &quot;1000&quot; ccv_timeout_period: 2419200s consumer_id: &quot;0&quot; consumer_redistribution_fraction: &quot;0.75&quot; distribution_transmission_channel: channel-1 enabled: true historical_entries: &quot;10000&quot; provider_fee_pool_addr_str: cosmos1ap0mh6xzfn8943urr84q6ae7zfnar48am2erhd provider_reward_denoms: [] retry_delay_period: 3600s reward_denoms: [] soft_opt_out_threshold: &quot;0&quot; transfer_timeout_period: 3600s unbonding_period: 1209600s   ","version":"Next","tagName":"h3"},{"title":"gRPC​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#grpc","content":" A user can query the consumer module using gRPC endpoints.  Next Fee Distribution​  The QueryNextFeeDistribution endpoint queries next fee distribution data.  interchain_security.ccv.consumer.v1.Query/QueryNextFeeDistribution   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryNextFeeDistribution Output: { &quot;data&quot;: { &quot;currentHeight&quot;: &quot;402&quot;, &quot;lastHeight&quot;: &quot;400&quot;, &quot;nextHeight&quot;: &quot;420&quot;, &quot;distributionFraction&quot;: &quot;0.75&quot; } }   Provider Info​  The QueryProviderInfo endpoint queries provider info.  interchain_security.ccv.consumer.v1.Query/QueryProviderInfo   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryProviderInfo Output: { &quot;consumer&quot;: { &quot;chainID&quot;: &quot;pion-1&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; }, &quot;provider&quot;: { &quot;chainID&quot;: &quot;provider&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; } }   Throttle State​  The QueryThrottleState endpoint queries on-chain state relevant with slash packet throttling.  interchain_security.ccv.consumer.v1.Query/QueryThrottleState   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryThrottleState Output: { &quot;slashRecord&quot;: { &quot;waitingOnReply&quot;: true, &quot;sendTime&quot;: &quot;2024-10-02T07:58:24.405645924Z&quot; }, &quot;packetDataQueue&quot;: [ { &quot;type&quot;: &quot;CONSUMER_PACKET_TYPE_SLASH&quot;, &quot;slashPacketData&quot;: { &quot;validator&quot;: { &quot;address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;power&quot;: &quot;500&quot; }, &quot;valsetUpdateId&quot;: &quot;48&quot;, &quot;infraction&quot;: &quot;INFRACTION_DOWNTIME&quot; } } ] }   Params​  The QueryParams endpoint queries consumer module parameters.  interchain_security.ccv.consumer.v1.Query/QueryParams   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.consumer.v1.Query/QueryParams Output: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1000&quot;, &quot;distributionTransmissionChannel&quot;: &quot;channel-1&quot;, &quot;providerFeePoolAddrStr&quot;: &quot;cosmos1ap0mh6xzfn8943urr84q6ae7zfnar48am2erhd&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;10000&quot;, &quot;unbondingPeriod&quot;: &quot;1209600s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot;, &quot;consumerId&quot;: &quot;0&quot; } }   ","version":"Next","tagName":"h3"},{"title":"REST​","type":1,"pageTitle":"x/ccv/consumer","url":"/interchain-security/build/modules/consumer#rest","content":" A user can query the consumer module using REST endpoints.  Next Fee Distribution​  The next-fee-distribution endpoint queries next fee distribution data.  /interchain_security/ccv/consumer/next-fee-distribution   Example curl http://localhost:1317/interchain_security/ccv/consumer/next-fee-distribution Output: { &quot;data&quot;: { &quot;currentHeight&quot;: &quot;402&quot;, &quot;lastHeight&quot;: &quot;400&quot;, &quot;nextHeight&quot;: &quot;420&quot;, &quot;distributionFraction&quot;: &quot;0.75&quot; } }   Provider Info​  The QueryProviderInfo endpoint queries provider info.  /interchain_security/ccv/consumer/provider-info   Example curl http://localhost:1317/interchain_security/ccv/consumer/provider-info Output: { &quot;consumer&quot;: { &quot;chainID&quot;: &quot;pion-1&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; }, &quot;provider&quot;: { &quot;chainID&quot;: &quot;provider&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; } }   Throttle State​  The throttle_state endpoint queries on-chain state relevant with slash packet throttling.  /interchain_security/ccv/consumer/throttle_state   Example curl http://localhost:1317/interchain_security/ccv/consumer/throttle_state Output: { &quot;consumer&quot;: { &quot;chainID&quot;: &quot;pion-1&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; }, &quot;provider&quot;: { &quot;chainID&quot;: &quot;provider&quot;, &quot;clientID&quot;: &quot;07-tendermint-0&quot;, &quot;connectionID&quot;: &quot;connection-0&quot;, &quot;channelID&quot;: &quot;channel-0&quot; } }   Params​  The params endpoint queries consumer module parameters.  /interchain_security/ccv/consumer/params   Example curl http://localhost:1317/interchain_security/ccv/consumer/params Output: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1000&quot;, &quot;distributionTransmissionChannel&quot;: &quot;channel-1&quot;, &quot;providerFeePoolAddrStr&quot;: &quot;cosmos1ap0mh6xzfn8943urr84q6ae7zfnar48am2erhd&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;10000&quot;, &quot;unbondingPeriod&quot;: &quot;1209600s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot;, &quot;consumerId&quot;: &quot;0&quot; } }  ","version":"Next","tagName":"h3"},{"title":"CosmWasm​","type":1,"pageTitle":"Consumer Chain Governance","url":"/interchain-security/consumer-development/consumer-chain-governance#cosmwasm","content":" There are several great DAO and governance frameworks written as CosmWasm contracts. These can be used as the main governance system for a consumer chain. Actions triggered by the CosmWasm governance contracts are able to affect parameters and trigger actions on the consumer chain.  For an example, see Neutron. ","version":"Next","tagName":"h2"},{"title":"Consumer Genesis Transformation","type":0,"sectionRef":"#","url":"/interchain-security/consumer-development/consumer-genesis-transformation","content":"","keywords":"","version":"Next"},{"title":"1. Prerequisite​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/consumer-development/consumer-genesis-transformation#1-prerequisite","content":" used provider and consumer versions require transformation step as indicated in in the compatibility notesinterchain-security-cd application supports the versions used by the consumer and provider  ","version":"Next","tagName":"h2"},{"title":"2. Export the CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/consumer-development/consumer-genesis-transformation#2-export-the-ccv-data","content":" Export the CCV data from the provider chain as described in the Onboarding and Changeover your following. As a result the CCV data will be stored in a file in JSON format.  ","version":"Next","tagName":"h2"},{"title":"3. Transform CCV data​","type":1,"pageTitle":"Consumer Genesis Transformation","url":"/interchain-security/consumer-development/consumer-genesis-transformation#3-transform-ccv-data","content":" To transform the CCV data  to the format supported by the current version of the consumer run the following command: interchain-security-cd genesis transform [genesis-file] where 'genesis-file' is the path to the file containing the CCV data exported in step 2. As a result the CCV data in the new format will be written to standard output.a specific target version of a consumer run the following command: interchain-security-cd genesis transform --to &lt;target_version&gt; [genesis-file] where &lt;target_version is the ICS version the consumer chain is running. Use interchain-security-cd genesis transform --help to get more details about supported target versions and more.  Use the new CCV data as described in the procedure you're following. ","version":"Next","tagName":"h2"},{"title":"Consumer Offboarding","type":0,"sectionRef":"#","url":"/interchain-security/consumer-development/offboarding","content":"Consumer Offboarding To offboard a consumer chain, the owner of the chain has to submit a MsgRemoveConsumer message with the chain's consumerId. If the chain is a Top N chain, the MsgRemoveConsumer has to be submitted through a governance proposal. Otherwise, the message can be submitted simply by the owner of the consumer chain. When the MsgRemoveConsumer executes, the provider chain will stop the chain from the ICS protocol (it will stop sending validator set updates) and the chain is considered to be in the stopped phase. At this phase, validators cannot opt in, change keys, etc. and validators stop receiving rewards. After the chain is stopped, and an unbonding period of time passes, part of the state of the chain is deleted and the chain is considered deleted.","keywords":"","version":"Next"},{"title":"Create an ICS chain with Spawn","type":0,"sectionRef":"#","url":"/interchain-security/consumer-development/create-with-spawn","content":"","keywords":"","version":"Next"},{"title":"Requirements​","type":1,"pageTitle":"Create an ICS chain with Spawn","url":"/interchain-security/consumer-development/create-with-spawn#requirements","content":" go 1.22+Docker  MacOS + Ubuntu Setup  ","version":"Next","tagName":"h2"},{"title":"Getting Started​","type":1,"pageTitle":"Create an ICS chain with Spawn","url":"/interchain-security/consumer-development/create-with-spawn#getting-started","content":" Note: This tutorial focuses on using the Spawn CLI to create an ICS consumer chain. For more complete documentation on Spawn, see the Spawn documentation.  In this tutorial, we'll create and interact with a new Interchain security enabled blockchain called &quot;consumer&quot;, with the token denomination &quot;uconsu&quot;.  Install Spawn  # Install from latest source git clone https://github.com/rollchains/spawn.git --depth 1 --branch v0.50.10 # Change to this directory cd spawn # Clear Go modules cache for a fresh install go clean -modcache # Install Spawn make install # Install Local Interchain (testnet runner) make get-localic # Install docker container builder make get-heighliner # Verify installations were successful spawn local-ic heighliner # If you get &quot;command 'spawn' not found&quot;, run the following # Linux / Windows / Some MacOS echo 'export PATH=$PATH:$(go env GOPATH)/bin' &gt;&gt; ~/.bashrc source ~/.bashrc # MacOS echo 'export PATH=$PATH:$(go env GOPATH)/bin' &gt;&gt; ~/.zshrc source ~/.zshrc # Legacy MacOS Go echo 'export PATH=$PATH:$HOME/go/bin' &gt;&gt; ~/.zshrc source ~/.zshrc # Sometimes it can be good to also clear your cache # especially WSL users go clean -cache   Create your chain using the spawn command and customize it to your needs!  GITHUB_USERNAME=&lt;your github username&gt; spawn new consumer \\ --consensus=interchain-security \\ --bech32=consu \\ --denom=uconsu \\ --bin=consumerd \\ --disabled=tokenfactory,ibc-packetforward,ibc-ratelimit,cosmwasm,wasm-light-client \\ --org=${GITHUB_USERNAME}   NOTE: spawn creates a ready to use repository complete with git and GitHub CI. It can be quickly pushed to a new repository getting you and your team up and running quickly.  Spin up a local testnet for your chain  cd consumer # Starts 2 networks for the IBC testnet at http://127.0.0.1:8080. # - Builds the docker image of your chain # - Launches a testnet with IBC automatically connected and relayed # # Note: you can run a single node, non IBC testnet, with `make sh-testnet`. make testnet   Open a new terminal window and send a transaction on your new chain  # list the keys that have been provisioned with funds in genesis consumerd keys list # send a transaction from one account to another consumerd tx bank send acc0 $(consumerd keys show acc1 -a) 1337uconsu --chain-id=localchain-1 # enter &quot;y&quot; to confirm the transaction # then query your balances tfor proof the transaction executed successfully consumerd q bank balances $(consumerd keys show acc1 -a)   (optional) Send an IBC transaction  # submit a cross chain transfer from acc0 to the other address consumerd tx ibc-transfer transfer transfer channel-0 cosmos1hj5fveer5cjtn4wd6wstzugjfdxzl0xpxvjjvr 7uconsu --from=acc0 --chain-id=localchain-1 --yes # Query the other side to confirm it went through sleep 10 # Interact with the other chain without having to install the cosmos binary # - Endpoints found at: GET http://127.0.0.1:8080/info local-ic interact localcosmos-1 query 'bank balances cosmos1hj5fveer5cjtn4wd6wstzugjfdxzl0xpxvjjvr' --api-endpoint=http://127.0.0.1:8080   Push your new chain to a github repository  # Create a new repository on GitHub from the gh cli gh repo create ics-consumer --source=. --remote=origin --push   You can also push it the old fashioned way with https://github.com/new and git push origin main.  In this tutorial, we configured a new custom chain, launched a testnet for it, tested a simple token transfer, and confirmed it was successful. This tutorial demonstrates just how easy it is to create a brand new custom Cosmos-SDK blockchain from scratch, saving developers time.  ","version":"Next","tagName":"h2"},{"title":"Modify your chain​","type":1,"pageTitle":"Create an ICS chain with Spawn","url":"/interchain-security/consumer-development/create-with-spawn#modify-your-chain","content":" New module code is usually added in the x/ directory of your repository. Check out the Cosmos SDK documentation for more information on how to add modules to your chain.  Once you're ready you can preview your chain using the section below.  ","version":"Next","tagName":"h2"},{"title":"List your chain​","type":1,"pageTitle":"Create an ICS chain with Spawn","url":"/interchain-security/consumer-development/create-with-spawn#list-your-chain","content":" You can list your chain on Forge, even if it's not finished, in the pre-launch stage. ","version":"Next","tagName":"h2"},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"/interchain-security/faq","content":"","keywords":"","version":"Next"},{"title":"General​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#general","content":" ","version":"Next","tagName":"h2"},{"title":"What is Interchain Security (ICS)?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#what-is-interchain-security-ics","content":" ICS is an IBC protocol that enables a provider chain (e.g., the Cosmos Hub) to provide security to multiple consumer chains. This means that consumer chains will leverage the stake locked on the provider chain for block production (i.e., a cross-chain proof-of-stake system). ICS allows anyone to launch a consumer chain using a subset, or even the entire, validator set from the provider chain. Note that validators need to run separate infrastructure for the provider and consumer chains, resulting in different networks that only share (a subset of) the validator set.  ","version":"Next","tagName":"h3"},{"title":"What is the difference between ICS and Partial Set Security (PSS)?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#what-is-the-difference-between-ics-and-partial-set-security-pss","content":" ICS is a protocol. PSS is a feature of ICS that allows a provider chain to share only a subset of its validator set with a consumer chain. PSS differentiates between TopN and Opt-In consumer chains. For TopN chains, the validator subset is determined by the top N% provider validators by voting power. For Opt-In chains, the validator subset is determined by validators opting in to validate the consumer chains. PSS allows for flexible tradeoffs between security, decentralization, and the budget a consumer chain spends on rewards to validators.  For more details, see the PSS feature.  ","version":"Next","tagName":"h3"},{"title":"Consumer Chains​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#consumer-chains","content":" ","version":"Next","tagName":"h2"},{"title":"What are consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#what-are-consumer-chains","content":" Consumer chains are blockchains operated by (a subset of) the validators of the provider chain. The ICS protocol ensures that consumer chains get information about which validators should validate on them. This information consists of the opted in validators and their power on the consumer chains. Note that the validators' power on the consumer chains is a function of their stake locked on the provider chain.  Consumer chains are run on infrastructure (virtual or physical machines) distinct from the provider chain, have their own configurations and operating requirements.  Consumer chains are free to choose how they wish to operate and which modules to include. For example, they can choose to use CosmWasm either in a permissioned or a permissionless way. Also, consumer chains are free to perform software upgrades at any time without impacting the provider chain.  ","version":"Next","tagName":"h3"},{"title":"How to become a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#how-to-become-a-consumer-chain","content":" To become a consumer chain use this checklist and check the App integration section.  ","version":"Next","tagName":"h3"},{"title":"What happens to consumers if the provider is down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#what-happens-to-consumers-if-the-provider-is-down","content":" In case the provider chain halts or experiences difficulties, the consumer chains will keep operating - the provider chain and consumer chains represent different networks that only share (a subset of) the validator set. As the validators run separate infrastructure on these networks, the provider chain liveness does not impact the liveness of consumer chains.  Every consumer chain communicates with the provider chain via a CCV channel -- an IBC ordered channel. If any of the packets sent over the CCV channel timeout (see the CCVTimeoutPeriod param), then the channel is closed and, consequently, the consumer chain transitions to a Proof of Authority (PoA) chain. This means that the validator set on the consumer will no longer be updated with information from the provider.  ","version":"Next","tagName":"h3"},{"title":"What happens to provider if any of the consumers are down?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#what-happens-to-provider-if-any-of-the-consumers-are-down","content":" Consumer chains do not impact the livness of the provider chain.The ICS protocol is concerned only with validator set management, and the only communication that the provider requires from the consumer is information about validator activity (essentially keeping the provider informed about slash events).  ","version":"Next","tagName":"h3"},{"title":"Can consumer chains have their own token?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#can-consumer-chains-have-their-own-token","content":" As any other Cosmos SDK chains, consumer chains can issue their own token and manage inflation parameters. Note that the ICS protocol does not impact the transaction fee system on the consumer chains. This means consumer chains can use any token (including their own token) to pay gas fees. For more details, see the democracy modules.  ","version":"Next","tagName":"h3"},{"title":"Can consumer chains have their own governance?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#can-consumer-chains-have-their-own-governance","content":" Yes. ICS allows consumer chains to separate governance from block production. Validator operators (with their stake locked on the provider) are responsible for block production, while representatives (aka governators, governors) are responsible for on-chain governance. For more details, see the democracy modules.  ","version":"Next","tagName":"h3"},{"title":"Can a consumer chain modify its power shaping parameters?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#can-a-consumer-chain-modify-its-power-shaping-parameters","content":" Yes, by issuing a MsgUpdateConsumer.  ","version":"Next","tagName":"h3"},{"title":"Can a Top N consumer chain become Opt-In or vice versa?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#can-a-top-n-consumer-chain-become-opt-in-or-vice-versa","content":" Yes, by issuing a MsgUpdateConsumer (see Permissionless ICS)  ","version":"Next","tagName":"h3"},{"title":"Validators​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#validators","content":" ","version":"Next","tagName":"h2"},{"title":"How can validators opt in to validate a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#how-can-validators-opt-in-to-validate-a-consumer-chain","content":" Check the validator guide to Partial Set Security.  An important note is that validator the top N% of the provider chain validator set are automatically opted in on Top N consumer chains.  ","version":"Next","tagName":"h3"},{"title":"Can validators opt in to an Opt-in chain after the spawn time if nobody else opted in?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#can-validators-opt-in-to-an-opt-in-chain-after-the-spawn-time-if-nobody-else-opted-in","content":" No, the consumer chain does not launch if nobody opted in by the spawn time. At least one validator, regardless of its voting power, must opt in before the spawn time in order for the chain can start.  ","version":"Next","tagName":"h3"},{"title":"How does a validator know which consumers chains it has to validate?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#how-does-a-validator-know-which-consumers-chains-it-has-to-validate","content":" In order for a validator to keep track of all the chains it has to validate, the validator can use thehas-to-validate query.  ","version":"Next","tagName":"h3"},{"title":"How many chains can a validator opt in to?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#how-many-chains-can-a-validator-opt-in-to","content":" There is no limit in the number of consumers chains a validator can choose to opt in to.  ","version":"Next","tagName":"h3"},{"title":"How can validators assign consumer keys?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#how-can-validators-assign-consumer-keys","content":" Check the Key Assignment guide for specific instructions.  Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  Also note that validators can assign consensus keys before a consumer chain is launched (e.g., during the voting period for Top N consumer chains).  ","version":"Next","tagName":"h3"},{"title":"What are the benefits for validators running consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#what-are-the-benefits-for-validators-running-consumer-chains","content":" The consumer chains sends a portion of its block rewards (e.g., transaction fees and inflation) to the provider chain as defined by the ConsumerRedistributionFraction param. These rewards are sent periodically to the provider (via IBC transfers), where they are distributed ONLY to the opted in validators and their delegators. For more details, see the Reward Distribution feature.  ","version":"Next","tagName":"h3"},{"title":"Can validators set per consumer chain commission rates?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#can-validators-set-per-consumer-chain-commission-rates","content":" Yes. See the validator guide to Partial Set Security.  ","version":"Next","tagName":"h3"},{"title":"What are the risks for validators running consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#what-are-the-risks-for-validators-running-consumer-chains","content":" Validators that perform an equivocation or a light-client attack on a consumer chain are slashed on the provider chain. This is done by submitting a proof of the equivocation or the light-client attack to the provider chain.  In addition, consumer chains send IBC packets via the CCV channels informing the provider when opted in validators should be jailed for downtime. It is important to notice that validators are not slashed for downtime on consumer chains. The downtime logic is custom to the consumer chain. For example, Cosmos SDK chains can use the slashing module to configure the downtime window.  For more details, see the slashing feature.  ","version":"Next","tagName":"h3"},{"title":"Can validators run the provider and consumer chains on the same machine?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#can-validators-run-the-provider-and-consumer-chains-on-the-same-machine","content":" In theory yes. In practice, we recommend validators to run the provider and consumer chains in separate environments for fault containment, i.e., failures of one machine do not impact the entire system.  ","version":"Next","tagName":"h3"},{"title":"Can validators opt out of validating a consumer chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#can-validators-opt-out-of-validating-a-consumer-chain","content":" Validators can always opt out from an Opt-In consumer chain. Validators can only opt out from a TopN chain if they do not belong to the top N% validators.  ","version":"Next","tagName":"h3"},{"title":"Can all validators opt out of an Opt-in chain?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#can-all-validators-opt-out-of-an-opt-in-chain","content":" Note that if all validators opt out of an Opt-In consumer chain, then the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"Next","tagName":"h3"},{"title":"How to connect to the testnets?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#how-to-connect-to-the-testnets","content":" Check out the Joining Interchain Security testnet section.  ","version":"Next","tagName":"h3"},{"title":"Integrators​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#integrators","content":" ","version":"Next","tagName":"h2"},{"title":"Which relayers are supported?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#which-relayers-are-supported","content":" Currently supported versions:  Hermes v1.8.0+  ","version":"Next","tagName":"h3"},{"title":"How to check when the next validator update will be sent to the consumer chains?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/interchain-security/faq#how-to-check-when-the-next-validator-update-will-be-sent-to-the-consumer-chains","content":" Validator updates are sent to consumer chains every BlocksPerEpoch blocks. Depending on the status of relayers between the Hub and the consumer chains, it might take a while for the validator updates to be processed and applied on the consumer chains.  To query how many blocks are left until the next epoch starts, run the following command:  interchain-security-pd query provider blocks-until-next-epoch  ","version":"Next","tagName":"h3"},{"title":"Key Assignment","type":0,"sectionRef":"#","url":"/interchain-security/features/key-assignment","content":"","keywords":"","version":"Next"},{"title":"Rules​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/features/key-assignment#rules","content":" A key can be assigned to any active (i.e., in the registered, initialized, or launched phase) chain.Validator A cannot assign consumer key K to consumer chain X if there is already a validator B (B!=A) using K on the provider.Validator A cannot assign consumer key K to consumer chain X if there is already a validator B using K on X.A new validator on the provider cannot use a consensus key K if K is already used by any validator on any consumer chain.  ","version":"Next","tagName":"h2"},{"title":"Adding a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/features/key-assignment#adding-a-key","content":" warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  First, create a new node on the consumer chain using the equivalent:  consumerd init &lt;moniker&gt;   Then query your node for the consensus key.  consumerd tendermint show-validator # {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, make an assign-consensus-key transaction on the provider chain in order to inform the provider chain about the consensus key you will be using for a specific consumer chain.  gaiad tx provider assign-consensus-key &lt;consumer-id&gt; '&lt;pubkey&gt;' --from &lt;tx-signer&gt; --home &lt;home_dir&gt; --gas 900000 -b sync -y -o json   consumer-id is the string identifier of the consumer chain, as assigned on the provider chainconsumer-pub-key has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}  Check that the key was assigned correctly by querying the provider:  gaiad query provider validator-consumer-key &lt;consumer-id&gt; cosmosvalcons1e....3xsj3ayzf4uv6   You must use a valcons address. You can obtain it by querying your node on the provider gaiad tendermint show-address  OR  gaiad query provider validator-provider-key &lt;consumer-id&gt; consumervalcons1e....123asdnoaisdao   You must use a valcons address. You can obtain it by querying your node on the consumer consumerd tendermint show-address  OR  gaiad query provider all-pairs-valconsensus-address &lt;consumer-id&gt;   You just need to use the consumerId of consumer to query all pairs valconsensus address with consumer-pub-key for each of pair  ","version":"Next","tagName":"h2"},{"title":"Changing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/features/key-assignment#changing-a-key","content":" To change your key, simply repeat all of the steps listed above. Take note that your old key will be remembered for at least the unbonding period of the consumer chain so any slashes can be correctly applied  ","version":"Next","tagName":"h2"},{"title":"Removing a key​","type":1,"pageTitle":"Key Assignment","url":"/interchain-security/features/key-assignment#removing-a-key","content":" To remove a key, simply switch it back to the consensus key you have assigned on the provider chain by following steps in the Adding a key section and using your provider consensus key. ","version":"Next","tagName":"h2"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/features/partial-set-security","content":"Partial Set Security Partial Set Security (PSS) is a complete revamp of the Hub's security offering. It allows consumer chains to leverage only a subset of validators from the provider chain, which offers more flexibility than the previous Replicated Security model. By introducing the top_N parameter, each consumer chain can choose the extent of security needed: Top N: Requires the top N% validators from the provider chain to secure the consumer chain. This guarantees that the validators with the most power on the provider will validate the consumer chain, while others can voluntarily opt in. Opt-In: If the top_N parameter is set to zero, no validator is mandated to secure the consumer chain. Instead, any validator from the provider chain can opt in using a dedicated transaction. An advantage of Top N chains is that they are guaranteed to receive at least a certain fraction of the market cap of the provider chain in security. In turn, Top N chains need to be approved by governance, since some validators will be forced to validate on them. Thus, Top N chains should typically expect to need to provide a strong case for why they should be added to the provider chain, and they should make sure they offer enough rewards to incentivize validators and delegators to vote for their proposal. Opt-In chains, on the other hand, are more flexible. Validators are never forced to validate these chains and simply opt in if they want to. Because of this, Opt-In chains can be launch completely permissionlessly by sending a transaction to the provider chain. As a trade-off though, Opt-In chains do not get a fixed amount of security as a relation of the market cap of the provider as top N chains do, so Opt-In chains might want to keep an eye on how many validators have opted in to validate their chain and adjust their reward emissions accordingly to incentivize validators. Note that Top N consumer chains can become Opt-In chains or vice versa via a MsgUpdateConsumer message. Partial Set Security is handled only by the provider chain - the consumer chains are simply sent validator sets, and they are not aware that this represents only a subset of the provider chain's validator set.","keywords":"","version":"Next"},{"title":"Power Shaping","type":0,"sectionRef":"#","url":"/interchain-security/features/power-shaping","content":"","keywords":"","version":"Next"},{"title":"Power Shaping Configuration​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/features/power-shaping#power-shaping-configuration","content":" Currently, ICS supports the following power shaping parameters.  ","version":"Next","tagName":"h2"},{"title":"Consumer Onboarding Checklist","type":0,"sectionRef":"#","url":"/interchain-security/consumer-development/onboarding","content":"","keywords":"","version":"Next"},{"title":"1. Complete testing & integration​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/consumer-development/onboarding#1-complete-testing--integration","content":"  test integration with gaia test your protocol with supported relayer versions (minimum hermes 1.10.2) reach out to the ICS team if you are facing issues  ","version":"Next","tagName":"h2"},{"title":"2. Create an Onboarding Repository​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/consumer-development/onboarding#2-create-an-onboarding-repository","content":" To help validators and other node runners onboard onto your chain, please prepare a repository with information on how to run your chain.  This should include (at minimum):   genesis.json without the consumer module genesis (before the spawn time passes). Make sure the genesis time is within the trusting period (i.e., one day before launch time or shorter). genesis.json with the consumer module genesis (after the spawn time passes). Check if the consumer module genesis needs to be transformed (see Transform Consumer Genesis) information about relevant seed/peer nodes you are running relayer information (compatible versions) a script showing how to start your chain and connect to peers (optional) take feedback from other developers, validators and community regarding your onboarding repo and make improvements where applicable  Example of such a repository can be found here.  ","version":"Next","tagName":"h2"},{"title":"3. Submit MsgCreateConsumer (and MsgUpdateConsumer) messages​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/consumer-development/onboarding#3-submit-msgcreateconsumer-and-msgupdateconsumer-messages","content":" Before you start your chain, you need to submit a MsgCreateConsumer message that generates and returns back theconsumerId that should be used in any upcoming interactions by the consumer chain or the validators that interact with your chain. Additionally, you need to decide whether your chain should be an Opt-In chain or a Top N chain (see Partial Set Security) and act accordingly (see Permissionless ICS).  If you create a Top N chain through, please consider allowing at least a day between your proposal passing and the chain spawn time. This will allow the validators, other node operators and the community to prepare for the chain launch. If possible, please set your spawn time so people from different parts of the globe can be available in case of emergencies. Ideally, you should set your spawn time to be between 12:00 UTC and 20:00 UTC so most validator operators are available and ready to respond to any issues.  Additionally, for a Top N chain, reach out to the community via the forum to formalize your intention to become an ICS consumer, gather community support and accept feedback from the community, validators and developers.   determine your chain's spawn time determine consumer chain parameters take note to include a link to your onboarding repository describe the purpose and benefits of running your chain if desired, decide on power-shaping parameters (see Power Shaping)  Example of initialization parameters:  // ConsumerInitializationParameters provided in MsgCreateConsumer or MsgUpdateConsumer { // Initial height of new consumer chain. // For a completely new chain, this will be {1,1}. &quot;initial_height&quot; : { &quot;revision_height&quot;: 1, &quot;revision_number&quot;: 1, }, // Hash of the consumer chain genesis state without the consumer CCV module genesis params. // It is used for off-chain confirmation of genesis.json validity by validators and other parties. &quot;genesis_hash&quot;: &quot;d86d756e10118e66e6805e9cc476949da2e750098fcc7634fd0cc77f57a0b2b0&quot;, // Hash of the consumer chain binary that should be run by validators on chain initialization. // It is used for off-chain confirmation of binary validity by validators and other parties. &quot;binary_hash&quot;: &quot;376cdbd3a222a3d5c730c9637454cd4dd925e2f9e2e0d0f3702fc922928583f1&quot;, // Time on the provider chain at which the consumer chain genesis is finalized and validators // will be responsible for starting their consumer chain validator node. &quot;spawn_time&quot;: &quot;2023-02-28T20:40:00.000000Z&quot;, // Unbonding period for the consumer chain. // It should be smaller than that of the provider. &quot;unbonding_period&quot;: 1728000000000000, // Timeout period for CCV related IBC packets. // Packets are considered timed-out after this interval elapses. &quot;ccv_timeout_period&quot;: 2419200000000000, // IBC transfer packets will timeout after this interval elapses. &quot;transfer_timeout_period&quot;: 1800000000000, // The fraction of tokens allocated to the consumer redistribution address during distribution events. // The fraction is a string representing a decimal number. For example &quot;0.75&quot; would represent 75%. // The reward amount distributed to the provider is calculated as: 1 - consumer_redistribution_fraction. &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, // BlocksPerDistributionTransmission is the number of blocks between IBC token transfers from the consumer chain to the provider chain. // eg. send rewards to the provider every 1000 blocks &quot;blocks_per_distribution_transmission&quot;: 1000, // The number of historical info entries to persist in store. // This param is a part of the cosmos sdk staking module. In the case of // a ccv enabled consumer chain, the ccv module acts as the staking module. &quot;historical_entries&quot;: 10000, // The ID of a token transfer channel used for the Reward Distribution // sub-protocol. If DistributionTransmissionChannel == &quot;&quot;, a new transfer // channel is created on top of the same connection as the CCV channel. // Note that transfer_channel_id is the ID of the channel end on the consumer chain. // it is most relevant for chains performing a standalone to consumer changeover // in order to maintain the existing ibc transfer channel &quot;distribution_transmission_channel&quot;: &quot;channel-123&quot; }   Example of power-shaping parameters:  // PowerShaping parameters provided in MsgCreateConsumer or MsgUpdateConsumer { // Corresponds to the percentage of validators that have to validate the chain under the Top N case. // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100]. // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain. &quot;top_N&quot;: 0, // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis. &quot;validators_power_cap&quot;: 0, // Corresponds to the maximum number of validators that can validate a consumer chain. // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op. &quot;validator_set_cap&quot;: 0, // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate // the consumer chain. &quot;allowlist&quot;: [&quot;cosmosvalcons...&quot;], // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain. &quot;denylist&quot;: [&quot;cosmosvalcons...&quot;], // Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain. &quot;min_stake&quot;: 0, // Corresponds to whether inactive validators are allowed to validate the consumer chain. &quot;allow_inactive_vals&quot;: false, // Corresponds to a list of provider consensus addresses of validators that have priority &quot;prioritylist&quot;: [], }   Example of allowlisted reward denoms:  // AllowlistedRewardDenoms provided in MsgCreateConsumer or MsgUpdateConsumer { &quot;denoms&quot;: [&quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;, &quot;ibc/054892D6BB43AF8B93AAC28AA5FD7019D2C59A15DAFD6F45C1FA2BF9BDA22454&quot;] }   caution For opt-in consumer chains, make sure that at least one validator opts in before the spawn time elapses. Otherwise the launch process will be aborted and the spawn time needs to be updated by submitting a MsgUpdateConsumer message.  ","version":"Next","tagName":"h2"},{"title":"4. Launch​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/consumer-development/onboarding#4-launch","content":" The consumer chain starts after at least 66.67% of its voting power comes online. Note that this means 66.67% of the voting power in the consumer validator set, which will be comprised of all validators that either opted in to the chain or are part of the top N% of the provider chain (and are thus automatically opted in). The consumer chain is considered interchain secured once the appropriate CCV channels are established and the first validator set update is propagated from the provider to the consumer   provide a repo with onboarding instructions for validators genesis.json with the consumer module section populated (MUST contain the initial validator set) maintenance &amp; emergency contact info (relevant discord, telegram, slack or other communication channels) have a block explorer in place to track chain activity &amp; health  ","version":"Next","tagName":"h2"},{"title":"Establish CCV channel​","type":1,"pageTitle":"Consumer Onboarding Checklist","url":"/interchain-security/consumer-development/onboarding#establish-ccv-channel","content":" Once the consumer chain is launched, the CCV channel needs to be established. The following instructions are setting both the connection and channel using Hermes:  #!/bin/bash # CONSUMER_CLIENT_ID is created on CONSUMER upon genesis CONSUMER_CLIENT_ID=&quot;&lt;consumer-client-id&gt;&quot; CONSUMER_CHAIN_ID=&quot;&lt;consumer-chain-id&gt;&quot; # PROVIDER_CLIENT_ID is created on PROVIDER upon CONSUMER spawn time: gaiad q provider list-consumer-chains PROVIDER_CLIENT_ID=&quot;&lt;provider-client-id&gt;&quot; PROVIDER_CHAIN_ID=&quot;&lt;provider-chain-id&gt;&quot; CONFIG=$1 if [ -z &quot;$CONFIG&quot; ]; then CONFIG=$HOME/.hermes/config.toml fi if [ ! -f &quot;$CONFIG&quot; ]; then echo &quot;no config file found at $CONFIG&quot; exit 1 fi output=$(hermes --json --config $CONFIG create connection --a-chain $CONSUMER_CHAIN_ID --a-client $CONSUMER_CLIENT_ID --b-client $PROVIDER_CLIENT_ID | tee /dev/tty) json_output=$(echo &quot;$output&quot; | grep 'result') a_side_connection_id=$(echo &quot;$json_output&quot; | jq -r '.result.a_side.connection_id') output=$(hermes --json --config $CONFIG create channel --a-chain $CONSUMER_CHAIN_ID --a-port consumer --b-port provider --order ordered --a-connection $a_side_connection_id --channel-version 1 | tee /dev/tty) json_output=$(echo &quot;$output&quot; | grep 'result') echo &quot;---- DONE ----&quot; echo &quot;$json_output&quot; | jq # hermes start  ","version":"Next","tagName":"h3"},{"title":"Permissionless ICS","type":0,"sectionRef":"#","url":"/interchain-security/features/permissionless","content":"","keywords":"","version":"Next"},{"title":"From chainId to consumerId​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/features/permissionless#from-chainid-to-consumerid","content":" With Permissionless ICS, anyone can issue a transaction to launch a consumer chain. As a result, the chainId of a consumer chain cannot uniquely identify a consumer chain from the point of view of the provider, because we could have multiple consumer chains with the exact same chainId. Because of this, Permissionless ICS introduces the notion of a consumerId. The provider associates for each consumer chain a unique consumerId. A consumer chain can then interact (e.g., update chain parameters) with its chain by utilizing this consumerId. Additionally, validators can interact (e.g., assign a consumer key, opt in, etc.) with a consumer chain by using the consumer's consumerId.  ","version":"Next","tagName":"h2"},{"title":"Phases of a Consumer Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/features/permissionless#phases-of-a-consumer-chain","content":" A consumer chain can reside in one of the phases shown in the table below.  Phase\tDescriptionRegistered\tThe consumer chain was created with MsgCreateConsumer and has received the consumer's associated consumerId. The chain cannot launch yet. Initialized\tThe consumer chain has set all the initialization parameters and is ready to launch at spawnTime. Launched\tThe consumer chain has launched and is running. The provider chain is sending VSCPackets to the consumer. Stopped\tThe consumer chain is stopped and the provider chain is not sending VSCPackets to the consumer. The consumer chain is slated to be deleted. Deleted\tThe majority of the state of the consumer chain on the provider is deleted. Basic metadata of the consumer chain, such as the chainId, etc. are not deleted.  The following diagram shows the phases and the actions that need to take place to move from one phase to another.    ","version":"Next","tagName":"h2"},{"title":"Owner of a Consumer Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/features/permissionless#owner-of-a-consumer-chain","content":" A consumer chain (either Opt In or Top N) has an owner. An Opt In chain is owned by the address that initially sent and signed the MsgCreateConsumer message. A Top N chain is owned by the governance module and can only be updated through governance proposals.  Note that the owner of a chain can be changed at any later point in time by providing a new_owner_address message in the MsgUpdateConsumer message. As a result, an Opt In chain can change its owner to be the governance module in order to transform to Top N chain, and a Top N chain can change its owner to something that is not the governance module to become an Opt In chain (see below).  ","version":"Next","tagName":"h2"},{"title":"Launch an Opt In Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/features/permissionless#launch-an-opt-in-chain","content":" To launch an Opt In chain, we have to send a MsgCreateConsumer message. This message returns the newly created consumerIdassociated with this consumer. The chain is considered to be in the registered phase at this point and its owner is the one that signed the MsgCreateConsumer message. If the optional initialization_parameters are provided in the MsgCreateConsumer, then the chain is considered to be in the initialized phase and the chain can launch at the spawnTime provided in the initialization_parameters.  If no initialization_parameters are provided in MsgCreateConsumer, the consumer can later set those parameters by issuing a MsgUpdateConsumer. The chain would then move to the initialized phase and be slated to launch.  info An Opt In can only launch at spawnTime if at least one validator is opted in at spawnTime.  ","version":"Next","tagName":"h2"},{"title":"Launch a Top N Chain​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/features/permissionless#launch-a-top-n-chain","content":" To launch a Top N chain, we need to issue a MsgCreateConsumer to retrieve the consumerId. At this stage, the chain corresponds to an Opt In chain and the owner of the chain is the one that signed the MsgCreateConsumer. For the chain to become Top N we need to issue a message and a governance proposal:  A MsgUpdateConsumer message to change the owner of the chain to be that of the governance module, that is to cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn.A governance proposal that includes a MsgUpdateConsumer that sets the TopN of the consumer chain.  warning If top_N, validators_power_cap, or some other argument is not included in the power-shaping parameters, then it is considered that the default value is set for this argument. For example, if a Top 50% chain wants to only modify validators_power_capfrom 35 to 40, then the power-shaping parameters in MsgUpdateConsumer still need to include that top_N is 50. Otherwisetop_N would be set to its default value of 0, and the chain would become an Opt-In chain. To be safe, if you include power-shaping parameters in the MsgUpdateConsumer, always include top_N and all the power-shaping parameters. The same applies for the initialization parameters.  ","version":"Next","tagName":"h2"},{"title":"Transform an Opt In Chain to Top N and Vice Versa​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/features/permissionless#transform-an-opt-in-chain-to-top-n-and-vice-versa","content":" ","version":"Next","tagName":"h2"},{"title":"From Opt In to Top N​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/features/permissionless#from-opt-in-to-top-n","content":" This corresponds to the case of launching a Top N chain. The Opt In chain has to issue a MsgUpdateConsumer to change the owner of the consumer to be that of the governance module and to issue a governance proposal that includes a MsgUpdateConsumer and sets the TopN of the consumer chain.  ","version":"Next","tagName":"h3"},{"title":"From Top N to Opt In​","type":1,"pageTitle":"Permissionless ICS","url":"/interchain-security/features/permissionless#from-top-n-to-opt-in","content":" A consumer chain can move from Top N to Opt In by issuing a governance proposal that includes a MsgUpdateConsumerthat sets TopN to 0 and also sets the owner of the chain to not be the governance module anymore. ","version":"Next","tagName":"h3"},{"title":"Capping the validator set size​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/features/power-shaping#capping-the-validator-set-size","content":" The consumer chain can specify a maximum number of validators it wants to have in its validator set. This can be used to limit the number of validators in the set, which can be useful for chains that want to have a smaller validator set for faster blocks or lower overhead. If more validators than the maximum size have opted in on a consumer chain, only the validators with the highest power, up to the specified maximum, will validate the consumer chain.  Note that this parameter only applies to Opt In consumer chains (i.e., with Top N = 0).  ","version":"Next","tagName":"h3"},{"title":"Capping the validator powers​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/features/power-shaping#capping-the-validator-powers","content":" The consumer chain can specify a power cap which corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. The validators-power cap is intended as a safeguard against a validator having too much power on the consumer chain and hence &quot;taking over&quot; the consumer chain. For example, if the validators-power cap is set to 32%, then no single validator can have more than 32% of the total voting power on the consumer, and thus no single validator would be able to halt the consumer by going offline.  To respect this power cap, the voting powers of the validators that run the consumer chain are decremented or incremented accordingly. It is important to note that the voting powers of validators on the provider do not change. For example, assume that the provider chain has among others, validators A, B, C, and D with voting powers 100, 1, 1, 1 respectively. Assume that only those 4 validators opt in on a consumer chain. Without a power cap set, validator Awould have 100 / (100 + 1 + 1 + 1) = ~97% of the total voting power on the consumer chain, while validators B, C, and D would have 1 /(100 + 1 + 1 + 1) = ~1% of the total voting power on the consumer chain. If the power cap is set to 30%, then the voting power of A would be reduced from 100 to 30 on the consumer chain, the voting power of B would be increased from 1 to 25, and the power of C and D would be increased from 1 to 24. After those modifications, A would have 30 / (30 + 25 + 24 + 24) = ~29% of the total voting power of the consumer chain, B would have 25 / (30 + 25 + 24 + 24) = ~25%, and C and D would both have 24 / (30 + 25 + 24 + 24) = ~23%. Naturally, there are many ways to change the voting powers of validators to respect the power cap, and ICS chooses one of them.  Note that respecting the power cap might NOT always be possible. For example, if we have a consumer chain with only 5 validators and the power cap is set to 10%, then it is not possible to respect the power cap. If the voting power of each validator is capped to a maximum of 10% of the total consumer chain's voting power, then the total voting power of the consumer chain would add up to 50% which obviously does not make sense (percentages should add up to 100%). In cases where it is not feasible to respect the power cap, all validators on the consumer chain will have equal voting power in order to minimize the power of a single validator. Thus, in the example of 5 validators and a power cap set to 10%, all validators would end up having 20% of the total voting power on the consumer chain. Therefore, power-cap operates on a best-effort basis.  Note that rewards are distributed proportionally to validators with respect to their capped voting power on the consumer and not their voting power on the provider. For more information, read on Reward Distribution.  ","version":"Next","tagName":"h3"},{"title":"Allowlist and denylist​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/features/power-shaping#allowlist-and-denylist","content":" The consumer chain can specify a list of validators that are allowed or disallowed from participating in the validator set. If an allowlist is set, all validators not on the allowlist cannot validate the consumer chain. If a validator is on both lists, the denylist takes precedence, that is, they cannot validate the consumer chain. By default, both lists are empty -- there are no restrictions on which validators are eligible to opt in.  warning Note that if denylisting is used in a Top N consumer chain, then the chain might not be secured by N% of the total provider's power. For example, consider that the top validator V on the provider chain has 10% of the voting power, and we have a Top 50% consumer chain, then if V is denylisted, the consumer chain would only be secured by at least 40% of the provider's power.  ","version":"Next","tagName":"h3"},{"title":"Minimum validator stake​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/features/power-shaping#minimum-validator-stake","content":" The consumer chains can specify a minimum amount of stake that any validator must have on the provider chain to be eligible to opt in. For example, setting this to 1000 would mean only validators with at least 1000 tokens staked on the provider chain can validate the consumer chain.  ","version":"Next","tagName":"h3"},{"title":"Allow inactive validators​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/features/power-shaping#allow-inactive-validators","content":" The consumer chains can specify whether validators outside of the provider's active set are eligible to opt in. This can be useful for chains that want to have a larger validator set than the provider chain, or for chains that want to have a more decentralized validator set. Consumer chains that enable this feature should strongly consider setting a minimum validator stake to ensure that only validators with some reputation/stake can validate the chain. By default, this parameter is set to false, i.e., validators outside of the provider's active set are not eligible to opt in.  ","version":"Next","tagName":"h3"},{"title":"Prioritylist​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/features/power-shaping#prioritylist","content":" The consumer chain can specify a priority list of validators for participation in the validator set. Validators on the priority list are considered first when forming the consumer chain's validator set. If a priority list isn't set, the remaining slots are filled based on validator power.  ","version":"Next","tagName":"h3"},{"title":"Setting Power Shaping Parameters​","type":1,"pageTitle":"Power Shaping","url":"/interchain-security/features/power-shaping#setting-power-shaping-parameters","content":" All the power shaping parameters can be set by the consumer chain in the MsgCreateConsumer or MsgUpdateConsumer messages. They operate solely on the provider chain, meaning the consumer chain simply receives the validator set after these rules have been applied and does not have any knowledge about whether they are applied.  When setting power shaping parameters, please consider the following guidelines:  Do not cap the validator set size too low.Notice that this number is the maximum number of validators that will ever validate the consumer chain. If this number is too low, the chain will be very limited in the amount of stake that secures it. The validator set size cap should only be used if there are strong reasons to prefer fewer validators.Be aware of the interaction between capping the validator powers capping the validator set size.For example, if there are only 3 validators, and the cap is 20%, this will not be possible (since even splitting the power fairly would mean that each validator has 33% of the power, so is above the cap). Also note that the smaller this value is, the more the original voting power gets distorted, which could discourage large validators from deciding to opt in to the chain.Do not have allowlist contain too few validators.If the allowlist is non empty, then only validators on the allowlist can validate the chain. Thus, an allowlist containing too few validators is a security risk, e.g., the validators on the allowlist get jailed on the provider.Do not have denylist contain too many validators.If the denylist is non empty, then the validators on the denylist cannot validate the chain. Thus, a denylist containing too many validators is a security risk, e.g., the validators on the denylist represents a large fraction of the provider's power.  In general, when setting these parameters, consider that the voting power distribution in the future might be very different from the one right now, and that the chain should be secure even if the power distribution changes significantly.  The power shaping parameters of a launched consumer chain can be changed through a MsgUpdateConsumer message.  The power shaping parameters can be seen by querying the list of consumer chains:  interchain-security-pd query provider list-consumer-chains  ","version":"Next","tagName":"h2"},{"title":"Reward Distribution","type":0,"sectionRef":"#","url":"/interchain-security/features/reward-distribution","content":"","keywords":"","version":"Next"},{"title":"Reward distribution with power capping​","type":1,"pageTitle":"Reward Distribution","url":"/interchain-security/features/reward-distribution#reward-distribution-with-power-capping","content":" If a consumer chain has set a validators-power cap, then the total received rewards are distributed proportionally to validators with respect to their capped voting power on the consumer and notwith respect to their voting power on the provider.  For example, assume that the provider chain has 4 validators, A, B, C, and D with voting powers 100, 1, 1, 1 respectively. So, validators A, B, C, and D have ~97%, ~1%, ~1%, and ~1% of the total voting power of the provider respectively. Now, assume that all those 4 validators opt in on a consumer chain that has set a validators-power cap set to 30%. As a result, validators A, B, C, and D have their powers modified (only) on the consumer chain to 30, 25, 24, and 24 and now have ~29%, ~25%, ~23%, and ~23% of the total voting power of the consumer. Roughly speaking, when rewards are sent from the consumer to the provider, validator A would get ~29% of the rewards because it has 29% of the total voting power on the consumer, regardless of A's 97% of the total power on the provider. Similarly, validator B would get 25% of the rewards, etc.  ","version":"Next","tagName":"h2"},{"title":"Whitelisting Reward Denoms​","type":1,"pageTitle":"Reward Distribution","url":"/interchain-security/features/reward-distribution#whitelisting-reward-denoms","content":" The ICS distribution system works by allowing consumer chains to send rewards to a module address on the provider called the ConsumerRewardsPool. Only whitelisted denoms from the ConsumerRewardsPool are then distributed to validators and their delegators.  The whitelisted denoms can be adjusted through governance by sending a MsgChangeRewardDenoms message.MsgChangeRewardDenoms is used to update the set of denoms accepted by the provider as rewards. Note that a MsgChangeRewardDenoms is only accepted on the provider chain if at least one of the denomsToAdd or denomsToRemove fields is populated with at least one denom. Also, a denom cannot be repeated in both sets.  An example of a MsgChangeRewardDenoms message:  { &quot;@type&quot;: &quot;/interchain_security.ccv.provider.v1.MsgChangeRewardDenoms&quot;, &quot;denoms_to_add&quot;: [ &quot;ibc/42C7464F6415DC7529A8C7581FE0991C7A090D60176BC90998B1DAF75B868635&quot; ], &quot;denoms_to_remove&quot;: [], &quot;authority&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot; }   Besides native provider denoms (e.g., uatom for the Cosmos Hub), please use the ibc/* denom trace format. For example, for untrn transferred over the path transfer/channel-569, the denom trace can be queried using the following command:  &gt; gaiad query ibc-transfer denom-hash transfer/channel-569/untrn hash: 0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5   Then use the resulting hash when adding or removing denoms. For example:   &quot;denoms_to_add&quot;: [ &quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot; ]   To query the list of whitelisted reward denoms on the Cosmos Hub, use the following command:  &gt; gaiad q provider registered-consumer-reward-denoms denoms: - ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 - ibc/6B8A3F5C2AD51CD6171FA41A7E8C35AD594AB69226438DB94450436EA57B3A89 - uatom   tip Use the following command to get a human readable denom from the ibc/* denom trace format: &gt; gaiad query ibc-transfer denom-trace ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5 denom_trace: base_denom: untrn path: transfer/channel-569  ","version":"Next","tagName":"h2"},{"title":"Inactive Validators Integration Guide","type":0,"sectionRef":"#","url":"/interchain-security/integrators/integrating_inactive_validators","content":"Inactive Validators Integration Guide With the inactive validators feature of Interchain Security, validators outside of the active set on the provider chain can validate on consumer chains that allow this. Technically, this is achieved by increasing the MaxValidators parameter in the staking module, to let additional validators be part of the set of bonded validators. However, to keep the set of validators participating in consensus on the Cosmos Hub the same, we introduce the MaxProviderConsensusValidators parameter in the provider module, which will restrict the number of validators that actively validate on the provider chain. To clarify the terminology: bonded validators are all validators that are bonded on the Cosmos Hub, and active validators are all validators that actively participate in consensus on the Cosmos Hub. Before the introduction of the feature, these two terms were equivalent: every bonded validator was active, and every active validator was bonded. After the introduction of this feature, it still holds that every active validator is bonded, but not every bonded validator is active. Importantly, only active validators receive inflation rewards from ATOM; only active validators may vote on behalf of their delegators in governance, and only active validators can get slashed for downtime (because only those validators participate in consensus and produce blocks). Apart from these differences, bonded but inactive validators are just like active validators - they can receive delegations, and they can validate on consumer chains (and receive rewards for this) just like active validators. The following queries will change after this upgrade: /cosmos/staking/v1beta1/pool / query staking pool The bonded_tokens will include the stake of all bonded validators. As the number of bonded validators will be increased as part of the upgrade, the number of bonded_tokens is expected to have a sudden increase after the upgrade is applied. All queries in the staking module that return a Validator All bonded validators will show with Status=Bonded. To identify active validators, query the validator set from Tendermint (https://docs.cometbft.com/v0.37/rpc/#/Info/validators or query comet-validator-set [height]), which will return the set of all active validators.","keywords":"","version":"Next"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/introduction/overview","content":"","keywords":"","version":"Next"},{"title":"Why Interchain Security?​","type":1,"pageTitle":"Overview","url":"/interchain-security/introduction/overview#why-interchain-security","content":" Tailored security.Consumer chains can choose the right level of security based on their needs: Chains can choose to inherit the whole validator set from the provider, or they can launch as an opt-in chain with a subset of the provider validators. Additionally, consumer chains have the power to shape the validator set to their specific requirements by setting allow &amp; deny lists, capping its size, etc. This allows for a wide range of security tradeoffs. For example, it enables emerging projects to deploy on consumer chains that don’t need high level of security.Permissionless deployment.Opt-in consumer chains -- consumers that do not compel any validator to participate -- can be launched permissionlessly. User can create and update opt-in consumer chains by submitting transactions to the provider chain. Provider validators that are eligible can opt in on any consumer they wish to validate.Separation of governance from block production.Consumer chains can separate their governance mechanism from block production. Block production is handled by provider validators, which means it is an extension of the proof-of-state (PoS) mechanism on the provider chain. Governance on the consumer chains can rely on the same PoS mechanism (using the same stake locked on the provider), but it doesn't have to. For example, consumer chains can have a governance system based on proof-of-authority (PoA) or on PoS using the consumer token (which would make the consumer token a governance token). This also allows the governance to be more decentralized without affecting consensus (i.e., increasing the number of validators usually leads to slower block production).Distribution of block rewards.Consumer chains can choose how to distribute the block rewards (i.e., inflation and fees), what percentage to send to the provider as payment for block production, and what percentage to keep on-chain. The rewards kept on-chain can then be distributed to the community DAO (the consumer's governance) or can be used in the protocol in other ways.No validator search.Consumer chains do not have their own validator sets, and so do not need to find validators one by one. Validators from the provider chain validate on the consumer chain with their stake on the provider chain, earning additional rewards. For the consumer chain, this comes with the benefit of exposing their chain to the wider audience of the provider chain.Instant sovereignty.Consumers can run arbitrary app logic similar to standalone chains. At any time in the future, a consumer chain can elect to become a completely standalone chain, with its own validator set.Block-space sharding.Consumer chains are Cosmos appchains, which means that transactions on these chains do not compete with any other applications. As a result, there will be no unexpected congestion, and performance will generally be much better than on a shared smart contract platform such as Ethereum.  ","version":"Next","tagName":"h2"},{"title":"Core protocol​","type":1,"pageTitle":"Overview","url":"/interchain-security/introduction/overview#core-protocol","content":" Validator updates. Once an IBC connection and channel are established between a provider and consumer chain, the provider will continually send validator set updates to the consumer over IBC. Note the provider only sends updates for opted in validators. The consumer uses these validator set updates to update its own validator set in the consensus engine (e.g., CometBFT).  Slashing and jailing.If the opted-in validators misbehave on the consumer chains, then they will be punished on the provider chain. ICS currently differentiates between two types of infractions -- double signing and downtime. Double signing on consumer chains results in the misbehaving validators having their provider stake slashed and being permanently jailed on the provider, while downtime on consumer chains results in the misbehaving validators being temporarily jailed. Note that jailing entails removing the validator from the provider active validator set and, consequently, from any of the consumer validator sets. This entails the validator will miss out on both staking and ICS rewards.  Tokenomics and rewards.Consumer chains are free to create their own native token which can be used for fees, and can be created on the consumer chain in the form of inflationary rewards. These rewards can be used to incentivize user behavior, for example, LPing or staking. A percentage of these fees and rewards will be sent to provider chain to be distributed among the opted in validators and their delegators. The percentage is completely customizable by the developers and subject to governance. ","version":"Next","tagName":"h2"},{"title":"Terminology","type":0,"sectionRef":"#","url":"/interchain-security/introduction/terminology","content":"","keywords":"","version":"Next"},{"title":"Shared Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/introduction/terminology#shared-security","content":" Shared Security is a family of technologies that include optimistic rollups, zk-rollups, sharding and Interchain Security. Basically, any protocol or technology that can allow one blockchain to lend/share its proof-of-stake security with another blockchain or off-chain process.  ","version":"Next","tagName":"h2"},{"title":"Interchain Security (ICS)​","type":1,"pageTitle":"Terminology","url":"/interchain-security/introduction/terminology#interchain-security-ics","content":" Interchain Security is the Cosmos-specific category of Shared Security that uses IBC (Inter-Blockchain Communication).  ","version":"Next","tagName":"h2"},{"title":"Consumer Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/introduction/terminology#consumer-chain","content":" Chain that is secured by the validator set of the provider, instead of its own. Interchain Security allows a subset of the provider chain's validator set to validate blocks on the consumer chain.  ","version":"Next","tagName":"h2"},{"title":"Replicated Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/introduction/terminology#replicated-security","content":" A particular protocol/implementation of Interchain Security that fully replicates the security and decentralization of a validator set across multiple blockchains. Replicated security has also been referred to as &quot;Interchain Security V1&quot;, a legacy term for the same protocol. That is, a &quot;provider chain&quot; such as the Cosmos Hub can share its exact validator set with multiple consumer chains by communicating changes in its validator set over IBC. Note that since the introduction of Partial Set Security, a TopN consumer chain with N 100% fully replicates the security and decentralization of the provider chain.  ","version":"Next","tagName":"h2"},{"title":"Partial Set Security (PSS)​","type":1,"pageTitle":"Terminology","url":"/interchain-security/introduction/terminology#partial-set-security-pss","content":" A major feature of Interchain Security (also referred to as &quot;Interchain Security V2&quot;) that allows a provider chain to share only a subset of its validator set with a consumer chain. This subset can be determined by the top N% validators by voting power, or by validators opting in to validate the consumer chain. PSS allows for more flexible security tradeoffs than Replicated Security.  ","version":"Next","tagName":"h2"},{"title":"Permissionless ICS​","type":1,"pageTitle":"Terminology","url":"/interchain-security/introduction/terminology#permissionless-ics","content":" Permissionless ICS is the latest version of ICS that allows to launch Opt In chains in a permissionless way (i.e., without requiring a governance proposal).  ","version":"Next","tagName":"h2"},{"title":"Standalone Chain​","type":1,"pageTitle":"Terminology","url":"/interchain-security/introduction/terminology#standalone-chain","content":" Chain that is secured by its own validator set. This chain does not participate in Interchain Security.  ","version":"Next","tagName":"h2"},{"title":"Changeover Procedure​","type":1,"pageTitle":"Terminology","url":"/interchain-security/introduction/terminology#changeover-procedure","content":" Chains that were not initially launched as consumers of Interchain Security can still participate in the protocol and leverage the economic security of the provider chain. The process where a standalone chain transitions to being a replicated consumer chain is called the changeover procedure and is part of the ICS protocol. After the changeover, the new consumer chain will retain all existing state, including the IBC clients, connections and channels already established by the chain.  ","version":"Next","tagName":"h2"},{"title":"Mesh Security​","type":1,"pageTitle":"Terminology","url":"/interchain-security/introduction/terminology#mesh-security","content":" A protocol built on IBC that allows delegators on a Cosmos chain to re-delegate their stake to validators in another chain's own validator set, using the original chain's token (which remains bonded on the original chain). For a deeper exploration of Mesh Security, see Replicated vs. Mesh Security on the Informal Blog. ","version":"Next","tagName":"h2"},{"title":"Validator Instructions for Changeover Procedure","type":0,"sectionRef":"#","url":"/interchain-security/validators/changeover-procedure","content":"","keywords":"","version":"Next"},{"title":"Timeline​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#timeline","content":" Upgrading standalone chains can be best visualised using a timeline, such as the one available Excalidraw graphic by Stride.  There is some flexibility with regards to how the changeover procedure is executed, so please make sure to follow the guides provided by the team doing the changeover.    ","version":"Next","tagName":"h2"},{"title":"Consumer Initiated Slashing","type":0,"sectionRef":"#","url":"/interchain-security/features/slashing","content":"","keywords":"","version":"Next"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/features/slashing#downtime-infractions","content":" Downtime infractions are reported by consumer chains and are acted upon on the provider as soon as they are received. The provider will jail and slash the offending validator. The jailing duration and slashing fraction are determined by the consumer's downtime infraction parameters on the provider chain. By default, validators are only jailed for downtime on consumer chains that they opted in to validate on, or in the case of Top N chains, where they are automatically opted in by being in the Top N% of the validator set on the provider.  For preventing malicious consumer chains from harming the provider, slash throttling (also known as jail throttling) ensures that only a fraction of the provider validator set can be jailed at any given time.  ","version":"Next","tagName":"h2"},{"title":"Equivocation Infractions​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/features/slashing#equivocation-infractions","content":" Equivocation infractions are reported by external agents (e.g., relayers) that can submit to the provider evidence of light client or double signing attacks observed on a consumer chain. The evidence is submitted by sending MsgSubmitConsumerMisbehaviour or MsgSubmitConsumerDoubleVoting messages to the provider. When valid evidence is received, the malicious validators are slashed, jailed, and tombstoned on the provider. The jailing duration and slashing fraction are determined by the consumer's double sign infraction parameters on the provider chain. This is enabled through the cryptographic verification of equivocation feature. For more details, see ADR-005 and ADR-013.  ","version":"Next","tagName":"h2"},{"title":"Report equivocation infractions through CLI​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/features/slashing#report-equivocation-infractions-through-cli","content":" The ICS provider module offers two commands for submitting evidence of misbehavior originating from a consumer chain. Below are two examples illustrating the process on Cosmos Hub.  Use the following command to submit evidence of double signing attacks:  gaiad tx provider submit-consumer-double-voting [consumer-id] [path/to/evidence.json] [path/to/infraction_header.json] --from node0 --home ../node0 --chain-id $CID   Example of evidence.json { &quot;vote_a&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;tBBWTqjECl31S/clZGoxLdDqs93kTvy3qhpPqET/laY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;ai2qCLgVZAFph4FJ4Cqw5QW1GZKR4zjOv0bI/Um5AIc=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.565207Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;signature&quot;: &quot;y9yILm9hmv45BZwAaaq9mS1FpH7QeAIJ5Jkcc3U2/k5uks9cuqr4NTIwaIrqMSMKwxVyqiR56xmCT59a6AngAA==&quot; }, &quot;vote_b&quot;: { &quot;type&quot;: 1, &quot;height&quot;: 25, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;3P06pszgPatuIdLTP5fDWiase4SYHIq9YXGSbRk9/50=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;S+SbOMxFRzfeNNpX9/jyFMz94VwBKk7Dpx6ZyvSYyNU=&quot; } }, &quot;timestamp&quot;: &quot;2023-11-20T12:57:54.599273Z&quot;, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;validator_index&quot;: 0, &quot;signature&quot;: &quot;DGFcn4Um1t2kXW60+JhMk5cj7ZFdE5goKVOGiZkLwnNv43+6aGmOWjoq0SHYVzM4MwSwOwbhgZNbkWX+EHGUBw==&quot; }, &quot;total_voting_power&quot;: 300, &quot;validator_power&quot;: 100, &quot;timestamp&quot;: &quot;2023-11-20T12:57:51.267308Z&quot; }   Example of infraction_header.json { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: 11, &quot;app&quot;: 2 }, &quot;chain_id&quot;: &quot;consumer&quot;, &quot;height&quot;: 22, &quot;time&quot;: &quot;2023-11-20T12:57:40.479686Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;L63hyLJ+y9+fpb7WYKdmmBhPHwbfEGQEuKmvGzyBPiY=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 18, &quot;hash&quot;: &quot;euzRQjN7MjGtM6skXM4B8wOgAldWGfZSJRA9JRlO42s=&quot; } }, &quot;last_commit_hash&quot;: &quot;qdDJwVziW3pPqmf8QDGZG+5HVd3OF7fCVh2Z8KQqNVU=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;next_validators_hash&quot;: &quot;pVc+gSYkGesaP3OkK4ig3DBi4o9/GCdXGtO/PQ6i/Ik=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;last_results_hash&quot;: &quot;Yu3HX62w7orbbY/pm2QEK7yIwR+AlNdjSSqiK1kmuJM=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: 22, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;PKrS32IEZoFY2q2S3iQ68HQL751ieBhf5Eu/Y5Z/QPg=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;8UuA7Oqw5AH/KOacpmHVSMOIDe4l2eC8VmdH2mzcpiM=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076538Z&quot;, &quot;signature&quot;: &quot;bSOH4+Vg2I37zeJphOguGOD0GK3JzM1ghSgJd0UlW/DHn1u9Hvv4EekHuCu6qwRLZcuS/ZxNlmr9qYNfxX3bDA==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:07:00Z&quot;, &quot;signature&quot;: &quot;7bXSDtlOwGK/gLEsFpTWOzm2TFoaARrWQUpbgWEwKtLlUs7iE06TOvJ3yPPfTfqqN/qYnvxxgjl0M0EhUWu5Bg==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.076519Z&quot;, &quot;signature&quot;: &quot;Pb6G4bCg4wafmV89WNnzXxbSCknZUHnSQfSCE5QMFxPtSUIN4A7SK5m7yltqMJF5zkyenlFiEI4J3OZ4KCjCAw==&quot; }, { &quot;block_id_flag&quot;: 2, &quot;validator_address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;timestamp&quot;: &quot;2023-11-20T12:57:44.057451Z&quot;, &quot;signature&quot;: &quot;j3EasIHNYA6MxW/PiWyruzHsjVsBV9t11W6Qx800WMm/+P+CkfR+UZAp7MPTvKZEZFuh3GUsBtyfb/vA+jJWCw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 }, { &quot;address&quot;: &quot;lrQDkJ2fk7UAgNzRZfcwMKSYa2E=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;UgN2JsjPy2WLh7dzJRBkUQtdgNoT4/uGj7kbIVqqHT8=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;+R94nXSeM1Z49e/CXpyHT3M+h3k=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;5svW8261x+cZosp2xIhqzgt2tyuawrSDyHlpbgS3BC4=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: 100 }, { &quot;address&quot;: &quot;aCG1hw85Zz7Ylgpsy263IJVJEMA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;dtn+SfD+4QLo0+t0hAoP6Q2sGjh0XEI3LWVG+doh3u0=&quot; }, &quot;voting_power&quot;: 100, &quot;proposer_priority&quot;: -200 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } }, &quot;trusted_height&quot;: { &quot;revision_height&quot;: 18 }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 }, { &quot;address&quot;: &quot;i/A830FM7cfmA8yTn9n3xBg5XpU=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;FCmIw7hSuiAoWk/2f4LuGQ+3zx5101xiqU8DoC5wGkg=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;2DrZF0roNnnvEy4NS2aY811ncKg=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;MI9c6sphsWlx0RAHCYOjMRXMFkTUaEYwOiOKG/0tsMs=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 }, { &quot;address&quot;: &quot;73aN0uOc5b/Zfq2Xcjl0kH2r+tw=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;gWNcDup4mdnsuqET4QeFRzVb+FnSP4Vz3iNMj5wvWXk=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: 1 } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;VUz+QceJ8Nu7GbJuVItwsfVjybA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;0s8KDTgEcwmOBrHWvV7mtBlItJ3upgM1FJsciwREdy4=&quot; }, &quot;voting_power&quot;: 1, &quot;proposer_priority&quot;: -3 } } }   Use the following command to submit evidence of light client attacks:  gaiad tx provider submit-consumer-misbehaviour [consumer-id] [path/to/misbehaviour.json] --from node0 --home ../node0 --chain-id $CID   Example of misbehaviour.json { &quot;client_id&quot;: &quot;07-tendermint-0&quot;, &quot;header_1&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;W2xVqzPw03ZQ1kAMpcpht9WohwMzsGnyKKNjPYKDF6U=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;PGTquCtnTNFFY5HfEFz9f9pA7PYqjtQfBwHq6cxF/Ux8OI6nVqyadD9a84Xm7fSm6mqdW+T6YVfqIKmIoRjJDQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;0e39yoBorwORAH/K9qJ7D1N1Yr7CutMiQJ+oiIK39eMhuoK3UWzQyMGRLzDOIDupf8yD99mvGVVAlNIODlV3Dg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;lhc2tkwydag9D1iLQhdDCE8GgrHP94M1LbHFYMoL9tExaEq6RiFW/k71TQH5x96XQ9XYOznMIHKC2BDh4GlnAQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:10Z&quot;, &quot;signature&quot;: &quot;8xeSBf0nSFs/X/rQ9CZLzwkJJhQBLA2jKdPGP3MlULxm992XxrOsIYq47u1daxvSsn6ql5OVYjzBNU0qbPpvCA==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } }, &quot;header_2&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;2&quot; }, &quot;chain_id&quot;: &quot;testchain2&quot;, &quot;height&quot;: &quot;19&quot;, &quot;time&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 10000, &quot;hash&quot;: &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; } }, &quot;last_commit_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;data_hash&quot;: &quot;bW4ouLmLUycELqUKV91G5syFHHLlKL3qpu/e7v5moLg=&quot;, &quot;validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;next_validators_hash&quot;: &quot;ImwBH++bKKkm2NDCwOxRn04P5GWWypgzeLVZWoc10+I=&quot;, &quot;consensus_hash&quot;: &quot;5eVmxB7Vfj/4zBDxhBeHiLj6pgKwfPH0JSF72BefHyQ=&quot;, &quot;app_hash&quot;: &quot;dPJh3vUG5ls8NeP/SBSEkIgTOzrkFOROqhKnuk2zRgc=&quot;, &quot;last_results_hash&quot;: &quot;CS4FhjAkftYAmGOhLu4RfSbNnQi1rcqrN/KrNdtHWjc=&quot;, &quot;evidence_hash&quot;: &quot;c4ZdsI9J1YQokF04mrTKS5bkWjIGx6adQ6Xcc3LmBxQ=&quot;, &quot;proposer_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;19&quot;, &quot;round&quot;: 1, &quot;block_id&quot;: { &quot;hash&quot;: &quot;IZM8NKS+8FHB7CBmgB8Nz7BRVVXiiyqMQDvHFUvgzxo=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 3, &quot;hash&quot;: &quot;hwgKOc/jNqZj6lwNm97vSTq9wYt8Pj4MjmYTVMGDFDI=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;pLIEZ4WSAtnMsgryujheHSq4+YG3RqTfMn2ZxgEymr0wyi+BNlQAKRtRfesm0vfYxvjzc/jhGqtUqHtSIaCwCQ==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;XG7iTe/spWyTUkT7XDzfLMpYqrdyqizE4/X4wl/W+1eaQp0WsCHYnvPU3x9NAnYfZzaKdonZiDWs7wacbZTcDg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;TqegK7ORuICSy++wVdPHt8fL2WfPlYsMPv1XW79wUdcjnQkezOM50OSqYaP4ua5frIZsn+sWteDrlqFTdkl3BA==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;timestamp&quot;: &quot;2020-01-02T00:08:20Z&quot;, &quot;signature&quot;: &quot;dhvp3XlIaCxx5MFDs0TCkAPHSm0PS2EtJzYAx2c/7MWdLwUJFZrAUTeimQE2c9i9ro91cjZn/vI0/oFRXab6Aw==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;18&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, { &quot;address&quot;: &quot;Ua+R3vfKH1LWhRg/k8PbA/uSLnc=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;H+7myYFFaCBTAxPiYaTX4IZIRtaUu+rcJVp+doLxd8c=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;Uns+2wsfv6IYTpOnYfAnPplVzTE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;QMHyl6i2OjmMEh73VXS5QBdsQ1vQ2mU3XzKGAhnKqmc=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; }, { &quot;address&quot;: &quot;sS7FyKFPDEG7StI+4o3+6fZy1pY=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;uSNKjObXRHsNslEdqdublnVDa4Vc2aoCpr0j+Fuvv5U=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;1&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;CbKqPquy50bcrY7JRdW7zXybSuA=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;sUkpD9xhOgWna0dv4bSwI7N7CkyH6q1bBDPYhjRolaY=&quot; }, &quot;voting_power&quot;: &quot;1&quot;, &quot;proposer_priority&quot;: &quot;-3&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } } }   ","version":"Next","tagName":"h3"},{"title":"Report equivocation infractions with Hermes​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/features/slashing#report-equivocation-infractions-with-hermes","content":" Ensure you have a well-configured Hermes v1.7.3+ relayer effectively relaying packets between a consumer chain and a provider chain. The following command demonstrates how to run a Hermes instance in evidence mode to detect misbehaviors on a consumer chain and automatically submit the evidence to the provider chain.  hermes evidence --chain &lt;CONSUMER-CHAIN-ID&gt;   Note that hermes evidence takes a --check-past-blocks option giving the possibility to look for older evidence (default is 100).  ","version":"Next","tagName":"h3"},{"title":"Infraction parameters​","type":1,"pageTitle":"Consumer Initiated Slashing","url":"/interchain-security/features/slashing#infraction-parameters","content":" Jailing and slashing for misbehavior on a consumer chain are governed by parameters defined on the provider chain for that specific consumer chain. To create or update these infraction parameters, use the MsgCreateConsumer or MsgUpdateConsumer messages. When creating a consumer chain, if custom infraction parameters are not specified, default values from the provider are applied. For updates, parameters can be modified immediately if the chain is in the pre-launch phase. If the chain has already launched, the update will be scheduled to take effect after the unbonding period expires. This ensures that changes are applied seamlessly based on the chain's lifecycle. ","version":"Next","tagName":"h3"},{"title":"Joining Neutron","type":0,"sectionRef":"#","url":"/interchain-security/validators/joining-neutron","content":"","keywords":"","version":"Next"},{"title":"Resources​","type":1,"pageTitle":"Joining Neutron","url":"/interchain-security/validators/joining-neutron#resources","content":" Neutron docs ","version":"Next","tagName":"h2"},{"title":"1. ConsumerAdditionProposal on provider chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#1-consumeradditionproposal-on-provider-chain","content":" This step will add the standalone chain to the list of consumer chains secured by the provider. This step dictates the spawn_time. After spawn_time the CCV state (initial validator set of the provider) will be available to the consumer.  To obtain it from the provider use:  gaiad q provider consumer-genesis stride-1 -o json &gt; ccv-state.json jq -s '.[0].app_state.ccvconsumer = .[1] | .[0]' genesis.json ccv-state.json &gt; ccv.json   Transformation of the exported consumer genesis state to the target version of the consumer might be needed in case the provider and consumer formats are incompatible. Refer to the compatibility notes here to check if data transformation is needed for your case. Instructions on how to transform the exported CCV genesis state (ccv-state.json in the example above) to the required target version can be found here  ","version":"Next","tagName":"h3"},{"title":"2. SoftwareUpgradeProposal on the standalone/consumer chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#2-softwareupgradeproposal-on-the-standaloneconsumer-chain","content":" This upgrade proposal will introduce ICS to the standalone chain, making it a consumer.  ","version":"Next","tagName":"h3"},{"title":"3. Assigning a consumer key​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#3-assigning-a-consumer-key","content":" After spawn_time, make sure to assign a consumer key if you intend to use one.  Instructions are available here  ","version":"Next","tagName":"h3"},{"title":"4. Perform the software upgrade on standalone chain​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#4-perform-the-software-upgrade-on-standalone-chain","content":" Please use instructions provided by the standalone chain team and make sure to reach out if you are facing issues. The upgrade preparation depends on your setup, so please make sure you prepare ahead of time.  danger The ccv.json from step 1. must be made available on the machine running the standalone/consumer chain at standalone chain upgrade_height. This file contains the initial validator set and parameters required for normal ICS operation. Usually, the file is placed in $NODE_HOME/config but this is not a strict requirement. The exact details are available in the upgrade code of the standalone/consumer chain.  Performing this upgrade will transition the standalone chain to be a consumer chain.  After 3 blocks, the standalone chain will stop using the &quot;old&quot; validator set and begin using the provider validator set.  ","version":"Next","tagName":"h3"},{"title":"FAQ​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#faq","content":" ","version":"Next","tagName":"h2"},{"title":"Can I reuse the same validator key for the consumer chain that I am already using on the standalone chain? Will I need to perform a AssignConsumerKey tx with this key before spawn time?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#can-i-reuse-the-same-validator-key-for-the-consumer-chain-that-i-am-already-using-on-the-standalone-chain-will-i-need-to-perform-a-assignconsumerkey-tx-with-this-key-before-spawn-time","content":" Validators must either assign a key or use the same key as on the provider.  If you are validating both the standalone and the provider, you can use your current standalone key with some caveats:  you must submit an AssignConsumerKey tx with your current standalone validator keyit is best to submit AssignConsumerKey tx before spawn_timeif you do not submit the Tx, it is assumed that you will be re-using your provider key to validate the standalone/consumer chain  ","version":"Next","tagName":"h3"},{"title":"Can I continue using the same node that was validating the standalone chain?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#can-i-continue-using-the-same-node-that-was-validating-the-standalone-chain","content":" Yes.  Please assign your consensus key as stated above.  ","version":"Next","tagName":"h3"},{"title":"Can I set up a new node to validate the standalone/consumer chain after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#can-i-set-up-a-new-node-to-validate-the-standaloneconsumer-chain-after-it-transitions-to-interchain-security","content":" Yes.  If you are planning to do this please make sure that the node is synced with standalone network and to submit AssignConsumerKey tx before spawn_time.  ","version":"Next","tagName":"h3"},{"title":"What happens to the standalone validator set after it transitions to Interchain Security?​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#what-happens-to-the-standalone-validator-set-after-it-transitions-to-interchain-security","content":" The standalone chain validators will stop being validators after the first 3 blocks are created while using Interchain Security. The standalone validators will become governors and still can receive delegations if the consumer chain is using the consumer-democracy module.  Governors DO NOT VALIDATE BLOCKS.  Instead, they can participate in the governance process and take on other chain-specific roles.  ","version":"Next","tagName":"h3"},{"title":"Credits​","type":1,"pageTitle":"Validator Instructions for Changeover Procedure","url":"/interchain-security/validators/changeover-procedure#credits","content":" Thank you Stride team for providing detailed instructions about the changeover procedure. ","version":"Next","tagName":"h2"},{"title":"Joining Stride","type":0,"sectionRef":"#","url":"/interchain-security/validators/joining-stride","content":"","keywords":"","version":"Next"},{"title":"Note​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/validators/joining-stride#note","content":" Stride re-uses an existing transfer channel to send consumer rewards to the provider chain, in order to preserve existing transfer IBC denom between stride-1 and cosmoshub-4.  ","version":"Next","tagName":"h2"},{"title":"Resources​","type":1,"pageTitle":"Joining Stride","url":"/interchain-security/validators/joining-stride#resources","content":" Stride docsChangeover procedure timelineChangeover upgrade docs ","version":"Next","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/interchain-security/validators/overview","content":"","keywords":"","version":"Next"},{"title":"Startup sequence overview​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#startup-sequence-overview","content":" An Opt In consumer chain cannot start and be secured by the validator set of the provider unless there is at least one validator opted in on the chain at spawn_time. A Top N consumer chain cannot start unless the governance proposal containing the MsgUpdateConsumer has passed.  Each chain defines a spawn_time - the timestamp when the consumer chain genesis is finalized and the consumer chain clients get initialized on the provider.  tip Validators are required to run consumer chain binaries only after spawn_time has passed.  Please note that any additional instructions pertaining to specific consumer chain launches will be available before spawn time. The chain start will be stewarded by the Cosmos Hub team and the teams developing their respective consumer chains.  The image below illustrates the startup sequence  ","version":"Next","tagName":"h2"},{"title":"1. Consumer Chain init + 2. Genesis generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#1-consumer-chain-init--2-genesis-generation","content":" Consumer chain team initializes the chain genesis.json and prepares binaries which will be listed in the initialization parameters of either MsgCreateConsumer or MsgUpdateConsumer.  ","version":"Next","tagName":"h3"},{"title":"3. Create the chain on the provider​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#3-create-the-chain-on-the-provider","content":" Consumer chain team (or their advocates) submits a MsgCreateConsumer message (and potentially later a governance proposal with a MsgUpdateConsumer message if it is a Top N chain). The most important parameters for validators are:  spawn_time - the time after which the consumer chain must be startedgenesis_hash - hash of the pre-ccv genesis.json; the file does not contain any validator info -&gt; the information is available only after the proposal is passed and spawn_time is reachedbinary_hash - hash of the consumer chain binary used to validate the software builds  ","version":"Next","tagName":"h3"},{"title":"4. CCV Genesis state generation​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#4-ccv-genesis-state-generation","content":" After reaching spawn_time the provider chain will automatically create the CCV validator states that will be used to populate the corresponding fields in the consumer chain genesis.json. The CCV validator set consists of the validator set on the provider at spawn_time.  The state can be queried on the provider chain (in this case the Cosmos Hub):   gaiad query provider consumer-genesis &lt;consumer-id&gt; -o json &gt; ccvconsumer_genesis.json   This is used by the launch coordinator to create the final genesis.json that will be distributed to validators in step 5.  ","version":"Next","tagName":"h3"},{"title":"5. Updating the genesis file​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#5-updating-the-genesis-file","content":" Upon reaching the spawn_time the initial validator set state will become available on the provider chain. The initial validator set is included in the final genesis.json of the consumer chain.  ","version":"Next","tagName":"h3"},{"title":"6. Chain start​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#6-chain-start","content":" info The consumer chain will start producing blocks as soon as 66.67% of the provider chain's voting power comes online (on the consumer chain). The relayer should be started after block production commences.  The new genesis.json containing the initial validator set will be distributed to validators by the consumer chain team (launch coordinator). Each validator should use the provided genesis.json to start their consumer chain node.  tip Please pay attention to any onboarding repositories provided by the consumer chain teams. Recommendations are available in Consumer Onboarding Checklist. Another comprehensive guide is available in the Interchain Security testnet repo.  ","version":"Next","tagName":"h3"},{"title":"7. Creating IBC connections​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#7-creating-ibc-connections","content":" Finally, to fully establish interchain security an IBC relayer is used to establish connections and create the required channels.  warning The relayer can establish the connection only after the consumer chain starts producing blocks.  hermes create connection --a-chain &lt;consumer chain ID&gt; --a-client 07-tendermint-0 --b-client &lt;client assigned by provider chain&gt; hermes create channel --a-chain &lt;consumer chain ID&gt; --a-port consumer --b-port provider --order ordered --a-connection connection-0 --channel-version 1 hermes start   ","version":"Next","tagName":"h3"},{"title":"Downtime Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#downtime-infractions","content":" At present, the consumer chain can report evidence about downtime infractions to the provider chain. The min_signed_per_window and signed_blocks_window can be different on each consumer chain and are subject to changes via consumer chain governance.  info Causing a downtime infraction on any consumer chain will not incur a slash penalty. Instead, the offending validator will be jailed on the provider chain and consequently on all consumer chains. To unjail, the validator must wait for the jailing period to elapse on the provider chain and submit an unjail transaction on the provider chain. After unjailing on the provider, the validator will be unjailed on all consumer chains. More information is available in Downtime Slashing documentation  ","version":"Next","tagName":"h2"},{"title":"Double-signing Infractions​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#double-signing-infractions","content":" To learn more about equivocation handling in interchain security check out the Slashing documentation section.  ","version":"Next","tagName":"h2"},{"title":"Key assignment​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#key-assignment","content":" Validators can use different consensus keys on the provider and each of the consumer chains. The consumer chain consensus key must be registered on the provider before use.  For more information check out the Key assignment overview and guide  ","version":"Next","tagName":"h2"},{"title":"References:​","type":1,"pageTitle":"Overview","url":"/interchain-security/validators/overview#references","content":" Cosmos Hub Validators FAQCosmos Hub Running a validatorStartup SequenceSubmit Unjailing Transaction ","version":"Next","tagName":"h2"},{"title":"Joining Interchain Security testnet","type":0,"sectionRef":"#","url":"/interchain-security/validators/joining-testnet","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/validators/joining-testnet#introduction","content":" This short guide will teach you how to join the Interchain Security testnet.  The experience gained in the testnet will prepare you for validating interchain secured chains.  tip Provider and consumer chain represent distinct networks and infrastructures operated by the same validator set. For general information about running cosmos-sdk based chains check out the validator basics and Running a Node section of Cosmos SDK docs  ","version":"Next","tagName":"h2"},{"title":"Joining the provider chain​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/validators/joining-testnet#joining-the-provider-chain","content":" A comprehensive guide is available here.  ","version":"Next","tagName":"h2"},{"title":"Initialization​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/validators/joining-testnet#initialization","content":" First, initialize your $NODE_HOME using the provider chain binary.  NODE_MONIKER=&lt;your_node&gt; CHAIN_ID=provider NODE_HOME=&lt;path_to_your_home&gt; gaiad init $NODE_MONIKER --chain-id $CHAIN_ID --home $NODE_HOME   Add your key to the keyring - more details available here.  In this example we will use the test keyring-backend. This option is not safe to use in production.  gaiad keys add &lt;key_moniker&gt; --keyring-backend test # save the address as variable for later use MY_VALIDATOR_ADDRESS=$(gaiad keys show my_validator -a --keyring-backend test)   Before issuing any transactions, use the provider testnet faucet to add funds to your address.  curl https://faucet.rs-testnet.polypore.xyz/request?address=$MY_VALIDATOR_ADDRESS&amp;chain=provider # example output: { &quot;address&quot;: &quot;cosmos17p3erf5gv2436fd4vyjwmudakts563a497syuz&quot;, &quot;amount&quot;: &quot;10000000uatom&quot;, &quot;chain&quot;: &quot;provider&quot;, &quot;hash&quot;: &quot;10BFEC53C80C9B649B66549FD88A0B6BCF09E8FCE468A73B4C4243422E724985&quot;, &quot;status&quot;: &quot;success&quot; }   Then, use the account associated with the keyring to issue a create-validator transaction which will register your validator on chain.  gaiad tx staking create-validator \\ --amount=1000000uatom \\ --pubkey=$(gaiad tendermint show-validator) \\ --moniker=&quot;choose a moniker&quot; \\ --chain-id=$CHAIN_ID&quot; \\ --commission-rate=&quot;0.10&quot; \\ --commission-max-rate=&quot;0.20&quot; \\ --commission-max-change-rate=&quot;0.01&quot; \\ --min-self-delegation=&quot;1000000&quot; \\ --gas=&quot;auto&quot; \\ --gas-prices=&quot;0.0025uatom&quot; \\ --from=&lt;key_moniker&gt;   tip Check this guide to edit your validator.  After this step, your validator is created and you can start your node and catch up to the rest of the network. It is recommended that you use statesync to catch up to the rest of the network.  You can use this script to modify your config.toml with the required statesync parameters.  # create the statesync script $: cd $NODE_HOME $: touch statesync.sh $ chmod 700 statesync.sh # make executable   Paste the following instructions into the statesync.sh:  #!/bin/bash SNAP_RPC=&quot;https://rpc.provider-state-sync-01.rs-testnet.polypore.xyz:443&quot; LATEST_HEIGHT=$(curl -s $SNAP_RPC/block | jq -r .result.block.header.height); \\ BLOCK_HEIGHT=$((LATEST_HEIGHT - 2000)); \\ TRUST_HASH=$(curl -s &quot;$SNAP_RPC/block?height=$BLOCK_HEIGHT&quot; | jq -r .result.block_id.hash) sed -i.bak -E &quot;s|^(enable[[:space:]]+=[[:space:]]+).*$|\\1true| ; \\ s|^(rpc_servers[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$SNAP_RPC,$SNAP_RPC\\&quot;| ; \\ s|^(trust_height[[:space:]]+=[[:space:]]+).*$|\\1$BLOCK_HEIGHT| ; \\ s|^(trust_hash[[:space:]]+=[[:space:]]+).*$|\\1\\&quot;$TRUST_HASH\\&quot;|&quot; $NODE_HOME/config/config.toml   Then, you can execute the script:  $: ./statesync.sh # setup config.toml for statesync   Finally, copy the provider genesis and start your node:  $: GENESIS_URL=https://github.com/cosmos/testnets/raw/master/interchain-security/provider/provider-genesis.json $: wget $GENESIS_URL -O genesis.json $: genesis.json $NODE_HOME/config/genesis.json # start the service $: gaiad start --x-crisis-skip-assert-invariants --home $NODE_HOME --p2p.seeds=&quot;08ec17e86dac67b9da70deb20177655495a55407@provider-seed-01.rs-testnet.polypore.xyz:26656,4ea6e56300a2f37b90e58de5ee27d1c9065cf871@provider-seed-02.rs-testnet.polypore.xyz:26656&quot;   Additional scripts to setup your nodes are available here and here. The scripts will configure your node and create the required services - the scripts only work in linux environments.  ","version":"Next","tagName":"h2"},{"title":"Joining consumer chains​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/validators/joining-testnet#joining-consumer-chains","content":" tip We strongly recommend that you assign a separate key for each consumer chain. Check out this guide to learn more about key assignment in interchain security.  To join consumer chains, simply replicate the steps above for each consumer using the correct consumer chain binaries.  info When running the provider chain and consumers on the same machine please update the PORT numbers for each of them and make sure they do not overlap (otherwise the binaries will not start). Important ports to re-configure: --rpc.laddr--p2p.laddr--api.address--grpc.address--grpc-web.address  ","version":"Next","tagName":"h2"},{"title":"Re-using consensus key​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/validators/joining-testnet#re-using-consensus-key","content":" To reuse the key on the provider and consumer chains, simply initialize your consumer chain and place the priv_validator_key.json into the home directory of your consumer chain (&lt;consumer_home&gt;/config/priv_validator_key.json).  When you start the chain, the consensus key will be the same on the provider and the consumer chain.  ","version":"Next","tagName":"h2"},{"title":"Assigning consensus keys​","type":1,"pageTitle":"Joining Interchain Security testnet","url":"/interchain-security/validators/joining-testnet#assigning-consensus-keys","content":" Whenever you initialize a new node, it will be configured with a consensus key you can use.  # machine running consumer chain consumerd init &lt;node_moniker&gt; --home &lt;home_path&gt; --chain-id consumer-1 # use the output of this command to get the consumer chain consensus key consumerd tendermint show-validator # output: {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}   Then, let the provider know which key you will be using for the consumer chain:  # machine running the provider chain gaiad tx provider assign-consensus-key consumer-id '&lt;consumer_pubkey&gt;' --from &lt;key_moniker&gt; --home $NODE_HOME --gas 900000 -b sync -y -o json   After this step, you are ready to copy the consumer genesis into your nodes's /config folder, start your consumer chain node and catch up to the network. ","version":"Next","tagName":"h2"},{"title":"Partial Set Security","type":0,"sectionRef":"#","url":"/interchain-security/validators/partial-set-security-for-validators","content":"","keywords":"","version":"Next"},{"title":"Messages​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#messages","content":" ","version":"Next","tagName":"h2"},{"title":"How to opt in to a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#how-to-opt-in-to-a-consumer-chain","content":" warning A validator is automatically opted in to a Top N chain if the validator belongs to the top N% of the validators on the provider chain.  In a Top N chain, a validator that does not belong to the top N% of the validators on the provider can still choose to opt in to a consumer chain. In other words, validators can opt in, in both Opt-In and Top N chains.  A validator can opt in to a consumer chain by issuing the following message:  interchain-security-pd tx provider opt-in &lt;consumer-id&gt; &lt;optional consumer-pub-key&gt;   where  consumer-id is the consumer id identifier of the consumer chain the validator wants to opt in to;consumer-pub-key corresponds to the public key the validator wants to use on the consumer chain, and it has the following format {&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;&lt;key&gt;&quot;}.  A validator can opt in to any active consumer chain, so a validator can opt in to a chain even before it launches. A validator can use the following command to retrieve the currently existing consumer chains:  interchain-security-pd query provider list-consumer-chains   By setting the consumer-pub-key, a validator can both opt in to a chain and assign a public key on a consumer chain. Note that a validator can always assigna new consumer key at a later stage. The key-assignment rulesstill apply when setting consumer-pub-key when opting in.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons.  Note that a validator is only eligible for consumer rewards from a consumer chain if the validator is opted into that chain.  ","version":"Next","tagName":"h3"},{"title":"How to opt out from a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#how-to-opt-out-from-a-consumer-chain","content":" A validator can opt out from a consumer by issuing the following message:  interchain-security-pd tx provider opt-out &lt;consumer-chain-id&gt;   where  consumer-id is the consumer identifier of the consumer chain.  The opting out mechanism has the following rules:  A validator cannot opt out from a Top N chain if it belongs to the top N% validators of the provider.If a validator moves from the Top N to outside of the top N% of the validators on the provider, it will notbe automatically opted-out. The validator has to manually opt out.A validator should stop its node on a consumer chain only after opting out and confirming through the has-to-validatequery (see below) that it does not have to validate the consumer chain any longer. Otherwise, the validator risks getting jailed for downtime.  warning If all validators opt out from an Opt-In chain, the chain will halt with a consensus failure upon receiving the VSCPacket with an empty validator set.  ","version":"Next","tagName":"h3"},{"title":"How to set specific per consumer chain commission rate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#how-to-set-specific-per-consumer-chain-commission-rate","content":" A validator can choose to set a different commission rate on each of the consumer chains. This can be done with the following command:  interchain-security-pd tx provider set-consumer-commission-rate &lt;consumer-id&gt; &lt;commission-rate&gt;   where  consumer-id is the consumer identifier of the consumer chain;comission-rate decimal in [minRate, 1] where minRate corresponds to the minimum commission rate set on the provider chain (see min_commission_rate in interchain-security-pd query staking params).  If a validator does not set a commission rate on a consumer chain, the commission rate defaults to their commission rate on the provider chain.  Validators can set their commission rate even for consumer chains that they are not currently opted in on, and the commission rate will be applied when they opt in. This is particularly useful for Top N chains, where validators might be opted in automatically, so validators can set the commission rate in advance.  If a validator opts out and then back in, this will not reset their commission rate back to the default. Instead, their set commission rate still applies.  ","version":"Next","tagName":"h3"},{"title":"Queries​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#queries","content":" PSS introduces a number of queries to assist validators in determining which consumer chains they have to validate, their commission rate per chain, etc.  ","version":"Next","tagName":"h2"},{"title":"Which chains does a validator have to validate?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#which-chains-does-a-validator-have-to-validate","content":" Naturally, a validator is aware of the Opt-In chains it has to validate because in order to validate an Opt-In chain, a validator has to manually opt in to the chain. This is not the case for Top N chains where a validator might be required to validate such a chain without explicitly opting in if it belongs to the top N% of the validators on the provider.  We introduce the following query:  interchain-security-pd query provider has-to-validate &lt;provider-validator-address&gt;   that can be used by validator with provider-validator-address address to retrieve the list of chains that it has to validate.  warning For a validator, the list of chains returned by has-to-validate is the list of chains the validator should be validating to avoid getting jailed for downtime.  ","version":"Next","tagName":"h3"},{"title":"How do you know how much voting power you need to have to be in the top N for a chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#how-do-you-know-how-much-voting-power-you-need-to-have-to-be-in-the-top-n-for-a-chain","content":" This can be seen as part of the list-consumer-chains query:  interchain-security-pd query provider list-consumer-chains   where the min_power_in_top_N field shows the minimum voting power required to be automatically opted in to the chain.  Note that list-consumer-chains shows the minimal voting power right now, but the automatic opt-in happens only when epochs end on the provider. In consequence, a validators power might be large enough to be automatically opted in during an epoch, but if their power is sufficiently decreased before the epoch ends, they will not be opted in automatically.  ","version":"Next","tagName":"h3"},{"title":"How to retrieve all the opted-in validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#how-to-retrieve-all-the-opted-in-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-opted-in-validators &lt;consumer-id&gt;   we can see all the opted-in validators on consumer-id that were manually or automatically opted in.  ","version":"Next","tagName":"h3"},{"title":"How to retrieve all the consumer validators on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#how-to-retrieve-all-the-consumer-validators-on-a-consumer-chain","content":" With the following query:  interchain-security-pd query provider consumer-validators &lt;consumer-id&gt;   we can see all the consumer validators (i.e., validator set) of consumer-id. The consumer validators are the ones that are currently (or in the future, see warning) validating the consumer chain. A consumer validator is an opted-in validator but not vice versa. For example, an opted-in validator V might not be a consumer validator because V is denylisted or because V is removed due to a validator-set cap.  Note that the returned consumer validators from this query do not necessarily correspond to the validator set that is validating the consumer chain at this exact moment. This is because the VSCPacket sent to a consumer chain might be delayed and hence this query might return the validator set that the consumer chain would have at some future point in time.  ","version":"Next","tagName":"h3"},{"title":"How can we see the commission rate a validator has set on a consumer chain?​","type":1,"pageTitle":"Partial Set Security","url":"/interchain-security/validators/partial-set-security-for-validators#how-can-we-see-the-commission-rate-a-validator-has-set-on-a-consumer-chain","content":" Using the following query:  interchain-security-pd query provider validator-consumer-commission-rate &lt;consumer-id&gt; &lt;provider-validator-address&gt;   we retrieve the commission rate set by validator with provider-validator-address address on consumer-id. ","version":"Next","tagName":"h3"},{"title":"Consumer chain validator rewards","type":0,"sectionRef":"#","url":"/interchain-security/validators/withdraw_rewards","content":"","keywords":"","version":"Next"},{"title":"Withdrawing rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/validators/withdraw_rewards#withdrawing-rewards","content":" Here are example steps for withdrawing rewards from consumer chains in the provider chain  info The examples used are from rs-testnet, the Interchain Security persistent testnet. Validator operator address: cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6Self-delegation address: cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf  Prior to withdrawing rewards, query balances for self-delegation address:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;1000000000000&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;   ","version":"Next","tagName":"h2"},{"title":"Querying validator rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/validators/withdraw_rewards#querying-validator-rewards","content":" Query rewards for the validator address:  gaiad q distribution rewards cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 rewards: - amount: &quot;158.069895000000000000&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;841842390516.072526500000000000&quot; denom: uatom   The ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD denom represents rewards from a consumer chain.  ","version":"Next","tagName":"h2"},{"title":"Withdrawing rewards and commission​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/validators/withdraw_rewards#withdrawing-rewards-and-commission","content":" ","version":"Next","tagName":"h2"},{"title":"1. Withdraw rewards​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/validators/withdraw_rewards#1-withdraw-rewards","content":" gaiad tx distribution withdraw-rewards cosmosvaloper1e5yfpc8l6g4808fclmlyd38tjgxuwshnmjkrq6 --from cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf --commission --chain-id provider --gas auto --fees 500uatom -b block -y txhash: A7E384FB1958211B43B7C06527FC7D4471FB6B491EE56FDEA9C5634D76FF1B9A   ","version":"Next","tagName":"h3"},{"title":"2. Confirm withdrawal​","type":1,"pageTitle":"Consumer chain validator rewards","url":"/interchain-security/validators/withdraw_rewards#2-confirm-withdrawal","content":" After withdrawing rewards self-delegation address balance to confirm rewards were withdrawn:  gaiad q bank balances cosmos1e5yfpc8l6g4808fclmlyd38tjgxuwshn7xzkvf balances: - amount: &quot;216&quot; denom: ibc/2CB0E87E2A742166FEC0A18D6FBF0F6AD4AA1ADE694792C1BD6F5E99088D67FD - amount: &quot;2233766225342&quot; denom: uatom pagination: next_key: null total: &quot;0&quot;  ","version":"Next","tagName":"h3"},{"title":"x/ccv/provider","type":0,"sectionRef":"#","url":"/interchain-security/build/modules/provider","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#overview","content":" The ICS provider module enables a proof-of-stake chain (known as the provider chain) to share (parts of) its security with other chains (known as consumer chains). This basically means that consumer chains can run as proof-of-stake chains using (parts of) the stake locked on the provider as collateral.  The provider module has the following functionalities:  The permissionless creation of consumer chains.The customization of the consumer chains validator sets.The option for validators to opt in to validate the consumer chains they want.The distribution of rewards from consumer chains to the opted in validators.The slashing and jailing of validators committing infractions on consumer chains based on cryptographic evidence.  ","version":"Next","tagName":"h2"},{"title":"State​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#state","content":" For clarity, the description of the provider module state is split into features. For a more accurate description, check out the x/ccv/provider/types/keys.go file, which contains the definitions of all the keys.  ","version":"Next","tagName":"h2"},{"title":"Consumer Lifecycle​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#consumer-lifecycle","content":" ConsumerId​  ConsumerId is the consumer ID of the next consumer chain to be created.  Format: byte(43) -&gt; uint64  ConsumerIdToChainId​  ConsumerIdToChainId is the chain ID of a given consumer chain.  Format: byte(44) | len(consumerId) | []byte(consumerId) -&gt; string  ConsumerIdToOwnerAddress​  ConsumerIdToOwnerAddress is the account address of the owner of a given consumer chain.  Format: byte(45) | len(consumerId) | []byte(consumerId) -&gt; string  ConsumerIdToMetadataKey​  ConsumerIdToMetadataKey is the metadata of a given consumer chain.  Format: byte(46) | len(consumerId) | []byte(consumerId) -&gt; ConsumerMetadata  ConsumerIdToPhase​  ConsumerIdToPhase is the phase of a given consumer chain.  Format: byte(49) | len(consumerId) | []byte(consumerId) -&gt; ConsumerPhase, where ConsumerPhase is defined as  enum ConsumerPhase { option (gogoproto.goproto_enum_prefix) = false; // UNSPECIFIED defines an empty phase. CONSUMER_PHASE_UNSPECIFIED = 0; // REGISTERED defines the phase in which a consumer chain has been assigned a unique consumer id. // A chain in this phase cannot yet launch. CONSUMER_PHASE_REGISTERED = 1; // INITIALIZED defines the phase in which a consumer chain has set all the needed parameters to launch but // has not yet launched (e.g., because the `spawnTime` of the consumer chain has not yet been reached). CONSUMER_PHASE_INITIALIZED = 2; // LAUNCHED defines the phase in which a consumer chain is running and consuming a subset of the validator // set of the provider. CONSUMER_PHASE_LAUNCHED = 3; // STOPPED defines the phase in which a previously-launched chain has stopped. CONSUMER_PHASE_STOPPED = 4; // DELETED defines the phase in which the state of a stopped chain has been deleted. CONSUMER_PHASE_DELETED = 5; }   ConsumerIdToRemovalTime​  ConsumerIdToRemovalTime is the removal time of a given consumer chain in the stopped phase.  Format: byte(50) | len(consumerId) | []byte(consumerId) -&gt; time.Time  SpawnTimeToConsumerIds​  SpawnTimeToConsumerIds are the IDs of initialized consumer chains ready to be launched at a timestamp ts.  Format: byte(51) | ts -&gt; ConsumerIds, where ConsumerIds is defined as  message ConsumerIds { repeated string ids = 1; }   RemovalTimeToConsumerIds​  RemovalTimeToConsumerIds are the IDs of stopped consumer chains ready to be removed at a timestamp ts.  Format: byte(52) | ts -&gt; ConsumerIds, where ConsumerIds is defined as  ","version":"Next","tagName":"h3"},{"title":"Consumer Launch​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#consumer-launch","content":" ConsumerIdToInitializationParameters​  ConsumerIdToInitializationParameters are the initialization parameters of a given consumer chain.  Format: byte(47) | len(consumerId) | []byte(consumerId) -&gt; ConsumerInitializationParameters  ConsumerIdToChannelId​  ConsumerIdToChannelId is the ID of the CCV channel associated with a consumer chain.  Format: byte(5) | []byte(consumerId) -&gt; string  ChannelIdToConsumerId​  ChannelIdToConsumerId is the consumer ID associated with a CCV channel.  Format: byte(6) | []byte(channelId) -&gt; string  ConsumerIdToClientId​  ConsumerIdToClientId is the ID of the client associated with a consumer chain. This is the underlying client of the corresponding CCV channel.  Format: byte(7) | []byte(consumerId) -&gt; string  ClientIdToConsumerId​  ClientIdToConsumerId is the consumer ID associated with an IBC client (i.e., the underlying client of the corresponding CCV channel).  Format: byte(53) | len(clientId) | []byte(clientId) -&gt; string  ConsumerGenesis​  ConsumerGenesis is the genesis state of the consumer module associated with a consumer chain.  Format: byte(14) | []byte(consumerId) -&gt; ConsumerGenesisState  ","version":"Next","tagName":"h3"},{"title":"Key Assignment​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#key-assignment","content":" ConsumerValidators​  TODO: ConsumerValidators and ConsumerValidator are too similar.  ConsumerValidators is the public key assigned by a given validator with addr as its provider consensus address (i.e., sdk.ConsAddress) on a given consumer chain.  Format: byte(22) | len(consumerId) | []byte(consumerId) | addr -&gt; crypto.PublicKey, where crypto is &quot;github.com/cometbft/cometbft/proto/tendermint/crypto&quot;.  ValidatorsByConsumerAddr​  ValidatorsByConsumerAddr is the consensus address on the provider chain of a validator with addr as its consensus address on a given consumer chain.  Format: byte(23) | len(consumerId) | []byte(consumerId) | addr -&gt; sdk.ConsAddress.  ConsumerAddrsToPruneV2​  ConsumerAddrsToPruneV2 stores the list of consumer consensus addresses that can be pruned at a timestamp ts as they are no longer needed.  Format: byte(40) | len(consumerId) | []byte(consumerId) | ts -&gt; AddressList, where AddressList is defined as  message AddressList { repeated bytes addresses = 1; }   ","version":"Next","tagName":"h3"},{"title":"Power Shaping​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#power-shaping","content":" ConsumerIdToPowerShapingParameters​  ConsumerIdToPowerShapingParameters are the power-shaping parameters of a given consumer chain.  Format: byte(48) | len(consumerId) | []byte(consumerId) -&gt; PowerShapingParameters  ConsumerValidator​  ConsumerValidator is the ConsensusValidator record of a provider validator on a given consumer chain, i.e.,  message ConsensusValidator { // validator's consensus address on the provider chain bytes provider_cons_addr = 1; // voting power the validator has during this epoch int64 power = 2; // public key the validator uses on the consumer chain during this epoch tendermint.crypto.PublicKey public_key = 3; // height the validator had when it FIRST became a consumer validator int64 join_height = 4; }   Format: byte(31) | len(consumerId) | []byte(consumerId) | addr -&gt; ConsensusValidator, with addr the validator's consensus address on the provider chain.  OptedIn​  OptedIn is the list of provider validators that opted in to validate on a given consumer chain. Note that opting in doesn't guarantee a spot in the consumer validator set.  Format: byte(32) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  Allowlist​  Allowlist is the list of provider validators that are eligible to validate a given consumer chain.  Format: byte(36) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  Denylist​  Denylist is the list of provider validators that are not eligible to validate a given consumer chain. Note that validators can opt in regardless of whether they are eligible or not.  Format: byte(37) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  MinimumPowerInTopN​  MinimumPowerInTopN is the minimum voting power a provider validator must have to be required to validate a given TopN consumer chain.  Format: byte(40) | len(consumerId) | []byte(consumerId) -&gt; uint64  Prioritylist​  Prioritylist is the list of provider validators that have priority to validate a given consumer chain.  Format: byte(56) | len(consumerId) | []byte(consumerId) | addr -&gt; []byte{}, with addr the validator's consensus address on the provider chain.  ","version":"Next","tagName":"h3"},{"title":"Validator Set Updates​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#validator-set-updates","content":" ValidatorSetUpdateId​  ValidatorSetUpdateId is an incrementing sequence number that is used as a unique identifier for validator set updates sent to the consumer chains. The validator set update ID is incremented every epoch.  Format: byte(2) -&gt; uint64  PendingVSCs​  PendingVSCs is the list of VSCPackets that are queued to be sent to a given consumer chain.  Format: byte(17) | []byte(consumerId) -&gt; ValidatorSetChangePackets, where ValidatorSetChangePackets is defined as  message ValidatorSetChangePackets { repeated ValidatorSetChangePacketData list = 1 [ (gogoproto.nullable) = false ]; }   LastProviderConsensusVals​  LastProviderConsensusVals is the last validator set sent to the consensus engine of the provider chain.  Format: byte(42) | addr -&gt; ConsensusValidator, with addr the validator's consensus address on the provider chain and ConsensusValidator defined as  message ConsensusValidator { // validator's consensus address on the provider chain bytes provider_cons_addr = 1; // voting power the validator has during this epoch int64 power = 2; // public key the validator uses on the consumer chain during this epoch tendermint.crypto.PublicKey public_key = 3; // height the validator had when it FIRST became a consumer validator int64 join_height = 4; }   ","version":"Next","tagName":"h3"},{"title":"Reward Distribution​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#reward-distribution","content":" ConsumerRewardDenoms​  ConsumerRewardDenoms is storing the list of whitelisted denoms that are accepted as ICS rewards. Note that denoms that are not whitelisted can still be transferred to the consumer_rewards_pool account on the provider module, but they will not be distributed to validators and their delegators.  Format: byte(27) | []byte(denom) -&gt; []byte{}  ConsumerRewardsAllocation​  ConsumerRewardsAllocation is the allocation of ICS rewards for a given consumer chain. This is used to distribute ICS rewards only to the validators that are part of the consumer chain validator set.  Format: byte(38) | []byte(consumerId) -&gt; ConsumerRewardsAllocation, where ConsumerRewardsAllocation is defined as  message ConsumerRewardsAllocation { repeated cosmos.base.v1beta1.DecCoin rewards = 1 [ (gogoproto.nullable) = false, (amino.dont_omitempty) = true, (gogoproto.castrepeated) = &quot;github.com/cosmos/cosmos-sdk/types.DecCoins&quot; ]; }   ConsumerCommissionRate​  ConsumerCommissionRate is the commission rate set by a provider validator for a given consumer chain.  Format: byte(39) | len(consumerId) | []byte(consumerId) | addr -&gt; math.LegacyDec, with addr the validator's consensus address on the provider chain and math is &quot;cosmossdk.io/math&quot;.  ","version":"Next","tagName":"h3"},{"title":"Consumer Infractions​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#consumer-infractions","content":" SlashMeter​  SlashMeter is the meter used for the throttling mechanism as the allowance of voting power that can be jailed over time. It is decremented by the amount of voting power jailed whenever a validator is jailed for downtime, and periodically replenished as decided by on-chain params. See ADR 002 for more details.  Format: byte(3) -&gt; math.Int  SlashMeterReplenishTimeCandidate​  SlashMeterReplenishTimeCandidate is the next UTC time the SlashMeter could potentially be replenished. Note that this value is the next time the SlashMeter will be replenished if and only if the SlashMeter is not full. Otherwise this value will be updated in every future block until the slash meter becomes not full.  Format: byte(4) -&gt; time.Time  ValsetUpdateBlockHeight​  ValsetUpdateBlockHeight is the block height associated with a validator set update ID vscId. This is used for mapping infraction heights on consumer chains to heights on the provider chain via the validator set update IDs (together with InitChainHeight).  Format: byte(13) | vscId -&gt; uint64  InitChainHeight​  InitChainHeight is the block height on the provider when the CCV channel of a given consumer chain was established (i.e., the channel opening handshake was completed). This is used for mapping infraction heights on consumer chains to heights on the provider chain (together with ValsetUpdateBlockHeight).  Format: byte(16) | []byte(consumerId) -&gt; uint64  SlashAcks​  SlashAcks are addresses of validators for which SlashPackets for downtime infractions received from a given consumer chain were handled. These addresses are sent together with the validator updates to the consumer chain as confirmation that the downtime infractions were dealt with.  Format: byte(15) | []byte(consumerId) -&gt; SlashAcks, where SlashAcks is defined as  message SlashAcks { repeated string addresses = 1; }   EquivocationEvidenceMinHeight​  EquivocationEvidenceMinHeight is the minimum height of a valid evidence of equivocation on a given consumer chain.  Format: byte(29) | []byte(consumerId) -&gt; uint64  ","version":"Next","tagName":"h3"},{"title":"State Transitions​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#state-transitions","content":" ","version":"Next","tagName":"h2"},{"title":"Consumer chain phases​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#consumer-chain-phases","content":" The following diagram describes the phases of a consumer chain from the perspective of the provider module:    ","version":"Next","tagName":"h3"},{"title":"IBC Callbacks​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#ibc-callbacks","content":" The consumer module is an IBC application that implements the IBC module callback.  ","version":"Next","tagName":"h2"},{"title":"OnChanOpenInit​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#onchanopeninit","content":" OnChanOpenInit returns an error. MsgChannelOpenInit should be sent to the consumer.  ","version":"Next","tagName":"h3"},{"title":"OnChanOpenTry​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#onchanopentry","content":" OnChanOpenTry validates the parameters of the CCV channel -- an ordered IBC channel connected on the provider port and with the counterparty port set to consumer -- and asserts that the counterparty version matches the expected version (only version 1 is supported).  If the validation passes, the provider module verifies that the underlying client is the expected client of the consumer chain (i.e., the client created during the consumer chain launch) and that no other CCV channel exists for this consumer chain.  Finally, it sets the ProviderFeePoolAddr as part of the metadata.  ","version":"Next","tagName":"h3"},{"title":"OnChanOpenAck​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#onchanopenack","content":" OnChanOpenAck returns an error. MsgChannelOpenAck should be sent to the consumer.  ","version":"Next","tagName":"h3"},{"title":"OnChanOpenConfirm​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#onchanopenconfirm","content":" OnChanOpenConfirm first verifies that no other CCV channel exists for this consumer chain. Note that this is a sanity check. Then, it sets the channel mapping in the state.  ","version":"Next","tagName":"h3"},{"title":"OnChanCloseInit​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#onchancloseinit","content":" OnChanCloseInit returns an error. MsgChannelCloseInit should be sent to the consumer.  ","version":"Next","tagName":"h3"},{"title":"OnChanCloseConfirm​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#onchancloseconfirm","content":" OnChanCloseConfirm is a no-op.  ","version":"Next","tagName":"h3"},{"title":"OnRecvPacket​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#onrecvpacket","content":" OnRecvPacket unmarshals the IBC packet data into a SlashPacketData struct (see below) and executes the handling logic.  Validate the fields in SlashPacketData: validator has a valid address and a non-zero power;infraction is either downtime or double-singing;the provider has in state a mapping from valset_update_id to a block height. If it is a double-signing infraction, then just log it and return.Verify that the consumer chain is launched and the validator is opted in.Update the meter used for jail throttling.Jail the validator on the provider chain.Store in state the ACK that the downtime infraction was handled. This will be sent to the consumer with the next validator updates to enable it to send other downtime infractions for this validator.  message SlashPacketData { tendermint.abci.Validator validator = 1 [ (gogoproto.nullable) = false, (gogoproto.moretags) = &quot;yaml:\\&quot;validator\\&quot;&quot; ]; // map to the infraction block height on the provider uint64 valset_update_id = 2; // tell if the slashing is for a downtime or a double-signing infraction cosmos.staking.v1beta1.Infraction infraction = 3; }   Note that IBC packets with VSCMaturedPacketData data are dropped. For more details, check out ADR 018.  ","version":"Next","tagName":"h3"},{"title":"OnAcknowledgementPacket​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#onacknowledgementpacket","content":" OnAcknowledgementPacket stops and eventually removes the consumer chain associated with the channel on which the MsgAcknowledgement message was received.  ","version":"Next","tagName":"h3"},{"title":"OnTimeoutPacket​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#ontimeoutpacket","content":" OnTimeoutPacket stops and eventually removes the consumer chain associated with the channel on which the MsgTimeout message was received.  ","version":"Next","tagName":"h3"},{"title":"Messages​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#messages","content":" ","version":"Next","tagName":"h2"},{"title":"MsgUpdateParams​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgupdateparams","content":" MsgUpdateParams updates the provider module parameters. The params are updated through a governance proposal where the signer is the gov module account address.  message MsgUpdateParams { option (cosmos.msg.v1.signer) = &quot;authority&quot;; // authority is the address of the governance account. string authority = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // params defines the x/provider parameters to update. Params params = 2 [(gogoproto.nullable) = false]; }   ","version":"Next","tagName":"h3"},{"title":"MsgChangeRewardDenoms​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgchangerewarddenoms","content":" MsgChangeRewardDenoms updates the list of whitelisted denoms accepted by the provider as ICS rewards. The list of accepted denoms is updated through a governance proposal where the signer is the gov module account address.  Note that this message replaces ChangeRewardDenomsProposal, which is deprecated.  message MsgChangeRewardDenoms { option (cosmos.msg.v1.signer) = &quot;authority&quot;; // the list of consumer reward denoms to add repeated string denoms_to_add = 1; // the list of consumer reward denoms to remove repeated string denoms_to_remove = 2; // signer address string authority = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   ","version":"Next","tagName":"h3"},{"title":"MsgCreateConsumer​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgcreateconsumer","content":" MsgCreateConsumer enables a user to create a consumer chain.  Both the chain_id and metadata fields are mandatory. The initialization_parameters, power_shaping_parameters, infraction_parameters and allowlisted_reward_denoms fields are optional. The parameters not provided are set to their zero value. If infraction_parameters are not set, the default values currently configured on the provider are used.  The owner of the created consumer chain is the submitter of the message. This message cannot be submitted as part of a governance proposal, i.e., the submitter cannot be the gov module account address. As a result, if the power_shaping_parameters are provided, then power_shaping_parameters.top_N must be set to zero (i.e., opt-in consumer chain).  To create a top-n consumer chain, the following steps are required:  Create an opt-in consumer chain (via MsgCreateConsumer).Change the ownership of the consumer chain to the gov module account address (via MsgUpdateConsumer).Change power_shaping_parameters.top_N to a value in [50, 100] through a governance proposal with a MsgUpdateConsumer message.  If the initialization_parameters field is set and initialization_parameters.spawn_time &gt; 0, then the consumer chain will be scheduled to launch at spawn_time.  message MsgCreateConsumer { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; // Submitter address. If the message is successfully handled, the ownership of // the consumer chain will given to this address. string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the chain id of the new consumer chain string chain_id = 2; ConsumerMetadata metadata = 3 [ (gogoproto.nullable) = false ]; ConsumerInitializationParameters initialization_parameters = 4; PowerShapingParameters power_shaping_parameters = 5; // allowlisted reward denoms by the consumer chain AllowlistedRewardDenoms allowlisted_reward_denoms = 6; // infraction parameters for slashing and jailing InfractionParameters infraction_parameters = 7; }   ","version":"Next","tagName":"h3"},{"title":"MsgUpdateConsumer​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgupdateconsumer","content":" MsgUpdateConsumer enables the owner of a consumer chain to update its parameters (e.g., set a new owner).  Note that only the owner (i.e., signer) and consumer_id fields are mandatory. The others fields are optional. Not providing one of them will leave the existing values unchanged. Providing one of metadata, initialization_parameters, power_shaping_parameters, or allowlisted_reward_denomswill update all the containing fields. If one of the containing fields is missing, it will be set to its zero value. For example, updating the initialization_parameters without specifying the spawn_time, will set the spawn_time to zero.  If the initialization_parameters field is set and initialization_parameters.spawn_time &gt; 0, then the consumer chain will be scheduled to launch at spawn_time. Updating the spawn_time from a positive value to zero will remove the consumer chain from the list of scheduled to launch chains. If the consumer chain is already launched, updating the initialization_parameters is no longer possible.  If the power_shaping_parameters field is set and power_shaping_parameters.top_N is positive, then the owner needs to be the gov module account address.  If the new_owner_address field is set to a value different than the gov module account address, then top_N needs to be zero.  We can also update the chain_id of a consumer chain by using the optional new_chain_id field. Note that the chain id of a consumer chain can only be updated if the chain has not yet launched. After launch, the chain id of a consumer chain cannot be updated anymore.  message MsgUpdateConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the address of the owner of the consumer chain to be updated string owner = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to be updated string consumer_id = 2; // the new owner of the consumer when updated string new_owner_address = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the metadata of the consumer when updated ConsumerMetadata metadata = 4; // initialization parameters can only be updated before a chain has launched ConsumerInitializationParameters initialization_parameters = 5; // the power-shaping parameters of the consumer when updated PowerShapingParameters power_shaping_parameters = 6; // allowlisted reward denoms by the consumer chain AllowlistedRewardDenoms allowlisted_reward_denoms = 7; // to update the chain id of the chain (can only be updated if the chain has not yet launched) string new_chain_id = 8; // infraction parameters for slashing and jailing InfractionParameters infraction_parameters = 9; }   ","version":"Next","tagName":"h3"},{"title":"MsgRemoveConsumer​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgremoveconsumer","content":" MsgRemoveConsumer enables the owner of a launched consumer chain to remove it from the provider chain. The message will first stop the consumer chain, which means the provider will stop sending it validator updates over IBC. Then, once the unbonding period elapses, the consumer chain is removed from the provider state.  message MsgRemoveConsumer { option (cosmos.msg.v1.signer) = &quot;owner&quot;; // the consumer id of the consumer chain to be stopped string consumer_id = 1; // the address of the owner of the consumer chain to be stopped string owner = 2 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; }   ","version":"Next","tagName":"h3"},{"title":"MsgOptIn​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgoptin","content":" MsgOptIn enables a validator to opt in to validate a consumer chain. Note that validators can opt in to validate consumer chains that are not launched yet. The signer of the message needs to match the validator address on the provider.  Note that opting in doesn't guarantee a spot in the consumer chain's validator set. Use the has-to-validate query to check if the validator is part of the consumer chain's validator set. For more details, check out the validator guide to Partial Set Security.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  The consumer_key field is optional. It enables the validator to set the consensus public key to use on the consumer chain. The validator can assign (or re-assign) this key also later via MsgAssignConsumerKey.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons. This is especially important since the introduction of thePermissionless ICS featurethat allows multiple consumer chains to have the same chain ID. A validator using the same consensus key to validate on two chains with the same chain ID might get slashed for double signing.  message MsgOptIn { option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; option (cosmos.msg.v1.signer) = &quot;signer&quot;; // [DEPRECATED] use `consumer_id` instead string chain_id = 1 [deprecated = true]; // the validator address on the provider string provider_addr = 2 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // (optional) The consensus public key to use on the consumer in json string format corresponding to proto-any, // for example `{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}`. // This field is optional and can remain empty (i.e., `consumer_key = &quot;&quot;`). A validator can always change the // consumer public key at a later stage by issuing a `MsgAssignConsumerKey` message. string consumer_key = 3; // submitter address string signer = 4 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to opt in to string consumer_id = 5; }   ","version":"Next","tagName":"h3"},{"title":"MsgAssignConsumerKey​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgassignconsumerkey","content":" MsgAssignConsumerKey enables a validator to assign the consensus public key to use on a consumer chain. Without assigning a specific key, the validator will need to use the same key as on the provider chain.  warning Validators are strongly recommended to assign a separate key for each consumer chain and not reuse the provider key across consumer chains for security reasons. This is especially important since the introduction of thePermissionless ICS featurethat allows multiple consumer chains to have the same chain ID. A validator using the same consensus key to validate on two chains with the same chain ID might get slashed for double signing.  The signer of the message needs to match the validator address on the provider.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details, check out the description of the Key Assignment feature.  message MsgAssignConsumerKey { option (cosmos.msg.v1.signer) = &quot;signer&quot;; option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; // [DEPRECATED] use `consumer_id` instead string chain_id = 1 [deprecated = true]; // The validator address on the provider string provider_addr = 2 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // The consensus public key to use on the consumer. // in json string format corresponding to proto-any, ex: // `{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}` string consumer_key = 3; string signer = 4 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to assign a consensus public key to string consumer_id = 5; }   ","version":"Next","tagName":"h3"},{"title":"MsgOptOut​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgoptout","content":" MsgOptOut enables a validator to opt out from validating a launched consumer chain. The signer of the message needs to match the validator address on the provider.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on optin out, check out the validator guide to Partial Set Security.  message MsgOptOut { option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; option (cosmos.msg.v1.signer) = &quot;signer&quot;; // [DEPRECATED] use `consumer_id` instead string chain_id = 1 [deprecated = true]; // the validator address on the provider string provider_addr = 2 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // submitter address string signer = 3 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to opt out from string consumer_id = 4; }   ","version":"Next","tagName":"h3"},{"title":"MsgSetConsumerCommissionRate​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgsetconsumercommissionrate","content":" MsgSetConsumerCommissionRate enables validators to set a per-consumer chain commission rate. The rate is a decimal in [minRate, 1], with minRate corresponding to the minimum commission rate set on the provider chain (see min_commission_rate in interchain-security-pd query staking params).  The signer of the message needs to match the validator address on the provider.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on setting per-consumer chain commission rates, check out the validator guide to Partial Set Security.  message MsgSetConsumerCommissionRate { option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; option (cosmos.msg.v1.signer) = &quot;signer&quot;; // The validator address on the provider string provider_addr = 1 [ (gogoproto.moretags) = &quot;yaml:\\&quot;address\\&quot;&quot; ]; // [DEPRECATED] use `consumer_id` instead string chain_id = 2 [deprecated = true]; // The rate to charge delegators on the consumer chain, as a fraction string rate = 3 [ (cosmos_proto.scalar) = &quot;cosmos.Dec&quot;, (gogoproto.customtype) = &quot;cosmossdk.io/math.LegacyDec&quot;, (gogoproto.nullable) = false ]; // submitter address string signer = 4 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // the consumer id of the consumer chain to set the commission rate string consumer_id = 5; }   ","version":"Next","tagName":"h3"},{"title":"MsgSubmitConsumerMisbehaviour​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgsubmitconsumermisbehaviour","content":" MsgSubmitConsumerMisbehaviour enables users to submit to the provider evidence of a light client attack that occurred on a consumer chain. This message can be submitted directly by users, e.g., via the CLI command tx provider submit-consumer-misbehaviour, or by a relayer that can be set to automatically detect consumer chain misbehaviors, e.g., Hermes.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on reporting light client attacks that occurred on consumer chains, check out the guide on equivocation infractions.  message MsgSubmitConsumerMisbehaviour { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // The Misbehaviour of the consumer chain wrapping // two conflicting IBC headers ibc.lightclients.tendermint.v1.Misbehaviour misbehaviour = 2; // the consumer id of the consumer chain where the misbehaviour occurred string consumer_id = 3; }   ","version":"Next","tagName":"h3"},{"title":"MsgSubmitConsumerDoubleVoting​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#msgsubmitconsumerdoublevoting","content":" MsgSubmitConsumerDoubleVoting enables users to submit to the provider evidence of a double signing infraction that occurred on a consumer chain. This message can be submitted directly by users, e.g., via the CLI command tx provider submit-consumer-double-voting, or by a relayer that can be set to automatically detect consumer chain misbehaviors, e.g., Hermes.  Note that since the introduction of thePermissionless ICS featurethe chain_id field is deprecated. Users should use consumer_id instead. You can use the list-consumer-chains query to get the list of all consumer chains and their consumer IDs.  For more details on reporting double signing infractions that occurred on consumer chains, check out the guide on equivocation infractions.  message MsgSubmitConsumerDoubleVoting { option (cosmos.msg.v1.signer) = &quot;submitter&quot;; option (gogoproto.equal) = false; option (gogoproto.goproto_getters) = false; string submitter = 1 [(cosmos_proto.scalar) = &quot;cosmos.AddressString&quot;]; // The equivocation of the consumer chain wrapping // an evidence of a validator that signed two conflicting votes tendermint.types.DuplicateVoteEvidence duplicate_vote_evidence = 2; // The light client header of the infraction block ibc.lightclients.tendermint.v1.Header infraction_block_header = 3; // the consumer id of the consumer chain where the double-voting took place string consumer_id = 4; }   ","version":"Next","tagName":"h3"},{"title":"BeginBlock​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#beginblock","content":" In the BeginBlock of the provider module the following actions are performed:  Launch every consumer chain that has a spawn time that already passed. Compute the initial validator set.Create the genesis state for the consumer module. Note that the genesis state contains the consumer module parameters and both the client state and consensus state needed for creating a provider client on the consumer chain.Create a consumer client. Remove every stopped consumer chain for which the removal time has passed.Replenish the throttling meter if necessary.Distribute ICS rewards to the opted in validators.Update consumer infraction parameters with the queued infraction parameters that were added to the queue before a time period greater than the unbonding time.  Note that for every consumer chain, the computation of its initial validator set is based on the consumer's power shaping parametersand the validators that opted in on that consumer.  ","version":"Next","tagName":"h2"},{"title":"EndBlock​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#endblock","content":" In the EndBlock of the provider module the following actions are performed:  Store in state the VSC id to block height mapping needed for determining the height of infractions on consumer chains.Prune the no-longer needed public keys assigned by validators to use when validating on consumer chains.Send validator updates to the consensus engine. The maximum number of validators is set through the MaxProviderConsensusValidators param.At the beginning of every epoch, for every launched consumer chain, compute the next consumer validator set and send it to the consumer chain via an IBC packet;increment the VSC id.  Note that for every consumer chain, the computation of its validator set is based on the consumer's power shaping parametersand the validators that opted in on that consumer.  ","version":"Next","tagName":"h2"},{"title":"Hooks​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#hooks","content":" TBA  ","version":"Next","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#events","content":" TBA  ","version":"Next","tagName":"h2"},{"title":"Parameters​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#parameters","content":" The provider module contains the following parameters.  ","version":"Next","tagName":"h2"},{"title":"TemplateClient​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#templateclient","content":" TemplateClient is a template of an IBC ClientState used for launching consumer chains.  ","version":"Next","tagName":"h3"},{"title":"TrustingPeriodFraction​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#trustingperiodfraction","content":" Type\tDefault valuestring\t&quot;0.66&quot;  TrustingPeriodFraction is used to used to compute the trusting period of IBC clients (for both provider and consumer chains) as UnbondingPeriod / TrustingPeriodFraction. Note that a light client must be updated within the trusting period in order to avoid being frozen.  The param is set as a string, and converted to a sdk.Dec when used.  ","version":"Next","tagName":"h3"},{"title":"CcvTimeoutPeriod​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#ccvtimeoutperiod","content":" Type\tDefault valuetime.Duration\t2419200s (4 weeks)  CcvTimeoutPeriod is the period used to compute the timeout timestamp when sending IBC packets. For more details, see the IBC specification of Channel &amp; Packet Semantics.  warning If a sent packet is not relayed within this period, then the packet times out. The CCV channel used by the interchain security protocol is closed, and the corresponding consumer is removed.  CcvTimeoutPeriod may have different values on the provider and consumer chains.CcvTimeoutPeriod on the provider must be larger than consumer unbonding period.  ","version":"Next","tagName":"h3"},{"title":"SlashMeterReplenishPeriod​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#slashmeterreplenishperiod","content":" Type\tDefault valuetime.Duration\t3600s (1 hour)  SlashMeterReplenishPeriod is the time interval at which the meter for jail throttling is replenished. The meter is replenished to an amount equal to the allowance for that block, or SlashMeterReplenishFraction * CurrentTotalVotingPower.  ","version":"Next","tagName":"h3"},{"title":"SlashMeterReplenishFraction​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#slashmeterreplenishfraction","content":" Type\tDefault valuestring\t&quot;0.05&quot;  SlashMeterReplenishFraction is the fraction (in range [0, 1]) of total voting power that is replenished to the slash meter when a replenishment occurs. This param also serves as a maximum fraction of total voting power that the slash meter can hold.  The param is set as a string, and converted to a sdk.Dec when used.  ","version":"Next","tagName":"h3"},{"title":"ConsumerRewardDenomRegistrationFee​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#consumerrewarddenomregistrationfee","content":" ConsumerRewardDenomRegistrationFee is deprecated.  ","version":"Next","tagName":"h3"},{"title":"BlocksPerEpoch​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#blocksperepoch","content":" Type\tDefault valueint64\t600  BlocksPerEpoch is the number of blocks in an ICS epoch. The provider sends validator updates to the consumer chains only once per epoch.  warning It is recommended for the length of an ICS epoch to not exceed a day. Large epochs would lead to delays in validator updates sent to the consumer chains, which might impact the security of the consumer chains.  ","version":"Next","tagName":"h3"},{"title":"NumberOfEpochsToStartReceivingRewards​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#numberofepochstostartreceivingrewards","content":" Type\tDefault valueint64\t24  NumberOfEpochsToStartReceivingRewards is the number of ICS epochs that a validator needs to wait after opting in on a consumer chain before being eligible to ICS rewards from that consumer.  ","version":"Next","tagName":"h3"},{"title":"MaxProviderConsensusValidators​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#maxproviderconsensusvalidators","content":" Type\tDefault valueint64\t180  MaxProviderConsensusValidators is the maximum number of validators sent to the provider consensus engine. This was introduced with the Inactive Provider Validators featureand it replaces the MaxValidators staking module parameter. As a result, the provider chain can differentiate betweenbonded validators, i.e., validators that have stake locked on the provider chain, and active validator, i.e., validators that participate actively in the provider chain's consensus.  ","version":"Next","tagName":"h3"},{"title":"Client​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#client","content":" ","version":"Next","tagName":"h2"},{"title":"CLI​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#cli","content":" A user can interact with the provider module using the CLI.  Query​  The query commands allow users to query provider state.  interchain-security-pd query provider --help   Consumer Genesis​  The consumer-genesis command allows to query for consumer chain genesis state by consumer id.  interchain-security-pd query provider consumer-genesis [consumer-id] [flags]   Example interchain-security-pd query provider consumer-genesis 0 Output: new_chain: true params: blocks_per_distribution_transmission: &quot;1000&quot; ccv_timeout_period: 2419200s consumer_id: &quot;0&quot; consumer_redistribution_fraction: &quot;0.75&quot; distribution_transmission_channel: &quot;&quot; enabled: true historical_entries: &quot;10000&quot; provider_fee_pool_addr_str: &quot;&quot; provider_reward_denoms: [] retry_delay_period: 3600s reward_denoms: [] soft_opt_out_threshold: &quot;0&quot; transfer_timeout_period: 3600s unbonding_period: 1209600s provider: client_state: allow_update_after_expiry: false allow_update_after_misbehaviour: false chain_id: provider frozen_height: revision_height: &quot;0&quot; revision_number: &quot;0&quot; latest_height: revision_height: &quot;25&quot; revision_number: &quot;0&quot; max_clock_drift: 10s proof_specs: - inner_spec: child_order: - 0 - 1 child_size: 33 empty_child: null hash: SHA256 max_prefix_length: 12 min_prefix_length: 4 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false - inner_spec: child_order: - 0 - 1 child_size: 32 empty_child: null hash: SHA256 max_prefix_length: 1 min_prefix_length: 1 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false trust_level: denominator: &quot;3&quot; numerator: &quot;1&quot; trusting_period: 1197504s unbonding_period: 1814400s upgrade_path: - upgrade - upgradedIBCState consensus_state: next_validators_hash: 632730A03DEF630F77B61DF4092629007AE020B789713158FABCB104962FA54F root: hash: Jcck4b/HHJOcjcVjTdMi8qHB4SeCpWpfLiN9DtB99oA= timestamp: &quot;2024-09-25T09:18:40.262655625Z&quot; initial_val_set: - power: &quot;500&quot; pub_key: ed25519: RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10= - power: &quot;500&quot; pub_key: ed25519: Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is= - power: &quot;500&quot; pub_key: ed25519: mAN6RXYxSM4MNGSIriYiS7pHuwAcOHDQAy9/wnlSzOI=   List Consumer Chains​  The list-consumer-chains command allows to query consumer chains supported by the provider chain. An optional integer parameter can be passed for phase filtering of consumer chains, (Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5).`  interchain-security-pd query provider list-consumer-chains [phase] [limit] [flags]   Example interchain-security-pd query provider list-consumer-chains 3 Output: chains: - allow_inactive_vals: true allowlist: [] prioritylist: [] chain_id: pion-1 client_id: 07-tendermint-0 consumer_id: &quot;0&quot; denylist: [&quot;cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6&quot;] metadata: description: description of your chain and all other relevant information metadata: some metadata about your chain name: pion-1 min_power_in_top_N: &quot;500&quot; min_stake: &quot;0&quot; phase: CONSUMER_PHASE_LAUNCHED top_N: 60 validator_set_cap: 0 validators_power_cap: 0 pagination: next_key: null total: &quot;1&quot;   Validator Consumer Key Assignment​  The validator-consumer-key command allows to query assigned validator consensus public key for a consumer chain.  interchain-security-pd query provider validator-consumer-key [consumer-id] [provider-validator-address] [flags]   Example interchain-security-pd query provider validator-consumer-key 0 cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6 Output: consumer_address: cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk   Validator Provider Key​  The validator-provider-key command allows to query validator consensus public key for the provider chain.  interchain-security-pd query provider validator-provider-key [consumer-id] [consumer-validator-address] [flags]   Example interchain-security-pd query provider validator-provider-key 0 cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk Output: provider_address: cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj   Throttle State​  The throttle-state command allows to query on-chain state relevant to slash packet throttling.  interchain-security-pd query provider throttle-state [flags]   Example interchain-security-pd query provider throttle-state Output: next_replenish_candidate: &quot;2024-09-26T07:59:51.336971970Z&quot; slash_meter: &quot;1500&quot; slash_meter_allowance: &quot;1511&quot;   Registered Consumer Reward Denoms​  The registered-consumer-reward-denoms command allows to query registered consumer reward denoms.  interchain-security-pd query provider registered-consumer-reward-denoms [flags]   Example interchain-security-pd query provider registered-consumer-reward-denoms Output: denoms: - ibc/3C3D7B3BE4ECC85A0E5B52A3AEC3B7DFC2AA9CA47C37821E57020D6807043BE9 - ibc/D549749C93524DA1831A4B3C850DFC1BA9060261BEDFB224B3B0B4744CD77A70   All Pairs Valconsensus Address​  The all-pairs-valconsensus-address command allows to query all pairs of valconsensus address by consumer id.  interchain-security-pd query provider all-pairs-valconsensus-address [consumer-id] [flags]   Example interchain-security-pd query provider all-pairs-valconsensus-address 0 Output: pair_val_con_addr: - consumer_address: cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk consumer_key: ed25519: Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is= provider_address: cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6   Provider Parameters​  The params command allows to query provider parameters information.  interchain-security-pd query provider params [flags]   Example interchain-security-pd query provider params Output: blocks_per_epoch: &quot;3&quot; ccv_timeout_period: 2419200s consumer_reward_denom_registration_fee: amount: &quot;10000000&quot; denom: stake max_provider_consensus_validators: &quot;180&quot; number_of_epochs_to_start_receiving_rewards: &quot;24&quot; slash_meter_replenish_fraction: &quot;1.0&quot; slash_meter_replenish_period: 3600s template_client: allow_update_after_expiry: false allow_update_after_misbehaviour: false chain_id: &quot;&quot; frozen_height: revision_height: &quot;0&quot; revision_number: &quot;0&quot; latest_height: revision_height: &quot;0&quot; revision_number: &quot;0&quot; max_clock_drift: 10s proof_specs: - inner_spec: child_order: - 0 - 1 child_size: 33 empty_child: null hash: SHA256 max_prefix_length: 12 min_prefix_length: 4 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false - inner_spec: child_order: - 0 - 1 child_size: 32 empty_child: null hash: SHA256 max_prefix_length: 1 min_prefix_length: 1 leaf_spec: hash: SHA256 length: VAR_PROTO prefix: AA== prehash_key: NO_HASH prehash_value: SHA256 max_depth: 0 min_depth: 0 prehash_key_before_comparison: false trust_level: denominator: &quot;3&quot; numerator: &quot;1&quot; trusting_period: 0s unbonding_period: 0s upgrade_path: - upgrade - upgradedIBCState trusting_period_fraction: &quot;0.66&quot;   Consumer Opted In Validators​  The consumer-opted-in-validators command allows to query opted-in validators for a given consumer chain.  interchain-security-pd query provider consumer-opted-in-validators [consumer-id] [flags]   Example interchain-security-pd query provider consumer-opted-in-validators 0 Output: validators_provider_addresses: - cosmosvalcons1qmq08eruchr5sf5s3rwz7djpr5a25f7xw4mceq - cosmosvalcons1nx7n5uh0ztxsynn4sje6eyq2ud6rc6klc96w39 - cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6   Consumer Validators​  The consumer-validators command allows to query the last set consumer-validator set for a given consumer chain.  interchain-security-pd query provider consumer-validators [consumer-id] [flags]   Example interchain-security-pd query provider consumer-validators 0 Output: validators: - consumer_commission_rate: &quot;0.100000000000000000&quot; consumer_key: ed25519: RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10= consumer_power: &quot;511&quot; description: details: &quot;&quot; identity: &quot;&quot; moniker: validatoralice security_contact: &quot;&quot; website: &quot;&quot; jailed: false power: &quot;0&quot; provider_address: cosmosvalcons1qmq08eruchr5sf5s3rwz7djpr5a25f7xw4mceq provider_commission_rate: &quot;0.100000000000000000&quot; provider_operator_address: cosmosvaloper19pe9pg5dv9k5fzgzmsrgnw9rl9asf7ddtrgtng provider_power: &quot;511&quot; provider_tokens: &quot;511000000&quot; rate: &quot;0.000000000000000000&quot; status: BOND_STATUS_BONDED validates_current_epoch: true - consumer_commission_rate: &quot;0.100000000000000000&quot; consumer_key: ed25519: mAN6RXYxSM4MNGSIriYiS7pHuwAcOHDQAy9/wnlSzOI= consumer_power: &quot;500&quot; description: details: &quot;&quot; identity: &quot;&quot; moniker: validatorbob security_contact: &quot;&quot; website: &quot;&quot; jailed: false power: &quot;0&quot; provider_address: cosmosvalcons1nx7n5uh0ztxsynn4sje6eyq2ud6rc6klc96w39 provider_commission_rate: &quot;0.100000000000000000&quot; provider_operator_address: cosmosvaloper1dkas8mu4kyhl5jrh4nzvm65qz588hy9qakmjnw provider_power: &quot;500&quot; provider_tokens: &quot;500000000&quot; rate: &quot;0.000000000000000000&quot; status: BOND_STATUS_BONDED validates_current_epoch: true   Has to Validate​  The has-to-validate command allows to query the consumer chains list a given validator has to validate.  interchain-security-pd query provider has-to-validate [provider-validator-address] [flags]   Example interchain-security-pd query provider has-to-validate cosmoscons1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj Output: consumer_ids: - &quot;0&quot; - &quot;2&quot;   Validator Consumer Commission Rate​  The validator-consumer-commission-rate command allows to query the consumer commission rate a validator charges on a consumer chain.  interchain-security-pd query provider validator-consumer-commission-rate [consumer-id] [provider-validator-address] [flags]   Example interchain-security-pd query provider validator-consumer-commission-rate 0 cosmoscons1gghjut3ccd8ay0zduzj64hwre2fxs9ldmqhffj Output: rate: &quot;0.750000000000000000&quot;   Blocks Until Next Epoch​  The blocks-until-next-epoch command allows to query the number of blocks until the next epoch begins and validator updates are sent to consumer chains  interchain-security-pd query provider blocks-until-next-epoch [flags]   Example interchain-security-pd query provider blocks-until-next-epoch Output: blocks_until_next_epoch: &quot;286&quot;   Consumer Id From Client Id​  The consumer-id-from-client-id command allows to query the consumer id of the chain associated with the provided client id.  interchain-security-pd query provider consumer-id-from-client-id [client-id] [flags]   Example interchain-security-pd query provider consumer-id-from-client-id 07-tendermint-0 Output: consumer_id: &quot;0&quot;   Consumer Chain​  The consumer-chain command allows to query the consumer chain associated with the consumer id.  interchain-security-pd query provider consumer-chain [consumer-id] [flags]   Example interchain-security-pd query provider consumer-chain 0 Output: chain_id: pion-1 consumer_id: &quot;0&quot; init_params: binary_hash: YmluX2hhc2g= blocks_per_distribution_transmission: &quot;1000&quot; ccv_timeout_period: 2419200s consumer_redistribution_fraction: &quot;0.75&quot; distribution_transmission_channel: &quot;&quot; genesis_hash: Z2VuX2hhc2g= historical_entries: &quot;10000&quot; initial_height: revision_height: &quot;1&quot; revision_number: &quot;0&quot; spawn_time: &quot;2024-09-26T06:55:14.616054Z&quot; transfer_timeout_period: 3600s unbonding_period: 1209600s connection_id: &quot;&quot; metadata: description: description of your chain and all other relevant information metadata: some metadata about your chain name: pion-1 owner_address: cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn phase: CONSUMER_PHASE_LAUNCHED power_shaping_params: allow_inactive_vals: false allowlist: [] denylist: [] min_stake: 0 top_N: 100 validator_set_cap: 0 validators_power_cap: 0 prioritylist: []   Consumer Genesis Time​  The consumer-genesis-time command allows to query the genesis time of the consumer chain associated with the consumer id.  interchain-security-pd query provider consumer-genesis-time [consumer-id] [flags]   Example interchain-security-pd query provider consumer-genesis-time 0 Output: genesis_time: &quot;2024-10-18T08:13:23.507178095Z&quot;   Transactions​  The tx commands allows users to interact with the provider module.  interchain-security-pd tx provider --help   Assign Consumer Key​  The assign-consensus-key command allows to assign a consensus public key to use for a consumer chain.  interchain-security-pd tx provider assign-consensus-key [consumer-id] [consumer-pubkey] [flags]   Example interchain-security-pd tx provider assign-consensus-key 0 \\ '{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}' \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Note that the consumer pubkey can be obtained by using interchain-security-cd tendermint show-validator command.  Create Consumer​  The create-consumer command allows to create a consumer chain.  interchain-security-pd tx provider create-consumer [consumer-parameters] [flags]   Example interchain-security-pd tx provider create-consumer path/to/create-consumer-msg.json \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where create-consumer-msg.json contains: { &quot;chain_id&quot; : &quot;pion-1&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;{\\&quot;forge_json_url\\&quot;: \\&quot;...\\&quot;, \\&quot;stage\\&quot;: \\&quot;mainnet\\&quot;}&quot; } }   Update Consumer​  The update-consumer command allows to update a consumer chain.  interchain-security-pd tx provider update-consumer [consumer-parameters] [flags]   Example interchain-security-pd tx provider update-consumer path/to/update-consumer.json \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where update-consumer-msg.json contains: { &quot;consumer_id&quot; : &quot;0&quot;, &quot;owner_address&quot;: &quot;cosmos1p3ucd3ptpw902fluyjzhq3ffgq4ntddac9sa3s&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;{\\&quot;forge_json_url\\&quot;: \\&quot;...\\&quot;, \\&quot;stage\\&quot;: \\&quot;mainnet\\&quot;}&quot; }, &quot;initialization_parameters&quot;:{ &quot;initial_height&quot;:{ &quot;revision_number&quot;: 1, &quot;revision_height&quot;: 1 }, &quot;genesis_hash&quot;: &quot;&quot;, &quot;binary_hash&quot;: &quot;&quot;, &quot;spawn_time&quot;: &quot;2024-09-29T12:57:43Z&quot;, &quot;unbonding_period&quot;: 1728000000000000, &quot;ccv_timeout_period&quot;: 2419200000000000, &quot;transfer_timeout_period&quot;: 1800000000000, &quot;consumer_redistribution_fraction&quot;: &quot;0.75&quot;, &quot;blocks_per_distribution_transmission&quot;: &quot;1500&quot;, &quot;historical_entries&quot;: &quot;1000&quot;, &quot;distribution_transmission_channel&quot;: &quot;&quot;, &quot;connection_id&quot;: &quot;&quot; }, &quot;power_shaping_parameters&quot;:{ &quot;top_N&quot;: 0, &quot;validators_power_cap&quot;: 10, &quot;validator_set_cap&quot;: 50, &quot;allowlist&quot;:[&quot;cosmosvalcons1l9qq4m300z8c5ez86ak2mp8znftewkwgjlxh88&quot;], &quot;denylist&quot;:[], &quot;min_stake&quot;: &quot;1000&quot;, &quot;allow_inactive_vals&quot;:true, &quot;prioritylist&quot;:[] }, &quot;allowlisted_reward_denoms&quot;: { &quot;denoms&quot;: [&quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;] } }   Remove Consumer​  The remove-consumer command allows to remove a consumer chain.  interchain-security-pd tx provider remove-consumer [consumer-id] [flags]   Example interchain-security-pd tx provider remove-consumer 0   Opt In​  The opt-in command allows a validator to opt in to a consumer chain and optionally set a consensus public key.  interchain-security-pd tx provider opt-in [consumer-id] [consumer-pubkey] [flags]   Example interchain-security-pd tx provider opt-in 0 \\ '{&quot;@type&quot;:&quot;/cosmos.crypto.ed25519.PubKey&quot;,&quot;key&quot;:&quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot;}' \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Opt Out​  The opt-out command allows validators to opt out from consumer chains.  interchain-security-pd tx provider opt-out [consumer-id] [flags]   Example interchain-security-pd tx provider opt-out 0 \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Set Consumer Commission Rate​  The set-consumer-commission-rate command allows to set a per-consumer chain commission rate.  interchain-security-pd tx provider set-consumer-commission-rate [consumer-id] [commission-rate] [flags]   Example interchain-security-pd tx provider set-consumer-commission-rate 0 0.5 \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\   Submit Consumer Double Voting​  The submit-consumer-double-voting command allows to submit a double voting evidence for a consumer chain.  interchain-security-pd tx provider submit-consumer-double-voting [consumer-id] [evidence] [infraction_header] [flags]   Example interchain-security-pd tx provider submit-consumer-double-voting 0 path/to/evidence.json path/to/infraction_header.json \\ --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where evidence.json contains: { &quot;vote_a&quot;: { &quot;type&quot;: &quot;SIGNED_MSG_TYPE_PREVOTE&quot;, &quot;height&quot;: &quot;59&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;paTPgLrLCZmw5ctQWlaMLJhXLckafakKN9skJbTiCHA=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;pVOTT8MO00rk0HAeVQgzdP3wjIOzN5X5tfPLTtXIn2g=&quot; } }, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.146234009Z&quot;, &quot;validator_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;validator_index&quot;: 1, &quot;signature&quot;: &quot;Z9C1oU5AEyFqXVmQ0LKNlaVa+tGh++95EB5HYe0i61PlREOmo/OTLlWedr8kuAThBu/1CpaLz446hYjISAKqBQ==&quot;, &quot;extension&quot;: null, &quot;extension_signature&quot;: null }, &quot;vote_b&quot;: { &quot;type&quot;: &quot;SIGNED_MSG_TYPE_PREVOTE&quot;, &quot;height&quot;: &quot;59&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;07tksQsQ0gVBphgP4eeyGII9tEaLUuCauQcmwar9ktk=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;nND/ClxCtoSJ9fC7Jyy884ab+nDh+PnHwI28T2fELCE=&quot; } }, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.051976301Z&quot;, &quot;validator_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;validator_index&quot;: 1, &quot;signature&quot;: &quot;QscqC9ilH4gL7+3GPqLMWly+UkO+p0JgcinDZtfHOM4fYosZhx+TzhLrrXNExYpwX3D8qQHmJlLCcXLqbo7aCA==&quot;, &quot;extension&quot;: null, &quot;extension_signature&quot;: null }, &quot;total_voting_power&quot;: &quot;1500&quot;, &quot;validator_power&quot;: &quot;500&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:45.945436342Z&quot; } and infraction_header.json contains: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;0&quot; }, &quot;chain_id&quot;: &quot;pion-1&quot;, &quot;height&quot;: &quot;59&quot;, &quot;time&quot;: &quot;2024-09-26T09:34:45.945436342Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;t8HcmkQbchpGE1CxqdhcogoT+yD5VIm+cRGLcosTtxE=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;fTediSh8XttUUoxWJLPIxO6iWecqdMMsegD2svBtR5E=&quot; } }, &quot;last_commit_hash&quot;: &quot;2U4mFcB6+FffQeFPUaHkd+eBtEV5/5d3Zy0Lk58dwIs=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;D26N3CL1zQt7yn+JUQ8Dcb2vCYG7QmHMiMfY+nGxhts=&quot;, &quot;next_validators_hash&quot;: &quot;D26N3CL1zQt7yn+JUQ8Dcb2vCYG7QmHMiMfY+nGxhts=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;k/RW/WMOYCS89VBhKMHIRYb30a30JkZ+puyp9ESTBiA=&quot;, &quot;last_results_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;59&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;07tksQsQ0gVBphgP4eeyGII9tEaLUuCauQcmwar9ktk=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;nND/ClxCtoSJ9fC7Jyy884ab+nDh+PnHwI28T2fELCE=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;BsDz5HzFx0gmkIjcLzZBHTqqJ8Y=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.271500717Z&quot;, &quot;signature&quot;: &quot;bXA2WgQVVlHAkn9mGIfoUvgn3C+EJCzNGTAjnhoQJwLkh1Okg3oYmwZRz+UGbc95kXyVO7kQSXhavt0ZPcJ4AA==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.305955426Z&quot;, &quot;signature&quot;: &quot;YG1OcUhpTKFz+Uo8halNmkw0s6n333+m53laZvyQSHM5gqOG4h8jzij2u9sU4H404OJMgdj+1GTxuHmQ8jWFBg==&quot; }, { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;tBw6QBQpY6pbEt3RxOWJDAs5JrE=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:34:47.255694467Z&quot;, &quot;signature&quot;: &quot;EYOC/yo+RaosEVhwBy0bZFjVwHCR7rRZo/FmTRWpAIXZHBVrIiX3iVzRUwn78lsfbaoT97TsqRX61bAiJDM6BA==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;BsDz5HzFx0gmkIjcLzZBHTqqJ8Y=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;-1000&quot; }, { &quot;address&quot;: &quot;mb06cu8SzQJOdYSzrJAK43Q8at8=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;mAN6RXYxSM4MNGSIriYiS7pHuwAcOHDQAy9/wnlSzOI=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;500&quot; }, { &quot;address&quot;: &quot;tBw6QBQpY6pbEt3RxOWJDAs5JrE=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;500&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;BsDz5HzFx0gmkIjcLzZBHTqqJ8Y=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;RrclQz9bIhkIy/gfL485g3PYMeiIku4qeo495787X10=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;-1000&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;0&quot; }, &quot;trusted_validators&quot;: null }   Submit Consumer Misbehaviour​  The submit-consumer-misbehaviour command allows to submit an IBC misbehaviour for a consumer chain.  interchain-security-pd tx provider submit-consumer-misbehaviour [consumer-id] [misbehaviour] [flags]   Example interchain-security-pd tx provider submit-consumer-misbehaviour 0 path/to/consumer-misbehaviour.json --chain-id provider \\ --from mykey \\ --gas=&quot;auto&quot; \\ --gas-adjustment=&quot;1.2&quot; \\ --gas-prices=&quot;0.025stake&quot; \\ where consumer-misbehaviour.json contains: { &quot;client_id&quot;: &quot;07-tendermint-0&quot;, &quot;header_1&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;0&quot; }, &quot;chain_id&quot;: &quot;pion-1&quot;, &quot;height&quot;: &quot;95&quot;, &quot;time&quot;: &quot;2024-09-26T09:15:52.845591095Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;PUph0B9N9X+LdrstqOoGf+W+OS6oHetQUa+0fpcRnF8=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;SlVkAlM1uq3DjgTk0NbZftLlFwOEJrau1Wnhg3jEH3A=&quot; } }, &quot;last_commit_hash&quot;: &quot;Hxe4aLTULJ7qxJ10XsQfluKyU1Rn+d+cgDeTm2AATqU=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;next_validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;uGHlqLiNp+ZCjE889JDFKnrNkRpZ5xZ5OOamXrCNcOc=&quot;, &quot;last_results_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;95&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;hkUUob+4UVRE4uJW53fY9UYViGTs2v6P5Sb/hUFYyak=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;0tx9pRIzYJ3vwrYyOgMC8zxf/sSJUtNVm9DBKM8Yxo0=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:15:53.852414554Z&quot;, &quot;signature&quot;: &quot;iiQCCxsCOoNVb2smAVmDO62o9HLf+I4rWk8o86uA1ZoFun/lk1bwrocaMp1It1SjVo/szYsX6Hp5rP1IwcAjDg==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;20&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } }, &quot;header_2&quot;: { &quot;signed_header&quot;: { &quot;header&quot;: { &quot;version&quot;: { &quot;block&quot;: &quot;11&quot;, &quot;app&quot;: &quot;0&quot; }, &quot;chain_id&quot;: &quot;consu&quot;, &quot;height&quot;: &quot;95&quot;, &quot;time&quot;: &quot;2024-09-26T09:15:54.044450012Z&quot;, &quot;last_block_id&quot;: { &quot;hash&quot;: &quot;MG9B1h4R9Xb4GRjvaNydD5NSqT37OOjGDcatCZpBlco=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;3jQh26/9EuNAAEL6v2tRuGhKtkotoyTqGtduOOn++vk=&quot; } }, &quot;last_commit_hash&quot;: &quot;s1hUy5e7i+GrH5IGW1ck4YHK2CDTY4fjnSiNMInJBWc=&quot;, &quot;data_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;next_validators_hash&quot;: &quot;+003y0s55+pbijWbJyVVgfNnquSaGGnQmC1hGRUIIjk=&quot;, &quot;consensus_hash&quot;: &quot;BICRvH3cKD93v7+R1zxE2ljD34qcvIZ0Bdi389qtoi8=&quot;, &quot;app_hash&quot;: &quot;bWRmShMthwEAB3lIVMgB673gH5vTdoqfn223M3Xrk6Q=&quot;, &quot;last_results_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;evidence_hash&quot;: &quot;47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=&quot;, &quot;proposer_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot; }, &quot;commit&quot;: { &quot;height&quot;: &quot;95&quot;, &quot;round&quot;: 0, &quot;block_id&quot;: { &quot;hash&quot;: &quot;z3MJTCXppRYoIEPOrneYzw/U0CSiYF3zsUv67ynxM6Q=&quot;, &quot;part_set_header&quot;: { &quot;total&quot;: 1, &quot;hash&quot;: &quot;BFSlw7bqXxBHl9O5O9sCUB01nbe0T0KGOmv7yyr8KYU=&quot; } }, &quot;signatures&quot;: [ { &quot;block_id_flag&quot;: &quot;BLOCK_ID_FLAG_COMMIT&quot;, &quot;validator_address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;timestamp&quot;: &quot;2024-09-26T09:15:55.054809888Z&quot;, &quot;signature&quot;: &quot;oi+TQ0yoDEeXyBchFIql9AGxbufnx3FzDKsCp4B8tx42ropD8tyotKOjk0OMuZQC5aMMRndRfKiYYsWiOrcpAg==&quot; } ] } }, &quot;validator_set&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;511&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; }, &quot;trusted_height&quot;: { &quot;revision_number&quot;: &quot;0&quot;, &quot;revision_height&quot;: &quot;20&quot; }, &quot;trusted_validators&quot;: { &quot;validators&quot;: [ { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; } ], &quot;proposer&quot;: { &quot;address&quot;: &quot;3wkKSIC1TNV7KnnmTZ6Wm9dRSwk=&quot;, &quot;pub_key&quot;: { &quot;ed25519&quot;: &quot;ujY14AgopV907IYgPAk/5x8c9267S4fQf89nyeCPTes=&quot; }, &quot;voting_power&quot;: &quot;500&quot;, &quot;proposer_priority&quot;: &quot;0&quot; }, &quot;total_voting_power&quot;: &quot;0&quot; } } }   ","version":"Next","tagName":"h3"},{"title":"gRPC​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#grpc","content":" A user can query the provider module using gRPC endpoints.  Consumer Genesis​  The QueryConsumerGenesis endpoint queries a consumer chain genesis state by consumer id.  interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 \\ interchain_security.ccv.provider.v1.Query/QueryConsumerGenesis Output: { &quot;genesisState&quot;: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;1000&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot; }, &quot;provider&quot;: { &quot;clientState&quot;: { &quot;chainId&quot;: &quot;provider&quot;, &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;57024s&quot;, &quot;unbondingPeriod&quot;: &quot;86400s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: { &quot;revisionHeight&quot;: &quot;10&quot; }, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;consensusState&quot;: { &quot;timestamp&quot;: &quot;2024-09-26T08:19:42.708111Z&quot;, &quot;root&quot;: { &quot;hash&quot;: &quot;xbZV/9QyM3PYzY/HyJAsNogaaJVJtyAGROTcXuqxHas=&quot; }, &quot;nextValidatorsHash&quot;: &quot;/zLB6RSu9omrO5L0tnDK03hCOUibwl/7eeVC3hTP7so=&quot; }, &quot;initialValSet&quot;: [ { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;E9bJ6bi7X9MG9s3djQ4MmBxshis9W15y7UzXCxp2Yuk=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;power&quot;: &quot;100&quot; } ] }, &quot;newChain&quot;: true } }   List Consumer Chains​  The QueryConsumerChains endpoint queries consumer chains supported by the provider chain and supports pagination for managing a large number of chains. An optional integer parameter can be passed for phase filtering of consumer chains, (Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5).`  interchain_security.ccv.provider.v1.Query/QueryConsumerChains   Example grpcurl -plaintext -d '{&quot;phase&quot;: &quot;1&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChains Output: { &quot;chains&quot;: [ { &quot;chainId&quot;: &quot;pion-1&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;2&quot; }, { &quot;chainId&quot;: &quot;dash-2&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;dash-2&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;4&quot; }, ], &quot;pagination&quot;: { &quot;total&quot;: &quot;6&quot; } }   Validator Consumer Key Assignment​  The QueryValidatorConsumerAddr endpoint queries the address assigned by a validator for a consumer chain.  interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;, &quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerAddr Output: { &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot; }   Validator Provider Key​  The QueryValidatorProviderAddr endpoint queries the provider chain address given a consumer chain validator address.  interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;, &quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryValidatorProviderAddr Output: { &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot; }   Throttle State​  The QueryThrottleState endpoint queries the main on-chain state relevant to slash packet throttling.  interchain_security.ccv.provider.v1.Query/QueryThrottleState   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryThrottleState Output: { &quot;slashMeter&quot;: &quot;15&quot;, &quot;slashMeterAllowance&quot;: &quot;15&quot;, &quot;nextReplenishCandidate&quot;: &quot;2024-09-26T14:27:38.066958Z&quot; }   Registered Consumer Reward Denoms​  The QueryRegisteredConsumerRewardDenoms command allows to query registered consumer reward denoms  interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryRegisteredConsumerRewardDenoms Output: { &quot;denoms&quot;: [ &quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;, &quot;ibc/054892D6BB43AF8B93AAC28AA5FD7019D2C59A15DAFD6F45C1FA2BF9BDA22454&quot;, &quot;uatom&quot; ] }   All Pairs Valconsensus Address​  The QueryAllPairsValConsAddrByConsumer endpoint queries the list of pair valconsensus address between provider and consumer chain.  interchain_security.ccv.provider.v1.Query/QueryAllPairsValConsAddrByConsumer   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryAllPairsValConsAddrByConsumer Output: { &quot;pairValConAddr&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6&quot;, &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; } } ] }   Provider Parameters​  The QueryParams endpoint queries all current values of provider parameters.  interchain_security.ccv.provider.v1.Query/QueryParams   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryParams Output: { &quot;params&quot;: { &quot;templateClient&quot;: { &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;0s&quot;, &quot;unbondingPeriod&quot;: &quot;0s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: {}, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;trustingPeriodFraction&quot;: &quot;0.66&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;slashMeterReplenishPeriod&quot;: &quot;3600s&quot;, &quot;slashMeterReplenishFraction&quot;: &quot;0.05&quot;, &quot;consumerRewardDenomRegistrationFee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocksPerEpoch&quot;: &quot;5&quot;, &quot;numberOfEpochsToStartReceivingRewards&quot;: &quot;24&quot;, &quot;maxProviderConsensusValidators&quot;: &quot;180&quot; } }   Consumer Opted In Validators​  The QueryConsumerChainOptedInValidators endpoint queries opted-in validators for a given consumer chain.  interchain_security.ccv.provider.v1.Query/QueryConsumerChainOptedInValidators   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChainOptedInValidators Output: { &quot;validatorsProviderAddresses&quot;: [ &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot; ] }   Consumer Validators​  The QueryConsumerValidators endpoint queries the latest set consumer-validator set for a given consumer ID. Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment because a VSCPacket could be delayed to be delivered on the consumer chain.  interchain_security.ccv.provider.v1.Query/QueryConsumerValidators   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerValidators Output: { &quot;validators&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;101&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;bob&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1a7u5k6f54ua3tptl9yn6u82yrvayet6sxn9ywn&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;101000000&quot;, &quot;providerPower&quot;: &quot;101&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;coordinator&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1jk2pp655zxy2gazhxj50s8jk3750y8np6wz4lm&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;alice&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper19vfen9jn3uk3e6rrkt3pxansunujnlm40wpdvg&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true } ] }   Has to Validate​  The QueryConsumerChainsValidatorHasToValidate endpoint queries a list of consumer chains that a given validator must validate.  interchain_security.ccv.provider.v1.Query/QueryConsumerChainsValidatorHasToValidate   Example grpcurl -plaintext -d '{&quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChainsValidatorHasToValidate Output: { &quot;consumerIds&quot;: [ &quot;0&quot;, &quot;2&quot; ] }   Validator Consumer Commission Rate​  The QueryValidatorConsumerCommissionRate endpoint queries the consumer commission rate a validator charges on a consumer chain.  interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerCommissionRate   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;, &quot;provider_address&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryValidatorConsumerCommissionRate Output: { &quot;rate&quot;: &quot;750000000000000000&quot; }   Blocks Until Next Epoch​  The QueryBlocksUntilNextEpoch endpoint allows to query the number of blocks until the next epoch begins and validator updates are sent to consumer chains.  interchain_security.ccv.provider.v1.Query/QueryBlocksUntilNextEpoch   Example grpcurl -plaintext localhost:9090 interchain_security.ccv.provider.v1.Query/QueryBlocksUntilNextEpoch Output: { &quot;blocks_until_next_epoch&quot;:&quot;4&quot; }   Consumer Id From Client Id​  The QueryConsumerIdFromClientId endpoint allows to query the consumer id of the chain associated with the provided client id.  interchain_security.ccv.provider.v1.Query/QueryConsumerIdFromClientId   Example grpcurl -plaintext -d '{&quot;client_id&quot;:&quot;07-tendermint-0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerIdFromClientId Output: { &quot;consumerId&quot;: &quot;0&quot; }   Consumer Chain​  The QueryConsumerChain endpoint allows to query the consumer chain associated with the consumer id.  interchain_security.ccv.provider.v1.Query/QueryConsumerChain   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerChain { &quot;consumerId&quot;: &quot;0&quot;, &quot;chainId&quot;: &quot;pion-1&quot;, &quot;ownerAddress&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_LAUNCHED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;description of your chain and all other relevant information&quot;, &quot;description&quot;: &quot;some metadata about your chain&quot;, &quot;metadata&quot;: &quot;pion-1&quot; }, &quot;initParams&quot;: { &quot;initialHeight&quot;: { &quot;revisionHeight&quot;: &quot;1&quot; }, &quot;genesisHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;binaryHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;spawnTime&quot;: &quot;2023-03-11T17:02:14.718477Z&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;historicalEntries&quot;: &quot;1000&quot; }, &quot;powerShapingParams&quot;: { &quot;topN&quot;: 100, &quot;validatorSetCap&quot;: 50, &quot;minStake&quot;: &quot;1000&quot;, &quot;allowInactiveVals&quot;: true }, &quot;infraction_parameters&quot;:{ &quot;double_sign&quot;:{ &quot;slash_fraction&quot;:&quot;0.050000000000000000&quot;, &quot;jail_duration&quot;:&quot;9223372036.854775807s&quot;, &quot;tombstone&quot;: true }, &quot;downtime&quot;:{ &quot;slash_fraction&quot;:&quot;0.000000000000000000&quot;, &quot;jail_duration&quot;:&quot;600s&quot;, &quot;tombstone&quot;: false } }, &quot;clientId&quot;: &quot;07-tendermint-28&quot; }   Consumer Genesis Time​  The QueryConsumerGenesisTime endpoint allows to query the genesis time of the consumer chain associated with the consumer id.  interchain_security.ccv.provider.v1.Query/QueryConsumerGenesisTime   Example grpcurl -plaintext -d '{&quot;consumer_id&quot;: &quot;0&quot;}' localhost:9090 interchain_security.ccv.provider.v1.Query/QueryConsumerGenesisTime { &quot;genesisTime&quot;: &quot;2024-10-18T08:13:23.507178095Z&quot; }   ","version":"Next","tagName":"h3"},{"title":"REST​","type":1,"pageTitle":"x/ccv/provider","url":"/interchain-security/build/modules/provider#rest","content":" A user can query the provider module using REST endpoints.  Consumer Genesis​  The consumer_genesis endpoint queries a consumer chain genesis state by consumer id.  interchain_security/ccv/provider/consumer_genesis/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_genesis/0 Output: { &quot;genesisState&quot;: { &quot;params&quot;: { &quot;enabled&quot;: true, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;historicalEntries&quot;: &quot;1000&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;softOptOutThreshold&quot;: &quot;0&quot;, &quot;retryDelayPeriod&quot;: &quot;3600s&quot; }, &quot;provider&quot;: { &quot;clientState&quot;: { &quot;chainId&quot;: &quot;provider&quot;, &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;57024s&quot;, &quot;unbondingPeriod&quot;: &quot;86400s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: { &quot;revisionHeight&quot;: &quot;10&quot; }, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;consensusState&quot;: { &quot;timestamp&quot;: &quot;2024-09-26T08:19:42.708111Z&quot;, &quot;root&quot;: { &quot;hash&quot;: &quot;xbZV/9QyM3PYzY/HyJAsNogaaJVJtyAGROTcXuqxHas=&quot; }, &quot;nextValidatorsHash&quot;: &quot;/zLB6RSu9omrO5L0tnDK03hCOUibwl/7eeVC3hTP7so=&quot; }, &quot;initialValSet&quot;: [ { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;E9bJ6bi7X9MG9s3djQ4MmBxshis9W15y7UzXCxp2Yuk=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;power&quot;: &quot;100&quot; }, { &quot;pubKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;power&quot;: &quot;100&quot; } ] }, &quot;newChain&quot;: true } }   List Consumer Chains​  The consumer_chains endpoint queries consumer chains supported by the provider chain. An optional integer parameter can be passed for phase filtering of consumer chains, (Registered=1|Initialized=2|Launched=3|Stopped=4|Deleted=5).`  interchain_security/ccv/provider/consumer_chains/{phase}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_chains/3 Output: { &quot;chains&quot;: [ { &quot;chainId&quot;: &quot;pion-1&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;pion-1&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;2&quot; }, { &quot;chainId&quot;: &quot;dash-2&quot;, &quot;minPowerInTopN&quot;: &quot;-1&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_REGISTERED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;dash-2&quot;, &quot;description&quot;:&quot;description of your chain and all other relevant information&quot;, &quot;metadata&quot;: &quot;some metadata about your chain&quot; }, &quot;consumerId&quot;: &quot;4&quot; }, ], &quot;pagination&quot;: { &quot;total&quot;: &quot;6&quot; } }   Validator Consumer Key Assignment​  The validator_consumer_addr endpoint queries the address assigned by a validator for a consumer chain.  /interchain_security/ccv/provider/validator_consumer_addr/{consumer_id}/{provider_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/validator_consumer_addr/0/cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj Output: { &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot; }   Validator Provider Key​  The validator_provider_addr endpoint queries the provider chain address given a consumer chain validator address.  /interchain_security/ccv/provider/validator_provider_addr/{consumer_id}/{consumer_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/validator_provider_addr/0/cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk Output: { &quot;providerAddress&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot; }   Throttle State​  The throttle_state queries the main on-chain state relevant to slash packet throttling.  &quot;/interchain_security/ccv/provider/throttle_state&quot;   Example curl http://localhost:1317/interchain_security/ccv/provider/throttle_state Output: { &quot;slashMeter&quot;: &quot;15&quot;, &quot;slashMeterAllowance&quot;: &quot;15&quot;, &quot;nextReplenishCandidate&quot;: &quot;2024-09-26T14:27:38.066958Z&quot; }   Registered Consumer Reward Denoms​  The registered_consumer_reward_denoms endpoint allows to query registered consumer reward denoms  interchain_security/ccv/provider/registered_consumer_reward_denoms   Example curl http://localhost:1317/interchain_security/ccv/provider/registered_consumer_reward_denoms Output: { &quot;denoms&quot;: [ &quot;ibc/0025F8A87464A471E66B234C4F93AEC5B4DA3D42D7986451A059273426290DD5&quot;, &quot;ibc/054892D6BB43AF8B93AAC28AA5FD7019D2C59A15DAFD6F45C1FA2BF9BDA22454&quot;, &quot;uatom&quot; ] }   All Pairs Valconsensus Address​  The address_pairs endpoint queries the list of pair valconsensus address between provider and consumer chain.  interchain_security/ccv/provider/address_pairs/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/address_pairs/0 Output: { &quot;pairValConAddr&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1ezyrq65s3gshhx5585w6mpusq3xsj3ayzf4uv6&quot;, &quot;consumerAddress&quot;: &quot;cosmosvalcons1kswr5sq599365kcjmhgufevfps9njf43e4lwdk&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; } } ] }   Provider Parameters​  The params endpoint queries all current values of provider parameters  interchain_security/ccv/provider/params   Example curl http://localhost:1317/interchain_security/ccv/provider/params Output: { &quot;params&quot;: { &quot;templateClient&quot;: { &quot;trustLevel&quot;: { &quot;numerator&quot;: &quot;1&quot;, &quot;denominator&quot;: &quot;3&quot; }, &quot;trustingPeriod&quot;: &quot;0s&quot;, &quot;unbondingPeriod&quot;: &quot;0s&quot;, &quot;maxClockDrift&quot;: &quot;10s&quot;, &quot;frozenHeight&quot;: {}, &quot;latestHeight&quot;: {}, &quot;proofSpecs&quot;: [ { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 33, &quot;minPrefixLength&quot;: 4, &quot;maxPrefixLength&quot;: 12, &quot;hash&quot;: &quot;SHA256&quot; } }, { &quot;leafSpec&quot;: { &quot;hash&quot;: &quot;SHA256&quot;, &quot;prehashValue&quot;: &quot;SHA256&quot;, &quot;length&quot;: &quot;VAR_PROTO&quot;, &quot;prefix&quot;: &quot;AA==&quot; }, &quot;innerSpec&quot;: { &quot;childOrder&quot;: [ 0, 1 ], &quot;childSize&quot;: 32, &quot;minPrefixLength&quot;: 1, &quot;maxPrefixLength&quot;: 1, &quot;hash&quot;: &quot;SHA256&quot; } } ], &quot;upgradePath&quot;: [ &quot;upgrade&quot;, &quot;upgradedIBCState&quot; ] }, &quot;trustingPeriodFraction&quot;: &quot;0.66&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;slashMeterReplenishPeriod&quot;: &quot;3600s&quot;, &quot;slashMeterReplenishFraction&quot;: &quot;0.05&quot;, &quot;consumerRewardDenomRegistrationFee&quot;: { &quot;denom&quot;: &quot;stake&quot;, &quot;amount&quot;: &quot;10000000&quot; }, &quot;blocksPerEpoch&quot;: &quot;5&quot;, &quot;numberOfEpochsToStartReceivingRewards&quot;: &quot;24&quot;, &quot;maxProviderConsensusValidators&quot;: &quot;180&quot; } }   Consumer Opted In Validators​  The opted_in_validators endpoint queries opted-in validators for a given consumer chain  /interchain_security/ccv/provider/opted_in_validators/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/opted_in_validators/0 Output: { &quot;validatorsProviderAddresses&quot;: [ &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot; ] }   Consumer Validators​  The consumer_validators endpoint queries the latest set consumer-validator set for a given consumer ID Note that this does not necessarily mean that the consumer chain is using this validator set at this exact moment because a VSCPacket could be delayed to be delivered on the consumer chain.  /interchain_security/ccv/provider/consumer_validators/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_validators/0 Output: { &quot;validators&quot;: [ { &quot;providerAddress&quot;: &quot;cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;62d2CCgWXYZHmlsCon2lzVgnu9gfubep2XRPlZKuLAQ=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;101&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;bob&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1a7u5k6f54ua3tptl9yn6u82yrvayet6sxn9ywn&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;101000000&quot;, &quot;providerPower&quot;: &quot;101&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1jnq3j55qe4f946qj8499w0tntxwz90atx26p4q&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;+9BFckSNCI1o/+S85HLjG3pYp1FIzmfYWVKmUH2njxs=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;coordinator&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper1jk2pp655zxy2gazhxj50s8jk3750y8np6wz4lm&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true }, { &quot;providerAddress&quot;: &quot;cosmosvalcons1h7zs5nwruzvhyzkktvhwypfuxlch6nrrw4jjmj&quot;, &quot;consumerKey&quot;: { &quot;ed25519&quot;: &quot;Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is=&quot; }, &quot;rate&quot;: &quot;0&quot;, &quot;consumerPower&quot;: &quot;100&quot;, &quot;consumerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;providerCommissionRate&quot;: &quot;100000000000000000&quot;, &quot;description&quot;: { &quot;moniker&quot;: &quot;alice&quot; }, &quot;providerOperatorAddress&quot;: &quot;cosmosvaloper19vfen9jn3uk3e6rrkt3pxansunujnlm40wpdvg&quot;, &quot;status&quot;: &quot;BOND_STATUS_BONDED&quot;, &quot;providerTokens&quot;: &quot;100000000&quot;, &quot;providerPower&quot;: &quot;100&quot;, &quot;validatesCurrentEpoch&quot;: true } ] }   Has to Validate​  The consumer_chains_per_validator endpoint queries a list of consumer chains that a given validator must validate.  interchain_security/ccv/provider/consumer_chains_per_validator/{provider_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_chains_per_validator/cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph Output: { &quot;consumerIds&quot;: [ &quot;0&quot;, &quot;2&quot; ] }   Validator Consumer Commission Rate​  The consumer_commission_rate endpoint queries the consumer commission rate a validator charges on a consumer chain.  /interchain_security/ccv/provider/consumer_commission_rate/{consumer_id}/{provider_address}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_commission_rate/0/cosmosvalcons1znhu88l6dsvexunfem4u0392kwqyvdkrj66wph Output: { &quot;rate&quot;: &quot;0.100000000000000000&quot; }   Blocks Until Next Epoch​  The blocks_until_next_epoch endpoint allows to query the number of blocks until the next epoch begins and validator updates are sent to consumer chains  interchain_security/ccv/provider/blocks_until_next_epoch   Example curl http://localhost:1317/interchain_security/ccv/provider/blocks_until_next_epoch Output: { &quot;blocks_until_next_epoch&quot;:&quot;3&quot; }   Consumer Id From Client Id​  The consumer_id endpoint allows to query the consumer id of the chain associated with the provided client id  /interchain_security/ccv/provider/consumer_id/{client_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_id/07-tendermint-0 Output: { &quot;consumer_id&quot;:&quot;0&quot; }   Consumer Chain​  The consumer_chain endpoint allows to query the consumer chain associated with the consumer id.  interchain_security/ccv/provider/consumer_chain/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_chain/0 Output: { &quot;consumerId&quot;: &quot;0&quot;, &quot;chainId&quot;: &quot;pion-1&quot;, &quot;ownerAddress&quot;: &quot;cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn&quot;, &quot;phase&quot;: &quot;CONSUMER_PHASE_LAUNCHED&quot;, &quot;metadata&quot;: { &quot;name&quot;: &quot;description of your chain and all other relevant information&quot;, &quot;description&quot;: &quot;some metadata about your chain&quot;, &quot;metadata&quot;: &quot;pion-1&quot; }, &quot;initParams&quot;: { &quot;initialHeight&quot;: { &quot;revisionHeight&quot;: &quot;1&quot; }, &quot;genesisHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;binaryHash&quot;: &quot;2D5C2110941DA54BE07CBB9FACD7E4A2E3253E79BE7BE3E5A1A7BDA518BAA4BE&quot;, &quot;spawnTime&quot;: &quot;2023-03-11T17:02:14.718477Z&quot;, &quot;unbondingPeriod&quot;: &quot;2419200s&quot;, &quot;ccvTimeoutPeriod&quot;: &quot;2419200s&quot;, &quot;transferTimeoutPeriod&quot;: &quot;3600s&quot;, &quot;consumerRedistributionFraction&quot;: &quot;0.75&quot;, &quot;blocksPerDistributionTransmission&quot;: &quot;1500&quot;, &quot;historicalEntries&quot;: &quot;1000&quot; }, &quot;powerShapingParams&quot;: { &quot;topN&quot;: 100, &quot;validatorSetCap&quot;: 50, &quot;minStake&quot;: &quot;1000&quot;, &quot;allowInactiveVals&quot;: true } , &quot;infraction_parameters&quot;:{ &quot;double_sign&quot;:{ &quot;slash_fraction&quot;:&quot;0.050000000000000000&quot;, &quot;jail_duration&quot;:&quot;9223372036.854775807s&quot;, &quot;tombstone&quot;: true }, &quot;downtime&quot;:{ &quot;slash_fraction&quot;:&quot;0.000000000000000000&quot;, &quot;jail_duration&quot;:&quot;600s&quot;, &quot;tombstone&quot;: false } } }   Consumer Genesis Time​  The consumer_genesis_time endpoint allows to query the genesis time of the consumer chain associated with the consumer id.  interchain_security/ccv/provider/consumer_genesis_time/{consumer_id}   Example curl http://localhost:1317/interchain_security/ccv/provider/consumer_genesis_time/0 Output: { &quot;genesis_time&quot;:&quot;2024-10-18T08:29:46.153234Z&quot; }  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}