"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2338],{4029:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var i=t(5893),s=t(1151);const o={sidebar_position:15,title:"Epochs"},r="ADR 014: Epochs",a={id:"adrs/adr-014-epochs",title:"Epochs",description:"Changelog",source:"@site/versioned_docs/version-v6.1.0/adrs/adr-014-epochs.md",sourceDirName:"adrs",slug:"/adrs/adr-014-epochs",permalink:"/interchain-security/v6.1.0/adrs/adr-014-epochs",draft:!1,unlisted:!1,tags:[],version:"v6.1.0",sidebarPosition:15,frontMatter:{sidebar_position:15,title:"Epochs"},sidebar:"tutorialSidebar",previous:{title:"Slashing on the provider for consumer equivocation",permalink:"/interchain-security/v6.1.0/adrs/adr-013-equivocation-slashing"},next:{title:"Partial Set Security",permalink:"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security"}},c={},h=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"adr-014-epochs",children:"ADR 014: Epochs"}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"2024-01-05: Proposed, first draft of ADR."}),"\n",(0,i.jsx)(n.li,{children:"2024-02-29: Updated so that it describes the implementation where we store the whole consumer validator set."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,i.jsx)(n.p,{children:"Accepted"}),"\n",(0,i.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,i.jsxs)(n.p,{children:["In every block that the provider valset changes, a ",(0,i.jsx)(n.code,{children:"VSCPacket"})," must be sent to every consumer and a corresponding ",(0,i.jsx)(n.code,{children:"VSCMaturedPacket"})," sent back.\nGiven that the validator powers may change very often on the provider chain (e.g., the Cosmos Hub), this approach results in a large workload for the relayers.\nAlthough the validator powers may change very often, these changes are usually small and have an insignificant impact on the chain's security.\nIn other words, the valset on the consumers can be slightly outdated without affecting security.\nAs a matter of fact, this already happens due to relaying delays."]}),"\n",(0,i.jsxs)(n.p,{children:["As a solution, this ADR introduces the concept of ",(0,i.jsx)(n.em,{children:"epochs"}),".\nAn epoch consists of multiple blocks.\nThe provider sends ",(0,i.jsx)(n.code,{children:"VSCPacket"}),"s once per epoch.\nA ",(0,i.jsx)(n.code,{children:"VSCPacket"})," contains all the validator updates that are needed by a consumer chain."]}),"\n",(0,i.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsx)(n.p,{children:"The implementation of epochs requires the following changes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"For each consumer chain, we store the consumer validator set that is currently (i.e., in this epoch) validating the\nconsumer chain. For each validator in the set we store i) its voting power, and ii) the public key that it is\nusing on the consumer chain during the current (i.e., ongoing) epoch.\nThe initial consumer validator set for a chain is set during the creation of the consumer genesis."}),"\n",(0,i.jsxs)(n.li,{children:["We introduce the ",(0,i.jsx)(n.code,{children:"BlocksPerEpoch"})," param that sets the number of blocks in an epoch. By default, ",(0,i.jsx)(n.code,{children:"BlocksPerEpoch"})," is\nset to be 600 which corresponds to 1 hour, assuming 6 seconds per block. This param can be changed through\na ",(0,i.jsx)(n.em,{children:"governance proposal"}),". In the provider ",(0,i.jsx)(n.code,{children:"EndBlock"})," we check ",(0,i.jsx)(n.code,{children:"BlockHeight() % BlocksPerEpoch() == 0"}),"\nto decide when an epoch has ended."]}),"\n",(0,i.jsxs)(n.li,{children:["At the end of every epoch, if there were validator set changes on the provider, then for every consumer chain, we\nconstruct a ",(0,i.jsx)(n.code,{children:"VSCPacket"})," with all the validator updates and add it to the list of ",(0,i.jsx)(n.code,{children:"PendingVSCPackets"}),". We compute the\nvalidator updates needed by a consumer chain by comparing the stored list of consumer validators with the current\nbonded validators on the provider, with something similar to this:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"// get the valset that has been validating the consumer chain during this epoch \ncurrentValidators := GetConsumerValSet(consumerChain)\n// generate the validator updates needed to be sent through a `VSCPacket` by comparing the current validators \n// in the epoch with the latest bonded validators\nvalUpdates := DiffValidators(currentValidators, stakingmodule.GetBondedValidators())\n// update the current validators set for the upcoming epoch to be the latest bonded validators instead\nSetConsumerValSet(stakingmodule.GetBondedValidators())\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that a validator can change its consumer public key for a specific consumer chain an arbitrary amount of times during\na block and during an epoch. Then, when we generate the validator updates in ",(0,i.jsx)(n.code,{children:"DiffValidators"}),", we have to check whether\nthe current consumer public key (retrieved by calling ",(0,i.jsx)(n.code,{children:"GetValidatorConsumerPubKey"}),") is different from the consumer public\nkey the validator was using in the current epoch."]}),"\n",(0,i.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,i.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reduce the cost of relaying."}),"\n",(0,i.jsx)(n.li,{children:"Reduce the amount of IBC packets needed for ICS."}),"\n",(0,i.jsxs)(n.li,{children:["Simplifies ",(0,i.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/main/docs/docs/adrs/adr-001-key-assignment.md",children:"key-assignment code"})," because\nwe only need to check if the ",(0,i.jsx)(n.code,{children:"consumer_public_key"})," has been modified since the last epoch to generate an update."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Increase the delay in the propagation of validator set changes (but for reasonable epoch lengths on the order of ~hours or less, this is unlikely to be significant)."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,i.jsx)(n.p,{children:"N/A"}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/issues/1087",children:"EPIC"})}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>r});var i=t(7294);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);