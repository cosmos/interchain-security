"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9834],{32:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var n=i(5893),a=i(1151);const o={sidebar_position:7},s="Power Shaping",r={id:"features/power-shaping",title:"Power Shaping",description:"To give consumer chains more flexibility in choosing their validator set, Interchain Security offers",source:"@site/versioned_docs/version-v4.5.0/features/power-shaping.md",sourceDirName:"features",slug:"/features/power-shaping",permalink:"/interchain-security/v4.5.0/features/power-shaping",draft:!1,unlisted:!1,tags:[],version:"v4.5.0",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Partial Set Security",permalink:"/interchain-security/v4.5.0/features/partial-set-security"},next:{title:"Developing an ICS consumer chain",permalink:"/interchain-security/v4.5.0/consumer-development/app-integration"}},h={},l=[{value:"Guidelines for setting power shaping parameters",id:"guidelines-for-setting-power-shaping-parameters",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"power-shaping",children:"Power Shaping"}),"\n",(0,n.jsx)(t.p,{children:'To give consumer chains more flexibility in choosing their validator set, Interchain Security offers\nseveral "power shaping" mechanisms for consumer chains.'}),"\n",(0,n.jsx)(t.p,{children:"These are:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Capping the size of the validator set"}),": The consumer chain can specify a maximum number of validators it\nwants to have in its validator set. This can be used to limit the number of validators in the set, which can\nbe useful for chains that want to have a smaller validator set for faster blocks or lower overhead. If more validators\nthan the maximum size have opted in on a consumer chain, only the validators with the highest power, up to the specified\nmaximum, will validate the consumer chain."]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"This is only applicable to Opt In chains (chains with Top N = 0)."})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Capping the fraction of power any single validator can have"}),": The consumer chain can specify a maximum fraction\nof the total voting power that any single validator in its validator set should have.\nThis is a security measure with the intention of making it harder for a single large validator to take over a consumer chain. This mitigates the risk of an Opt In chain with only a few validators being dominated by a validator with a large amount of stake opting in.\nFor example, setting this fraction to e.g. 33% would mean that no single validator can have more than 33% of the total voting power,\nand thus there is no single validator who would stop the chain by going offline."]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"This is a soft cap, and the actual power of a validator can exceed this fraction if the validator set is small (e.g. there are only 3 validators and the cap is 20%)."})}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"Rewards are distributed proportionally to validators with respect to their capped voting power on the consumer,\nnot their total voting power on the provider."})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Allowlist and denylist"}),": The consumer chain can specify a list of validators that are allowed or disallowed from participating in the validator set. If an allowlist is set, all validators not on the allowlist cannot validate the consumer chain. If a validator is on both lists, the denylist takes precedence, that is, they cannot validate the consumer chain. If neither list is set, all validators are able to validate the consumer chain."]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"warning",children:(0,n.jsxs)(t.p,{children:["Note that if denylisting is used in a Top N consumer chain, then the chain might not be secured by N% of the total provider's\npower. For example, consider that the top validator ",(0,n.jsx)(t.code,{children:"V"})," on the provider chain has 10% of the voting power, and we have a Top 50% consumer chain,\nthen if ",(0,n.jsx)(t.code,{children:"V"})," is denylisted, the consumer chain would only be secured by at least 40% of the provider's power."]})}),"\n",(0,n.jsxs)(t.p,{children:["All these mechanisms are set by the consumer chain in the ",(0,n.jsx)(t.code,{children:"ConsumerAdditionProposal"}),". They operate ",(0,n.jsx)(t.em,{children:"solely on the provider chain"}),", meaning the consumer chain simply receives the validator set after these rules have been applied and does not have any knowledge about whether they are applied."]}),"\n",(0,n.jsxs)(t.p,{children:["Each of these mechanisms is ",(0,n.jsx)(t.em,{children:"set during the consumer addition proposal"})," (see ",(0,n.jsx)(t.a,{href:"/interchain-security/v4.5.0/consumer-development/onboarding#3-submit-a-governance-proposal",children:"Onboarding"}),"), and is currently ",(0,n.jsx)(t.em,{children:"immutable"})," after the chain has been added."]}),"\n",(0,n.jsx)(t.p,{children:"The values can be seen by querying the list of consumer chains:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"interchain-security-pd query provider list-consumer-chains\n"})}),"\n",(0,n.jsx)(t.h2,{id:"guidelines-for-setting-power-shaping-parameters",children:"Guidelines for setting power shaping parameters"}),"\n",(0,n.jsx)(t.p,{children:"When setting power shaping parameters, please consider the following guidelines:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Do not cap the validator set size too low: Notice that this number is the *",(0,n.jsx)(t.em,{children:"maximum"})," number of validators that will ever validate the consumer chain. If this number is too low, the chain will be very limited in the\namount of stake that secures it. The validator set size cap should only be used if there are strong reasons to prefer fewer validators. Consider that setting the cap will mean that\neven if the whole validator set of the provider wants to validate on the chain, some validators will simply not be able to."]}),"\n",(0,n.jsx)(t.li,{children:"Capping the fraction of power any single validator can have is a decent security measure, but it's good to be aware of the interactions with the size of the validator set.\nFor example, if there are only 3 validators, and the cap is 20%, this will not be possible (since even splitting the power fairly would mean that each validator has 33% of the power, so is above the cap).\nHowever, the cap can be a good measure to prevent a single large validator from essentially taking over the chain.\nIn general, values under 33% make sense (since a validator that has 33% of the chains power would halt the chain if they go offline).\nNotice that the smaller this value is, the more the original voting power gets distorted, which could discourage large validators from deciding to opt in to the chain."}),"\n",(0,n.jsxs)(t.li,{children:["If the allowlist is ",(0,n.jsx)(t.em,{children:"empty"}),", all validators can validate the chain. If it is ",(0,n.jsx)(t.em,{children:"non empty"}),", then ",(0,n.jsx)(t.em,{children:"only"})," validators on the allowlist can validate the chain.\nThus, an allowlist containing too few validators is a security risk. In particular, consider that if the validators on the allowlist lose a lot of stake or stop being validators,\nan allowlist that is too short can very quickly become outdated and leave too few validators, or validators with too little stake, to secure the chain in a decentralized way."]}),"\n",(0,n.jsx)(t.li,{children:"If the denylist is too full, this can likewise be problematic. If too many large validators are denylisted, the chain might not be secured by a large enough fraction of the provider's power, in particular when\nthe power distribution on the provider shifts and the denylisted validators gain more power."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"In general, when setting these parameters, consider that the voting power distribution in the future might be very different from the one right now,\nand that the chain should be secure even if the power distribution changes significantly."}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsxs)(t.p,{children:["The power shaping parameters of a running consumer chain can be changed through a ",(0,n.jsx)(t.a,{href:"/interchain-security/v4.5.0/features/proposals#consumermodificationproposal",children:(0,n.jsx)(t.code,{children:"ConsumerModificationProposal"})}),"."]})})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>s});var n=i(7294);const a={},o=n.createContext(a);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);