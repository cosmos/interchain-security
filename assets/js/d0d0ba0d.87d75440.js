"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8772],{9133:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>h});var s=t(5893),o=t(1151);const a={sidebar_position:11,title:"Standalone to Consumer Changeover"},r=void 0,i={id:"adrs/adr-010-standalone-changeover",title:"Standalone to Consumer Changeover",description:"ADR 010: Standalone to Consumer Changeover",source:"@site/docs/adrs/adr-010-standalone-changeover.md",sourceDirName:"adrs",slug:"/adrs/adr-010-standalone-changeover",permalink:"/interchain-security/adrs/adr-010-standalone-changeover",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11,title:"Standalone to Consumer Changeover"},sidebar:"tutorialSidebar",previous:{title:"Soft Opt-Out",permalink:"/interchain-security/adrs/adr-009-soft-opt-out"},next:{title:"Improving testing and increasing confidence",permalink:"/interchain-security/adrs/adr-011-improving-test-confidence"}},c={},h=[{value:"ADR 010: Standalone to Consumer Changeover",id:"adr-010-standalone-to-consumer-changeover",level:2},{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Process",id:"process",level:3},{value:"Changes to CCV Protocol",id:"changes-to-ccv-protocol",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"References",id:"references",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"adr-010-standalone-to-consumer-changeover",children:"ADR 010: Standalone to Consumer Changeover"}),"\n",(0,s.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"6/30/23: Feature completed, first draft of ADR."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,s.jsx)(n.p,{children:"Implemented"}),"\n",(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/Stride-Labs/stride",children:"Stride"}),' will be the first consumer to "changeover" from a standalone cosmos blockchain, to a consumer chain secured by the Cosmos Hub. This document outlines the changes made to support this changeover process.']}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsx)(n.h3,{id:"process",children:"Process"}),"\n",(0,s.jsx)(n.p,{children:'Prior to the changeover, the consumer chain will have an existing staking keeper and validator set, these may be referred to as the "standalone staking keeper" and "standalone validator set" respectively.'}),"\n",(0,s.jsx)(n.p,{children:"The first step in the changeover process is to submit a ConsumerAdditionProposal. If the proposal passes, the provider will create a new IBC client for the consumer at spawn time, with the provider's validator set. A consumer genesis will also be constructed by the provider for validators to query. Within this consumer genesis contains the initial validator set for the consumer to apply after the changeover."}),"\n",(0,s.jsx)(n.p,{children:"Next, the standalone consumer chain runs an upgrade which adds the CCV module, and is properly setup to execute changeover logic."}),"\n",(0,s.jsx)(n.p,{children:"The consumer upgrade height must be reached after the provider has created the new IBC client. Any Interchain Security validators who will run the consumer, but are not a part of the sovereign validator set, must sync up a full node before the consumer upgrade height is reached. The disk state of said full node will be used to run the consumer chain after the changeover has completed."}),"\n",(0,s.jsxs)(n.p,{children:["The meat of the changeover logic is that the consumer chain validator set is updated to that which was specified by the provider via the queried consumer genesis. Validators which were a part of the old set, but not the new set, are given zero voting power. Once these validator updates are given to Comet, the set is committed, and in effect 2 blocks later (see ",(0,s.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/f10e780df182158d95a30f7cf94588b2d0479309/x/ccv/consumer/keeper/changeover.go#L19",children:"FirstConsumerHeight"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"A relayer then establishes the new IBC connection between the provider and consumer. The CCV channel handshake is started on top of this connection. Once the CCV channel is established and VSC packets are being relayed, the consumer chain is secured by the provider."}),"\n",(0,s.jsx)(n.h3,{id:"changes-to-ccv-protocol",children:"Changes to CCV Protocol"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Consumer Genesis state is updated to include a ",(0,s.jsx)(n.code,{children:"PreCCV"})," boolean. When this boolean is set true in the  consumer genesis JSON, ",(0,s.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/f10e780df182158d95a30f7cf94588b2d0479309/x/ccv/consumer/keeper/changeover.go",children:"special logic"})," is executed on InitGenesis to trigger the changeover process on the consumer's first endblocker after the upgrade which adds the CCV module. Note that InitGenesis is not automatically called during chain upgrades, so the consumer must manually call the consumer's InitGenesis method in an upgrade handler."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"ConsumerAdditionProposal"})," type is updated to include a ",(0,s.jsx)(n.code,{children:"DistributionTransmissionChannel"})," field. This field allows the consumer to use an existing IBC transfer channel to send rewards as a part of the CCV protocol. Consumers that're not changing over from a standalone chain will leave this field blank, indicating that a new transfer channel should be created on top of the same connection as the CCV channel."]}),"\n",(0,s.jsx)(n.li,{children:"The CCV consumer keeper is updated to contain an optional reference to the standalone staking keeper. The standalone staking keeper is used to slash for infractions that happened before the changeover was completed. Ie. any infraction from a block height before the changeover, that is submitted after the changeover, will call the standalone staking keeper's slash method. Note that a changeover consumer's  standalone staking keeper becomes a democracy module keeper, so it is possible for a governance token to be slashed."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Existing cosmos chains are now able to onboard over to a consumer chain secured by a provider."}),"\n",(0,s.jsx)(n.li,{children:"The previous staking keepers for such chains can be transitioned to democracy staking module keepers."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The delineation between different types of consumers in this repo becomes less clear. Ie. there is code in the ",(0,s.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/f10e780df182158d95a30f7cf94588b2d0479309/app/consumer-democracy/app.go",children:"democracy consumer's app.go"})," that only applies to a previously standalone chain, but that file also serves as the base for a normal democracy consumer launched with RS from genesis."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["EPIC: Standalone to Consumer Changeover ",(0,s.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/issues/756",children:"#756"})]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://app.excalidraw.com/l/9UFOCMAZLAI/5EVLj0WJcwt",children:"Changeover diagram from Stride"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>r});var s=t(7294);const o={},a=s.createContext(o);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);