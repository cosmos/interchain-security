"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7457],{5834:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var t=s(5893),i=s(1151);const r={sidebar_position:20,title:"Permissionless ICS"},a="ADR 019: Permissionless Interchain Security",o={id:"adrs/adr-019-permissionless-ics",title:"Permissionless ICS",description:"Changelog",source:"@site/versioned_docs/version-v6.1.0/adrs/adr-019-permissionless-ics.md",sourceDirName:"adrs",slug:"/adrs/adr-019-permissionless-ics",permalink:"/interchain-security/v6.1.0/adrs/adr-019-permissionless-ics",draft:!1,unlisted:!1,tags:[],version:"v6.1.0",sidebarPosition:20,frontMatter:{sidebar_position:20,title:"Permissionless ICS"},sidebar:"tutorialSidebar",previous:{title:"Remove VSCMatured Packets",permalink:"/interchain-security/v6.1.0/adrs/adr-018-remove-vscmatured"}},c={},h=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"The Phases of a Consumer Chain",id:"the-phases-of-a-consumer-chain",level:3},{value:"From <code>chainId</code> to <code>consumerId</code>",id:"from-chainid-to-consumerid",level:3},{value:"State",id:"state",level:4},{value:"New Messages",id:"new-messages",level:3},{value:"Create a Consumer Chain",id:"create-a-consumer-chain",level:4},{value:"Update a Consumer Chain",id:"update-a-consumer-chain",level:4},{value:"Remove (Stop) a Consumer Chain",id:"remove-stop-a-consumer-chain",level:4},{value:"Examples of Launching a Consumer Chain",id:"examples-of-launching-a-consumer-chain",level:4},{value:"Additional Modifications",id:"additional-modifications",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"adr-019-permissionless-interchain-security",children:"ADR 019: Permissionless Interchain Security"}),"\n",(0,t.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"27th of June, 2024: Initial draft"}),"\n",(0,t.jsx)(n.li,{children:"12th of September, 2024: Updated to take into account message changes, etc."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,t.jsx)(n.p,{children:"Accepted"}),"\n",(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsxs)(n.p,{children:["Currently, a consumer chain can join ",(0,t.jsx)(n.em,{children:"Interchain Security"})," (ICS) only through a ",(0,t.jsx)(n.a,{href:"/interchain-security/v6.1.0/features/proposals",children:"governance proposal"}),".\nA governance proposal was needed before the introduction of ",(0,t.jsx)(n.a,{href:"/interchain-security/v6.1.0/features/partial-set-security",children:"Partial Set Security"})," (PSS)\nbecause validators were required to validate a consumer chain. However, after the introduction of PSS, a consumer chain can\nbe either ",(0,t.jsx)(n.em,{children:"Top N"})," or ",(0,t.jsx)(n.em,{children:"Opt In"}),". If a chain is an Opt In chain, then no validator is required to validate this chain unless they choose to.\nBecause of this, we can launch an Opt In consumer chain without going through a governance proposal."]}),"\n",(0,t.jsxs)(n.p,{children:["This ADR presents ",(0,t.jsx)(n.em,{children:"Permissionless"})," ICS, a way in which an ",(0,t.jsx)(n.a,{href:"/interchain-security/v6.1.0/adrs/adr-015-partial-set-security",children:(0,t.jsx)(n.em,{children:"Opt In"})})," consumer chain can join\nICS without needing a governance proposal but by simply issuing a transaction."]}),"\n",(0,t.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsx)(n.p,{children:"In Permissionless ICS, launching an Opt In chain can be done by issuing a transaction.\nNaturally, Permissionless ICS does not eliminate governance proposals, as proposals are still necessary for Top N chains.\nNevertheless, a Top N chain can transform to an Opt In chain through a gov proposal and vice versa."}),"\n",(0,t.jsx)(n.h3,{id:"the-phases-of-a-consumer-chain",children:"The Phases of a Consumer Chain"}),"\n",(0,t.jsxs)(n.p,{children:["We first present the notion of an ",(0,t.jsx)(n.em,{children:"owner"})," of a consumer chain before showing the specific phases of a consumer chain."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Owner."})," A consumer chain has an ",(0,t.jsx)(n.em,{children:"owner"}),", which is simply an address. Only the owner can interact (i.e., launch, update, or stop)\nwith the chain. The owner of an Opt In chain is the one who signed the initial transaction to register a consumer chain (more on this later).\nNaturally, an Opt In chain can change its owner at any point. The owner of a Top N chain is the account of the governance module.\nTherefore, any changes on a Top N chain have to go through governance proposals."]}),"\n",(0,t.jsxs)(n.p,{children:["A consumer chain can reside in five phases: i) ",(0,t.jsx)(n.em,{children:"registered"}),", ii) ",(0,t.jsx)(n.em,{children:"initialized"}),", iii) ",(0,t.jsx)(n.em,{children:"launched"}),", iv) ",(0,t.jsx)(n.em,{children:"stopped"}),", and\nv) ",(0,t.jsx)(n.em,{children:"deleted"})," phase as seen in the diagram below:\n",(0,t.jsx)(n.img,{alt:"Phases of a consumer chain",src:s(9337).Z+"",width:"2459",height:"1457"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Registered phase."})," In the ",(0,t.jsx)(n.em,{children:"registered phase"}),", a consumer chain has an assigned a unique identifier, that of ",(0,t.jsx)(n.code,{children:"consumerId"})," (more on this later)\nthat identifies a consumer chain that is used to interact with the chain (e.g., when a validator opts in on a chain, etc.).\nA chain is created and resides at the registered phase through the use of a ",(0,t.jsx)(n.code,{children:"MsgCreateConsumer"})," which response contains the ",(0,t.jsx)(n.code,{children:"consumerId"}),".\n",(0,t.jsx)(n.code,{children:"MsgCreateConsumer"})," is the first step in creating either a Top N or an Opt In consumer chain."]}),"\n",(0,t.jsxs)(n.p,{children:["If all the optional initialization parameters are provided in ",(0,t.jsx)(n.code,{children:"MsgCreateConsumer"}),", then an Opt In chain\ncan immediately move to the initialized phase (see below) and get scheduled to launch.\nNote, however that a Top N chain needs at least two more ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"})," messages and one gov proposal to be able to launch."]}),"\n",(0,t.jsxs)(n.p,{children:["In the registered phase, it is not yet known if the consumer chain would end up being a Top N or an Opt In chain and hence\nthe owner of the consumer chain at this phase is the one that signed the ",(0,t.jsx)(n.code,{children:"MsgCreateConsumer"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Initialized phase."})," The ",(0,t.jsx)(n.em,{children:"initialized phase"})," means that the chain has set all the needed initialization parameters\nto launch but has not yet launched.\nIf a chain in the registered phase has not yet set the initialization parameters, it can issue a ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"}),"\nmessage to set those parameters. Additionally, ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"})," can be used to set up other parameters, such as the ",(0,t.jsx)(n.a,{href:"https://cosmos.github.io/interchain-security/features/power-shaping",children:"power-shaping parameters"}),".\nIf a chain is in the initialized phase and ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"})," is issued with spawn time being zero, the chain moves back\nto the registered phase."]}),"\n",(0,t.jsxs)(n.p,{children:["In order to move a Top N chain to the initialized phase, we need to issue at least two ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"})," messages:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"one to change the owner of the chain to be the account of the governance module;"}),"\n",(0,t.jsx)(n.li,{children:"another as part of a governance proposal to set the Top N."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Launched phase."})," In the ",(0,t.jsx)(n.em,{children:"launched phase"})," the consumer chain is running and is consuming a subset of the validator set\nof the provider. When the ",(0,t.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/v5.1.0/proto/interchain_security/ccv/provider/v1/provider.proto#L57",children:(0,t.jsx)(n.code,{children:"spawnTime"})}),"\npasses and ",(0,t.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/v5.1.0/x/ccv/provider/keeper/proposal.go#L430",children:"at least one validator has opted in"}),"\nthe chain can launch and moves to the launched phase. Note that a Top N chain can launch if and only if the ",(0,t.jsx)(n.code,{children:"spawnTime"})," has passed and\nthe proposal with the ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"})," has successfully passed. While in launched phase, a consumer chain can choose to modify\nits parameters through ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"}),". Naturally, only the owner of the chain can issue ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"}),", thus\nfor Top N chains, the chain can be updated only through a governance proposal that contains a ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"}),".\nAdditionally, note that after the chain moves to the launched phase, the initialization parameters cannot be updated anymore,\nbut general metadata and power-shaping parameters of the chain can still be updated."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Stopped phase."})," In the ",(0,t.jsx)(n.em,{children:"stopped phase"})," the consumer chain stops receiving ",(0,t.jsx)(n.code,{children:"VSCPacket"}),"s.\nA chain moves to the stopped phase, when the owner of the chain sends the ",(0,t.jsx)(n.code,{children:"MsgRemoveConsumer"})," message."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Deleted phase."})," In the ",(0,t.jsx)(n.em,{children:"deleted phase"})," the majority of the state in relation to this consumer chain is deleted from the provider.\nA chain moves to the deleted phase after the chain has been stopped for an unbonding period.\nWe keep track of the state of the consumer chain for an unbonding period, so that we are able to punish validators for misbehaviors\nthat occurred before the consumer chain stopped.\nAdditionally, we do not fully delete the whole state of this chain, so that we can still query parameters a deleted chain used to have.\nThis is useful for front-ends, etc."]}),"\n",(0,t.jsx)(n.p,{children:"Note that everything described so far and everything that follows applies to consumer chains that transition from standalone chains as well."}),"\n",(0,t.jsxs)(n.h3,{id:"from-chainid-to-consumerid",children:["From ",(0,t.jsx)(n.code,{children:"chainId"})," to ",(0,t.jsx)(n.code,{children:"consumerId"})]}),"\n",(0,t.jsxs)(n.p,{children:["A hindrance in moving to Permissionless ICS is ",(0,t.jsx)(n.a,{href:"https://forum.cosmos.network/t/pss-permissionless-vs-premissioned-lite-opt-in-consumer-chains/12984/17",children:"chain-id squatting"}),".\nIn a permissionless setting, anyone could issue a transaction to launch a consumer chain with a ",(0,t.jsx)(n.code,{children:"chainId"})," that might already be used by some other consumer chain. This is a problem\nbecause in the current design the majority of stored state for a consumer chain is indexed using the ",(0,t.jsx)(n.code,{children:"chainId"})," as the key (e.g.,\nsee ",(0,t.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/v5.1.0/x/ccv/provider/types/keys.go#L245",children:"key used to store client ids"}),").\nTo tackle this problem, in Permissionless ICS, we introduce the ",(0,t.jsx)(n.code,{children:"consumerId"})," that defines a consumer chain and is simply\nan increasing counter (i.e., ",(0,t.jsx)(n.code,{children:"counter"}),"), thus we can support multiple consumer chains with the same ",(0,t.jsx)(n.code,{children:"chainId"}),".\nAnother way to understand this is with an analogy between consumer chains and IBC clients: Imagine having multiple IBC clients\nthat each point to different consumer chains, but all share the exact same ",(0,t.jsx)(n.code,{children:"chainId"}),". It is then up to the user to select the\nappropriate client (i.e., ",(0,t.jsx)(n.code,{children:"clientId"}),") based on the actual chain they want to communicate with. Similarly, there can be multiple\nconsumer chains with the exact same ",(0,t.jsx)(n.code,{children:"chainId"}),", and it is the responsibility of the validators to choose the one they wish\nto interact with by providing the right ",(0,t.jsx)(n.code,{children:"consumerId"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that with Permissionless ICS, all interactions on a consumer chain have to use the ",(0,t.jsx)(n.code,{children:"consumerId"})," instead of the ",(0,t.jsx)(n.code,{children:"chainId"}),".\nFor example, if a validator opts in on a chain using ",(0,t.jsx)(n.code,{children:"MsgOptIn"}),", the validator has to provide the ",(0,t.jsx)(n.code,{children:"consumerId"}),".\nSpecifically, for the equivocation evidence, we update the ",(0,t.jsx)(n.code,{children:"MsgSubmitConsumerMisbehaviour"})," and ",(0,t.jsx)(n.code,{children:"MsgSubmitConsumerDoubleVoting"}),"\nmessages to include the ",(0,t.jsx)(n.code,{children:"consumerId"}),", and modify ",(0,t.jsx)(n.a,{href:"https://github.com/informalsystems/hermes",children:"Hermes"}),"\nto include ",(0,t.jsx)(n.code,{children:"consumerId"})," in those constructed messages as well.\nHermes can find out the ",(0,t.jsx)(n.code,{children:"consumerId"})," by querying the provider's ",(0,t.jsx)(n.code,{children:"clientId"})," for some consumer chain (i.e., ",(0,t.jsx)(n.code,{children:"query ccvconsumer provider-info"}),")\nand then asking the provider chain for the ",(0,t.jsx)(n.code,{children:"consumerId"})," that corresponds to this ",(0,t.jsx)(n.code,{children:"clientId"}),". To do this, we store\nthe ",(0,t.jsx)(n.code,{children:"clientId"})," to ",(0,t.jsx)(n.code,{children:"consumerId"})," association on the provider and introduce a query to retrieve the ",(0,t.jsx)(n.code,{children:"clientId"})," given the ",(0,t.jsx)(n.code,{children:"consumerId"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"state",children:"State"}),"\n",(0,t.jsxs)(n.p,{children:["As a result of using ",(0,t.jsx)(n.code,{children:"consumerId"}),", we have to migrate a substantial chunk of state to re-index it using ",(0,t.jsx)(n.code,{children:"consumerId"})," as the key.\nCurrently, in ICS we have state that is indexed by a multitude of ",(0,t.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/v5.1.0/x/ccv/provider/types/keys.go#L40",children:"keys"}),".\nIn the table below, we see the ones that are associated with a ",(0,t.jsx)(n.code,{children:"chainId"})," and how often state under those keys gets updated.\nAdditionally, for each key, the table shows whose action can lead to the setting or deletion of the state associated with that key.\nAn action can stem either from: i) a consumer chain (e.g., through a ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"})," message, an IBC packet sent over to the provider, etc.),\nii) a provider chain (e.g., at the end of a block some action is taken), or by iii) a validator (e.g., through a ",(0,t.jsx)(n.code,{children:"MsgAssignConsumerKey"})," message)\nor a combination of them."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Key"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Who can set this?"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Who can delete this?"}),(0,t.jsxs)(n.th,{children:["How often are ",(0,t.jsx)(n.code,{children:"chainId"}),"-associated keys updated?"]})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ChainToChannelBytePrefix"})}),(0,t.jsxs)(n.td,{children:["Stores the CCV ",(0,t.jsx)(n.code,{children:"channelID"})," for a specific chain"]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{children:"Only once (during set up)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ChannelToChainBytePrefix"})}),(0,t.jsxs)(n.td,{children:["Stores ",(0,t.jsx)(n.code,{children:"chainId"})," for a specific channel"]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{children:"Only once (during set up)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ChainToClientBytePrefix"})}),(0,t.jsxs)(n.td,{children:["Stores the ",(0,t.jsx)(n.code,{children:"clientID"})," for a specific chain"]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{children:"Only once (during set up)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PendingCAPBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores pending consumer addition proposals"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"provider chain"}),(0,t.jsx)(n.td,{children:"Only once (for successful proposal)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PendingCRPBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores pending consumer removal proposals"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"provider chain"}),(0,t.jsx)(n.td,{children:"Only once (for successful proposal)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ConsumerGenesisBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores the consumer genesis for a specific chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{children:"Only once (during set up)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SlashAcksBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores slash acks for a specific consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"provider chain"}),(0,t.jsx)(n.td,{children:"Every time we receive a Slash packet"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PendingVSCsBytePrefix"})}),(0,t.jsxs)(n.td,{children:["Stores ",(0,t.jsx)(n.code,{children:"VSCPacket"}),"s for a specific consumer chain"]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"provider chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"provider chain"}),(0,t.jsxs)(n.td,{children:["Every ",(0,t.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/v5.1.0/docs/docs/adrs/adr-014-epochs.md",children:"epoch"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ConsumerValidatorsBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores consumer key per validator per consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"validator"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsxs)(n.td,{children:["Every ",(0,t.jsx)(n.code,{children:"MsgAssignConsumerKey"})," or ",(0,t.jsx)(n.code,{children:"MsgOptIn"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ValidatorsByConsumerAddrBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores consumer to provider validator address"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"validator"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer or provider chain"}),(0,t.jsxs)(n.td,{children:["Every ",(0,t.jsx)(n.code,{children:"MsgAssignConsumerKey"})," or ",(0,t.jsx)(n.code,{children:"MsgOptIn"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"EquivocationEvidenceMinHeightBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores min height for a consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{children:"Only once (during set up)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ProposedConsumerChainByteKey"})}),(0,t.jsxs)(n.td,{children:["Stores ",(0,t.jsx)(n.code,{children:"proposalID"}),"s for consumer chains with proposals in the voting period"]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"not applicable for Opt In chains"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"not applicable for Opt In chains"}),(0,t.jsx)(n.td,{children:"Created when the proposal is submitted and deleted when the proposal's voting period ends"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ConsumerValidatorBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores consumer validators for a specific chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"validator"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"validator or consumer chain"}),(0,t.jsx)(n.td,{children:"Potentially at every epoch"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"OptedInBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores opted-in validators for a specific chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"validator"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"validator or consumer chain"}),(0,t.jsx)(n.td,{children:"Potentially at every block"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"TopNBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores whether a consumer chain is Top N or not"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"not applicable for Opt In chains"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"not applicable for Opt In chains"}),(0,t.jsx)(n.td,{children:"Every parameter update"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ValidatorsPowerCapPrefix"})}),(0,t.jsx)(n.td,{children:"Stores the power cap of a chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{children:"Every parameter update"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ValidatorSetCapPrefix"})}),(0,t.jsx)(n.td,{children:"Stores the set cap of a chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{children:"Every parameter update"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"AllowlistPrefix"})}),(0,t.jsx)(n.td,{children:"Stores the allowlist of a chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{children:"Every parameter update"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"DenylistPrefix"})}),(0,t.jsx)(n.td,{children:"Stores the denylist of a chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsx)(n.td,{children:"Every parameter update"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ConsumerRewardsAllocationBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores the ICS rewards per chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer or provider chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"provider chain"}),(0,t.jsx)(n.td,{children:"Every IBC transfer packet that sends rewards to the provider"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ConsumerCommissionRatePrefix"})}),(0,t.jsx)(n.td,{children:"Commission rate per chain per validator"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"validator"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"consumer chain"}),(0,t.jsxs)(n.td,{children:["Every ",(0,t.jsx)(n.code,{children:"MsgSetConsumerCommissionRate"})," message"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"MinimumPowerInTopNBytePrefix"})}),(0,t.jsx)(n.td,{children:"Stores the minimum power needed to opt in for a chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"not applicable for Opt In chains"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"not applicable for Opt In chains"}),(0,t.jsx)(n.td,{children:"Every epoch"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ConsumerAddrsToPruneV2BytePrefix"})}),(0,t.jsxs)(n.td,{children:["Stores consumer addresses to be pruned (as part of ",(0,t.jsx)(n.code,{children:"VSCMaturedPacket"}),"s deprecation)"]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"validator or provider chain"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"provider chain"}),(0,t.jsxs)(n.td,{children:["Every ",(0,t.jsx)(n.code,{children:"MsgAssignConsumerKey"})," or ",(0,t.jsx)(n.code,{children:"MsgOptIn"})," and later during actual pruning"]})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Everything stored under one of the above keys is associated with a ",(0,t.jsx)(n.code,{children:"chainId"})," and has to be migrated to new state under a ",(0,t.jsx)(n.code,{children:"consumerId"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"new-messages",children:"New Messages"}),"\n",(0,t.jsxs)(n.p,{children:["In this section, we describe the new messages (i.e., ",(0,t.jsx)(n.code,{children:"MsgCreateConsumer"}),",  ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"}),", and ",(0,t.jsx)(n.code,{children:"MsgRemoveConsumer"}),") that Permissionless ICS introduces."]}),"\n",(0,t.jsx)(n.h4,{id:"create-a-consumer-chain",children:"Create a Consumer Chain"}),"\n",(0,t.jsx)(n.p,{children:"We first have to create a chain before launching it, irrespectively of whether it is Top N or Opt In.\nThis is done through the following message:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'message MsgCreateConsumer {\n  option (cosmos.msg.v1.signer) = "submitter";\n\n  // Submitter address. If the message is successfully handled, the ownership of \n  // the consumer chain will given to this address.\n  string submitter = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];\n\n  // the chain id of the new consumer chain\n  string chain_id = 2;\n\n  ConsumerMetadata metadata = 3 [ (gogoproto.nullable) = false ];\n\n  ConsumerInitializationParameters initialization_parameters = 4;\n\n  PowerShapingParameters power_shaping_parameters = 5;\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Note that ",(0,t.jsx)(n.code,{children:"metadata"})," is a required field, while the ",(0,t.jsx)(n.code,{children:"initialization_parameterrs"})," and ",(0,t.jsx)(n.code,{children:"power_shaping_parameters"})," are optional and can later be set using ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"metadata"})," is of the following type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:"message ConsumerMetadata {\n  // the name of the chain\n  string name = 1;\n  // the description of the chain\n  string description = 2;\n  // the metadata (e.g., GitHub repository URL) of the chain\n  string metadata = 3;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"initialization_parameters"})," is of the following type and if all are provided the chain is scheduled to launch:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'// ConsumerInitializationParameters are the parameters needed to launch a chain\nmessage ConsumerInitializationParameters {\n  // ---------- ---------- ----------\n  // Following fields are used when the consumer chain launches and are not needed by the provider afterwards.\n  // ---------- ---------- ----------\n\n  // the proposed initial height of new consumer chain.\n  // For a completely new chain, this will be {0,1}. However, it may be\n  // different if this is a chain that is converting to a consumer chain.\n  ibc.core.client.v1.Height initial_height = 1 [ (gogoproto.nullable) = false ];\n  // The hash of the consumer chain genesis state without the consumer CCV\n  // module genesis params. It is used for off-chain confirmation of\n  // genesis.json validity by validators and other parties.\n  bytes genesis_hash = 2;\n  // The hash of the consumer chain binary that should be run by validators on\n  // chain initialization. It is used for off-chain confirmation of binary\n  // validity by validators and other parties.\n  bytes binary_hash = 3;\n  // spawn time is the time on the provider chain at which the consumer chain\n  // genesis is finalized and all validators will be responsible for starting\n  // their consumer chain validator node.\n  google.protobuf.Timestamp spawn_time = 4 [ (gogoproto.nullable) = false, (gogoproto.stdtime) = true ];\n  // Unbonding period for the consumer,\n  // which should be smaller than that of the provider in general.\n  google.protobuf.Duration unbonding_period = 5  [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];\n\n\n  // ---------- ---------- ----------\n  // Following fields are used to construct the consumer genesis of the to-be-launched consumer chain\n  // and are set up as params on the consumer chain. Those params can then be directly modified by the consumer chain.\n  // ---------- ---------- ----------\n\n  // Sent CCV related IBC packets will timeout after this duration\n  google.protobuf.Duration ccv_timeout_period = 6  [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];\n  // Sent transfer related IBC packets will timeout after this duration\n  google.protobuf.Duration transfer_timeout_period = 7 [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];\n  // The fraction of tokens allocated to the consumer redistribution address\n  // during distribution events. The fraction is a string representing a\n  // decimal number. For example "0.75" would represent 75%.\n  string consumer_redistribution_fraction = 8;\n  // BlocksPerDistributionTransmission is the number of blocks between\n  // ibc-token-transfers from the consumer chain to the provider chain. On\n  // sending transmission event, `consumer_redistribution_fraction` of the\n  // accumulated tokens are sent to the consumer redistribution address.\n  int64 blocks_per_distribution_transmission = 9;\n  // The number of historical info entries to persist in store.\n  // This param is a part of the cosmos sdk staking module. In the case of\n  // a ccv enabled consumer chain, the ccv module acts as the staking module.\n  int64 historical_entries = 10;\n  // The ID of a token transfer channel used for the Reward Distribution\n  // sub-protocol. If DistributionTransmissionChannel == "", a new transfer\n  // channel is created on top of the same connection as the CCV channel.\n  // Note that transfer_channel_id is the ID of the channel end on the consumer\n  // chain. it is most relevant for chains performing a sovereign to consumer\n  // changeover in order to maintain the existing ibc transfer channel\n  string distribution_transmission_channel = 11;\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"power_shaping_parameters"})," is of the following type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'// PowerShapingParameters contains parameters that shape the validator set that we send to the consumer chain\nmessage PowerShapingParameters {\n  // Corresponds to the percentage of validators that have to validate the chain under the Top N case.\n  // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power\n  // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100].\n  // A chain can join with top_N == 0 as an Opt In chain, or with top_N \u2208 [50, 100] as a Top N chain.\n  uint32 top_N = 1;\n  // `validators_power_cap` corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain.\n  // For instance, if `validators_power_cap` is set to 32, no validator can have more than 32% of the total voting power of the\n  // consumer chain. The power cap is intended as a safeguard against a validator having too much power on the consumer\n  // chain and hence "taking over" the consumer chain.\n  uint32 validators_power_cap = 2;\n  // Corresponds to the maximum number of validators that can validate a consumer chain.\n  // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.\n  uint32 validator_set_cap = 3;\n  // corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate the consumer chain\n  repeated string allowlist = 4;\n  // corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain\n  repeated string denylist = 5;\n  // Corresponds to the minimal amount of (provider chain) stake required to validate on the consumer chain.\n  uint64 min_stake = 6;\n  // Corresponds to whether inactive validators are allowed to validate the consumer chain.\n  bool allow_inactive_vals = 7;\n}\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This ",(0,t.jsx)(n.code,{children:"MsgCreateConsumerResponse"})," response contains a single ",(0,t.jsx)(n.code,{children:"string"})," that is the ",(0,t.jsx)(n.code,{children:"consumerId"})," for this registered consumer chain"]}),"\n",(0,t.jsx)(n.h4,{id:"update-a-consumer-chain",children:"Update a Consumer Chain"}),"\n",(0,t.jsxs)(n.p,{children:["We can issue a ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"})," at any point during the registered, initialized, or launched phase of a chain to\nupdate parameters of the consumer chain."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"})," message is as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'message MsgUpdateConsumer {\n  option (cosmos.msg.v1.signer) = "owner";\n\n  // the address of the owner of the consumer chain to be updated\n  string owner = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];\n\n  // the consumer id of the consumer chain to be updated\n  string consumer_id = 2;\n\n  // the new owner of the consumer when updated\n  string new_owner_address = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];\n\n  // the metadata of the consumer when updated\n  ConsumerMetadata metadata = 4;\n\n  // initialization parameters can only be updated before a chain has launched\n  ConsumerInitializationParameters initialization_parameters = 5;\n\n  // the power-shaping parameters of the consumer when updated\n  PowerShapingParameters power_shaping_parameters = 6;\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Note that we need to extensively check the fields of the provided ",(0,t.jsx)(n.code,{children:"ConsumerInitializationParameters"})," to guarantee that no consumer chain launches with problematic parameters."]}),"\n",(0,t.jsxs)(n.p,{children:["For all consumer chains, irrespectively of their phase (even in the deleted phase), we keep a mapping between ",(0,t.jsx)(n.code,{children:"consumerId"}),"\nand the underlying ",(0,t.jsx)(n.code,{children:"ConsumerMetadata"}),", ",(0,t.jsx)(n.code,{children:"ConsumerInitializationParameters"})," and ",(0,t.jsx)(n.code,{children:"PowerShapingParameters"}),".\nThis way, we can respond to queries that ask for all the consumer chain's parameters. For example, retrieving the ",(0,t.jsx)(n.code,{children:"spawn_time"})," of consumer chain with a given ",(0,t.jsx)(n.code,{children:"consumerId"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"MsgUpdateConsumer"})," can be executed multiple times for the same Opt In consumer chain during its initialized phase\nto potentially change its to-be-launched parameters (e.g., ",(0,t.jsx)(n.code,{children:"spawnTime"}),")."]}),"\n",(0,t.jsx)(n.h4,{id:"remove-stop-a-consumer-chain",children:"Remove (Stop) a Consumer Chain"}),"\n",(0,t.jsxs)(n.p,{children:["We introduce the ",(0,t.jsx)(n.code,{children:"MsgRemoveConsumer"})," message so that we can stop any Opt In chain at any point in time.\nNote that all relevant state for this consumer chain remains on the provider's state before getting removed after the time\nof an unbonding period (of the provider) has passed. This is to enable potential slashing for any infraction that might have been incurred until now.\nNote however that we never recycle previously-used ",(0,t.jsx)(n.code,{children:"consumerId"}),"s. Naturally, this message can only be issued by the owner of the consumer chain."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'message MsgRemoveConsumer {\n  option (cosmos.msg.v1.signer) = "owner";\n\n  // the consumer id of the consumer chain to be stopped\n  string consumer_id = 1;\n  // the address of the owner of the consumer chain to be stopped\n  string owner = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"examples-of-launching-a-consumer-chain",children:"Examples of Launching a Consumer Chain"}),"\n",(0,t.jsx)(n.p,{children:"The figures below depict some examples of some of the phases a consumer chain resides before launching."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Examples of a launching consumer chain",src:s(9439).Z+"",width:"4104",height:"1406"})}),"\n",(0,t.jsx)(n.h3,{id:"additional-modifications",children:"Additional Modifications"}),"\n",(0,t.jsxs)(n.p,{children:["We need to perform multiple migrations. All state needs to be reindex based on a ",(0,t.jsx)(n.code,{children:"consumerId"})," instead of the ",(0,t.jsx)(n.code,{children:"chainId"}),".\nBecause we only have two consumer chains (i.e., Neutron and Stride) at the moment, this is not going to be an expensive migration even if we have some live\nconsumer chains that are being voted upon. Similarly, all the messages, queries, etc. would need to be changed to operate on a ",(0,t.jsx)(n.code,{children:"consumerId"})," instead of a ",(0,t.jsx)(n.code,{children:"chainId"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["It is ",(0,t.jsx)(n.strong,{children:"important"})," to migrate any live proposals, such as ",(0,t.jsx)(n.code,{children:"ConsumerAdditionProposal"}),"s and ",(0,t.jsx)(n.code,{children:"MsgConsumerAddition"}),"s, etc.\nwhen we upgrade before we actually deprecate ",(0,t.jsx)(n.code,{children:"ConsumerAdditionProposal"}),"s, ",(0,t.jsx)(n.code,{children:"MsgConsumerAddition"}),"s, etc."]}),"\n",(0,t.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Easier to launch an Opt In consumer chain because no governance is required."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Extensive migration and overhaul of existing code base (as part of API-breaking changes) that could lead to bugs."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://forum.cosmos.network/t/chips-discussion-phase-permissionless-ics/13955",children:"CHIPs Discussion phase: Permissionless ICS"}),"\n",(0,t.jsx)(n.a,{href:"https://forum.cosmos.network/t/pss-permissionless-vs-premissioned-lite-opt-in-consumer-chains/12984/17",children:"Chain-id squatting"})]})]})}function l(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},9439:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/adr19_flows_of_launching_a_consumer_chain-5a10aab8d4e2b4799da43dd3093eb8f9.png"},9337:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/adr19_phases_of_a_consumer_chain-394060dd7a1e0f22242083b4ff5eae12.png"},1151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>a});var t=s(7294);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);