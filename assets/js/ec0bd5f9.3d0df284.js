"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6362],{8750:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var a=i(5893),n=i(1151);const o={sidebar_position:7},r="Power Shaping",s={id:"features/power-shaping",title:"Power Shaping",description:"To give consumer chains more flexibility in choosing their validator set, Interchain Security offers",source:"@site/versioned_docs/version-v6.1.0/features/power-shaping.md",sourceDirName:"features",slug:"/features/power-shaping",permalink:"/interchain-security/v6.1.0/features/power-shaping",draft:!1,unlisted:!1,tags:[],version:"v6.1.0",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Partial Set Security",permalink:"/interchain-security/v6.1.0/features/partial-set-security"},next:{title:"Developing an ICS consumer chain",permalink:"/interchain-security/v6.1.0/consumer-development/app-integration"}},l={},h=[{value:"Power Shaping Configuration",id:"power-shaping-configuration",level:2},{value:"Capping the validator set size",id:"capping-the-validator-set-size",level:3},{value:"Capping the validator powers",id:"capping-the-validator-powers",level:3},{value:"Allowlist and denylist",id:"allowlist-and-denylist",level:3},{value:"Minimum validator stake",id:"minimum-validator-stake",level:3},{value:"Allow inactive validators",id:"allow-inactive-validators",level:3},{value:"Setting Power Shaping Parameters",id:"setting-power-shaping-parameters",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"power-shaping",children:"Power Shaping"}),"\n",(0,a.jsx)(t.p,{children:"To give consumer chains more flexibility in choosing their validator set, Interchain Security offers\nseveral ways to shape the powers of the validator sets on the consumer chains."}),"\n",(0,a.jsx)(t.h2,{id:"power-shaping-configuration",children:"Power Shaping Configuration"}),"\n",(0,a.jsx)(t.p,{children:"Currently, ICS supports the following power shaping parameters."}),"\n",(0,a.jsx)(t.h3,{id:"capping-the-validator-set-size",children:"Capping the validator set size"}),"\n",(0,a.jsx)(t.p,{children:"The consumer chain can specify a maximum number of validators it wants to have in its validator set.\nThis can be used to limit the number of validators in the set, which can be useful for chains that want to have a smaller validator set for faster blocks or lower overhead.\nIf more validators than the maximum size have opted in on a consumer chain, only the validators with the highest power, up to the specified\nmaximum, will validate the consumer chain."}),"\n",(0,a.jsx)(t.p,{children:"Note that this parameter only applies to Opt In consumer chains (i.e., with Top N = 0)."}),"\n",(0,a.jsx)(t.h3,{id:"capping-the-validator-powers",children:"Capping the validator powers"}),"\n",(0,a.jsx)(t.p,{children:"The consumer chain can specify a maximum fraction of the total voting power any of its validators should have.\nThis is a security measure that makes it harder for a single large validator to take over a consumer chain:\nIt mitigates the risk of an Opt In chain with only a few validators being dominated by a validator with a large amount of stake.\nFor example, setting this fraction to 33% would mean that no single validator can have more than 33% of the total voting power on the consumer, and thus no single validator would be able to stop the consumer by going offline."}),"\n",(0,a.jsx)(t.admonition,{type:"warning",children:(0,a.jsx)(t.p,{children:"This parameter is a soft cap, and the actual power of a validator can exceed this fraction if the validator set is small (e.g. there are only 3 validators and the cap is 20%)."})}),"\n",(0,a.jsx)(t.p,{children:"Note that rewards are distributed proportionally to validators with respect to their capped voting power on the consumer, not their total voting power on the provider."}),"\n",(0,a.jsx)(t.h3,{id:"allowlist-and-denylist",children:"Allowlist and denylist"}),"\n",(0,a.jsxs)(t.p,{children:["The consumer chain can specify a list of validators that are allowed or disallowed from participating in the validator set.\nIf an allowlist is set, all validators not on the allowlist cannot validate the consumer chain.\nIf a validator is on both lists, ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.em,{children:"the denylist takes precedence"})}),", that is, they cannot validate the consumer chain.\nBy default, both lists are empty -- there are no restrictions on which validators are eligible to opt in."]}),"\n",(0,a.jsx)(t.admonition,{type:"warning",children:(0,a.jsxs)(t.p,{children:["Note that if denylisting is used in a Top N consumer chain, then the chain might not be secured by N% of the total provider's power.\nFor example, consider that the top validator ",(0,a.jsx)(t.code,{children:"V"})," on the provider chain has 10% of the voting power, and we have a Top 50% consumer chain,\nthen if ",(0,a.jsx)(t.code,{children:"V"})," is denylisted, the consumer chain would only be secured by at least 40% of the provider's power."]})}),"\n",(0,a.jsx)(t.h3,{id:"minimum-validator-stake",children:"Minimum validator stake"}),"\n",(0,a.jsx)(t.p,{children:"The consumer chains can specify a minimum amount of stake that any validator must have on the provider chain to be eligible to opt in.\nFor example, setting this to 1000 would mean only validators with at least 1000 tokens staked on the provider chain can validate the consumer chain."}),"\n",(0,a.jsx)(t.h3,{id:"allow-inactive-validators",children:"Allow inactive validators"}),"\n",(0,a.jsxs)(t.p,{children:["The consumer chains can specify whether validators outside of the provider's active set are eligible to opt in.\nThis can be useful for chains that want to have a larger validator set than the provider chain, or for chains that want to have a more decentralized validator set.\nConsumer chains that enable this feature should strongly consider setting a minimum validator stake to ensure that only validators with some reputation/stake can validate the chain.\nBy default, this parameter is set to ",(0,a.jsx)(t.code,{children:"false"}),", i.e., validators outside of the provider's active set are not eligible to opt in."]}),"\n",(0,a.jsx)(t.h2,{id:"setting-power-shaping-parameters",children:"Setting Power Shaping Parameters"}),"\n",(0,a.jsxs)(t.p,{children:["All the power shaping parameters can be set by the consumer chain in the ",(0,a.jsx)(t.code,{children:"ConsumerAdditionProposal"})," (see ",(0,a.jsx)(t.a,{href:"/interchain-security/v6.1.0/consumer-development/onboarding#3-submit-a-governance-proposal",children:"Onboarding"}),").\nThey operate ",(0,a.jsx)(t.em,{children:"solely on the provider chain"}),", meaning the consumer chain simply receives the validator set after these rules have been applied and does not have any knowledge about whether they are applied."]}),"\n",(0,a.jsx)(t.p,{children:"When setting power shaping parameters, please consider the following guidelines:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Do not cap the validator set size too low."}),"\nNotice that this number is the *",(0,a.jsx)(t.em,{children:"maximum"})," number of validators that will ever validate the consumer chain.\nIf this number is too low, the chain will be very limited in the amount of stake that secures it.\nThe validator set size cap should only be used if there are strong reasons to prefer fewer validators."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Be aware of the interaction between capping the validator powers capping the validator set size."}),"\nFor example, if there are only 3 validators, and the cap is 20%, this will not be possible (since even splitting the power fairly would mean that each validator has 33% of the power, so is above the cap).\nAlso note that the smaller this value is, the more the original voting power gets distorted, which could discourage large validators from deciding to opt in to the chain."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Do not have allowlist contain too few validators."}),"\nIf the allowlist is ",(0,a.jsx)(t.em,{children:"non empty"}),", then ",(0,a.jsx)(t.em,{children:"only"})," validators on the allowlist can validate the chain.\nThus, an allowlist containing too few validators is a security risk, e.g., the validators on the allowlist get jailed on the provider."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Do not have denylist contain too many validators."}),"\nIf the denylist is ",(0,a.jsx)(t.em,{children:"non empty"}),", then the validators on the denylist cannot validate the chain.\nThus, a denylist containing too many validators is a security risk, e.g., the validators on the denylist represents a large fraction of the provider's power."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In general, when setting these parameters, consider that the voting power distribution in the future might be very different from the one right now,\nand that the chain should be secure even if the power distribution changes significantly."}),"\n",(0,a.jsxs)(t.p,{children:["The power shaping parameters of a running consumer chain can be changed through a ",(0,a.jsx)(t.a,{href:"/interchain-security/v6.1.0/features/proposals#consumermodificationproposal",children:(0,a.jsx)(t.code,{children:"ConsumerModificationProposal"})}),"."]}),"\n",(0,a.jsx)(t.p,{children:"The power shaping parameters can be seen by querying the list of consumer chains:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"interchain-security-pd query provider list-consumer-chains\n"})})]})}function c(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,t,i)=>{i.d(t,{Z:()=>s,a:()=>r});var a=i(7294);const n={},o=a.createContext(n);function r(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);