"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8445],{150:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>c});var t=s(5893),r=s(1151);const i={sidebar_position:19,title:"Remove VSCMatured Packets"},o="ADR 018: Remove VSCMatured Packets",d={id:"adrs/adr-018-remove-vscmatured",title:"Remove VSCMatured Packets",description:"Changelog",source:"@site/docs/adrs/adr-018-remove-vscmatured.md",sourceDirName:"adrs",slug:"/adrs/adr-018-remove-vscmatured",permalink:"/interchain-security/adrs/adr-018-remove-vscmatured",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:19,frontMatter:{sidebar_position:19,title:"Remove VSCMatured Packets"},sidebar:"tutorialSidebar",previous:{title:"ICS with Inactive Provider Validators",permalink:"/interchain-security/adrs/adr-017-allowing-inactive-validators"},next:{title:"Permissionless ICS",permalink:"/interchain-security/adrs/adr-019-permissionless-ics"}},a={},c=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Provider Changes (R1)",id:"provider-changes-r1",level:3},{value:"Parameters",id:"parameters",level:4},{value:"State",id:"state",level:4},{value:"State Transitions",id:"state-transitions",level:4},{value:"Queries",id:"queries",level:4},{value:"Consumer Changes (R2)",id:"consumer-changes-r2",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"State",id:"state-1",level:4},{value:"State Transitions",id:"state-transitions-1",level:4},{value:"Messages",id:"messages",level:4},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"adr-018-remove-vscmatured-packets",children:"ADR 018: Remove VSCMatured Packets"}),"\n",(0,t.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"19/06/2024: Create initial draft"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,t.jsx)(n.p,{children:"Accepted"}),"\n",(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["The idea of removing VSCMatured packets was first suggested by ",(0,t.jsx)(n.a,{href:"https://github.com/jaekwon",children:"Jae Kwon"})," over a conversation in 2022.\nAs a result of that conversation, ",(0,t.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/pull/712",children:"an ADR was proposed"})," to halt consumer chain if VSC packets are no longer received.\nThe ADR was not accepted due to other considerations regarding the safety of consumer chains.\nSee ",(0,t.jsx)(n.a,{href:"https://informal.systems/blog/learning-to-live-with-unbonding-pausing",children:"this blog post"})," for more details."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The consumer module on the consumer chains is a representation of the Hub\u2019s staking module, i.e., it provides an ",(0,t.jsx)(n.em,{children:"asynchronous"})," view of the voting powers and indirectly of the locked collateral.\nThe key word here is ",(0,t.jsx)(n.em,{children:"asynchronous"}),", which means that (in theory) there is no bound on the lag between the Hub\u2019s view of stake and the consumer\u2019s view of stake.\nThe reasons for this asynchrony are relaying delays and chain liveness (e.g., a consumer could be down for a long period of time without affecting the liveness of the staking module on the Hub)."]}),"\n",(0,t.jsxs)(n.p,{children:["The current version of ICS uses ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"})," to create on the consumers a ",(0,t.jsx)(n.em,{children:"partially synchronous"})," view of the Hub\u2019s staking module.\nPartially synchronous means that the lag between the Hub\u2019s view of stake and the consumer\u2019s view of stake is bounded, because consumers that exceed this lag are forcibly removed from the protocol.\nBasically, unlocking collateral from the Hub is being delayed until the consumers\u2019 ",(0,t.jsx)(n.code,{children:"UnbondingPeriod"})," elapses.\nThe reason the view is only partially synchronous is that eventually the collateral is unlocked, i.e., if ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"})," are not received from a consumer for ",(0,t.jsx)(n.code,{children:"VscTimeoutPeriod"})," (default: 5 weeks), then the consumer is removed from ICS and the collateral is unlocked.\nNote that keeping the stake locked \u201cforever\u201d would affect the Hub\u2019s liveness, so it\u2019s not a viable option."]}),"\n",(0,t.jsxs)(n.p,{children:["The issue is that whatever attack is possible with an asynchronous view of the staking module, it is eventually possible with the partially synchronous view as well.\nFor example, an attacker could wait for ",(0,t.jsx)(n.code,{children:"VscTimeoutPeriod"})," for the collateral to be unlocked and then send invalid headers to third-party chains that are not aware the consumer's collateral is no longer locked on the Hub (i.e., the consumer is no longer part of ICS)."]}),"\n",(0,t.jsxs)(n.p,{children:["Moreover, with the introduction of ",(0,t.jsx)(n.a,{href:"/interchain-security/adrs/adr-015-partial-set-security",children:"PSS"}),", a consumer\u2019s validator set could \u201clie\u201d about its ",(0,t.jsx)(n.code,{children:"UnbondingPeriod"})," elapsing by sending ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"})," earlier.\nThis would result in a discrepancy between a light client\u2019s view of the ",(0,t.jsx)(n.code,{children:"UnbondingPeriod"})," and the actual Hub\u2019s ",(0,t.jsx)(n.code,{children:"UnbondingPeriod"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsxs)(n.p,{children:["This ADR proposes the removal of ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"}),". The reason is twofold.\nFirst, ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"}),' provide a "false" sense of correctness as the attack described above is still possible.\nSecond, ',(0,t.jsx)(n.code,{children:"VSCMaturedPackets"})," add considerable complexity to the ICS protocol -- an extra message plus the pausing of unbonding operations that can affect the UX."]}),"\n",(0,t.jsxs)(n.p,{children:["To simplify the upgrading process, removing ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"})," can be done in two releases:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(R1) Update the provider to drop ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["(R2) Update the consumer to stop sending ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"As a result, once the provider chain runs R1, the consumers can start upgrading to R2."}),"\n",(0,t.jsx)(n.h3,{id:"provider-changes-r1",children:"Provider Changes (R1)"}),"\n",(0,t.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["Deprecate the ",(0,t.jsx)(n.code,{children:"InitTimeoutPeriod"})," and ",(0,t.jsx)(n.code,{children:"VscTimeoutPeriod"})," parameters."]}),"\n",(0,t.jsx)(n.h4,{id:"state",children:"State"}),"\n",(0,t.jsx)(n.p,{children:"Add the following key prefix to the state:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConsumerAddrsToPruneV2BytePrefix"})," -- the byte prefix for storing consumer validators addresses that need to be pruned.\nThese are stored as","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"ConsumerAddrsToPruneV2BytePrefix | len(chainID) | chainID | ts -> (consumer_address1, consumer_address2, ...)\n"})}),"\n","where ",(0,t.jsx)(n.code,{children:"ts"})," is the timestamp at which the consumer validators addresses can be pruned."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Migrate the consumer validator addresses stored under the ",(0,t.jsx)(n.code,{children:"ConsumerAddrsToPruneBytePrefix"})," to the new prefix ",(0,t.jsx)(n.code,{children:"ConsumerAddrsToPruneV2BytePrefix"}),".\nNote that these consumer validators addresses are stored as"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"ConsumerAddrsToPruneBytePrefix | len(chainID) | chainID | vscID -> (consumer_address1, consumer_address2, ...)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["where ",(0,t.jsx)(n.code,{children:"vscID"})," is the ID of the first VSCPacket sent after these consumer validator addresses were changed.\nThese means that we can use the ",(0,t.jsx)(n.code,{children:"VscSendTimestamp"}),"s to compute the timestamps when these consumer validator addresses can be pruned, i.e.,"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-golang",children:"func MigrateConsumerAddrsToPrune()\n    iterator := sdk.KVStorePrefixIterator(store, []byte{providertypes.ConsumerAddrsToPruneBytePrefix})\n    for ; iterator.Valid(); iterator.Next() {\n        chainID, vscID, _ := providertypes.ParseChainIdAndUintIdKey(providertypes.ConsumerAddrsToPruneBytePrefix, iterator.Key())\n        // use the VscSendTimestamp index to compute the timestamp at which this consumer addresses can be pruned\n        vscSendTimestampKey := providertypes.ChainIdAndUintIdKey(providertypes.VscSendTimestampBytePrefix, chainID, vscID)\n        timeBz := store.Get(vscSendTimestampKey)\n        sentTime, _ := sdk.ParseTimeBytes(timeBz)\n        pruneTs := sentTime.Add(sk.UnbondingTime(ctx))\n\n        var addrs providertypes.AddressList\n        addrs.Unmarshal(iterator.Value())\n\n        for _, addr := range addrs.Addresses {\n            consumerAddr := providertypes.NewConsumerConsAddress(addr)\n            pk.AppendConsumerAddrsToPrune(ctx, chainID, pruneTs, consumerAddr)\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Remove the following key prefixes from the state. Note that these removals require state migration."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MaturedUnbondingOpsByteKey"})," -- the byte key that stores the list of all unbonding operations ids that have matured from a consumer chain perspective."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"UnbondingOpBytePrefix"})," -- the byte prefix that stores a record of all the ids of consumer chains that need to unbond before a given unbonding operation can unbond on this chain."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"UnbondingOpIndexBytePrefix"})," -- the byte prefix of the index for looking up which unbonding operations are waiting for a given consumer chain to unbond."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InitTimeoutTimestampBytePrefix"})," -- the byte prefix for storing the init timeout timestamp for a given consumer chainID."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"VscSendTimestampBytePrefix"})," -- the byte prefix for storing the list of VSC sending timestamps for a given consumer chainID."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ConsumerAddrsToPruneBytePrefix"})," -- the byte prefix for storing the mapping from VSC IDs to consumer validators addresses that need to be pruned."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"state-transitions",children:"State Transitions"}),"\n",(0,t.jsxs)(n.p,{children:["Removing ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"})," affects three ICS sub-protocols (see ",(0,t.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/blob/v4.2.0/x/ccv/provider/keeper/relay.go#L51",children:"HandleVSCMaturedPacket"}),"): unbonding operations pausing, ",(0,t.jsx)(n.code,{children:"VSCPackets"})," timeout, and key assignment pruning.\nThe first two are no longer needed, while the third (key assignment pruning) needs to be redesigned to not depend on ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Removing unbonding operations pausing:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Make the ",(0,t.jsx)(n.code,{children:"AfterUnbondingInitiated"})," hook a no-op. As a result, unbonding operations are no longer paused."]}),"\n",(0,t.jsxs)(n.li,{children:["Stop calling the ",(0,t.jsx)(n.code,{children:"UnbondingCanComplete"})," method from the staking keeper. This entails, it is no longer necessary to append ",(0,t.jsx)(n.code,{children:"MaturedUnbondingOps"})," and the ",(0,t.jsx)(n.code,{children:"completeMaturedUnbondingOps"})," method can be removed."]}),"\n",(0,t.jsxs)(n.li,{children:["Note, that during the upgrade, all unbonding operations stored under the ",(0,t.jsx)(n.code,{children:"UnbondingOpBytePrefix"})," prefix need to be completed (via the ",(0,t.jsx)(n.code,{children:"UnbondingCanComplete"})," method from the staking keeper)."]}),"\n",(0,t.jsxs)(n.li,{children:["Remove the init timeout timestamp logic from the following methods: ",(0,t.jsx)(n.code,{children:"CreateConsumerClient"}),", ",(0,t.jsx)(n.code,{children:"SetConsumerChain"}),", and ",(0,t.jsx)(n.code,{children:"EndBlockCCR"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Removing ",(0,t.jsx)(n.code,{children:"VSCPackets"})," timeout:"]})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Stop setting VSC send timestamps when sending ",(0,t.jsx)(n.code,{children:"VSCPackets"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Stop removing the VSC send timestamps when receiving ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Remove the logic from ",(0,t.jsx)(n.code,{children:"EndBlockCCR"})," that checks if the first VSC send timestamp in iterator plus ",(0,t.jsx)(n.code,{children:"VscTimeoutPeriod"})," exceeds the current block time."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Redesign key assignment pruning."}),' The reason for keeping "old" consumer addresses is to enable slashing / jailing validators that misbehave on consumer chains,\ni.e., the slashing logic uses the ',(0,t.jsx)(n.code,{children:"GetProviderAddrFromConsumerAddr"})," method that accesses the mapping from validator addresses on consumer chains to validator addresses on the provider chain (",(0,t.jsx)(n.code,{children:"ValidatorsByConsumerAddrBytePrefix"}),').\nThus, "old" consumer addresses are no longer needed after the provider\'s ',(0,t.jsx)(n.code,{children:"UnbondingPeriod"}),' elapses.\nThis means that once a validator changes its key on a consumer, we can prune the address corresponding to the "old" key after ',(0,t.jsx)(n.code,{children:"UnbondingPeriod"}),".\nThis requires the following changes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Adapt the ",(0,t.jsx)(n.code,{children:"AppendConsumerAddrsToPrune()"})," method to use the timestamp at which it is safe to prune the consumer validator address (instead of the current ",(0,t.jsx)(n.code,{children:"vscID"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Add a new method ",(0,t.jsx)(n.code,{children:"ConsumeConsumerAddrsToPrune(ts)"})," that returns the list of consumer addresses that can be pruned at timestamp ",(0,t.jsx)(n.code,{children:"ts"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Adapt the ",(0,t.jsx)(n.code,{children:"PruneKeyAssignments()"})," method to call ",(0,t.jsx)(n.code,{children:"ConsumeConsumerAddrsToPrune(ctx.BlockTime())"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Call the ",(0,t.jsx)(n.code,{children:"PruneKeyAssignments()"})," method from every ",(0,t.jsx)(n.code,{children:"EndBlock()"})," instead of calling it from ",(0,t.jsx)(n.code,{children:"HandleVSCMaturedPacket()"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"queries",children:"Queries"}),"\n",(0,t.jsxs)(n.p,{children:["Remove the ",(0,t.jsx)(n.code,{children:"oldest_unconfirmed_vsc"})," query."]}),"\n",(0,t.jsx)(n.h3,{id:"consumer-changes-r2",children:"Consumer Changes (R2)"}),"\n",(0,t.jsx)(n.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["Given that currently relayers use the consumer ",(0,t.jsx)(n.code,{children:"UnbondingPeriod"})," (see ",(0,t.jsx)(n.code,{children:"ConsumerParams"}),"), this param cannot be deprecated.\nNote that Hermes queries the ",(0,t.jsx)(n.code,{children:"UnbondingPeriod"})," for sanity checks and to set the default trusting period when it is not specified.\nAs a result, the ",(0,t.jsx)(n.code,{children:"UnbondingTime"})," method from the staking interface will continue to be used to retrieve the consumer's ",(0,t.jsx)(n.code,{children:"UnbondingPeriod"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"state-1",children:"State"}),"\n",(0,t.jsx)(n.p,{children:"Remove the following key prefixes from the state:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PacketMaturityTimeBytePrefix"})," -- the byte prefix that will store maturity time for each received VSC packet"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Note that these removals require state migration."}),"\n",(0,t.jsx)(n.h4,{id:"state-transitions-1",children:"State Transitions"}),"\n",(0,t.jsxs)(n.p,{children:["To stop the consumer chains from sending ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"}),", it is sufficient to not store the maturity time of ",(0,t.jsx)(n.code,{children:"VSCPacket"}),"s when receiving them, i.e., do not call ",(0,t.jsx)(n.code,{children:"SetPacketMaturityTime"})," from the ",(0,t.jsx)(n.code,{children:"OnRecvVSCPacket()"})," method.\nNote that eventually, no additional ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"})," will be added to the sending queue as ",(0,t.jsx)(n.code,{children:"QueueVSCMaturedPackets"})," iterates over elapsed maturity times.\nIn addition, to clean up the code, the ",(0,t.jsx)(n.code,{children:"QueueVSCMaturedPackets"})," must be removed."]}),"\n",(0,t.jsx)(n.h4,{id:"messages",children:"Messages"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"VSCMaturedPacketData"})," is deprecated.\nNote that this is a wire-breaking change -- older consumer versions will send ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"})," and older provider versions will expect to receive ",(0,t.jsx)(n.code,{children:"VSCMaturedPackets"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Remove feature that provides a "false" sense of correctness.'}),"\n",(0,t.jsx)(n.li,{children:"Remove unnecessary complexity, from both ICS and Cosmos SDK."}),"\n",(0,t.jsx)(n.li,{children:"Remove one IBC packet and, thus, reduce relaying cost."}),"\n",(0,t.jsx)(n.li,{children:"Remove unbonding pausing logic that could affect the UX."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Large refactor that might introduce unexpected bugs."}),"\n",(0,t.jsxs)(n.li,{children:["Consumer chains are no longer removed if the duration between creating a client and creating the CCV channel exceeds ",(0,t.jsx)(n.code,{children:"InitTimeoutPeriod"}),".\nThis means that if the CCV channel is not created on time, the client expires and the consumer chain can no longer start without a ClientUpdate proposal or re-submitting a ",(0,t.jsx)(n.code,{children:"ConsumerAdditionProposal"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Consumer chains are no longer removed after a ",(0,t.jsx)(n.code,{children:"VscTimeoutPeriod"})," of inactivity.\nNote that consumers are still removed if their CCV channel expires, which usually happens after two weeks instead of five weeks (the default value for ",(0,t.jsx)(n.code,{children:"VscTimeoutPeriod"}),")."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/cosmos/interchain-security/pull/712",children:"PR #712"})," -- Proposal to set an expiration date on the consumer chain updated on each VSCPacket received to ensure the chain is up-to-date."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://informal.systems/blog/learning-to-live-with-unbonding-pausing",children:"Learning to Live with \u201cUnbonding Pausing\u201d"})," blog post."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>d,a:()=>o});var t=s(7294);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);