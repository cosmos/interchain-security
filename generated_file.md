# Test Documentation

# [changeover.go](../../tests/integration/changeover.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestRecycleTransferChannel](../../tests/integration/changeover.go#L18) | TestRecycleTransferChannel tests that an existing transfer channel can be reused when transitioning from a standalone to a consumer chain.<details><summary>Details</summary>The test case:<br>* sets up a provider chain and a standalone chain<br>* creates a connection between the two chains<br>* creates a transfer channel between the two chains<br>* transitions the standalone chain to a consumer chain<br>* confirms that no extra transfer channel is created, thus only one transfer channel and one CCV channel exist.<br>test</details> |
</details>

# [democracy.go](../../tests/integration/democracy.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestDemocracyRewardsDistribution](../../tests/integration/democracy.go#L78) | TestDemocracyRewardsDistribution checks that rewards to democracy representatives, community pool, and provider redistribution account are done correctly.<details><summary>Details</summary>* Set up a democracy consumer chain.<br>* Create a new block.<br>* Check that rewards to democracy representatives, community pool, and provider redistribution account are distributed in the right proportions.</details> |
 [TestDemocracyGovernanceWhitelisting](../../tests/integration/democracy.go#L194) | TestDemocracyGovernanceWhitelisting checks that only whitelisted governance proposals can be executed on democracy consumer chains.<details><summary>Details</summary>For context, see the whitelist for proposals in app/consumer-democracy/proposals_whitelisting.go.<br>* Set up a democracy consumer chain.<br>* Submit a proposal containing changes to the auth and mint module parameters.<br>* Check that the proposal is not executed, since the change to the auth module is not whitelisted.<br>* Submit a proposal containing changes *only* to the mint module parameters.<br>* Check that the proposal is executed, since the change to the mint module is whitelisted.<br>* Submit a proposal containing changes *only* to the auth module parameters.<br>* Check that again, the proposal is not executed, since the change to the auth module is not whitelisted.</details> |
 [TestDemocracyMsgUpdateParams](../../tests/integration/democracy.go#L294) | TestDemocracyMsgUpdateParams checks that the consumer parameters can be updated through a governance proposal.<details><summary>Details</summary>* Set up a democracy consumer chain.<br>* Submit a proposal containing changes to the consumer module parameters.<br>* Check that the proposal is executed, and the parameters are updated.</details> |
</details>

# [distribution.go](../../tests/integration/distribution.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestRewardsDistribution](../../tests/integration/distribution.go#L32) | TestRewardsDistribution tests the distribution of rewards from the consumer chain to the provider chain.<details><summary>Details</summary>* Set up a provider and consumer chain and completes the channel initialization.<br>* Send tokens into the FeeCollector on the consumer chain,<br>and check that these tokens distributed correctly across the provider and consumer chain.<br>* Check that the tokens are distributed purely on the consumer chain,<br>then advance the block height to make the consumer chain send a packet with rewards to the provider chain.<br>* Don't whitelist the consumer denom, so that the tokens stay in the ConsumerRewardsPool on the provider chain.</details> |
 [TestSendRewardsRetries](../../tests/integration/distribution.go#L190) | TestSendRewardsRetries tests that failed reward transmissions are retried every BlocksPerDistributionTransmission blocks<details><summary>Details</summary>* Set up a provider and consumer chain and complete the channel initialization.<br>* Fill the fee pool on the consumer chain, then corrupt the transmission channel<br>and try to send rewards to the provider chain, which should fail.<br>* Advance the block height to trigger a retry of the reward transmission, and confirm that this time, the transmission is successful.</details> |
 [TestEndBlockRD](../../tests/integration/distribution.go#L272) | TestEndBlockRD tests that the last transmission block height is correctly updated after the expected number of block have passed.<details><summary>Details</summary>* Set up CCV and transmission channels between the provider and consumer chains.<br>* Fill the fee pool on the consumer chain, prepare the system for reward<br>distribution, and optionally corrupt the transmission channel to simulate failure scenarios.<br>* After advancing the block height, verify whether the LBTH is updated correctly<br>and if the escrow balance changes as expected.<br>* Check that the IBC transfer states are discarded if the reward distribution<br>to the provider has failed.<br><br>Note: this method is effectively a unit test for EndBLockRD(), but is written as an integration test to avoid excessive mocking.</details> |
 [TestSendRewardsToProvider](../../tests/integration/distribution.go#L395) | TestSendRewardsToProvider is effectively a unit test for SendRewardsToProvider(), but is written as an integration test to avoid excessive mocking.<details><summary>Details</summary>* Set up CCV and transmission channels between the provider and consumer chains.<br>* Verify the SendRewardsToProvider() function under various scenarios and checks if the<br>function handles each scenario correctly by ensuring the expected number of token transfers.</details> |
 [TestIBCTransferMiddleware](../../tests/integration/distribution.go#L542) | TestIBCTransferMiddleware tests the logic of the IBC transfer OnRecvPacket callback.<details><summary>Details</summary>* Set up IBC and transfer channels.<br>* Simulate various scenarios of token transfers from the provider chain to<br>the consumer chain, and evaluate how the middleware processes these transfers.<br>* Ensure that token transfers are handled correctly and rewards are allocated as expected.</details> |
 [TestAllocateTokens](../../tests/integration/distribution.go#L736) | TestAllocateTokens is a happy-path test of the consumer rewards pool allocation to opted-in validators and the community pool.<details><summary>Details</summary>* Set up a provider chain and multiple consumer chains, and initialize the channels between them.<br>* Fund the consumer rewards pools on the provider chain and allocate rewards to the consumer chains.<br>* Begin a new block to cause rewards to be distributed to the validators and the community pool,<br>and check that the rewards are allocated as expected.</details> |
 [TestAllocateTokensToConsumerValidators](../../tests/integration/distribution.go#L883) | TestAllocateTokensToConsumerValidators tests the allocation of tokens to consumer validators.<details><summary>Details</summary>* The test exclusively uses the provider chain.<br>* Set up a current set of consumer validators, then call the AllocateTokensToConsumerValidators<br>function to allocate a number of tokens to the validators.<br>* Check that the expected number of tokens were allocated to the validators.<br>* The test covers the following scenarios:<br>  - The tokens to be allocated are empty<br>  - The consumer validator set is empty<br>  - The tokens are allocated to a single validator<br>  - The tokens are allocated to multiple validators</details> |
 [TestAllocateTokensToConsumerValidatorsWithDifferentValidatorHeights](../../tests/integration/distribution.go#L1028) | TestAllocateTokensToConsumerValidatorsWithDifferentValidatorHeights tests AllocateTokensToConsumerValidators test with consumer validators that have different heights.<details><summary>Details</summary>* Set up a context where the consumer validators have different join heights and verify that rewards are<br>correctly allocated only to validators who have been active long enough.<br>* Ensure that rewards are evenly distributed among eligible validators, that validators<br>can withdraw their rewards correctly, and that no rewards are allocated to validators<br>who do not meet the required join height criteria.<br>* Confirm that validators that have been consumer validators for some time receive rewards,<br>while validators that recently became consumer validators do not receive rewards.</details> |
 [TestMultiConsumerRewardsDistribution](../../tests/integration/distribution.go#L1148) | TestMultiConsumerRewardsDistribution tests the rewards distribution of multiple consumers chains.<details><summary>Details</summary>* Set up multiple consumer and transfer channels and verify the distribution of rewards from<br>various consumer chains to the provider's reward pool.<br>* Ensure that the consumer reward pools are correctly populated<br>and that rewards are properly transferred to the provider.<br>* Checks that the provider's reward pool balance reflects the accumulated<br>rewards from all consumer chains after processing IBC transfer packets and relaying<br>committed packets.</details> |
</details>

# [double_vote.go](../../tests/integration/double_vote.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestHandleConsumerDoubleVoting](../../tests/integration/double_vote.go#L23) | TestHandleConsumerDoubleVoting tests the handling of double voting evidence from the consumer chain.<details><summary>Details</summary>* Set up a CCV channel.<br>* Create various double voting scenarios and submit those to the provider chain.<br>* Check if the provider chain correctly processes the evidence, jail and tombstone validators as needed, and apply the<br>correct slashing penalties.<br>* Verify that invalid evidence is properly rejected and does not result in incorrect penalties.</details> |
 [TestHandleConsumerDoubleVotingSlashesUndelegationsAndRelegations](../../tests/integration/double_vote.go#L283) | TestHandleConsumerDoubleVotingSlashesUndelegationsAndRelegations tests the handling of double voting evidence from the consumer chain and checks if slashing, undelegations, and redelegations are correctly processed.<details><summary>Details</summary>* Set up a CCV channel.<br>* Create various double voting scenarios and submit those to the provider chain.<br>* Verify that the evidence is processed correctly.<br>* Ensure that the provider chain slashes the validator appropriately, and that it handles undelegations and redelegations accurately.<br>* Confirm that the validator’s staking status reflects these actions.<br>* Check if the slashing penalties are applied correctly and update the validator’s balance and delegations as expected.</details> |
</details>

# [expired_client.go](../../tests/integration/expired_client.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestVSCPacketSendExpiredClient](../../tests/integration/expired_client.go#L29) | TestVSCPacketSendExpiredClient tests queueing of VSCPackets when the consumer client is expired.<details><summary>Details</summary>* Set up a CCV channel and expire the client on consumer chain.<br>* Bond tokens to provider, send CCV packet to consumer and check pending packets.<br>* While the consumer client is expired (or inactive for some reason) all packets will be queued.<br>* The packet sending and checks are then repeated.<br>* More tokens are bonded on provider to change validator powers.<br>* Upgrade expired client to the consumer and all packets are cleared once the consumer client is established.</details> |
 [TestConsumerPacketSendExpiredClient](../../tests/integration/expired_client.go#L99) | TestConsumerPacketSendExpiredClient tests the consumer sending packets when the provider client is expired.<details><summary>Details</summary>* Set up a CCV channel and bond tokens on provider.<br>* Send CCV packet to consumer and rebond tokens on provider.<br>* Check for pending VSC packets and relay all VSC packets to consumer.<br>* The provider client is then expired.<br>* Confirm that while the provider client is expired all packets will be queued and then cleared<br>once the provider client is upgraded.</details> |
</details>

# [key_assignment.go](../../tests/integration/key_assignment.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestKeyAssignment](../../tests/integration/key_assignment.go#L35) | TestKeyAssignment tests key assignments relayed from the provider chain to the consumer chain at different times in the protocol lifecycle.<details><summary>Details</summary>Each test scenario sets up a provider chain and then assigns a key for a validator.<br>However, the assignment comes at different times in the protocol lifecycle.<br>The test covers the following scenarios:<br>* successfully assign the key before the CCV channel initialization is complete, then check that a VSCPacket is indeed queued<br>* successfully assign the key after the CCV channel initialization is complete<br>* successfully assign the key during an same epoch where the validator power changes<br>* get an error when assigning the same key twice in the same block by different validators<br>* get an error when assigning the same key twice in the same block by the same validator<br>* successfully assign two different keys in the same block by one validator<br>* get an error when assigning the same key twice in different blocks by different validators<br>* get an error when assigning the same key twice in different blocks by the same validator<br>For each scenario where the key assignment does not produce an error,<br>the test also checks that VSCPackets are relayed to the consumer chain and that the clients on<br>the provider and consumer chain can be updated.<br>TODO: Remove panics when unexpected error occurs.</details> |
</details>

# [misbehaviour.go](../../tests/integration/misbehaviour.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestHandleConsumerMisbehaviour](../../tests/integration/misbehaviour.go#L25) | TestHandleConsumerMisbehaviour tests the handling of consumer misbehavior.<details><summary>Details</summary>* Set up a CCV channel and send an empty VSC packet to ensure that the consumer client revision height is greater than 0.<br>* Construct a Misbehaviour object with two conflicting headers and process the equivocation evidence.<br>* Verify that the provider chain correctly processes this misbehavior.<br>* Ensure that all involved validators are jailed, tombstoned, and slashed according to the expected outcomes.<br>* Assert that their tokens are adjusted based on the slashing fraction.</details> |
 [TestGetByzantineValidators](../../tests/integration/misbehaviour.go#L101) | TestGetByzantineValidators checks the GetByzantineValidators function on various instances of misbehaviour.<details><summary>Details</summary>* Set up a provider and consumer chain.<br>* Create a header with a subset of the validators on the consumer chain, then create a second header (in a variety of different ways),<br>and check which validators are considered Byzantine by calling the GetByzantineValidators function.<br>* The test scenarios are:<br>- when one of the headers is empty, the function should return an error<br>- when one of the headers has a corrupted validator set (e.g. by a validator having a different public key), the function should return an error<br>- when the signatures in one of the headers are corrupted, the function should return an error<br>- when the attack is an amnesia attack (i.e. the headers have different block IDs), no validator is considered byzantine<br>- for non-amnesia misbehaviour, all validators that signed both headers are considered byzantine</details> |
 [TestCheckMisbehaviour](../../tests/integration/misbehaviour.go#L399) | TestCheckMisbehaviour tests that the CheckMisbehaviour function correctly checks for misbehaviour.<details><summary>Details</summary>* Set up a provider and consumer chain.<br>* Create a valid client header and then create a misbehaviour by creating a second header in a variety of different ways.<br>* Check that the CheckMisbehaviour function correctly checks for misbehaviour by verifying that<br>it returns an error when the misbehaviour is invalid and no error when the misbehaviour is valid.<br>* The test scenarios are:<br>  - both headers are identical (returns an error)<br>  - the misbehaviour is not for the consumer chain (returns an error)<br>  - passing an invalid client id (returns an error)<br>  - passing a misbehaviour with different header height (returns an error)<br>  - passing a misbehaviour older than the min equivocation evidence height (returns an error)<br>  - one header of the misbehaviour has insufficient voting power (returns an error)<br>  - passing a valid misbehaviour (no error)<br><br>* Test does not test actually submitting the misbehaviour to the chain or freezing the client.</details> |
</details>

# [normal_operations.go](../../tests/integration/normal_operations.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestHistoricalInfo](../../tests/integration/normal_operations.go#L19) | TestHistoricalInfo tests the tracking of historical information in the context of new blocks being committed.<details><summary>Details</summary>* Save the initial number of CC validators and current block height.<br>* Add a new validator and then advance the blockchain by one block, triggering the tracking of historical information.<br>* Create 2 validators and then call TrackHistoricalInfo with header block height.<br>* Verify that historical information is pruned correctly and that the validator set is updated as expected.<br>* Check if the historical information is correctly handled and pruned based on the block height.</details> |
</details>

# [slashing.go](../../tests/integration/slashing.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestRelayAndApplyDowntimePacket](../../tests/integration/slashing.go#L50) | TestRelayAndApplyDowntimePacket tests that downtime slash packets can be properly relayed from consumer to provider, handled by provider, with a VSC and jailing eventually effective on consumer and provider.<details><summary>Details</summary>* Set up CCV channels and retrieve consumer validators.<br>* Select a validator and create its consensus address.<br>* Retrieve the provider consensus address that corresponds to the consumer consensus address of the validator.<br>* The validator's current state is also retrieved, including its token balance,<br>* Set validator's signing information is to ensure it will be jailed for downtime.<br>* Create the slashing packet and send it from the consumer chain to the provider chain with a specified timeout.<br>* Receive the packet and verify that the validator was removed from the provider validator set.<br>* Relay VSC packets from the provider chain to each consumer chain and verify that the consumer chains correctly process these packets.<br>* Check the validator's balance and status on the provider chain to ensure it was jailed correctly but not slashed,<br>and its unjailing time is updated.<br>* Reset the outstanding downtime flag on the consumer chain, and ensure that the consumer<br>chain acknowledges receipt of the packet from the provider chain.<br><br>Note: This method does not test the actual slash packet sending logic for downtime<br>and double-signing, see TestValidatorDowntime and TestValidatorDoubleSigning for<br>those types of tests.</details> |
 [TestSlashPacketAcknowledgement](../../tests/integration/slashing.go#L185) | TestSlashPacketAcknowledgement tests the handling of a slash packet acknowledgement.<details><summary>Details</summary>* Set up a provider and consumer chain, with channel initialization between them performed.<br>* Send a slash packet with randomized fields from the consumer to the provider.<br>* The provider processes the packet</details> |
 [TestHandleSlashPacketDowntime](../../tests/integration/slashing.go#L236) | TestHandleSlashPacketDowntime tests the handling of a downtime related slash packet, with integration tests.<details><summary>Details</summary>* Retrieve a validator from provider chain's validators and checks if it's bonded.<br>* Set tThe signing information for the validator.<br>* The provider processes the downtime slashing packet from the consumer.<br>* Check that the validator has been jailed as a result of the downtime slashing packet being processed.<br>* Verify that the validator’s signing information is updated and that the jailing duration is set correctly.<br><br>Note that only downtime slash packets are processed by HandleSlashPacket.</details> |
 [TestOnRecvSlashPacketErrors](../../tests/integration/slashing.go#L283) | TestOnRecvSlashPacketErrors tests errors for the OnRecvSlashPacket method in an integration testing setting.<details><summary>Details</summary>* Set up all CCV channels and expect panic if the channel is not established via dest channel of packet.<br>* After the correct channelID is added to the packet, a panic shouldn't occur anymore.<br>* Create an instance of SlashPacketData and then verify correct processing and error handling<br>for slashing packets received by the provider chain.<br>TODO: Move to unit tests.</details> |
 [TestValidatorDowntime](../../tests/integration/slashing.go#L412) | TestValidatorDowntime tests if a slash packet is sent and if the outstanding slashing flag is switched when a validator has downtime on the slashing module.<details><summary>Details</summary>* Set up all CCV channel and send an empty VSC packet, then retrieve the address of a validator.<br>* Validator signs blocks for the duration of the signedBlocksWindow and a slash packet is constructed to be sent and committed.<br>* Simulate the validator missing blocks and then verify that the validator is jailed and the jailed time is correctly updated.<br>* Ensure that the missed block counters are reset.<br>* Check that there is a pending slash packet in the queue, and then send the pending packets.<br>* Check if slash record is created and verify that the consumer queue still contains the packet since no<br>acknowledgment has been received from the provider.<br>* Verify that the slash packet was sent and check that the outstanding slashing flag prevents the jailed validator to keep missing block.</details> |
 [TestQueueAndSendSlashPacket](../../tests/integration/slashing.go#L533) | TestQueueAndSendSlashPacket tests the integration of QueueSlashPacket with SendPackets. In normal operation slash packets are queued in BeginBlock and sent in EndBlock.<details><summary>Details</summary>* Set up all CCV channels and then queue slash packets for both downtime and double-signing infractions.<br>* Check that the correct number of slash requests are stored in the queue, including duplicates for downtime infractions.<br>* Prepare the CCV channel for sending actual slash packets.<br>* Send the slash packets and check that the outstanding downtime flags are correctly set for validators that were slashed<br>for downtime infractions.<br>* Ensure that the pending data packets queue is empty.<br>TODO: Move to unit tests.</details> |
 [TestCISBeforeCCVEstablished](../../tests/integration/slashing.go#L618) | TestCISBeforeCCVEstablished tests that the consumer chain doesn't panic or have any undesired behavior when a slash packet is queued before the CCV channel is established. Then once the CCV channel is established, the slash packet should be sent soon after.<details><summary>Details</summary>* Check that no pending packets exist and that there's no slash record found.<br>* Triggers a slashing event which queues a slash packet.<br>* The slash packet should be queued but not sent, and it should stay like that until the CCV channel is established and the packet is sent.<br>*Verify that a slashing record now exists, indicating that the slashing packet has been successfully sent.</details> |
</details>

# [stop_consumer.go](../../tests/integration/stop_consumer.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestStopConsumerChain](../../tests/integration/stop_consumer.go#L26) | TestStopConsumerChain tests the functionality of stopping a consumer chain at a higher level than unit tests.<details><summary>Details</summary>* Retrieve a validator from the provider chain's validators and then the delegator address.<br>* Set up test operations, populating the provider chain states using the following operations:<br>  - Setup CCV channels; establishes the CCV channel and sets channelToChain, chainToChannel, and initHeight mapping for the consumer chain ID.<br>  - Delegate the total bond amount to the chosen validator.<br>  - Undelegate the shares in four consecutive blocks evenly; create UnbondingOp and UnbondingOpIndex entries for the consumer chain ID.<br>  - Set SlashAck state for the consumer chain ID.<br><br>* After, the setup operations are executed, and the consumer chain is stopped.<br>* Check that the state associated with the consumer chain is properly cleaned up after it is stopped.</details> |
 [TestStopConsumerOnChannelClosed](../../tests/integration/stop_consumer.go#L117) | TestStopConsumerOnChannelClosed tests stopping a consumer chain correctly.<details><summary>Details</summary>* Set up CCV channel and transfer channel, and send empty VSC packet.<br>* Stop the consumer chain and verify that the provider chain's channel end is closed.<br><br>TODO Simon: implement OnChanCloseConfirm in IBC-GO testing to close the consumer chain's channel end</details> |
</details>

# [throttle.go](../../tests/integration/throttle.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestBasicSlashPacketThrottling](../../tests/integration/throttle.go#L35) | TestBasicSlashPacketThrottling tests slash packet throttling with a single consumer, two slash packets, and no VSC matured packets. The most basic scenario.<details><summary>Details</summary>* Set up various test cases, all CCV channels and validator powers.<br>* Retrieve the initial value of the slash meter, and the test verify it has the expected value.<br>* All validators are retrieved as well, and it's ensured that none of them are jailed from the start.<br>* Create a slash packet for the first validator and send it from the consumer to the provider.<br>* Asserts that validator 0 is jailed, has no power, and that the slash meter and allowance have the expected values.<br>* Then, create a second slash packet for a different validator, and check if the second validator is<br>not jailed after sending the second slash packet.<br>* Replenishes the slash meter until it is positive.<br>* Assert that validator 2 is jailed once the slash packet is retried and that it has no more voting power.</details> |
 [TestMultiConsumerSlashPacketThrottling](../../tests/integration/throttle.go#L219) | TestMultiConsumerSlashPacketThrottling tests slash packet throttling in the context of multiple consumers sending slash packets to the provider, with VSC matured packets sprinkled around.<details><summary>Details</summary>* Set up all CCV channels and validator powers.<br>* Choose three consumer bundles from the available bundles.<br>* Send the slash packets from each of the chosen consumer bundles to the provider chain. They will each slash a different validator.<br>* Confirm that the slash packet for the first consumer was handled first, and afterward, the slash packets for the second and<br>third consumers were bounced.<br>* Check the total power of validators in the provider chain to ensure it reflects the expected state after the first validator has been jailed.<br>* Replenish the slash meter and handle one of the two queued slash packet entries when both are retried.<br>* Verify again that the total power is updated.<br>* Replenish the slash meter one more time, and handle the final slash packet.<br>* Confirm that all validators are jailed.</details> |
 [TestPacketSpam](../../tests/integration/throttle.go#L348) | TestPacketSpam confirms that the provider can handle a large number of incoming slash packets in a single block.<details><summary>Details</summary>* Set up all CCV channels and validator powers.<br>* Set the parameters related to the handling of slash packets.<br>* Prepare the slash packets for the first three validators, and create 500 slash packets, alternating between<br>downtime and double-sign infractions.<br>* Simulate the reception of the 500 packets by the provider chain within the same block.<br>* Verify that the first three validators have been jailed as expected. This confirms that the<br>system correctly processed the slash packets and applied the penalties.</details> |
 [TestDoubleSignDoesNotAffectThrottling](../../tests/integration/throttle.go#L420) | TestDoubleSignDoesNotAffectThrottling tests that a large number of double sign slash packets do not affect the throttling mechanism.<details><summary>Details</summary>* Set up a scenario where 3 validators are slashed for double signing, and the 4th is not.<br>* Send 500 double sign slash packets from a consumer to the provider in a single block.<br>* Confirm that the slash meter is not affected by this, and that no validators are jailed.</details> |
 [TestSlashingSmallValidators](../../tests/integration/throttle.go#L508) | TestSlashingSmallValidators tests that multiple slash packets from validators with small power can be handled by the provider chain in a non-throttled manner.<details><summary>Details</summary>* Set up all CCV channels and delegate tokens to four validators, giving the first validator a larger amount of power.<br>* Initialize the slash meter, and verify that none of the validators are jailed before the slash packets are processed.<br>* Set up default signing information for the three smaller validators to prepare them for being jailed.<br>* The slash packets for the small validators are then constructed and sent.<br>* Verify validator powers after processing the slash packets.<br>* Confirm that the large validator remains unaffected and that the three smaller ones have been penalized and jailed.</details> |
 [TestSlashMeterAllowanceChanges](../../tests/integration/throttle.go#L587) | TestSlashMeterAllowanceChanges tests scenarios where the slash meter allowance is expected to change.<details><summary>Details</summary>* Set up all CCV channels, verify the initial slash meter allowance, and update the power of validators.<br>* Confirm that the value of the slash meter allowance is adjusted correctly after updating the validators' powers.<br>* Change the replenish fraction and assert the new expected allowance.<br><br>TODO: This should be a unit test, or replaced by TestTotalVotingPowerChanges.</details> |
 [TestSlashAllValidators](../../tests/integration/throttle.go#L619) | TestSlashAllValidators is similar to TestSlashSameValidator, but 100% of validators' power is jailed in a single block.<details><summary>Details</summary>* Set up all CCV channels and validator powers.<br>* Set the slash meter parameters.<br>* Create one slash packet for each validator, and then an additional five more for each validator<br>in order to test the system's ability to handle multiple slashing events in a single block.<br>* Receive and process each slashing packet in the provider chain and check that all validators are jailed as expected.<br><br>Note: This edge case should not occur in practice, but it is useful to validate that<br>the slash meter can allow any number of slash packets to be handled in a single block when<br>its allowance is set to "1.0".</details> |
</details>

# [throttle_retry.go](../../tests/integration/throttle_retry.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestSlashRetries](../../tests/integration/throttle_retry.go#L27) | TestSlashRetries tests the throttling v2 retry logic at an integration level.<details><summary>Details</summary>* Set up the CCV channels and the provider.<br>* Retrieve the validators and ensure that none are initially jailed.<br>* Select two validators and set up their signing information.<br>* Set up the consumer, and then construct and queue a slashing packet for the first validator.<br>* Verify that the packet is sent.<br>* Receive the packet on the provider side and handle it.<br>* Confirm that the first validator has been jailed and check the provider's slash meter to ensure it reflects the correct state.<br>* Acknowledge the packet on the consumer chain, and verify that the slash record has been deleted and no pending packets remain.<br>* Confirm that packet sending is now permitted.<br>* Queue a second slashing packet for the second validator and verify its pending status.<br>* Handle the second packet, check that the second validator is jailed, and confirm<br>the final state of the slash record and pending packets on the consumer chain.</details> |
</details>

# [unbonding.go](../../tests/integration/unbonding.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestUndelegationCompletion](../../tests/integration/unbonding.go#L16) | TestUndelegationCompletion tests that undelegations complete after the unbonding period elapses on the provider, regardless of the consumer's state<details><summary>Details</summary>* Set up CCV channel.<br>* Perform initial delegation of tokens followed by a partial undelegation (1/4 of the tokens).<br>* Verify that the staking unbonding operation is created as expected.<br>* Increment provider block height.<br>* Check that the unbonding operation has been completed.<br>* Verify that the token balances are correctly updated and the expected amount of tokens has been returned to the account.</details> |
</details>

# [valset_update.go](../../tests/integration/valset_update.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestPacketRoundtrip](../../tests/integration/valset_update.go#L23) | TestPacketRoundtrip tests a CCV packet roundtrip when tokens are bonded on the provider.<details><summary>Details</summary>* Set up CCV and transfer channels.<br>* Bond some tokens on the provider side in order to change validator power.<br>* Relay a packet from the provider chain to the consumer chain.<br>* Relays a matured packet from the consumer chain back to the provider chain.</details> |
 [TestQueueAndSendVSCMaturedPackets](../../tests/integration/valset_update.go#L59) | TestQueueAndSendVSCMaturedPackets tests the behavior of EndBlock QueueVSCMaturedPackets call and its integration with SendPackets call.<details><summary>Details</summary>* Set up CCV channel.<br>* Create and simulate the sending of three VSC packets from the provider chain to the consumer chain at different times.<br>* Send the first packet and validate its processing.<br>* Simulate the passage of one hour.<br>* Send the second packet and validate its processing.<br>* Simulate the passage of 24 more hours.<br>* Send the third packet and validate its processing.<br>* Retrieve all packet maturity times from the consumer, and use this to check the maturity status of the packets sent earlier.<br>* Advance the time so that the first two packets reach their unbonding period, while the third packet does not.<br>* Ensure first two packets are unbonded, their maturity times are deleted, and that VSCMatured packets are queued.<br>* The third packet is still in the store and has not yet been processed for unbonding.<br>* Checks that the packet commitments for the processed packets are correctly reflected in the consumer chain's state.</details> |
</details>

