# Test Documentation

# [changeover.go](../../tests/integration/changeover.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestRecycleTransferChannel](../../tests/integration/changeover.go#L17) | TestRecycleTransferChannel tests that an existing transfer channel can be reused when transitioning from a standalone to a consumer chain.<details><summary>Details</summary>The test case:<br>* sets up a provider chain and a standalone chain<br>* creates a connection between the two chains<br>* creates a transfer channel between the two chains<br>* transitions the standalone chain to a consumer chain<br>* confirms that no extra transfer channel is created, thus only one transfer channel and one CCV channel exist.</details> |
</details>

# [democracy.go](../../tests/integration/democracy.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestDemocracyRewardsDistribution](../../tests/integration/democracy.go#L79) | TestDemocracyRewardsDistribution checks that rewards to democracy representatives, community pool, and provider redistribution account are done correctly.<details><summary>Details</summary>* Sets up a democracy consumer chain<br>* Creates a new block<br>* Checks that rewards to democracy representatives, community pool, and provider redistribution account are distributed in the right proportions</details> |
 [TestDemocracyGovernanceWhitelisting](../../tests/integration/democracy.go#L195) | TestDemocracyGovernanceWhitelisting checks that only whitelisted governance proposals can be executed on democracy consumer chains.<details><summary>Details</summary>For context, see the whitelist for proposals in app/consumer-democracy/proposals_whitelisting.go.<br>* Sets up a democracy consumer chain<br>* Submits a proposal containing changes to the auth and mint module parameters<br>* Checks that the proposal is not executed, since the change to the auth module is not whitelisted.<br>* Submits a proposal containing changes *only* to the mint module parameters<br>* Checks that the proposal is executed, since the change to the mint module is whitelisted.<br>* Submits a proposal containing changes *only* to the auth module parameters<br>* Checks that again, the proposal is not executed, since the change to the auth module is not whitelisted.</details> |
 [TestDemocracyMsgUpdateParams](../../tests/integration/democracy.go#L295) | TestDemocracyMsgUpdateParams checks that the consumer parameters can be updated through a governance proposal.<details><summary>Details</summary>* Sets up a democracy consumer chain<br>* Submits a proposal containing changes to the consumer module parameters<br>* Checks that the proposal is executed, and the parameters are updated</details> |
</details>

# [distribution.go](../../tests/integration/distribution.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestRewardsDistribution](../../tests/integration/distribution.go#L32) | TestRewardsDistribution tests the distribution of rewards from the consumer chain to the provider chain.<details><summary>Details</summary>The test sets up a provider and consumer chain and completes the channel initialization.<br>Then, it sends tokens into the FeeCollector on the consumer chain,<br>and checks that these tokens distributed correctly across the provider and consumer chain.<br>It first checks that the tokens are distributed purely on the consumer chain,<br>then advances the block height to make the consumer chain send a packet with rewards to the provider chain.<br>It does not whitelist the consumer denom, so the tokens are expected to stay in<br>the ConsumerRewardsPool on the provider chain.</details> |
 [TestSendRewardsRetries](../../tests/integration/distribution.go#L204) | TestSendRewardsRetries tests that failed reward transmissions are retried every BlocksPerDistributionTransmission blocks<details><summary>Details</summary>The test sets up a provider and consumer chain and completes the channel initialization.<br>It fills the fee pool on the consumer chain,<br>then corrupts the transmission channel and tries to send rewards to the provider chain,<br>which should fail.<br>The test then advances the block height to trigger a retry of the reward transmission,<br>and confirms that this time, the transmission is successful.</details> |
 [TestEndBlockRD](../../tests/integration/distribution.go#L285) | Note: this method is effectively a unit test for EndBLockRD(), but is written as an integration test to avoid excessive mocking. |
 [TestSendRewardsToProvider](../../tests/integration/distribution.go#L408) | TestSendRewardsToProvider is effectively a unit test for SendRewardsToProvider(), but is written as an integration test to avoid excessive mocking.<details><summary>Details</summary>The test first sets up CCV and transmission channels between the provider and consumer chains.<br>Then it verifies the SendRewardsToProvider() function under various scenarios and checks if the<br>function handles each scenario correctly by ensuring the expected number of token transfers.</details> |
 [TestIBCTransferMiddleware](../../tests/integration/distribution.go#L554) | TestIBCTransferMiddleware tests the logic of the IBC transfer OnRecvPacket callback.<details><summary>Details</summary>The test first sets up IBC and transfer channels. Then it simulates various scenarios of token transfers from the provider chain to<br>the consumer chain, and evaluates how the middleware processes these transfers. It ensures that token transfers are handled correctly and<br>rewards are allocated as expected.</details> |
 [TestAllocateTokens](../../tests/integration/distribution.go#L744) | TestAllocateTokens is a happy-path test of the consumer rewards pool allocation to opted-in validators and the community pool.<details><summary>Details</summary>The test sets up a provider chain and multiple consumer chains, and initializes the channels between them.<br>It funds the consumer rewards pools on the provider chain and allocates rewards to the consumer chains.<br>Then, it begins a new block to cause rewards to be distributed to the validators and the community pool,<br>and checks that the rewards are allocated as expected.</details> |
 [TestAllocateTokensToConsumerValidators](../../tests/integration/distribution.go#L884) | TestAllocateTokensToConsumerValidators tests the allocation of tokens to consumer validators.<details><summary>Details</summary>The test exclusively uses the provider chain.<br>It sets up a current set of consumer validators, then calls the AllocateTokensToConsumerValidators<br>function to allocate a number of tokens to the validators.<br>The test then checks that the expected number of tokens were allocated to the validators.<br>The test covers the following scenarios:<br>- The tokens to be allocated are empty<br>- The consumer validator set is empty<br>- The tokens are allocated to a single validator<br>- The tokens are allocated to multiple validators</details> |
 [TestAllocateTokensToConsumerValidatorsWithDifferentValidatorHeights](../../tests/integration/distribution.go#L1026) | TestAllocateTokensToConsumerValidatorsWithDifferentValidatorHeights tests AllocateTokensToConsumerValidators test with consumer validators that have different heights.<details><summary>Details</summary>It sets up a context where the consumer validators have different join heights and verifies that rewards are<br>correctly allocated only to validators who have been active long enough. It ensures that rewards are evenly distributed<br>among eligible validators, that validators can withdraw their rewards correctly, and that no rewards are allocated to validators<br>who do not meet the required join height criteria. It confirms that validators that have been consumer validators<br>for some time receive rewards, while validators that recently became consumer validators do not receive rewards.</details> |
 [TestMultiConsumerRewardsDistribution](../../tests/integration/distribution.go#L1142) | TestMultiConsumerRewardsDistribution tests the rewards distribution of multiple consumers chains.<details><summary>Details</summary>It sets up multiple consumer and transfer channels and verifies the distribution of rewards from<br>various consumer chains to the provider's reward pool. It ensures that the consumer reward pools are<br>correctly populated and that rewards are properly transferred to the provider. The test checks that<br>the provider's reward pool balance reflects the accumulated rewards from all consumer chains after<br>processing IBC transfer packets and relaying committed packets.</details> |
</details>

# [double_vote.go](../../tests/integration/double_vote.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestHandleConsumerDoubleVoting](../../tests/integration/double_vote.go#L21) | TestHandleConsumerDoubleVoting tests the handling of double voting evidence from the consumer chain.<details><summary>Details</summary>The test sets up a CCV channel, creates various double voting scenarios, and submits these to the provider chain.<br>It checks if the provider chain correctly processes the evidence, jails and tombstones validators as needed, and applies the<br>correct slashing penalties. Finally, it verifies that invalid evidence is properly rejected and does not result in<br>incorrect penalties.</details> |
 [TestHandleConsumerDoubleVotingSlashesUndelegationsAndRelegations](../../tests/integration/double_vote.go#L279) | TestHandleConsumerDoubleVotingSlashesUndelegationsAndRelegations tests the handling of double voting evidence from the consumer chain and checks if slashing, undelegations, and redelegations are correctly processed.<details><summary>Details</summary>The test sets up a CCV channel, creates various double voting scenarios, and submits these to the provider chain.<br>It verifies that the evidence is processed correctly, ensures that the provider chain slashes the validator appropriately, and that<br>it handles undelegations and redelegations accurately. Then the test confirms that the validator’s staking status reflects these<br>actions. It also checks if the slashing penalties are applied correctly and updates the validator’s balance and delegations as expected.</details> |
</details>

# [expired_client.go](../../tests/integration/expired_client.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestVSCPacketSendExpiredClient](../../tests/integration/expired_client.go#L27) | TestVSCPacketSendExpiredClient tests queueing of VSCPackets when the consumer client is expired.<details><summary>Details</summary>The test sets up a CCV channel and expires the client on consumer chain. Then, it bonds tokens to provider,<br>sends CCV packet to consumer and checks pending packets. While the consumer client is expired (or inactive for some reason)<br>all packets will be queued. The packet sending and checks are then repeated. After that more tokens are bonded on<br>provider to change validator powers. Finally expired client is upgraded to the consumer<br>and all packets are cleared once the consumer client is established.</details> |
 [TestConsumerPacketSendExpiredClient](../../tests/integration/expired_client.go#L95) | TestConsumerPacketSendExpiredClient tests the consumer sending packets when the provider client is expired.<details><summary>Details</summary>The test sets up a CCV channel and bonds tokens on provider, then it sends CCV packet to consumer and rebonds tokens on<br>provider. Then it checks for pending VSC packets and relays all VSC packets to consumer. After that the provider client<br>is expired. Finally it confirms that while the provider client is expired all packets will be queued and then cleared<br>once the provider client is upgraded.</details> |
</details>

# [key_assignment.go](../../tests/integration/key_assignment.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestKeyAssignment](../../tests/integration/key_assignment.go#L33) | TestKeyAssignment tests key assignments relayed from the provider chain to the consumer chain at different times in the protocol lifecycle.<details><summary>Details</summary>Each test scenario sets up a provider chain and then assigns a key for a validator.<br>However, the assignment comes at different times in the protocol lifecycle.<br>The test covers the following scenarios:<br>* successfully assign the key before the CCV channel initialization is complete, then check that a VSCPacket is indeed queued<br>* successfully assign the key after the CCV channel initialization is complete<br>* successfully assign the key during an same epoch where the validator power changes<br>* get an error when assigning the same key twice in the same block by different validators<br>* get an error when assigning the same key twice in the same block by the same validator<br>* successfully assign two different keys in the same block by one validator<br>* get an error when assigning the same key twice in different blocks by different validators<br>* get an error when assigning the same key twice in different blocks by the same validator<br>For each scenario where the key assignment does not produce an error,<br>the test also checks that VSCPackets are relayed to the consumer chain and that the clients on<br>the provider and consumer chain can be updated.</details> |
</details>

# [misbehaviour.go](../../tests/integration/misbehaviour.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestHandleConsumerMisbehaviour](../../tests/integration/misbehaviour.go#L24) | TestHandleConsumerMisbehaviour tests the handling of consumer misbehavior.<details><summary>Details</summary>The test sets up a CCV channel and sends an empty VSC packet to ensure that the consumer client revision height is greater than 0.<br>It then constructs a Misbehaviour object with two conflicting headers and process the equivocation evidence.<br>After that it verifies that the provider chain correctly processes this misbehavior. The test ensures that all involved<br>validators are jailed, tombstoned, and slashed according to the expected outcomes. It includes steps to assert<br>that their tokens are adjusted based on the slashing fraction.</details> |
 [TestGetByzantineValidators](../../tests/integration/misbehaviour.go#L102) | TestGetByzantineValidators checks the GetByzantineValidators function on various instances of misbehaviour.<details><summary>Details</summary>The test sets up a provider and consumer chain.<br>It creates a header with a subset of the validators on the consumer chain,<br>then creates a second header (in a variety of different ways),<br>and checks which validators are considered Byzantine<br>by calling the GetByzantineValidators function.<br>The test scenarios are:<br>* when one of the headers is empty, the function should return an error<br>* when one of the headers has a corrupted validator set (e.g. by a validator having a different public key), the function should return an error<br>* when the signatures in one of the headers are corrupted, the function should return an error<br>* when the attack is an amnesia attack (i.e. the headers have different block IDs), no validator is considered byzantine<br>* for non-amnesia misbehaviour, all validators that signed both headers are considered byzantine</details> |
 [TestCheckMisbehaviour](../../tests/integration/misbehaviour.go#L399) | TestCheckMisbehaviour tests that the CheckMisbehaviour function correctly checks for misbehaviour.<details><summary>Details</summary>The test sets up a provider and consumer chain.<br>It creates a valid client header and then creates a misbehaviour by creating a second header in a variety of different ways.<br>It then checks that the CheckMisbehaviour function correctly checks for misbehaviour by verifying that<br>it returns an error when the misbehaviour is invalid and no error when the misbehaviour is valid.<br>The test scenarios are:<br>* both headers are identical (returns an error)<br>* the misbehaviour is not for the consumer chain (returns an error)<br>* passing an invalid client id (returns an error)<br>* passing a misbehaviour with different header height (returns an error)<br>* passing a misbehaviour older than the min equivocation evidence height (returns an error)<br>* one header of the misbehaviour has insufficient voting power (returns an error)<br>* passing a valid misbehaviour (no error)<br>It does not test actually submitting the misbehaviour to the chain or freezing the client.</details> |
</details>

# [normal_operations.go](../../tests/integration/normal_operations.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestHistoricalInfo](../../tests/integration/normal_operations.go#L19) | TestHistoricalInfo tests the tracking of historical information in the context of new blocks being committed.<details><summary>Details</summary>The test first saves the initial number of CC validators and current block height.<br>Then it adds a new validator and then advance the blockchain by one block, triggering the tracking of historical information.<br>After, the test setup creates 2 validators and then calls TrackHistoricalInfo with header block height<br>Test cases verify that historical information is pruned correctly and that the validator set is updated as expected.<br>Execution of test cases checks if the historical information is correctly handled and pruned based on the block height.</details> |
</details>

# [provider_gov_hooks.go](../../tests/integration/provider_gov_hooks.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestAfterPropSubmissionAndVotingPeriodEnded](../../tests/integration/provider_gov_hooks.go#L23) | TestAfterPropSubmissionAndVotingPeriodEnded tests the results of GetProviderInfo method.<details><summary>Details</summary>The test sets up the account that will create the proposal, and then the proposal is submitted.<br>After the proposal is submitted the AfterProposalSubmission hook is triggered<br>and it should handle the submission of the proposal in the provider module.<br>Proposal submission is then verified, and lastly AfterProposalVotingPeriodEnded is triggered.<br>Tests verifies the deletion of the proposal.</details> |
 [TestGetConsumerAdditionFromProp](../../tests/integration/provider_gov_hooks.go#L58) | TestGetConsumerAdditionFromProp manually calls the GetConsumerAdditionLegacyPropFromProp hook on various types of proposals to test the behavior of the hook.<details><summary>Details</summary>The test case creates a provider chain, then submits a Proposal with various different types of content.<br>Then, it tries to get the ConsumerAdditionProposal from the proposal using the hook.<br>Test cases include a proposal with no messages; a proposal with a transfer message; a proposal with an unrelated legacy proposal;<br>a proposal with an invalid legacy proposal; and a proposal with a ConsumerAdditionProposal.<br>In the case of a valid ConsumerAdditionProposal, the test verifies that the proposal is found and returned by the hook.</details> |
</details>

# [slashing.go](../../tests/integration/slashing.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestRelayAndApplyDowntimePacket](../../tests/integration/slashing.go#L48) | TestRelayAndApplyDowntimePacket tests that downtime slash packets can be properly relayed from consumer to provider, handled by provider, with a VSC and jailing eventually effective on consumer and provider.<details><summary>Details</summary>It sets up CCV channels and retrieves consumer validators. A validator is selected and its consensus address is created.<br>The test then retrieves the provider consensus address that corresponds to the consumer consensus address of the validator.<br>Also the validator's current state is retrieved, including its token balance, and the validator's signing information is set to ensure<br>it will be jailed for downtime. The slashing packet is then created and sent from the consumer chain to the provider chain with a specified<br>timeout. The packet is then received and the test also verifies that the validator was removed from the provider validator set.<br>After, the test relays VSC packets from the provider chain to each consumer chain and verifies that the consumer chains correctly<br>process these packets. The validator's balance and status on the provider chain are checked to ensure it was jailed correctly but not slashed,<br>and its unjailing time is updated. The outstanding downtime flag is reset on the consumer chain, and lastly, the test ensures that the consumer<br>chain acknowledges receipt of the packet from the provider chain.<br><br>Note: This method does not test the actual slash packet sending logic for downtime<br>and double-signing, see TestValidatorDowntime and TestValidatorDoubleSigning for<br>those types of tests.</details> |
 [TestRelayAndApplyDoubleSignPacket](../../tests/integration/slashing.go#L190) | TestRelayAndApplyDoubleSignPacket tests correct processing of double sign slashing packets, handled by provider, with a VSC and jailing eventually effective on consumer and provider.<details><summary>Details</summary>It sets up CCV channels and retrieves consumer validators. A validator is selected and its consensus address is created.<br>The test then retrieves the provider consensus address that corresponds to the consumer consensus address of the validator.<br>Also the validator's current state is retrieved, including its token balance, and the validator's signing information is set to ensure<br>The double sign slashing packet is then created and sent from the consumer chain to the provider chain.<br>timeout and sets infraction type to be double signed. The test then verifies that the validator wasn't slashed, that its status is still bonded,<br>and that the unjailing time and tombstone status are correctly managed. Provider chain then sends an acknowledgment for the slashing<br>packet to confirm that it has been processed.<br><br>Note that double-sign slash packets should not affect the provider validator set.</details> |
 [TestSlashPacketAcknowledgement](../../tests/integration/slashing.go#L276) | TestSlashPacketAcknowledgement tests the handling of a slash packet acknowledgement.<details><summary>Details</summary>It sets up a provider and consumer chain, with channel initialization between them performed,<br>then sends a slash packet with randomized fields from the consumer to the provider.<br>The provider processes the packet</details> |
 [TestHandleSlashPacketDowntime](../../tests/integration/slashing.go#L326) | TestHandleSlashPacketDowntime tests the handling of a downtime related slash packet, with integration tests.<details><summary>Details</summary>It retrieves a validator from provider chain's validators and checks if it's bonded.<br>The signing information for the validator is then set. The provider processes the downtime slashing packet from the consumer.<br>The test then checks that the validator has been jailed as a result of the downtime slashing packet being processed.<br>It also verifies that the validator’s signing information is updated and that the jailing duration is set correctly.<br><br>Note that only downtime slash packets are processed by HandleSlashPacket.</details> |
 [TestOnRecvSlashPacketErrors](../../tests/integration/slashing.go#L372) | TestOnRecvSlashPacketErrors tests errors for the OnRecvSlashPacket method in an integration testing setting.<details><summary>Details</summary>It sets up all CCV channels and expects panic if the channel is not established via dest channel of packet.<br>After the correct channelID is added to the packet, a panic shouldn't occur anymore.<br>The test creates an instance of SlashPacketData and then verifies correct processing and error handling<br>for slashing packets received by the provider chain.</details> |
 [TestValidatorDowntime](../../tests/integration/slashing.go#L478) | TestValidatorDowntime tests if a slash packet is sent and if the outstanding slashing flag is switched when a validator has downtime on the slashing module.<details><summary>Details</summary>It sets up all CCV channel and send an empty VSC packet, then retrieves the address of a validator.<br>Validator signs blocks for the duration of the signedBlocksWindow and a slash packet is constructed to be sent and committed.<br>The test simulates the validator missing blocks and then verifies that the validator is jailed and the jailed time is correctly updated.<br>Also it ensures that the missed block counters are reset. After it checks that there is a pending slash packet in the queue, the test sends<br>the pending packets. Then checks if slash record is created and verifies that the consumer queue still contains the packet since no<br>acknowledgment has been received from the provider. It verifies that the slash packet was sent and check that the outstanding<br>slashing flag prevents the jailed validator to keep missing block.</details> |
 [TestValidatorDoubleSigning](../../tests/integration/slashing.go#L595) | TestValidatorDoubleSigning tests if a slash packet is sent when a double-signing evidence is handled by the evidence module.<details><summary>Details</summary>It sets up all CCV channel and sends an empty VSC packet, then creates a validator public key and address. Then the infraction parameters are set and<br>evidence of double signing is created. Validator signing-info are also added to the store and the slash packet is constructed.<br>The test then simulates double signing and sends the slash packet. It then verifies the handling of slash packet, and after<br>it checks if slash record was created and if it's waiting for reply. Lastly the test confirms that the queue is not cleared and the slash packet is sent</details> |
 [TestQueueAndSendSlashPacket](../../tests/integration/slashing.go#L687) | TestQueueAndSendSlashPacket tests the integration of QueueSlashPacket with SendPackets. In normal operation slash packets are queued in BeginBlock and sent in EndBlock.<details><summary>Details</summary>It sets up all CCV channels and then queues slash packets for both downtime and double-signing infractions.<br>Then, it checks that the correct number of slash requests are stored in the queue, including duplicates for downtime infractions.<br>After the CCV channel for sending actual slash packets is prepared, the slash packets are sent, and the test checks that the outstanding downtime flags<br>are correctly set for validators that were slashed for downtime infractions. Lastly, the test ensures that the pending data packets queue is empty.</details> |
 [TestCISBeforeCCVEstablished](../../tests/integration/slashing.go#L771) | TestCISBeforeCCVEstablished tests that the consumer chain doesn't panic or have any undesired behavior when a slash packet is queued before the CCV channel is established. Then once the CCV channel is established, the slash packet should be sent soon after.<details><summary>Details</summary>It checks that no pending packets exist and that there's no slash record found. Then it triggers a slashing event which queues a slash packet.<br>The slash packet should be queued but not sent, and it should stay like that until the CCV channel is established and the packet is sent.<br>The test then verifies that a slashing record now exists, indicating that the slashing packet has been successfully sent.</details> |
</details>

# [stop_consumer.go](../../tests/integration/stop_consumer.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestStopConsumerChain](../../tests/integration/stop_consumer.go#L24) | TestStopConsumerChain tests the functionality of stopping a consumer chain at a higher level than unit tests.<details><summary>Details</summary>It retrieves a validator from the provider chain's validators and then the delegator address.<br>Then the test sets up test operations, populating the provider chain states using the following operations:<br>  - Setup CCV channels; establishes the CCV channel and sets channelToChain, chainToChannel, and initHeight mapping for the consumer chain ID.<br>  - Delegate the total bond amount to the chosen validator.<br>  - Undelegate the shares in four consecutive blocks evenly; create UnbondingOp and UnbondingOpIndex entries for the consumer chain ID.<br>  - Set SlashAck state for the consumer chain ID.<br><br>After, the setup operations are executed, and the consumer chain is stopped. Finally, the test checks that the state<br>associated with the consumer chain is properly cleaned up after it is stopped.</details> |
 [TestStopConsumerOnChannelClosed](../../tests/integration/stop_consumer.go#L114) | TestStopConsumerOnChannelClosed tests stopping a consumer chain correctly.<details><summary>Details</summary>This test sets up CCV channel and transfer channel, and sends empty VSC packet.<br>Then it stops the consumer chain and verifies that the provider chain's channel end is closed<br><br>TODO Simon: implement OnChanCloseConfirm in IBC-GO testing to close the consumer chain's channel end</details> |
</details>

# [throttle.go](../../tests/integration/throttle.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestBasicSlashPacketThrottling](../../tests/integration/throttle.go#L32) | TestBasicSlashPacketThrottling tests slash packet throttling with a single consumer, two slash packets, and no VSC matured packets. The most basic scenario.<details><summary>Details</summary>It sets up various test cases, all CCV channels and validator powers. Also, the initial value of the slash meter is retrieved, and the test verifies it<br>has the expected value. All validators are retrieved as well, and it's ensured that none of them are jailed from the start.<br>The test then creates a slash packet for the first validator and sends it from the consumer to the provider.<br>Afterward, it asserts that validator 0 is jailed, has no power, and that the slash meter and allowance have the expected values.<br>Then, a second slash packet is created for a different validator, and the test validates that the second validator is<br>not jailed after sending the second slash packet. Next, it replenishes the slash meter until it is positive.<br>Lastly, it asserts that validator 2 is jailed once the slash packet is retried and that it has no more voting power.</details> |
 [TestMultiConsumerSlashPacketThrottling](../../tests/integration/throttle.go#L214) | TestMultiConsumerSlashPacketThrottling tests slash packet throttling in the context of multiple consumers sending slash packets to the provider, with VSC matured packets sprinkled around.<details><summary>Details</summary>It sets up all CCV channels and validator powers. It then chooses three consumer bundles from the available bundles. Next, the slash<br>packets are sent from each of the chosen consumer bundles to the provider chain. They will each slash a different validator. The test<br>then confirms that the slash packet for the first consumer was handled first, and afterward, the slash packets for the second and<br>third consumers were bounced. It then checks the total power of validators in the provider chain to ensure it reflects the expected<br>state after the first validator has been jailed. The slash meter is then replenished, and one of the two queued. The slash meter<br>is then replenished, and one of the two queued slash packet entries is handled when both are retried. The total power is then updated<br>and verified again. Then, the slash meter is replenished one more time, and the final slash packet is handled. Lastly, the test<br>confirms that all validators are jailed.</details> |
 [TestPacketSpam](../../tests/integration/throttle.go#L341) | TestPacketSpam confirms that the provider can handle a large number of incoming slash packets in a single block.<details><summary>Details</summary>It sets up all CCV channels and validator powers. Then the parameters related to the handling of slash packets are set.<br>The slash packets for the first three validators are then prepared, and 500 slash packets are created, alternating between<br>downtime and double-sign infractions. The test then simulates the reception of the 500 packets by the provider chain within<br>the same block. Lastly, it verifies that the first three validators have been jailed as expected. This confirms that the<br>system correctly processed the slash packets and applied the penalties.</details> |
 [TestDoubleSignDoesNotAffectThrottling](../../tests/integration/throttle.go#L413) | TestDoubleSignDoesNotAffectThrottling tests that a large number of double sign slash packets do not affect the throttling mechanism.<details><summary>Details</summary>This test sets up a scenario where 3 validators are slashed for double signing, and the 4th is not.<br>It then sends 500 double sign slash packets from a consumer to the provider in a single block.<br>The test confirms that the slash meter is not affected by this, and that no validators are jailed.</details> |
 [TestSlashingSmallValidators](../../tests/integration/throttle.go#L501) | TestSlashingSmallValidators tests that multiple slash packets from validators with small power can be handled by the provider chain in a non-throttled manner.<details><summary>Details</summary>It sets up all CCV channels and delegates tokens to four validators, giving the first validator a larger amount of power.<br>The slash meter is then initialized, and the test verifies that none of the validators are jailed before the slash packets are processed.<br>It then sets up default signing information for the three smaller validators to prepare them for being jailed.<br>The slash packets for the small validators are then constructed and sent.<br>Lastly, the test verifies validator powers after processing the slash packets. It confirms that the large validator remains unaffected and<br>that the three smaller ones have been penalized and jailed.</details> |
 [TestSlashMeterAllowanceChanges](../../tests/integration/throttle.go#L580) | TestSlashMeterAllowanceChanges tests scenarios where the slash meter allowance is expected to change.<details><summary>Details</summary>It sets up all CCV channels, verifies the initial slash meter allowance, and updates the power of validators.<br>Then, it confirms that the value of the slash meter allowance is adjusted correctly after updating the validators' powers.<br>Lastly, it changes the replenish fraction and asserts the new expected allowance.<br><br>TODO: This should be a unit test, or replaced by TestTotalVotingPowerChanges.</details> |
 [TestSlashAllValidators](../../tests/integration/throttle.go#L612) | TestSlashAllValidators is similar to TestSlashSameValidator, but 100% of validators' power is jailed in a single block.<details><summary>Details</summary>It sets up all CCV channels and validator powers. Then the slash meter parameters are set.<br>One slash packet is created for each validator, and then an additional five more for each validator<br>in order to test the system's ability to handle multiple slashing events in a single block.<br>The test then receives and processes each slashing packet in the provider chain<br>and afterward, it checks that all validators are jailed as expected.<br><br>Note: This edge case should not occur in practice, but it is useful to validate that<br>the slash meter can allow any number of slash packets to be handled in a single block when<br>its allowance is set to "1.0".</details> |
</details>

# [throttle_retry.go](../../tests/integration/throttle_retry.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestSlashRetries](../../tests/integration/throttle_retry.go#L23) | TestSlashRetries tests the throttling v2 retry logic at an integration level.<details><summary>Details</summary>This test sets up the CCV channels and the provider. It retrieves the validators and ensures that none are initially jailed.<br>Two validators are then selected, and their signing information is set up.<br>The test also sets up the consumer, and then constructs and queues a slashing packet for the first validator.<br>It verifies that the packet is sent. Packet is then received on the provider side and handled. The test then confirms that the first validator has been jailed<br>and checks the provider's slash meter to ensure it reflects the correct state. The packet is acknowledged on the consumer chain, and it is verified<br>that the slash record has been deleted and no pending packets remain. Additionally, it confirms that packet sending is now permitted.<br>The test then queues a second slashing packet for the second validator and verifies its pending status. Finally, it handles the second packet,<br>checks that the second validator is jailed, and confirms the final state of the slash record and pending packets on the consumer chain.</details> |
</details>

# [unbonding.go](../../tests/integration/unbonding.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestUndelegationCompletion](../../tests/integration/unbonding.go#L14) | TestUndelegationCompletion tests that undelegations complete after the unbonding period elapses on the provider, regardless of the consumer's state<details><summary>Details</summary>It sets up a CCV channel and performs an initial delegation of tokens followed by a partial undelegation<br>(undelegating 1/4 of the tokens). Then it verifies that the staking unbonding operation is created as expected. Block height is then incremented<br>on the provider. After this period elapses, the test checks that the unbonding operation has been completed. Finally, it verifies<br>that the token balances are correctly updated, ensuring that the expected amount of tokens has been returned to the account.</details> |
</details>

# [valset_update.go](../../tests/integration/valset_update.go) 
<details><summary> Test Specifications </summary>

| Function | Short Description |
|----------|-------------------|
 [TestPacketRoundtrip](../../tests/integration/valset_update.go#L21) | TestPacketRoundtrip tests a CCV packet roundtrip when tokens are bonded on the provider.<details><summary>Details</summary>It sets up CCV and transfer channels. Some tokens are then bonded on the provider side in order to change validator power.<br>The test then relays a packet from the provider chain to the consumer chain.<br>Lastly, it relays a matured packet from the consumer chain back to the provider chain.</details> |
 [TestQueueAndSendVSCMaturedPackets](../../tests/integration/valset_update.go#L54) | TestQueueAndSendVSCMaturedPackets tests the behavior of EndBlock QueueVSCMaturedPackets call and its integration with SendPackets call.<details><summary>Details</summary>It sets up CCV channel and then creates and simulates the sending of three VSC packets<br>from the provider chain to the consumer chain at different times. The first packet is sent, and its processing is validated.<br>After simulating the passage of one hour, the second packet is sent and its processing is validated. Then after simulating the<br>passage of 24 more hours, the third packet is sent and its processing is validated. The test then retrieves all packet maturity<br>times from the consumer, and this is used to check the maturity status of the packets sent earlier.<br>The test then advances the time so that the first two packets reach their unbonding period, while the third packet does not.<br>Next it ensures first two packets are unbonded, their maturity times are deleted, and that VSCMatured packets are queued.<br>The third packet is still in the store and has not yet been processed for unbonding.<br>Finally, the test checks that the packet commitments for the processed packets are correctly reflected in the consumer chain's state.</details> |
</details>

