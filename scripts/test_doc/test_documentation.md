# Test Documentation

| File | Function | Short Description |
|------|----------|-------------------|
| [changeover.go](../../tests/integration/changeover.go#L17) | TestRecycleTransferChannel | TestRecycleTransferChannel tests that an existing transfer channel can be reused when transitioning from a standalone to a consumer chain.<details><summary>Details</summary>The test case:<br>* sets up a provider chain and a standalone chain<br>* creates a connection between the two chains<br>* creates a transfer channel between the two chains<br>* transitions the standalone chain to a consumer chain<br>* confirms that no extra transfer channel is created, thus only one transfer channel and one CCV channel exist.</details> |
| [channel_init.go](../../tests/integration/channel_init.go#L10) | TestInitTimeout | TestInitTimeout tests that the init timeout is respected.<details><summary>Details</summary>The test sets up a provider with a configured init timeout period.<br>It then creates a connection between the provider and consumer chains,<br>and then performs a handshake (stopping at various stages of the process to simulate a timeout).<br>It then increments the time by the init timeout period and checks that the chain was removed if the timeout was reached,<br>or that the chain was not removed if the handshake was indeed completed before the timeout.</details> |
| [democracy.go](../../tests/integration/democracy.go#L79) | TestDemocracyRewardsDistribution | TestDemocracyRewardsDistribution checks that rewards to democracy representatives, community pool, and provider redistribution account are done correctly.<details><summary>Details</summary>* Sets up a democracy consumer chain<br>* Creates a new block<br>* Checks that rewards to democracy representatives, community pool, and provider redistribution account are distributed in the right proportions</details> |
| [democracy.go](../../tests/integration/democracy.go#L195) | TestDemocracyGovernanceWhitelisting | TestDemocracyGovernanceWhitelisting checks that only whitelisted governance proposals can be executed on democracy consumer chains.<details><summary>Details</summary>For context, see the whitelist for proposals in app/consumer-democracy/proposals_whitelisting.go.<br>* Sets up a democracy consumer chain<br>* Submits a proposal containing changes to the auth and mint module parameters<br>* Checks that the proposal is not executed, since the change to the auth module is not whitelisted.<br>* Submits a proposal containing changes *only* to the mint module parameters<br>* Checks that the proposal is executed, since the change to the mint module is whitelisted.<br>* Submits a proposal containing changes *only* to the auth module parameters<br>* Checks that again, the proposal is not executed, since the change to the auth module is not whitelisted.</details> |
| [democracy.go](../../tests/integration/democracy.go#L295) | TestDemocracyMsgUpdateParams | TestDemocracyMsgUpdateParams checks that the consumer parameters can be updated through a governance proposal.<details><summary>Details</summary>* Sets up a democracy consumer chain<br>* Submits a proposal containing changes to the consumer module parameters<br>* Checks that the proposal is executed, and the parameters are updated</details> |
| [distribution.go](../../tests/integration/distribution.go#L32) | TestRewardsDistribution | TesRewardsDistribution tests the distribution of rewards from the consumer chain to the provider chain.<details><summary>Details</summary>The test sets up a provider and consumer chain and completes the channel initialization.<br>Then, it sends tokens into the FeeCollector on the consumer chain,<br>and checks that these tokens distributed correctly across the provider and consumer chain.<br>It first checks that the tokens are distributed purely on the consumer chain,<br>then advances the block height to make the consumer chain send a packet with rewards to the provider chain.<br>It does not whitelist the consumer denom, so the tokens are expected to stay in<br>the ConsumerRewardsPool on the provider chain.</details> |
| [distribution.go](../../tests/integration/distribution.go#L194) | TestSendRewardsRetries | TestSendRewardsRetries tests that failed reward transmissions are retried every BlocksPerDistributionTransmission blocks |
| [distribution.go](../../tests/integration/distribution.go#L270) | TestEndBlockRD | TestEndBlockRD tests that the last transmission block height (LTBH) is correctly updated after the expected number of block have passed. It also checks that the IBC transfer transfer states are discarded if the reward distribution to the provider has failed.  Note: this method is effectively a unit test for EndBLockRD(), but is written as an integration test to avoid excessive mocking. |
| [distribution.go](../../tests/integration/distribution.go#L390) | TestSendRewardsToProvider | TestSendRewardsToProvider is effectively a unit test for SendRewardsToProvider(), but is written as an integration test to avoid excessive mocking. |
| [distribution.go](../../tests/integration/distribution.go#L532) | TestIBCTransferMiddleware | TestIBCTransferMiddleware tests the logic of the IBC transfer OnRecvPacket callback |
| [distribution.go](../../tests/integration/distribution.go#L714) | TestAllocateTokens | TestAllocateTokens is a happy-path test of the consumer rewards pool allocation to opted-in validators and the community pool |
| [distribution.go](../../tests/integration/distribution.go#L854) | TestAllocateTokensToConsumerValidators | TestAllocateTokensToConsumerValidators tests the allocation of tokens to consumer validators.<details><summary>Details</summary>The test exclusively uses the provider chain.<br>It sets up a current set of consumer validators, then calls the AllocateTokensToConsumerValidators<br>function to allocate a number of tokens to the validators.<br>The test then checks that the expected number of tokens were allocated to the validators.<br>The test covers the following scenarios:<br>- The tokens to be allocated are empty<br>- The consumer validator set is empty<br>- The tokens are allocated to a single validator<br>- The tokens are allocated to multiple validators</details> |
| [distribution.go](../../tests/integration/distribution.go#L989) | TestAllocateTokensToConsumerValidatorsWithDifferentValidatorHeights | TestAllocateTokensToConsumerValidatorsWithDifferentValidatorHeights tests `AllocateTokensToConsumerValidators` with consumer validators that have different heights. Specifically, test that validators that have been consumer validators for some time receive rewards, while validators that recently became consumer validators do not receive rewards. |
| [distribution.go](../../tests/integration/distribution.go#L1097) | TestMultiConsumerRewardsDistribution | TestMultiConsumerRewardsDistribution tests the rewards distribution of multiple consumers chains |
| [double_vote.go](../../tests/integration/double_vote.go#L17) | TestHandleConsumerDoubleVoting | TestHandleConsumerDoubleVoting verifies that handling a double voting evidence of a consumer chain results in the expected tombstoning, jailing, and slashing of the misbehaved validator |
| [double_vote.go](../../tests/integration/double_vote.go#L271) | TestHandleConsumerDoubleVotingSlashesUndelegationsAndRelegations | TestHandleConsumerDoubleVotingSlashesUndelegationsAndRelegations verifies that handling a successful double voting evidence of a consumer chain results in the expected slashing of the misbehave validator undelegations |
| [expired_client.go](../../tests/integration/expired_client.go#L23) | TestVSCPacketSendExpiredClient | TestVSCPacketSendWithExpiredClient tests queueing of VSCPackets when the consumer client is expired. While the consumer client is expired (or inactive for some reason) all packets will be queued and and cleared once the consumer client is established. |
| [expired_client.go](../../tests/integration/expired_client.go#L87) | TestConsumerPacketSendExpiredClient | TestConsumerPacketSendExpiredClient tests the consumer sending packets when the provider client is expired. While the provider client is expired  all packets will be queued and and cleared once the provider client is upgraded. |
| [key_assignment.go](../../tests/integration/key_assignment.go#L33) | TestKeyAssignment | TestKeyAssignment tests key assignments relayed from the provider chain to the consumer chain at different times in the protocol lifecycle.<details><summary>Details</summary>Each test scenarios sets up a provider chain and then assigns a key for a validator.<br>However, the assignment comes at different times in the protocol lifecycle.<br>The test covers the following scenarios:<br>* successfully assign the key before the CCV channel initialization is complete, then check that a VSCPacket is indeed queud<br>* successfully assign the key after the CCV channel initialization is complete<br>* successfully assign the key during an same epoch where the validator power changes<br>* get an error when assigning the same key twice in the same block by different validators<br>* get an error when assigning the same key twice in the same block by the same validator<br>* successfully assign two different keys in the same block by one validator<br>* get an error when assigning the same key twice in different blocks by different validators<br>* get an error when assigning the same key twice in different blocks by the same validator<br>For each scenario where the key assignment does not produce an error,<br>the test also checks that VSCPackets are relayed to the consumer chain and that the clients on<br>the provider and consumer chain can be updated.</details> |
| [misbehaviour.go](../../tests/integration/misbehaviour.go#L19) | TestHandleConsumerMisbehaviour | TestHandleConsumerMisbehaviour tests that handling a valid misbehaviour, with conflicting headers forming an equivocation, results in the jailing of the validators |
| [misbehaviour.go](../../tests/integration/misbehaviour.go#L97) | TestGetByzantineValidators | TestGetByzantineValidators checks the GetByzantineValidators function on various instances of misbehaviour.<details><summary>Details</summary>The test sets up a provider and consumer chain.<br>It creates a header with a subset of the validators on the consumer chain,<br>then creates a second header (in a variety of different ways),<br>and checks which validators are considered Byzantine<br>by calling the GetByzantineValidators function.<br>The test scenarios are:<br>* when one of the headers is empty, the function should return an error<br>* when one of the headers has a corrupted validator set (e.g. by a validator having a different public key), the function should return an error<br>* when the signatures in one of the headers are corrupted, the function should return an error<br>* when the attack is an amnesia attack (i.e. the headers have different block IDs), no validator is considered byzantine<br>* for non-amnesia misbehaviour, all validators that signed both headers are considered byzantine</details> |
| [misbehaviour.go](../../tests/integration/misbehaviour.go#L394) | TestCheckMisbehaviour | TestCheckMisbehaviour tests that the CheckMisbehaviour function correctly checks for misbehaviour.<details><summary>Details</summary>The test sets up a provider and consumer chain.<br>It creates a valid client header and then creates a misbehaviour by creating a second header in a variety of different ways.<br>It then checks that the CheckMisbehaviour function correctly checks for misbehaviour by verifying that<br>it returns an error when the misbehaviour is invalid and no error when the misbehaviour is valid.<br>The test scenarios are:<br>* both headers are identical (returns an error)<br>* the misbehaviour is not for the consumer chain (returns an error)<br>* passing an invalid client id (returns an error)<br>* passing a misbehaviour with different header height (returns an error)<br>* passing a misbehaviour older than the min equivocation evidence height (returns an error)<br>* one header of the misbehaviour has insufficient voting power (returns an error)<br>* passing a valid misbehaviour (no error)<br>It does not test actually submitting the misbehaviour to the chain or or freezing the client.</details> |
| [normal_operations.go](../../tests/integration/normal_operations.go#L13) | TestHistoricalInfo | Tests the tracking of historical info in the context of new blocks being committed |
| [provider_gov_hooks.go](../../tests/integration/provider_gov_hooks.go#L18) | TestAfterPropSubmissionAndVotingPeriodEnded | tests AfterProposalSubmission and AfterProposalVotingPeriodEnded hooks hooks require adding a proposal in the gov module and registering a consumer chain with the provider module |
| [provider_gov_hooks.go](../../tests/integration/provider_gov_hooks.go#L60) | TestGetConsumerAdditionLegacyPropFromProp | TestGetConsumerAdditionLegacyPropFromProp manually calls the GetConsumerAdditionLegacyPropFromProp hook on various types of proposals to test the behavior of the hook.<details><summary>Details</summary>The tes case created a provider chain,<br>then submits a Proposal with various different types of content.<br>Then, it tries to get the ConsumerAdditionProposal from the proposal using the hook.<br>Test cases include a proposal with no messages; a proposal with a transfer message; a proposal with an unrelated legacy proposal;<br>a proposal with an invalid legacy proposal; and a proposal with a ConsumerAdditionProposal.<br>In the case of a valid ConsumerAdditionProposal, the test verifies that the proposal is found and returned by the hook.</details> |
| [slashing.go](../../tests/integration/slashing.go#L39) | TestRelayAndApplyDowntimePacket | TestRelayAndApplyDowntimePacket tests that downtime slash packets can be properly relayed from consumer to provider, handled by provider, with a VSC and jailing eventually effective on consumer and provider.  Note: This method does not test the actual slash packet sending logic for downtime and double-signing, see TestValidatorDowntime and TestValidatorDoubleSigning for those types of tests. |
| [slashing.go](../../tests/integration/slashing.go#L177) | TestRelayAndApplyDoubleSignPacket | Similar setup to TestRelayAndApplyDowntimePacket, but with a double sign slash packet. Note that double-sign slash packets should not affect the provider validator set. |
| [slashing.go](../../tests/integration/slashing.go#L263) | TestSlashPacketAcknowledgement | TestSlashPacketAcknowledgement tests the handling of a slash packet acknowledgement.<details><summary>Details</summary>It sets up a provider and consumer chain, with channel initialization between them performed,<br>then sends a slash packet with randomized fields from the consumer to the provider.<br>The provider processes the packet</details> |
| [slashing.go](../../tests/integration/slashing.go#L307) | TestHandleSlashPacketDowntime | TestHandleSlashPacketDowntime tests the handling of a downtime related slash packet, with integration tests. Note that only downtime slash packets are processed by HandleSlashPacket. |
| [slashing.go](../../tests/integration/slashing.go#L348) | TestOnRecvSlashPacketErrors | TestOnRecvSlashPacketErrors tests errors for the OnRecvSlashPacket method in an integration testing setting |
| [slashing.go](../../tests/integration/slashing.go#L447) | TestValidatorDowntime | TestValidatorDowntime tests if a slash packet is sent and if the outstanding slashing flag is switched when a validator has downtime on the slashing module |
| [slashing.go](../../tests/integration/slashing.go#L560) | TestValidatorDoubleSigning | TestValidatorDoubleSigning tests if a slash packet is sent when a double-signing evidence is handled by the evidence module |
| [slashing.go](../../tests/integration/slashing.go#L647) | TestQueueAndSendSlashPacket | TestQueueAndSendSlashPacket tests the integration of QueueSlashPacket with SendPackets. In normal operation slash packets are queued in BeginBlock and sent in EndBlock. |
| [slashing.go](../../tests/integration/slashing.go#L727) | TestCISBeforeCCVEstablished | TestCISBeforeCCVEstablished tests that the consumer chain doesn't panic or have any undesired behavior when a slash packet is queued before the CCV channel is established. Then once the CCV channel is established, the slash packet should be sent soon after. |
| [stop_consumer.go](../../tests/integration/stop_consumer.go#L14) | TestStopConsumerChain | Tests the functionality of stopping a consumer chain at a higher level than unit tests |
| [stop_consumer.go](../../tests/integration/stop_consumer.go#L99) | TestStopConsumerOnChannelClosed | TODO Simon: implement OnChanCloseConfirm in IBC-GO testing to close the consumer chain's channel end |
| [throttle.go](../../tests/integration/throttle.go#L24) | TestBasicSlashPacketThrottling | TestBasicSlashPacketThrottling tests slash packet throttling with a single consumer, two slash packets, and no VSC matured packets. The most basic scenario. |
| [throttle.go](../../tests/integration/throttle.go#L197) | TestMultiConsumerSlashPacketThrottling | TestMultiConsumerSlashPacketThrottling tests slash packet throttling in the context of multiple consumers sending slash packets to the provider, with VSC matured packets sprinkled around. |
| [throttle.go](../../tests/integration/throttle.go#L319) | TestPacketSpam | TestPacketSpam confirms that the provider can handle a large number of incoming slash packets in a single block. |
| [throttle.go](../../tests/integration/throttle.go#L391) | TestDoubleSignDoesNotAffectThrottling | TestDoubleSignDoesNotAffectThrottling tests that a large number of double sign slash packets do not affect the throttling mechanism.<details><summary>Details</summary>This test sets up a scenario where 3 validators are slashed for double signing, and the 4th is not.<br>It then sends 500 double sign slash packets from a consumer to the provider in a single block.<br>The test confirms that the slash meter is not affected by this, and that no validators are jailed.</details> |
| [throttle.go](../../tests/integration/throttle.go#L472) | TestSlashingSmallValidators | TestSlashingSmallValidators tests that multiple slash packets from validators with small power can be handled by the provider chain in a non-throttled manner. |
| [throttle.go](../../tests/integration/throttle.go#L547) | TestSlashMeterAllowanceChanges | TestSlashMeterAllowanceChanges tests scenarios where the slash meter allowance is expected to change.  TODO: This should be a unit test, or replaced by TestTotalVotingPowerChanges. |
| [throttle.go](../../tests/integration/throttle.go#L573) | TestSlashAllValidators | Similar to TestSlashSameValidator, but 100% of val power is jailed a single block, and in the first packets recv for that block. This edge case should not occur in practice, but is useful to validate that the slash meter can allow any number of slash packets to be handled in a single block when its allowance is set to "1.0". |
| [throttle_retry.go](../../tests/integration/throttle_retry.go#L14) | TestSlashRetries | TestSlashRetries tests the throttling v2 retry logic at an integration level. |
| [unbonding.go](../../tests/integration/unbonding.go#L16) | TestUndelegationNormalOperation | TestUndelegationNormalOperation tests that undelegations complete after the unbonding period elapses on both the consumer and provider, without VSC packets timing out. |
| [unbonding.go](../../tests/integration/unbonding.go#L131) | TestUndelegationVscTimeout | TestUndelegationVscTimeout tests that an undelegation completes after vscTimeoutPeriod even if it does not reach maturity on the consumer chain. In this case, the consumer chain is removed. |
| [unbonding.go](../../tests/integration/unbonding.go#L192) | TestUndelegationDuringInit | TestUndelegationDuringInit checks that before the CCV channel is established   - no undelegations can complete, even if the provider unbonding period elapses   - all the VSC packets are stored in state as pending   - if the channel handshake times out, then the undelegation completes |
| [unbonding.go](../../tests/integration/unbonding.go#L304) | TestUnbondingNoConsumer | Bond some tokens on provider Unbond them to create unbonding op Check unbonding ops on both sides Advance time so that provider's unbonding op completes Check that unbonding has completed in provider staking |
| [unbonding.go](../../tests/integration/unbonding.go#L342) | TestRedelegationNoConsumer | TestRedelegationNoConsumer tests a redelegate transaction submitted on a provider chain with no consumers |
| [unbonding.go](../../tests/integration/unbonding.go#L392) | TestRedelegationProviderFirst | TestRedelegationWithConsumer tests a redelegate transaction submitted on a provider chain when the unbonding period elapses first on the provider chain |
| [unbonding.go](../../tests/integration/unbonding.go#L475) | TestTooManyLastValidators | This test reproduces a fixed bug when an inactive validator enters back into the active set. It used to cause a panic in the provider module hook called by AfterUnbondingInitiated during the staking module EndBlock. |
| [valset_update.go](../../tests/integration/valset_update.go#L17) | TestPacketRoundtrip | TestPacketRoundtrip tests a CCV packet roundtrip when tokens are bonded on provider |
| [valset_update.go](../../tests/integration/valset_update.go#L41) | TestQueueAndSendVSCMaturedPackets | TestQueueAndSendVSCMaturedPackets tests the behavior of EndBlock QueueVSCMaturedPackets call and its integration with SendPackets call. |
