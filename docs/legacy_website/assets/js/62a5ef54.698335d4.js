"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6501],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=r,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||o;return n?i.createElement(h,a(a({ref:t},p),{},{components:n})):i.createElement(h,a({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,a[1]=s;for(var d=2;d<o;d++)a[d]=n[d];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5242:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3},a="Interchain Security Parameters",s={unversionedId:"introduction/params",id:"version-v3.2.0/introduction/params",title:"Interchain Security Parameters",description:"The parameters necessary for Interchain Security (ICS) are defined in",source:"@site/versioned_docs/version-v3.2.0/introduction/params.md",sourceDirName:"introduction",slug:"/introduction/params",permalink:"/interchain-security/legacy/v3.2.0/introduction/params",draft:!1,tags:[],version:"v3.2.0",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Terminology",permalink:"/interchain-security/legacy/v3.2.0/introduction/terminology"},next:{title:"Technical Specification",permalink:"/interchain-security/legacy/v3.2.0/introduction/technical-specification"}},l={},d=[{value:"Time-based parameters",id:"time-based-parameters",level:2},{value:"ProviderUnbondingPeriod",id:"providerunbondingperiod",level:3},{value:"ConsumerUnbondingPeriod",id:"consumerunbondingperiod",level:3},{value:"TrustingPeriodFraction",id:"trustingperiodfraction",level:3},{value:"CCVTimeoutPeriod",id:"ccvtimeoutperiod",level:3},{value:"InitTimeoutPeriod",id:"inittimeoutperiod",level:3},{value:"<code>VscTimeoutPeriod</code>",id:"vsctimeoutperiod",level:3},{value:"BlocksPerDistributionTransmission",id:"blocksperdistributiontransmission",level:3},{value:"TransferPeriodTimeout",id:"transferperiodtimeout",level:3},{value:"Slash Throttle Parameters",id:"slash-throttle-parameters",level:2},{value:"SlashMeterReplenishPeriod",id:"slashmeterreplenishperiod",level:3},{value:"SlashMeterReplenishFraction",id:"slashmeterreplenishfraction",level:3},{value:"MaxThrottledPackets",id:"maxthrottledpackets",level:3}],p={toc:d},c="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"interchain-security-parameters"},"Interchain Security Parameters"),(0,r.kt)("p",null,"The parameters necessary for Interchain Security (ICS) are defined in "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"Params")," structure in ",(0,r.kt)("inlineCode",{parentName:"li"},"proto/interchain_security/ccv/provider/v1/provider.proto")," for the provider;"),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"Params")," structure in ",(0,r.kt)("inlineCode",{parentName:"li"},"proto/interchain_security/ccv/consumer/v1/consumer.proto")," for the consumer.")),(0,r.kt)("h2",{id:"time-based-parameters"},"Time-based parameters"),(0,r.kt)("p",null,"ICS relies on the following time-based parameters."),(0,r.kt)("h3",{id:"providerunbondingperiod"},"ProviderUnbondingPeriod"),(0,r.kt)("p",null,"is the unbonding period on the provider chain as configured during chain genesis. This parameter can later be changed via governance."),(0,r.kt)("h3",{id:"consumerunbondingperiod"},"ConsumerUnbondingPeriod"),(0,r.kt)("p",null,"is the unbonding period on the consumer chain."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"ConsumerUnbondingPeriod")," is set via the ",(0,r.kt)("inlineCode",{parentName:"p"},"ConsumerAdditionProposal")," governance proposal to add a new consumer chain.\nIt is recommended that every consumer chain set and unbonding period shorter than ",(0,r.kt)("inlineCode",{parentName:"p"},"ProviderUnbondingPeriod")),(0,r.kt)("br",null),(0,r.kt)("p",{parentName:"admonition"},"Example:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre"},"ConsumerUnbondingPeriod = ProviderUnbondingPeriod - one day\n"))),(0,r.kt)("p",null,"Unbonding operations (such as undelegations) are completed on the provider only after the unbonding period elapses on every consumer."),(0,r.kt)("h3",{id:"trustingperiodfraction"},"TrustingPeriodFraction"),(0,r.kt)("p",null,"is used to calculate the ",(0,r.kt)("inlineCode",{parentName:"p"},"TrustingPeriod")," of created IBC clients on both provider and consumer chains.  "),(0,r.kt)("p",null,"Setting ",(0,r.kt)("inlineCode",{parentName:"p"},"TrustingPeriodFraction")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.5")," would result in the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"TrustingPeriodFraction = 0.5\nProviderClientOnConsumerTrustingPeriod = ProviderUnbondingPeriod * 0.5\nConsumerClientOnProviderTrustingPeriod = ConsumerUnbondingPeriod * 0.5\n")),(0,r.kt)("p",null,"Note that a light clients must be updated within the ",(0,r.kt)("inlineCode",{parentName:"p"},"TrustingPeriod")," in order to avoid being frozen."),(0,r.kt)("p",null,"For more details, see the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/blob/main/spec/client/ics-007-tendermint-client/README.md"},"IBC specification of Tendermint clients"),"."),(0,r.kt)("h3",{id:"ccvtimeoutperiod"},"CCVTimeoutPeriod"),(0,r.kt)("p",null,"is the period used to compute the timeout timestamp when sending IBC packets. "),(0,r.kt)("p",null,"For more details, see the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/blob/main/spec/core/ics-004-channel-and-packet-semantics/README.md#sending-packets"},"IBC specification of Channel & Packet Semantics"),"."),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"If a sent packet is not relayed within this period, then the packet times out. The CCV channel used by the interchain security protocol is closed, and the corresponding consumer is removed.")),(0,r.kt)("p",null,"CCVTimeoutPeriod may have different values on the provider and consumer chains."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CCVTimeoutPeriod")," on the provider ",(0,r.kt)("strong",{parentName:"li"},"must")," be larger than ",(0,r.kt)("inlineCode",{parentName:"li"},"ConsumerUnbondingPeriod")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CCVTimeoutPeriod")," on the consumer is initial set via the ",(0,r.kt)("inlineCode",{parentName:"li"},"ConsumerAdditionProposal"))),(0,r.kt)("h3",{id:"inittimeoutperiod"},"InitTimeoutPeriod"),(0,r.kt)("p",null,"is the maximum allowed duration for CCV channel initialization to execute."),(0,r.kt)("p",null,"For any consumer chain, if the CCV channel is not established within ",(0,r.kt)("inlineCode",{parentName:"p"},"InitTimeoutPeriod")," then the consumer chain will be removed and therefore will not be secured by the provider chain."),(0,r.kt)("p",null,"The countdown starts when the ",(0,r.kt)("inlineCode",{parentName:"p"},"spawn_time")," specified in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ConsumerAdditionProposal")," is reached."),(0,r.kt)("h3",{id:"vsctimeoutperiod"},(0,r.kt)("inlineCode",{parentName:"h3"},"VscTimeoutPeriod")),(0,r.kt)("p",null,"is the provider-side param that enables the provider to timeout VSC packets even when a consumer chain is not live.\nIf the ",(0,r.kt)("inlineCode",{parentName:"p"},"VscTimeoutPeriod")," is ever reached for a consumer chain that chain will be considered not live and removed from interchain security."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"VscTimeoutPeriod")," MUST be larger than the ",(0,r.kt)("inlineCode",{parentName:"p"},"ConsumerUnbondingPeriod"),".")),(0,r.kt)("h3",{id:"blocksperdistributiontransmission"},"BlocksPerDistributionTransmission"),(0,r.kt)("p",null,"is the number of blocks between rewards transfers from the consumer to the provider."),(0,r.kt)("h3",{id:"transferperiodtimeout"},"TransferPeriodTimeout"),(0,r.kt)("p",null,"is the period used to compute the timeout timestamp when sending IBC transfer packets from a consumer to the provider."),(0,r.kt)("p",null,"If this timeout expires, then the transfer is attempted again after ",(0,r.kt)("inlineCode",{parentName:"p"},"BlocksPerDistributionTransmission")," blocks."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TransferPeriodTimeout")," on the consumer is initial set via the ",(0,r.kt)("inlineCode",{parentName:"li"},"ConsumerAdditionProposal")," gov proposal to add the consumer"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TransferPeriodTimeout")," should be smaller than ",(0,r.kt)("inlineCode",{parentName:"li"},"BlocksPerDistributionTransmission x avg_block_time"))),(0,r.kt)("h2",{id:"slash-throttle-parameters"},"Slash Throttle Parameters"),(0,r.kt)("h3",{id:"slashmeterreplenishperiod"},"SlashMeterReplenishPeriod"),(0,r.kt)("p",null,"exists on the provider such that once the slash meter becomes not-full, the slash meter is replenished after this period has elapsed."),(0,r.kt)("p",null,"The meter is replenished to an amount equal to the slash meter allowance for that block, or ",(0,r.kt)("inlineCode",{parentName:"p"},"SlashMeterReplenishFraction * CurrentTotalVotingPower"),"."),(0,r.kt)("h3",{id:"slashmeterreplenishfraction"},"SlashMeterReplenishFraction"),(0,r.kt)("p",null,"exists on the provider as the portion (in range ","[0, 1]",") of total voting power that is replenished to the slash meter when a replenishment occurs."),(0,r.kt)("p",null,"This param also serves as a maximum fraction of total voting power that the slash meter can hold. The param is set/persisted as a string, and converted to a ",(0,r.kt)("inlineCode",{parentName:"p"},"sdk.Dec")," when used."),(0,r.kt)("h3",{id:"maxthrottledpackets"},"MaxThrottledPackets"),(0,r.kt)("p",null,"exists on the provider as the maximum amount of throttled slash or vsc matured packets that can be queued from a single consumer before the provider chain halts, it should be set to a large value."),(0,r.kt)("p",null,"This param would allow provider binaries to panic deterministically in the event that packet throttling results in a large amount of state-bloat. In such a scenario, packet throttling could prevent a violation of safety caused by a malicious consumer, at the cost of provider liveness."))}u.isMDXComponent=!0}}]);