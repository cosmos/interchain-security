"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8055],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||i;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1813:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:13,title:"Separate Releasing"},o="ADR 012: Separate Releasing",l={unversionedId:"adrs/adr-012-separate-releasing",id:"version-v3.3.1-lsm/adrs/adr-012-separate-releasing",title:"Separate Releasing",description:"Changelog",source:"@site/versioned_docs/version-v3.3.1-lsm/adrs/adr-012-separate-releasing.md",sourceDirName:"adrs",slug:"/adrs/adr-012-separate-releasing",permalink:"/interchain-security/legacy/adrs/adr-012-separate-releasing",draft:!1,tags:[],version:"v3.3.1-lsm",sidebarPosition:13,frontMatter:{sidebar_position:13,title:"Separate Releasing"},sidebar:"tutorialSidebar",previous:{title:"Improving testing and increasing confidence",permalink:"/interchain-security/legacy/adrs/adr-011-improving-test-confidence"},next:{title:"Slashing on the provider for consumer equivocation",permalink:"/interchain-security/legacy/adrs/adr-013-equivocation-slashing"}},s={},p=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Spike results",id:"spike-results",level:3},{value:"Why go.mod split is not the way to go",id:"why-gomod-split-is-not-the-way-to-go",level:3},{value:"Why separate repos is cool but also not the way to go",id:"why-separate-repos-is-cool-but-also-not-the-way-to-go",level:3},{value:"Decision",id:"decision",level:2},{value:"Example release flow",id:"example-release-flow",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}],u={toc:p},d="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"adr-012-separate-releasing"},"ADR 012: Separate Releasing"),(0,r.kt)("h2",{id:"changelog"},"Changelog"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"{8/18/22}: Initial draft of idea in ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/cosmos/interchain-security/issues/801"},"#801")),(0,r.kt)("li",{parentName:"ul"},"{8/22/22}: Put idea in this ADR"),(0,r.kt)("li",{parentName:"ul"},"{11/10/22}: Reject this ADR")),(0,r.kt)("h2",{id:"status"},"Status"),(0,r.kt)("p",null,"Rejected"),(0,r.kt)("h2",{id:"context"},"Context"),(0,r.kt)("h3",{id:"spike-results"},"Spike results"),(0,r.kt)("p",null,"I explored the idea of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/interchain-security/issues/801"},"#801")," with this ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/interchain-security/tree/shawn%2Fgo-mod-split-aug-spike"},"spike branch"),". Here's my conclusions:"),(0,r.kt)("p",null,"Splitting this repo to have multiple go.mods is possible. However there are various intricacies involved in decoupling the package hierarchy to have ",(0,r.kt)("inlineCode",{parentName:"p"},"x/ccv/types")," as the lowest level dep, with ",(0,r.kt)("inlineCode",{parentName:"p"},"x/ccv/consumer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"x/ccv/provider")," being one dep layer above, with high-level tests depending on all three of the mentioned packages. I'd estimate this decoupling would take 2-5 workdays to finish, and require significant review effort."),(0,r.kt)("h3",{id:"why-gomod-split-is-not-the-way-to-go"},"Why go.mod split is not the way to go"),(0,r.kt)("p",null,"Let's take a step back and remember the issue we're trying to solve - ",(0,r.kt)("strong",{parentName:"p"},"We need a clean way to decouple semver/releasing for the consumer and provider modules"),". After more consideration, splitting up go.mods gives us little benefit in achieving this. Reasons:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"go.mod")," dependency system is tied to git tags for the entire repo (ex: ",(0,r.kt)("inlineCode",{parentName:"li"},"require github.com/cometbft/cometbft v0.37.2")," refers to a historical tag for the entire cometbft repo)."),(0,r.kt)("li",{parentName:"ul"},"It'd be an odd dev experience to allow modules to reference past releases of other modules in the same repo. When would we ever want the consumer module to reference a past release of the types module for example?"),(0,r.kt)("li",{parentName:"ul"},"If we allow for ",(0,r.kt)("inlineCode",{parentName:"li"},"go.mod")," replace statements to build from local source code, why split up the package deps at all?"),(0,r.kt)("li",{parentName:"ul"},"Splitting go.mods adds a bunch of complexity with ",(0,r.kt)("inlineCode",{parentName:"li"},"go.work")," files and all that shiz. VSCode does not play well with multiple module repos either.")),(0,r.kt)("h3",{id:"why-separate-repos-is-cool-but-also-not-the-way-to-go"},"Why separate repos is cool but also not the way to go"),(0,r.kt)("p",null,"All this considered, the cleanest solution to decoupling semver/releasing for the consumer and provider modules would be to have multiple repos, each with their own go.mod (3-4 repos total including high level tests). With this scheme we could separately tag each repo as changes are merged, they could share some code from ",(0,r.kt)("inlineCode",{parentName:"p"},"types")," being an external dep, etc."),(0,r.kt)("p",null,"I don't think any of us want to split up the monorepo, that's a lot of work and seems like bikeshedding. There's another solution that's very simple..  "),(0,r.kt)("h2",{id:"decision"},"Decision"),(0,r.kt)("p",null,"Slightly adapting ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/interchain-security/blob/cca008d856e3ffc60ec1a486871d0faa702abe26/CONTRIBUTING.md#semantic-versioning"},"the current semver ruleset"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A library API breaking change to EITHER the provider or consumer module will result in an increase of the MAJOR version number for BOTH modules (X.y.z-provider AND X.y.z-consumer)."),(0,r.kt)("li",{parentName:"ul"},"A state breaking change (change requiring coordinated upgrade and/or state migration) will result in an increase of the MINOR version number for the AFFECTED module(s) (x.Y.z-provider AND/OR x.Y.z-consumer)."),(0,r.kt)("li",{parentName:"ul"},"Any other changes (including node API breaking changes) will result in an increase of the PATCH version number for the AFFECTED module(s) (x.y.Z-provider AND/OR x.y.Z-consumer).")),(0,r.kt)("h3",{id:"example-release-flow"},"Example release flow"),(0,r.kt)("p",null,"We upgrade ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," to use a new version of SDK. This is a major version bump, triggering a new release for both the provider and consumer modules, ",(0,r.kt)("inlineCode",{parentName:"p"},"v5.0.0-provider")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"v5.0.0-consumer"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A state breaking change is merged to ",(0,r.kt)("inlineCode",{parentName:"li"},"main")," for the provider module. We release only a ",(0,r.kt)("inlineCode",{parentName:"li"},"v5.1.0-provider")," off main."),(0,r.kt)("li",{parentName:"ul"},"Another state breaking change is merged to ",(0,r.kt)("inlineCode",{parentName:"li"},"main")," for the provider module. We release only a ",(0,r.kt)("inlineCode",{parentName:"li"},"v5.2.0-provider")," off main."),(0,r.kt)("li",{parentName:"ul"},"At this point, the latest consumer version is still ",(0,r.kt)("inlineCode",{parentName:"li"},"v5.0.0-consumer"),". We now merge a state breaking change for the consumer module to ",(0,r.kt)("inlineCode",{parentName:"li"},"main"),", and consequently release ",(0,r.kt)("inlineCode",{parentName:"li"},"v5.1.0-consumer"),". Note that ",(0,r.kt)("inlineCode",{parentName:"li"},"v5.1.0-consumer")," is tagged off a LATER commit from main than ",(0,r.kt)("inlineCode",{parentName:"li"},"v5.2.0-provider"),". This is fine, as the consumer module should not be affected by the provider module's state breaking changes."),(0,r.kt)("li",{parentName:"ul"},"Once either module sees a library API breaking change, we bump the major version for both modules. For example, we merge a library API breaking change to ",(0,r.kt)("inlineCode",{parentName:"li"},"main")," for the provider module. We release ",(0,r.kt)("inlineCode",{parentName:"li"},"v6.0.0-provider")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"v6.0.0-consumer")," off main. Note that most often, a library API breaking change will affect both modules simultaneously (example being bumping sdk version).")),(0,r.kt)("h2",{id:"consequences"},"Consequences"),(0,r.kt)("h3",{id:"positive"},"Positive"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Consumer repos have clear communication of what tagged versions are relevant to them. Consumer devs should know to never reference an ICS version that starts with ",(0,r.kt)("inlineCode",{parentName:"li"},"provider"),", even if it'd technically build."),(0,r.kt)("li",{parentName:"ul"},"Consumer and provider modules do not deviate as long as we continually release off a shared main branch. Backporting remains relatively unchanged besides being explicit about what module(s) your changes should affect."),(0,r.kt)("li",{parentName:"ul"},"No code changes, just changes in process. Very simple.")),(0,r.kt)("h3",{id:"negative"},"Negative"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("del",{parentName:"li"},"Slightly more complexity."),"Considerably more complex to manage the ICS library.\nThis is because ICS needs to support multiple versions of SDK (e.g., 0.45, 0.47, 0.50).\nIn addition, ICS needs to support a special fork of SDK (with LSM included) for the Cosmos Hub.\nThis means that instead of focusing on main the development team needs to manage multiple release\nbranches with different dependency trees. "),(0,r.kt)("li",{parentName:"ul"},"This solution does not allow having provider and consumer on separate versions of e.g. the Cosmos SDK.")),(0,r.kt)("h3",{id:"neutral"},"Neutral"),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/cosmos/interchain-security/issues/801"},"#801")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/cosmos/interchain-security/issues/801#issuecomment-1683349298"},"#801 comment"))))}c.isMDXComponent=!0}}]);