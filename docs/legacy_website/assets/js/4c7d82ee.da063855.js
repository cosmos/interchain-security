"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7649],{3905:(e,t,i)=>{i.d(t,{Zo:()=>h,kt:()=>m});var n=i(7294);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function s(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){a(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function r(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),i=t;return e&&(i="function"==typeof e?e(t):s(s({},t),e)),i},h=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var i=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),d=l(i),p=a,m=d["".concat(c,".").concat(p)]||d[p]||u[p]||o;return i?n.createElement(m,s(s({ref:t},h),{},{components:i})):n.createElement(m,s({ref:t},h))}));function m(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=i.length,s=new Array(o);s[0]=p;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r[d]="string"==typeof e?e:a,s[1]=r;for(var l=2;l<o;l++)s[l]=i[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,i)}p.displayName="MDXCreateElement"},1089:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var n=i(7462),a=(i(7294),i(3905));const o={sidebar_position:4,title:"Cryptographic verification of equivocation evidence"},s="ADR 005: Cryptographic verification of equivocation evidence",r={unversionedId:"adrs/adr-005-cryptographic-equivocation-verification",id:"adrs/adr-005-cryptographic-equivocation-verification",title:"Cryptographic verification of equivocation evidence",description:"Changelog",source:"@site/docs/adrs/adr-005-cryptographic-equivocation-verification.md",sourceDirName:"adrs",slug:"/adrs/adr-005-cryptographic-equivocation-verification",permalink:"/interchain-security/legacy/adrs/adr-005-cryptographic-equivocation-verification",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Cryptographic verification of equivocation evidence"},sidebar:"tutorialSidebar",previous:{title:"Equivocation governance proposal",permalink:"/interchain-security/legacy/adrs/adr-003-equivocation-gov-proposal"},next:{title:"Throttle with retries",permalink:"/interchain-security/legacy/adrs/adr-008-throttle-retries"}},c={},l=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Light Client Attack",id:"light-client-attack",level:3},{value:"Double Signing Attack",id:"double-signing-attack",level:3},{value:"Decision",id:"decision",level:2},{value:"Light Client Attack",id:"light-client-attack-1",level:3},{value:"Double Signing Attack",id:"double-signing-attack-1",level:3},{value:"Current limitations:",id:"current-limitations",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"References",id:"references",level:2}],h={toc:l},d="wrapper";function u(e){let{components:t,...i}=e;return(0,a.kt)(d,(0,n.Z)({},h,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"adr-005-cryptographic-verification-of-equivocation-evidence"},"ADR 005: Cryptographic verification of equivocation evidence"),(0,a.kt)("h2",{id:"changelog"},"Changelog"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"5/1/2023: First draft"),(0,a.kt)("li",{parentName:"ul"},"7/23/2023: Add light client attacks handling"),(0,a.kt)("li",{parentName:"ul"},"9/6/2023: Add double signing attacks handling")),(0,a.kt)("h2",{id:"status"},"Status"),(0,a.kt)("p",null,"Accepted"),(0,a.kt)("h2",{id:"context"},"Context"),(0,a.kt)("p",null,"Currently, we use a governance proposal to slash validators for equivocation (double signing and light client attacks).\nEvery proposal needs to go through a (two weeks) voting period before it can be approved.\nGiven a three-week unbonding period, this means that an equivocation proposal needs to be submitted within one week since the infraction occurred."),(0,a.kt)("p",null,"This ADR proposes a system to slash validators automatically for equivocation, immediately upon the provider chain's receipt of the evidence. Another thing to note is that we intend to introduce this system in stages, since even the partial ability to slash and/or tombstone is a strict improvement in security.\nThe feature is implemented in two parts, each with its dedicated endpoint. One endpoint handles light client attacks, while the other handles double signing attacks."),(0,a.kt)("h3",{id:"light-client-attack"},"Light Client Attack"),(0,a.kt)("p",null,"In a nutshell, the light client is a process that solely verifies a specific state machine's\nconsensus without executing the transactions. The light clients get new headers by querying\nmultiple nodes, called primary and witness nodes. "),(0,a.kt)("p",null,"Light clients download new headers committed on chain from a primary. Headers can be verified in two ways: sequentially,\nwhere the block height of headers is serial, or using skipping. This second verification method allows light clients to download headers\nwith nonconsecutive block height, where some intermediate headers are skipped (see ",(0,a.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/2010.07031.pdf"},"Tendermint Light Client, Figure 1 and Figure 3"),").\nAdditionally, light clients are cross-checking new headers obtained from a primary with witnesses to ensure all nodes share the same state."),(0,a.kt)("p",null,"A light client attack occurs when a Byzantine validator sends invalid headers to a light client.\nAs the light client doesn't execute transactions, it can be deceived into trusting corrupted application state transitions.\nFor instance, if a light client receives header ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," from the primary and header ",(0,a.kt)("inlineCode",{parentName:"p"},"B")," from a witness for the same block height ",(0,a.kt)("inlineCode",{parentName:"p"},"H"),",\nand both headers are successfully verified, it indicates a light client attack.\nNote that in this case, either the primary or the witness or both are malicious."),(0,a.kt)("p",null,"The types of light client attacks are defined by analyzing the differences between the conflicting headers.\nThere are three types of light client attacks: lunatic attack, equivocation attack, and amnesia attack.\nFor details, see the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/notes-on-evidence-handling.md#evidence-handling"},"CometBFT specification"),"."),(0,a.kt)("p",null,"When a light client agent detects two conflicting headers, it will initially verify their traces (see ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/v0.34.28/light/detector.go#L28"},"cometBFT detector"),") using its primary and witness nodes.\nIf these headers pass successful verification, the Byzantine validators will be identified based on the header's commit signatures\nand the type of light client attack. The agent will then transmit this information to its nodes using a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/v0.34.28/spec/consensus/evidence.md#light-client-attacks"},(0,a.kt)("inlineCode",{parentName:"a"},"LightClientAttackEvidence"))," evidence to be eventually voted on and added to a block.\nNote that from a light client agent perspective, it is not possible to establish whether a primary or a witness node, or both, are malicious.\nTherefore, it will create and send two evidences: one against the primary (sent to the witness), and one against the witness (sent to the primary).\nBoth nodes will then verify it before broadcasting it and adding it to the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/v0.34.28/evidence/pool.go#L28"},"evidence pool"),".\nIf an evidence is finally committed to a block, the chain's evidence module will execute it, resulting in the jailing and the slashing of the validators responsible for the light client attack."),(0,a.kt)("p",null,"Light clients are a core component of IBC. In the event of a light client attack, IBC relayers notify the affected chains by submitting an ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/v4.4.2/proto/ibc/lightclients/tendermint/v1/tendermint.proto#L79"},"IBC misbehavior message"),".\nA misbehavior message includes the conflicting headers that constitute a light client attack evidence. Upon receiving such a message,\na chain will first verify whether these headers would have convinced its light client. This verification is achieved by checking\nthe header states against the light client consensus states (see ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/v4.4.2/modules/light-clients/07-tendermint/types/misbehaviour_handle.go#L24"},"IBC misbehaviour handler"),'). If the misbehaviour is successfully verified, the chain will then "freeze" the\nlight client, halting any further trust in or updating of its states.'),(0,a.kt)("h3",{id:"double-signing-attack"},"Double Signing Attack"),(0,a.kt)("p",null,"A double signing attack, also known as equivocation,\noccurs when a validator votes for two different blocks in the same round of the CometBFT consensus.\nThis consensus mechanism operates with multiple voting rounds at each block height,\nand it strictly prohibits sending two votes of the same type during a round\n(see ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/v0.34.28/spec/consensus/consensus.md#state-machine-overview"},"CometBFT State Machine Overview"),")."),(0,a.kt)("p",null,"When a node observes two votes from the same peer, it will use these two votes to create\na ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/v0.34.28/types/evidence.go#L35"},(0,a.kt)("inlineCode",{parentName:"a"},"DuplicateVoteEvidence")),"\nevidence and gossip it to the other nodes in the network\n(see ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/v0.34.28/spec/consensus/evidence.md#detection"},"CometBFT equivocation detection"),").\nEach node will then verify the evidence according to the CometBFT rules that define a valid double signing infraction, and based on this verification, they will decide whether to add the evidence to a block.\nDuring the evidence verification process, the signatures of the conflicting votes must be verified successfully.\nNote that this is achieved using the public key of the misbehaving validator, along with the chain ID of the chain where the infraction occurred (see ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/v0.34.28/spec/consensus/evidence.md#verification"},"CometBFT equivocation verification"),")."),(0,a.kt)("p",null,"Once a double signing evidence is committed to a block, the consensus layer will report the equivocation to the evidence module of the Cosmos SDK application layer.\nThe application will, in turn, punish the malicious validator through jailing, tombstoning and slashing\n(see ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.45.16-ics-lsm/x/evidence/keeper/infraction.go#L263"},"handleEquivocationEvidence"),")."),(0,a.kt)("h2",{id:"decision"},"Decision"),(0,a.kt)("h3",{id:"light-client-attack-1"},"Light Client Attack"),(0,a.kt)("p",null,"In the first part of the feature, we introduce a new endpoint: ",(0,a.kt)("inlineCode",{parentName:"p"},"HandleConsumerMisbehaviour(ctx sdk.Context, misbehaviour ibctmtypes.Misbehaviour)"),".\nThe main idea is to leverage the current IBC misbehaviour handling and update it to solely jail and slash the validators that\nperformed a light client attack. Note that in this context, we assume that chains connected via a light client\nshare the same validator set, as is the case with Replicated Security. "),(0,a.kt)("p",null,"This endpoint reuses the IBC client libraries to verify that the misbehaviour headers would have fooled the light client.\nAdditionally, it\u2019s crucial that the endpoint logic results in the slashing and jailing of validators under the same conditions\nas a light client agent detector. Therefore, the endpoint ensures that the two conditions are met:\nthe headers in the misbehaviour message have the same block height, and\nthe light client isn\u2019t expired."),(0,a.kt)("p",null,"After having successfully verified a misbehaviour, the endpoint executes the jailing and slashing of the malicious validators similarly as in the evidence module. "),(0,a.kt)("h3",{id:"double-signing-attack-1"},"Double Signing Attack"),(0,a.kt)("p",null,"In the second part of the feature, we introduce a new endpoint ",(0,a.kt)("inlineCode",{parentName:"p"},"HandleConsumerDoubleVoting(\nctx sdk.Context, evidence *tmtypes.DuplicateVoteEvidence, chainID string, pubkey cryptotypes.PubKey)"),".\nSimply put, the handling logic verifies a double signing evidence against a provided\npublic key and chain ID and, if successful, executes the jailing of the malicious validator who double voted."),(0,a.kt)("p",null,"We define a new\n",(0,a.kt)("inlineCode",{parentName:"p"},"MsgSubmitConsumerDoubleVoting")," message to report a double voting evidence observed\non a consumer chain to the endpoint of the provider chain. This message contains two fields:\na double signing evidence\n",(0,a.kt)("inlineCode",{parentName:"p"},"duplicate_vote_evidence")," and a light client header for the infraction block height,\nreferred to as ",(0,a.kt)("inlineCode",{parentName:"p"},"infraction_block_header"),".\nThe latter provides the malicious validator's public key and the chain ID required to verify the signature of the votes contained in the evidence."),(0,a.kt)("p",null,"Note that double signing evidence is not verified using the same conditions as in the implementation CometBFT (see\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cometbft/cometbft/blob/v0.34.28/evidence/verify.go#L19"},(0,a.kt)("inlineCode",{parentName:"a"},"verify(evidence types.Evidence)"))," method). Specifically, we do not check that the evidence hasn't expired.\nMore details can be found in the ",(0,a.kt)("a",{parentName:"p",href:"#current-limitations"},'"Current limitations"')," section below. "),(0,a.kt)("p",null,"Upon a successful equivocation verification, the misbehaving validator is jailed for the maximum time\n(see ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/v0.45.16-ics-lsm/x/evidence/types/params.go#L11"},"DoubleSignJailEndTime"),"\nin the SDK evidence module)."),(0,a.kt)("h3",{id:"current-limitations"},"Current limitations:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"We cannot derive an infraction height from the evidence, so it is only possible to jail validators, not actually slash them.\nTo explain the technical reasons behind this limitation, let's recap the initial consumer initiated slashing logic.\nIn a nutshell, consumer heights are mapped to provider heights through VSCPackets, namely through the so called vscIDs.\nWhen an infraction occurs on the consumer, a SlashPacket containing the vscID obtained from mapping the consumer infraction height\nis sent to the provider. Upon receiving the packet, the provider maps the consumer infraction height to a local infraction height,\nwhich is used to slash the misbehaving validator. In the context of untrusted consumer chains, all their states, including vscIDs,\ncould be corrupted and therefore cannot be used for slashing purposes.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"For the same reasons explained above, the age of a consumer double signing evidence can't be verified,\neither using its infraction height or its unsigned timestamp. Note that changes the jailing behaviour, potentially leading to a validator's jailing based on some \"old\" evidence from a consumer, which wouldn't occur if the consumer were a standalone chain.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"In the first stage of this feature, validators are jailed indefinitely without being tombstoned.\nThe underlying reason is that a malicious validator could take advantage of getting tombstoned\nto avoid being slashed on the provider (",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/interchain-security/pull/1232#issuecomment-1693127641"},"see comment"),"). ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},'Currently, the endpoint can only handle "equivocation" light client attacks. This is because the "lunatic" attacks require the endpoint to possess the ability to dissociate which header is conflicted or trusted upon receiving a misbehavior message. Without this information, it\'s not possible to define the Byzantine validators from the conflicting headers (see ',(0,a.kt)("a",{parentName:"p",href:"https://github.com/cosmos/interchain-security/pull/826#discussion_r1268668684"},"comment"),")."))),(0,a.kt)("h2",{id:"consequences"},"Consequences"),(0,a.kt)("h3",{id:"positive"},"Positive"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It is now possible for the provider chain to jail validators who committed\nlight client or double signing attacks on a consumer chain.")),(0,a.kt)("h3",{id:"negative"},"Negative"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"N/A")),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cosmos/interchain-security/pull/826"},"ICS misbehaviour handling PR")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cosmos/interchain-security/pull/1232"},"Consumer double voting handler PR")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.google.com/document/d/1fe1uSJl1ZIYWXoME3Yf4Aodvz7V597Ric875JH-rigM/edit#heading=h.rv4t8i6d6jfn"},"Architectural diagrams")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cosmos/interchain-security/blob/main/docs/docs/adrs/adr-013-equivocation-slashing.md"},"ADR on equivocation slashing"))))}u.isMDXComponent=!0}}]);