syntax = "proto3";
package interchain_security.ccv.provider.v1;

option go_package = "github.com/cosmos/interchain-security/v4/x/ccv/provider/types";

import "google/api/annotations.proto";
import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";
import "interchain_security/ccv/provider/v1/provider.proto";
import "interchain_security/ccv/v1/shared_consumer.proto";
import "interchain_security/ccv/v1/wire.proto";
import "tendermint/crypto/keys.proto";
import "cosmos_proto/cosmos.proto";

service Query {
  // ConsumerGenesis queries the genesis state needed to start a consumer chain
  // whose proposal has been accepted
  rpc QueryConsumerGenesis(QueryConsumerGenesisRequest)
      returns (QueryConsumerGenesisResponse) {
    option (google.api.http).get =
        "/interchain_security/ccv/provider/consumer_genesis/{chain_id}";
  }

  // ConsumerChains queries active consumer chains supported by the provider
  // chain
  rpc QueryConsumerChains(QueryConsumerChainsRequest)
      returns (QueryConsumerChainsResponse) {
    option (google.api.http).get =
        "/interchain_security/ccv/provider/consumer_chains";
  }

  // QueryConsumerChainStarts queries consumer chain start proposals.
  rpc QueryConsumerChainStarts(QueryConsumerChainStartProposalsRequest)
      returns (QueryConsumerChainStartProposalsResponse) {
    option (google.api.http).get =
        "/interchain_security/ccv/provider/consumer_chain_start_proposals";
  }

  // QueryConsumerChainStops queries consumer chain stop proposals.
  rpc QueryConsumerChainStops(QueryConsumerChainStopProposalsRequest)
      returns (QueryConsumerChainStopProposalsResponse) {
    option (google.api.http).get =
        "/interchain_security/ccv/provider/consumer_chain_stop_proposals";
  }

  // QueryValidatorConsumerAddr queries the address
  // assigned by a validator for a consumer chain.
  rpc QueryValidatorConsumerAddr(QueryValidatorConsumerAddrRequest)
      returns (QueryValidatorConsumerAddrResponse) {
    option (google.api.http).get =
        "/interchain_security/ccv/provider/validator_consumer_addr";
  }

  // QueryProviderAddr returns the provider chain validator
  // given a consumer chain validator address
  rpc QueryValidatorProviderAddr(QueryValidatorProviderAddrRequest)
      returns (QueryValidatorProviderAddrResponse) {
    option (google.api.http).get =
        "/interchain_security/ccv/provider/validator_provider_addr";
  }

  // QueryThrottleState returns the main on-chain state relevant to currently
  // throttled slash packets
  rpc QueryThrottleState(QueryThrottleStateRequest)
      returns (QueryThrottleStateResponse) {
    option (google.api.http).get =
        "/interchain_security/ccv/provider/throttle_state";
  }

  // QueryRegisteredConsumerRewardDenoms returns a list of consumer reward
  // denoms that are registered
  rpc QueryRegisteredConsumerRewardDenoms(
      QueryRegisteredConsumerRewardDenomsRequest)
      returns (QueryRegisteredConsumerRewardDenomsResponse) {
    option (google.api.http).get =
        "/interchain_security/ccv/provider/registered_consumer_reward_denoms";
  }

  // QueryProposedConsumerChainIDs returns the chain IDs of the proposed consumer chain addition proposals
  // that are still in the voting period
  rpc QueryProposedConsumerChainIDs(
      QueryProposedChainIDsRequest)
      returns (QueryProposedChainIDsResponse) {
  option (google.api.http).get =
      "/interchain_security/ccv/provider/proposed_consumer_chains";
      }

  // QueryAllPairsValConAddrByConsumerChainID returns a list of pair valconsensus address
  // between provider and consumer chain
  rpc QueryAllPairsValConAddrByConsumerChainID (
    QueryAllPairsValConAddrByConsumerChainIDRequest)
    returns (QueryAllPairsValConAddrByConsumerChainIDResponse) {
      option (google.api.http).get =
    "/interchain_security/ccv/provider/consumer_chain_id";
    }

  // QueryParams returns all current values of provider parameters
  rpc QueryParams(QueryParamsRequest)
    returns (QueryParamsResponse) {
      option (google.api.http).get =
    "/interchain_security/ccv/provider/params";
    }

  // QueryOptedInValidatorsByConsumerChainID returns a list of validators consensus address
  // that opted-in to the given consumer chain
  rpc QueryOptedInValidatorsByConsumerChainID(
    QueryOptedInValidatorsByConsumerChainIDRequest)
    returns (QueryOptedInValidatorsByConsumerChainIDResponse) {
      option (google.api.http).get =
    "/interchain_security/ccv/provider/opted_in_validators";
    }

  // QueryConsumerChainsByValidatorAddress returns a list of consumer chains
  // that a given validator must validate
  rpc QueryConsumerChainsByValidatorAddress(
    QueryConsumerChainsByValidatorAddressRequest)
    returns (QueryConsumerChainsByValidatorAddressResponse) {
      option (google.api.http).get =
    "/interchain_security/ccv/provider/consumer_chains_per_validator";
    }

   // QueryValidatorConsumerCommissionRate returns the commission rate a given
   // validator charges on a given consumer chain
  rpc QueryValidatorConsumerCommissionRate(
    QueryValidatorConsumerCommissionRateRequest)
    returns (QueryValidatorConsumerCommissionRateResponse) {
      option (google.api.http).get =
    "/interchain_security/ccv/provider/consumer_commission_rate";
    }
}

message QueryConsumerGenesisRequest { string chain_id = 1; }

message QueryConsumerGenesisResponse {
  interchain_security.ccv.v1.ConsumerGenesisState genesis_state = 1
      [ (gogoproto.nullable) = false ];
}

message QueryConsumerChainsRequest {}

message QueryConsumerChainsResponse { repeated Chain chains = 1; }

message QueryConsumerChainStartProposalsRequest {}

message QueryConsumerChainStartProposalsResponse {
  ConsumerAdditionProposals proposals = 1;
}

message QueryConsumerChainStopProposalsRequest {}

message QueryConsumerChainStopProposalsResponse {
  ConsumerRemovalProposals proposals = 1;
}

message Chain {
  string chain_id = 1;
  string client_id = 2;
  // If the `chainID` is an Opt-In chain, i.e., no validator is forced to validate chain `chainID`
  bool opt_In = 3;
  // If chain with `chainID` is a Top-N chain, i.e., enforces at least one validator to validate chain `chainID`
  uint32 top_N = 4;
}

message QueryValidatorConsumerAddrRequest {
  option (gogoproto.equal) = false;
  option (gogoproto.goproto_getters) = false;
  // The id of the consumer chain
  string chain_id = 1;
  // The consensus address of the validator on the provider chain
  string provider_address = 2 [ (gogoproto.moretags) = "yaml:\"address\"" ];
}

message QueryValidatorConsumerAddrResponse {
  // The address of the validator on the consumer chain
  string consumer_address = 1;
}

message QueryValidatorProviderAddrRequest {
  option (gogoproto.equal) = false;
  option (gogoproto.goproto_getters) = false;
  // The id of the provider chain
  string chain_id = 1;
  // The consensus address of the validator on the consumer chain
  string consumer_address = 2 [ (gogoproto.moretags) = "yaml:\"address\"" ];
}

message QueryValidatorProviderAddrResponse {
  // The address of the validator on the provider chain
  string provider_address = 1;
}

message QueryThrottleStateRequest {}

message QueryThrottleStateResponse {
  // current slash_meter state
  int64 slash_meter = 1;
  // allowance of voting power units (int) that the slash meter is given per
  // replenish period this also serves as the max value for the meter.
  int64 slash_meter_allowance = 2;
  // next time the slash meter could potentially be replenished, iff it's not
  // full
  google.protobuf.Timestamp next_replenish_candidate = 3
      [ (gogoproto.stdtime) = true, (gogoproto.nullable) = false ];
}

message QueryRegisteredConsumerRewardDenomsRequest {}

message QueryRegisteredConsumerRewardDenomsResponse {
  repeated string denoms = 1;
}

message QueryProposedChainIDsRequest {}

message QueryProposedChainIDsResponse {
  repeated ProposedChain proposedChains = 1
  [ (gogoproto.nullable) = false ];
}

message ProposedChain {
  string chainID = 1;
  uint64 proposalID = 2;
}

message QueryAllPairsValConAddrByConsumerChainIDRequest {
  // The id of the consumer chain
  string chain_id = 1;
}

message QueryAllPairsValConAddrByConsumerChainIDResponse {
  repeated PairValConAddrProviderAndConsumer pair_val_con_addr = 1;
}

message PairValConAddrProviderAndConsumer {
  // The consensus address of the validator on the provider chain
  string provider_address = 1 [ (gogoproto.moretags) = "yaml:\"address\"" ];
  // The consensus address of the validator on the consumer chain
  string consumer_address = 2 [ (gogoproto.moretags) = "yaml:\"address\"" ];
  tendermint.crypto.PublicKey consumer_key = 3;
}

message QueryParamsRequest {}

message QueryParamsResponse {
  Params params = 1 [(gogoproto.nullable) = false];
}


message QueryOptedInValidatorsByConsumerChainIDRequest {
  string chain_id = 1;
}

message QueryOptedInValidatorsByConsumerChainIDResponse {
  repeated string validators_provider_address = 1;
}


message QueryConsumerChainsByValidatorAddressRequest {
  // The consensus address of the validator on the provider chain
  string provider_address = 1 [ (gogoproto.moretags) = "yaml:\"address\"" ];
}

message QueryConsumerChainsByValidatorAddressResponse {
  repeated string validator_consumer_chains = 1;
}

message QueryValidatorConsumerCommissionRateRequest {
  string chain_id = 1;
    // The consensus address of the validator on the provider chain
  string provider_address = 2 [ (gogoproto.moretags) = "yaml:\"address\"" ];
}

message QueryValidatorConsumerCommissionRateResponse {
  // The rate to charge delegators on the consumer chain, as a fraction
  string rate = 1 [
    (cosmos_proto.scalar)  = "cosmos.Dec",
    (gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Dec",
    (gogoproto.nullable)   = false 
  ];
}

