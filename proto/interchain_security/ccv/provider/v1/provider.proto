syntax = "proto3";

package interchain_security.ccv.provider.v1;

option go_package = "github.com/cosmos/interchain-security/v5/x/ccv/provider/types";

import "interchain_security/ccv/v1/wire.proto";
import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "ibc/core/client/v1/client.proto";
import "ibc/lightclients/tendermint/v1/tendermint.proto";
import "tendermint/crypto/keys.proto";
import "cosmos/evidence/v1beta1/evidence.proto";
import "cosmos/base/v1beta1/coin.proto";
import "cosmos_proto/cosmos.proto";
import "amino/amino.proto";

//
// Note any type defined in this file is ONLY used internally to the provider CCV module.
// These schemas can change with proper consideration of compatibility or migration. 
// 

// ConsumerAdditionProposal is a governance proposal on the provider chain to
// spawn a new consumer chain. If it passes, then all validators on the provider
// chain are expected to validate the consumer chain at spawn time or get
// slashed. It is recommended that spawn time occurs after the proposal end
// time.
// Use MsgConsumerAddition to submit this proposal type.
message ConsumerAdditionProposal {
  option (gogoproto.goproto_getters) = false;
  option (gogoproto.goproto_stringer) = false;
  option (cosmos_proto.implements_interface) = "cosmos.gov.v1beta1.Content";

  // the title of the proposal
  string title = 1;
  // the description of the proposal
  string description = 2;
  // the proposed chain-id of the new consumer chain, must be different from all
  // other consumer chain ids of the executing provider chain.
  string chain_id = 3;
  // the proposed initial height of new consumer chain.
  // For a completely new chain, this will be {0,1}. However, it may be
  // different if this is a chain that is converting to a consumer chain.
  ibc.core.client.v1.Height initial_height = 4 [ (gogoproto.nullable) = false ];
  // The hash of the consumer chain genesis state without the consumer CCV
  // module genesis params. It is used for off-chain confirmation of
  // genesis.json validity by validators and other parties.
  bytes genesis_hash = 5;
  // The hash of the consumer chain binary that should be run by validators on
  // chain initialization. It is used for off-chain confirmation of binary
  // validity by validators and other parties.
  bytes binary_hash = 6;
  // spawn time is the time on the provider chain at which the consumer chain
  // genesis is finalized and all validators will be responsible for starting
  // their consumer chain validator node.
  google.protobuf.Timestamp spawn_time = 7
      [ (gogoproto.stdtime) = true, (gogoproto.nullable) = false ];

  // Unbonding period for the consumer,
  // which should be smaller than that of the provider in general.
  google.protobuf.Duration unbonding_period = 8
      [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];
  // Sent CCV related IBC packets will timeout after this duration
  google.protobuf.Duration ccv_timeout_period = 9
      [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];
  // Sent transfer related IBC packets will timeout after this duration
  google.protobuf.Duration transfer_timeout_period = 10
      [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];
  // The fraction of tokens allocated to the consumer redistribution address
  // during distribution events. The fraction is a string representing a
  // decimal number. For example "0.75" would represent 75%.
  string consumer_redistribution_fraction = 11;
  // BlocksPerDistributionTransmission is the number of blocks between
  // ibc-token-transfers from the consumer chain to the provider chain. On
  // sending transmission event, `consumer_redistribution_fraction` of the
  // accumulated tokens are sent to the consumer redistribution address.
  int64 blocks_per_distribution_transmission = 12;
  // The number of historical info entries to persist in store.
  // This param is a part of the cosmos sdk staking module. In the case of
  // a ccv enabled consumer chain, the ccv module acts as the staking module.
  int64 historical_entries = 13;
  // The ID of a token transfer channel used for the Reward Distribution
  // sub-protocol. If DistributionTransmissionChannel == "", a new transfer
  // channel is created on top of the same connection as the CCV channel.
  // Note that transfer_channel_id is the ID of the channel end on the consumer
  // chain. it is most relevant for chains performing a sovereign to consumer
  // changeover in order to maintain the existing ibc transfer channel
  string distribution_transmission_channel = 14;
  // Corresponds to the percentage of validators that have to validate the chain under the Top N case.
  // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
  // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100].
  // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain.
  uint32 top_N = 15;
  // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
  // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
  // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
  // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
  // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
  uint32 validators_power_cap = 16;
  // Corresponds to the maximum number of validators that can validate a consumer chain.
  // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
  uint32 validator_set_cap = 17;
  // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
  // the consumer chain.
  repeated string allowlist = 18;
  // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain.
  repeated string denylist = 19;
}

// ConsumerRemovalProposal is a governance proposal on the provider chain to
// remove (and stop) a consumer chain. If it passes, all the consumer chain's
// state is removed from the provider chain. The outstanding unbonding operation
// funds are released.
// Use MsgConsumerRemoval to submit this proposal type.
message ConsumerRemovalProposal {
  option (cosmos_proto.implements_interface) = "cosmos.gov.v1beta1.Content";

  // the title of the proposal
  string title = 1;
  // the description of the proposal
  string description = 2;
  // the chain-id of the consumer chain to be stopped
  string chain_id = 3;
  // the time on the provider chain at which all validators are responsible to
  // stop their consumer chain validator node
  google.protobuf.Timestamp stop_time = 4
      [ (gogoproto.stdtime) = true, (gogoproto.nullable) = false ];
}

// ConsumerModificationProposal is a governance proposal on the provider chain to modify parameters of a running
// consumer chain. If it passes, the consumer chain's state is updated to take into account the newest params.
message ConsumerModificationProposal {
  // the title of the proposal
  string title = 1;
  // the description of the proposal
  string description = 2;
  // the chain-id of the consumer chain to be modified
  string chain_id = 3;
  // Corresponds to the percentage of validators that have to validate the chain under the Top N case.
  // For example, 53 corresponds to a Top 53% chain, meaning that the top 53% provider validators by voting power
  // have to validate the proposed consumer chain. top_N can either be 0 or any value in [50, 100].
  // A chain can join with top_N == 0 as an Opt In chain, or with top_N ∈ [50, 100] as a Top N chain.
  uint32 top_N = 4;
  // Corresponds to the maximum power (percentage-wise) a validator can have on the consumer chain. For instance, if
  // `validators_power_cap` is set to 32, it means that no validator can have more than 32% of the voting power on the
  // consumer chain. Note that this might not be feasible. For example, think of a consumer chain with only
  // 5 validators and with `validators_power_cap` set to 10%. In such a scenario, at least one validator would need
  // to have more than 20% of the total voting power. Therefore, `validators_power_cap` operates on a best-effort basis.
  uint32 validators_power_cap = 5;
  // Corresponds to the maximum number of validators that can validate a consumer chain.
  // Only applicable to Opt In chains. Setting `validator_set_cap` on a Top N chain is a no-op.
  uint32 validator_set_cap = 6;
  // Corresponds to a list of provider consensus addresses of validators that are the ONLY ones that can validate
  // the consumer chain.
  repeated string allowlist = 7;
  // Corresponds to a list of provider consensus addresses of validators that CANNOT validate the consumer chain.
  repeated string denylist = 8;
}


// EquivocationProposal is a governance proposal on the provider chain to
// punish a validator for equivocation on a consumer chain.
// 
// This type is only used internally to the consumer CCV module.  
// WARNING: This message is deprecated now that equivocations can be submitted
// and verified automatically on the provider. (see SubmitConsumerDoubleVoting in proto/interchain-security/ccv/provider/v1/tx.proto).
message EquivocationProposal {
  option deprecated = true;
  // the title of the proposal
  string title = 1;
  // the description of the proposal
  string description = 2;
  // the list of equivocations that will be processed
  repeated cosmos.evidence.v1beta1.Equivocation equivocations = 3;
}

// ChangeRewardDenomsProposal is a governance proposal on the provider chain to
// mutate the set of denoms accepted by the provider as rewards.
// Use MsgChangeRewardDenoms to submit this proposal type.
message ChangeRewardDenomsProposal {
  option (cosmos_proto.implements_interface) = "cosmos.gov.v1beta1.Content";

  // the title of the proposal
  string title = 1;
  // the description of the proposal
  string description = 2;
  // the list of consumer reward denoms to add
  repeated string denoms_to_add = 3;
  // the list of consumer reward denoms to remove
  repeated string denoms_to_remove = 4;
}

// A persisted queue entry indicating that a slash packet data instance needs to
// be handled. This type belongs in the "global" queue, to coordinate slash
// packet handling times between consumers.
message GlobalSlashEntry {
  // Block time that slash packet was received by provider chain.
  // This field is used for store key iteration ordering.
  google.protobuf.Timestamp recv_time = 1
      [ (gogoproto.stdtime) = true, (gogoproto.nullable) = false ];
  // The consumer that sent a slash packet.
  string consumer_chain_id = 2 [ (gogoproto.customname) = "ConsumerChainID" ];
  // The IBC sequence number of the recv packet.
  // This field is used in the store key to ensure uniqueness.
  uint64 ibc_seq_num = 3;
  // The provider's consensus address of the validator being slashed.
  // This field is used to obtain validator power in HandleThrottleQueues.
  //
  // This field is not used in the store key, but is persisted in value bytes,
  // see QueueGlobalSlashEntry.
  bytes provider_val_cons_addr = 4;
}

// Params defines the parameters for CCV Provider module
message Params {

  // Reserve 8th slot for removed max throttled packet param
  reserved 8;

  ibc.lightclients.tendermint.v1.ClientState template_client = 1;
  // TrustingPeriodFraction is used to compute the consumer and provider IBC
  // client's TrustingPeriod from the chain defined UnbondingPeriod
  string trusting_period_fraction = 2;
  // Sent IBC packets will timeout after this duration
  google.protobuf.Duration ccv_timeout_period = 3
      [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];
  // The channel initialization (IBC channel opening handshake) will timeout
  // after this duration
  google.protobuf.Duration init_timeout_period = 4
      [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];
  // The VSC packets sent by the provider will timeout after this duration.
  // Note that unlike ccv_timeout_period which is an IBC param,
  // the vsc_timeout_period is a provider-side param that enables the provider
  // to timeout VSC packets even when a consumer chain is not live.
  google.protobuf.Duration vsc_timeout_period = 5
      [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];

  // The period for which the slash meter is replenished
  google.protobuf.Duration slash_meter_replenish_period = 6
      [ (gogoproto.nullable) = false, (gogoproto.stdduration) = true ];

  // The fraction of total voting power that is replenished to the slash meter
  // every replenish period. This param also serves as a maximum fraction of
  // total voting power that the slash meter can hold.
  string slash_meter_replenish_fraction = 7;

  // The fee required to be paid to add a reward denom
  cosmos.base.v1beta1.Coin consumer_reward_denom_registration_fee = 9
      [ (gogoproto.nullable) = false ];

  // The number of blocks that comprise an epoch.
  int64 blocks_per_epoch = 10;

  // The number of epochs a validator has to validate a consumer chain in order to start receiving rewards from that chain.
  int64 number_of_epochs_to_start_receiving_rewards = 11;
}

// SlashAcks contains cons addresses of consumer chain validators
// successfully slashed on the provider chain. 
message SlashAcks { repeated string addresses = 1; }

// ConsumerAdditionProposals holds pending governance proposals on the provider
// chain to spawn a new chain.
message ConsumerAdditionProposals {
  // proposals waiting for spawn_time to pass
  repeated ConsumerAdditionProposal pending = 1;
}

// ConsumerRemovalProposals holds pending governance proposals on the provider
// chain to remove (and stop) a consumer chain.
message ConsumerRemovalProposals {
  // proposals waiting for stop_time to pass
  repeated ConsumerRemovalProposal pending = 1;
}

// AddressList contains a list of consensus addresses
message AddressList { repeated bytes addresses = 1; }

// ChannelToChain is used to map a CCV channel ID to the consumer chainID
message ChannelToChain {
  string channel_id = 1;
  string chain_id = 2;
}

// VscUnbondingOps contains the IDs of unbonding operations that are waiting for
// at least one VSCMaturedPacket with vscID from a consumer chain
message VscUnbondingOps {
  uint64 vsc_id = 1;
  repeated uint64 unbonding_op_ids = 2;
}

// UnbondingOp contains the ids of consumer chains that need to unbond before
// the unbonding operation with the given ID can unbond
message UnbondingOp {
  uint64 id = 1;
  // consumer chains that are still unbonding
  repeated string unbonding_consumer_chains = 2;
}

message InitTimeoutTimestamp {
  string chain_id = 1;
  uint64 timestamp = 2;
}

message VscSendTimestamp {
  uint64 vsc_id = 1;
  google.protobuf.Timestamp timestamp = 2
      [ (gogoproto.stdtime) = true, (gogoproto.nullable) = false ];
}

// ValidatorSetChangePackets is a pb list of ccv.ValidatorSetChangePacketData.
message ValidatorSetChangePackets {
  repeated interchain_security.ccv.v1.ValidatorSetChangePacketData list = 1
      [ (gogoproto.nullable) = false ];
}

// MaturedUnbondingOps defines a list of ids corresponding to ids of matured
// unbonding operations.
message MaturedUnbondingOps { repeated uint64 ids = 1; }

// ExportedVscSendTimestamps is VscSendTimestamp with chainID info for exporting to genesis
message ExportedVscSendTimestamp {
  string chain_id = 1;
  repeated VscSendTimestamp vsc_send_timestamps = 2
    [ (gogoproto.nullable) = false ];
}

//
// Key assignment section
//

message KeyAssignmentReplacement {
  bytes provider_addr = 1;
  tendermint.crypto.PublicKey prev_c_key = 2;
  int64 power = 3;
}

// Used to serialize the ValidatorConsumerPubKey index from key assignment
// ValidatorConsumerPubKey: (chainID, providerAddr consAddr) -> consumerKey
// tmprotocrypto.PublicKey
message ValidatorConsumerPubKey {
  string chain_id = 1;
  bytes provider_addr = 2;
  tendermint.crypto.PublicKey consumer_key = 3;
}

// Used to serialize the ValidatorConsumerAddr index from key assignment
// ValidatorByConsumerAddr: (chainID, consumerAddr consAddr) -> providerAddr
// consAddr
message ValidatorByConsumerAddr {
  string chain_id = 1;
  bytes consumer_addr = 2;
  bytes provider_addr = 3;
}

// Used to serialize the ConsumerAddrsToPrune index from key assignment
// ConsumerAddrsToPrune: (chainID, vscID uint64) -> consumerAddrs AddressList
message ConsumerAddrsToPrune {
  string chain_id = 1;
  uint64 vsc_id = 2;
  AddressList consumer_addrs = 3;
}

// ConsumerValidator is used to facilitate epoch-based transitions. It contains relevant info for
// a validator that is expected to validate on a consumer chain during an epoch.
message ConsumerValidator {
  // validator's consensus address on the provider chain
  bytes provider_cons_addr = 1;
  // voting power the validator has during this epoch
  int64 power = 2;
  // public key the validator uses on the consumer chain during this epoch
  tendermint.crypto.PublicKey consumer_public_key = 3;
  // height the validator had when it FIRST became a consumer validator
  // If a validator becomes a consumer validator at height `H` and is continuously a consumer validator for all the upcoming
  // epochs, then the height of the validator SHOULD remain `H`. This height only resets to a different height if a validator
  // stops being a consumer validator during an epoch and later becomes again a consumer validator.
  int64 join_height = 4;
}
// ConsumerRewardsAllocation stores the rewards allocated by a consumer chain
// to the consumer rewards pool. It is used to allocate the tokens to the consumer 
// opted-in validators and the community pool during BeginBlock.
message ConsumerRewardsAllocation {
  repeated cosmos.base.v1beta1.DecCoin rewards = 1 [
    (gogoproto.nullable)     = false,
    (amino.dont_omitempty)   = true,
    (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.DecCoins"
  ];
}
